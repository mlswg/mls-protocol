<?xml version="1.0"?>
<rfc category="std" consensus="true" docName="draft-ietf-mls-protocol-20" ipr="trust200902" number="9420" obsoletes="" sortRefs="true" submissionType="IETF" symRefs="true" tocInclude="true" updates="" version="3" xml:lang="en">
  <front>
    <title abbrev="MLS">The Messaging Layer Security (MLS) Protocol</title>
    <seriesInfo name="RFC" value="9420"/>
    <author fullname="Richard Barnes" initials="R." surname="Barnes">
      <organization>Cisco</organization>
      <address>
        <email>rlb@ipv.sx</email>
      </address>
    </author>
    <author fullname="Benjamin Beurdouche" initials="B." surname="Beurdouche">
      <organization>Inria &amp; Mozilla</organization>
      <address>
        <email>ietf@beurdouche.com</email>
      </address>
    </author>
    <author fullname="Raphael Robert" initials="R." surname="Robert">
      <organization>Phoenix R&amp;D</organization>
      <address>
        <email>ietf@raphaelrobert.com</email>
      </address>
    </author>
    <author fullname="Jon Millican" initials="J." surname="Millican">
      <organization>Meta Platforms</organization>
      <address>
        <email>jmillican@meta.com</email>
      </address>
    </author>
    <author fullname="Emad Omara" initials="E." surname="Omara">
      <organization/>
      <address>
        <email>emad.omara@gmail.com</email>
      </address>
    </author>
    <author fullname="Katriel Cohn-Gordon" initials="K." surname="Cohn-Gordon">
      <organization>University of Oxford</organization>
      <address>
        <email>me@katriel.co.uk</email>
      </address>
    </author>
    <date month="May" year="2023"/>
    <area>sec</area>
    <workgroup>mls</workgroup>
    <keyword>security</keyword>
    <keyword>authenticated key exchange</keyword>
    <keyword>end-to-end encryption</keyword>
    <abstract>
      <t>Messaging applications are increasingly making use of end-to-end
security mechanisms to ensure that messages are only accessible to
the communicating endpoints, and not to any servers involved in delivering
messages.  Establishing keys to provide such protections is
challenging for group chat settings, in which more than two
clients need to agree on a key but may not be online at the same
time.  In this document, we specify a key establishment
protocol that provides efficient asynchronous group key establishment
with forward secrecy (FS) and post-compromise security (PCS) for groups
in size ranging from two to thousands.</t>
    </abstract>
  </front>
  <middle>
    <section anchor="introduction">
      <name>Introduction</name>
      <t>A group of users who want to send each other encrypted messages needs
a way to derive shared symmetric encryption keys. For two parties,
this problem has been studied thoroughly, with the Double Ratchet
emerging as a common solution <xref target="DoubleRatchet"/> <xref target="Signal"/>.
Channels implementing the Double Ratchet enjoy fine-grained forward secrecy
as well as post-compromise security, but are nonetheless efficient
enough for heavy use over low-bandwidth networks.</t>
      <t>For a group of size greater than two, a common strategy is to
distribute symmetric "sender keys" over existing 1:1
secure channels, and then for each member to send messages to the
group encrypted with their own sender key. On the one hand, using sender keys
improves efficiency relative to pairwise transmission of individual messages, and
it provides forward secrecy (with the addition of a hash ratchet).
On the other hand, it is difficult to achieve post-compromise security with
sender keys, requiring a number of key update messages that scales as the square
of the group size.
An adversary who learns a sender key can often indefinitely and
passively eavesdrop on that member's messages.  Generating and
distributing a new sender key provides a form of post-compromise
security with regard to that sender.  However, it requires
computation and communications resources that scale linearly with
the size of the group.</t>
      <t>In this document, we describe a protocol based on tree structures
that enables asynchronous group keying with forward secrecy and
post-compromise security.  Based on earlier work on "asynchronous
ratcheting trees" <xref target="ART"/>, the protocol presented here uses an
asynchronous key-encapsulation mechanism for tree structures.
This mechanism allows the members of the group to derive and update
shared keys with costs that scale as the log of the group size.</t>
    </section>
    <section anchor="terminology">
      <name>Terminology</name>
      <t>The key words "<bcp14>MUST</bcp14>", "<bcp14>MUST NOT</bcp14>", "<bcp14>REQUIRED</bcp14>", "<bcp14>SHALL</bcp14>", "<bcp14>SHALL NOT</bcp14>",
"<bcp14>SHOULD</bcp14>", "<bcp14>SHOULD NOT</bcp14>", "<bcp14>RECOMMENDED</bcp14>", "<bcp14>NOT RECOMMENDED</bcp14>", "<bcp14>MAY</bcp14>", and
"<bcp14>OPTIONAL</bcp14>" in this document are to be interpreted as described in
BCP 14 <xref target="RFC2119"/> <xref target="RFC8174"/> when, and only when, they appear in all
      capitals, as shown here.</t>
      <dl>
        <dt>Client:</dt>
        <dd>An agent that uses this protocol to establish shared cryptographic
state with other clients.  A client is defined by the
cryptographic keys it holds.</dd>
        <dt>Group:</dt>
        <dd>A group represents a logical collection of clients that share a common
secret value at any given time.  Its state is represented as a linear
sequence of epochs in which each epoch depends on its predecessor.</dd>
        <dt>Epoch:</dt>
        <dd>A state of a group in which a specific set of authenticated clients hold
shared cryptographic state.</dd>
        <dt>Member:</dt>
        <dd>A client that is included in the shared state of a group and hence
has access to the group's secrets.</dd>
        <dt>Key Package:</dt>
        <dd>A signed object describing a client's identity and capabilities, including
a hybrid public key encryption (HPKE) <xref target="RFC9180"/> public key that
can be used to encrypt to that client. Other clients can use a client's
KeyPackage to introduce the client to a new group.</dd>
        <dt>Group Context:</dt>
        <dd>An object that summarizes the shared, public state of the group. The group
context is typically distributed in a signed GroupInfo message, which is provided
to new members to help them join a group.</dd>
        <dt>Signature Key:</dt>
        <dd>A signing key pair used to authenticate the sender of a message.</dd>
        <dt>Proposal:</dt>
        <dd>A message that proposes a change to the group, e.g., adding or removing a
member.</dd>
        <dt>Commit:</dt>
        <dd>A message that implements the changes to the group proposed in a set of
Proposals.</dd>
        <dt>PublicMessage:</dt>
        <dd>An MLS protocol message that is signed by its sender and authenticated as
coming from a member of the group in a particular epoch, but not encrypted.</dd>
        <dt>PrivateMessage:</dt>
        <dd>An MLS protocol message that is signed by its sender, authenticated as
coming from a member of the group in a particular epoch, and encrypted so
that it is confidential to the members of the group in that epoch.</dd>
        <dt>Handshake Message:</dt>
        <dd>A PublicMessage or PrivateMessage carrying an MLS Proposal or Commit
object, as opposed to application data.</dd>
        <dt>Application Message:</dt>
        <dd>A PrivateMessage carrying application data.</dd>
      </dl>
      <t>Terminology specific to tree computations is described in
<xref target="ratchet-tree-terminology"/>.</t>
      <t>In general, symmetric values are referred to as "keys" or "secrets"
interchangeably.  Either term denotes a value that <bcp14>MUST</bcp14> be kept confidential to
a client.  When labeling individual values, we typically use "secret" to refer
to a value that is used to derive further secret values and "key" to refer to a
value that is used with an algorithm such as Hashed Message Authentication Code
(HMAC) or an Authenticated Encryption with Associated Data (AEAD) algorithm.</t>
      <t>The PublicMessage and PrivateMessage formats are defined in <xref target="message-framing"/>.
Security notions such as forward secrecy and post-compromise
security are defined in <xref target="security-considerations"/>.</t>
      <t>As detailed in <xref target="grease"/>, MLS uses the "Generate Random Extensions And Sustain
Extensibility" (GREASE) approach to maintaining extensibility, where senders insert random
values into fields in which receivers are required to ignore unknown values.
Specific "GREASE values" for this purpose are registered in the appropriate IANA
registries.</t>
      <section anchor="presentation-language">
        <name>Presentation Language</name>
        <t>We use the TLS presentation language <xref target="RFC8446"/> to describe the structure of
protocol messages.  In addition to the base syntax, we add two additional
features: the ability for fields to be optional and the ability for vectors to
have variable-size length headers.</t>
        <section anchor="optional-value">
          <name>Optional Value</name>
          <t>An optional value is encoded with a presence-signaling octet, followed by the
value itself if present.  When decoding, a presence octet with a value other
than 0 or 1 <bcp14>MUST</bcp14> be rejected as malformed.</t>
          <sourcecode type="tls-presentation">
struct {
    uint8 present;
    select (present) {
        case 0: struct{};
        case 1: T value;
    };
} optional&lt;T&gt;;
</sourcecode>
        </section>
        <section anchor="variable-size-vector-length-headers">
          <name>Variable-Size Vector Length Headers</name>
          <t>In the TLS presentation language, vectors are encoded as a sequence of encoded
elements prefixed with a length.  The length field has a fixed size set by
specifying the minimum and maximum lengths of the encoded sequence of elements.</t>
          <t>In MLS, there are several vectors whose sizes vary over significant ranges.  So
instead of using a fixed-size length field, we use a variable-size length using
a variable-length integer encoding based on the one described in
<xref section="16" sectionFormat="of" target="RFC9000"/>. They differ only in that the one here requires a minimum-size
encoding. Instead of presenting min and max values, the vector description
simply includes a <tt>V</tt>. For example:</t>
          <sourcecode type="tls-presentation">
struct {
    uint32 fixed&lt;0..255&gt;;
    opaque variable&lt;V&gt;;
} StructWithVectors;
</sourcecode>
          <t>Such a vector can represent values with length from 0 bytes to 2<sup>30</sup> bytes.
The variable-length integer encoding reserves the two most significant bits
of the first byte to encode the base 2 logarithm of the integer encoding length
in bytes.  The integer value is encoded on the remaining bits, so that the
overall value is in network byte order.
The encoded value <bcp14>MUST</bcp14> use the smallest number of bits required to
represent the value.  When decoding, values using more bits than necessary <bcp14>MUST</bcp14>
be treated as malformed.</t>
          <t>This means that integers are encoded in 1, 2, or 4 bytes and can encode 6-,
14-, or 30-bit values, respectively.</t>
          <table anchor="integer-summary">
            <name>Summary of Integer Encodings</name>
            <thead>
              <tr>
                <th align="left">Prefix</th>
                <th align="left">Length</th>
                <th align="left">Usable Bits</th>
                <th align="left">Min</th>
                <th align="left">Max</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td align="left">00</td>
                <td align="left">1</td>
                <td align="left">6</td>
                <td align="left">0</td>
                <td align="left">63</td>
              </tr>
              <tr>
                <td align="left">01</td>
                <td align="left">2</td>
                <td align="left">14</td>
                <td align="left">64</td>
                <td align="left">16383</td>
              </tr>
              <tr>
                <td align="left">10</td>
                <td align="left">4</td>
                <td align="left">30</td>
                <td align="left">16384</td>
                <td align="left">1073741823</td>
              </tr>
              <tr>
                <td align="left">11</td>
                <td align="left">invalid</td>
                <td align="left">-</td>
                <td align="left">-</td>
                <td align="left">-</td>
              </tr>
            </tbody>
          </table>
          <t>Vectors that start with the prefix "11" are invalid and <bcp14>MUST</bcp14> be rejected.</t>
          <t>For example:</t>
          <ul spacing="normal">
            <li>The four-byte length value 0x9d7f3e7d decodes to 494878333.</li>
            <li>The two-byte length value 0x7bbd decodes to 15293.</li>
            <li>The single-byte length value 0x25 decodes to 37.</li>
          </ul>
          <t>The following figure adapts the pseudocode provided in <xref target="RFC9000"/> to add a
check for minimum-length encoding:</t>
          <sourcecode type="pseudocode">
ReadVarint(data):
  // The length of variable-length integers is encoded in the
  // first two bits of the first byte.
  v = data.next_byte()
  prefix = v &gt;&gt; 6
  if prefix == 3:
    raise Exception('invalid variable length integer prefix')

  length = 1 &lt;&lt; prefix

  // Once the length is known, remove these bits and read any
  // remaining bytes.
  v = v &amp; 0x3f
  repeat length-1 times:
    v = (v &lt;&lt; 8) + data.next_byte()

  // Check if the value would fit in half the provided length.
  if prefix &gt;= 1 &amp;&amp; v &lt; (1 &lt;&lt; (8*(length/2) - 2)):
    raise Exception('minimum encoding was not used')

  return v
</sourcecode>
          <t>The use of variable-size integers for vector lengths allows vectors to grow
very large, up to 2<sup>30</sup> bytes.  Implementations should take care not to allow
vectors to overflow available storage.  To facilitate debugging of potential
interoperability problems, implementations <bcp14>SHOULD</bcp14> provide a clear error when
such an overflow condition occurs.</t>
        </section>
      </section>
    </section>
    <section anchor="protocol-overview">
      <name>Protocol Overview</name>
      <t>MLS is designed to operate in the context described in
<xref target="I-D.ietf-mls-architecture"/>. In particular, we assume that the following
services are provided:</t>
      <ul spacing="normal">
        <li>An Authentication Service (AS) that enables group members to authenticate the
credentials presented by other group members.</li>
        <li>A Delivery Service (DS) that routes MLS messages among the participants in the
protocol.</li>
      </ul>
      <t>MLS assumes a trusted AS but a largely untrusted DS. <xref target="authentication-service-compromise"/>
describes the impact of compromise or
misbehavior of an AS. MLS is designed to protect the confidentiality and integrity of
the group data even in the face of a compromised DS;
in general, the DS is only expected to reliably deliver messages.
<xref target="delivery-service-compromise"/> describes the impact of compromise or
misbehavior of a DS.</t>
      <t>The core functionality of MLS is continuous group authenticated key exchange
(AKE).  As with other authenticated key exchange protocols (such as TLS), the
participants in the protocol agree on a common secret value, and each
participant can verify the identity of the other participants. That secret
can then be used to protect messages sent from one participant in the
group to the other participants using the MLS framing layer
or can be exported for use with other protocols. MLS provides
group AKE in the sense that there can be more than two participants in the
protocol, and continuous group AKE in the sense that the set of participants in
the protocol can change over time.</t>
      <t>The core organizing principles of MLS are <em>groups</em> and <em>epochs</em>.  A group
represents a logical collection of clients that share a common secret value at
any given time.  The history of a group is divided into a linear sequence of
epochs.  In each epoch, a set of authenticated <em>members</em> agree on an <em>epoch
secret</em> that is known only to the members of the group in that epoch.  The set
of members involved in the group can change from one epoch to the next, and MLS
ensures that only the members in the current epoch have access to the epoch
secret.  From the epoch secret, members derive further shared secrets for
message encryption, group membership authentication, and so on.</t>
      <t>The creator of an MLS group creates the group's first epoch unilaterally, with
no protocol interactions.  Thereafter, the members of the group advance their
shared cryptographic state from one epoch to another by exchanging MLS messages.</t>
      <ul spacing="normal">
        <li>A <em>KeyPackage</em> object describes a client's capabilities and provides keys that
can be used to add the client to a group.</li>
        <li>A <em>Proposal</em> message proposes a change to be made in the next epoch, such as
adding or removing a member.</li>
        <li>A <em>Commit</em> message initiates a new epoch by instructing members of the group
to implement a collection of proposals.</li>
        <li>A <em>Welcome</em> message provides a new member to the group with the information to
initialize their state for the epoch in which they were added or in which they
want to add themselves to the group.</li>
      </ul>
      <t>KeyPackage and Welcome messages are used to initiate a group or introduce new
members, so they are exchanged between group members and clients not yet in the
group. A client publishes a KeyPackage via the DS, thus enabling other
clients to add it to groups. When a group member wants to add a new member to a
group, it uses the new member's KeyPackage to add them and constructs a Welcome
message with which the new member can initialize their local state.</t>
      <t>Proposal and Commit messages are sent from one member of a group to the others.
MLS provides a common framing layer for sending messages within a group:
A <em>PublicMessage</em> provides sender authentication for unencrypted Proposal and Commit
messages.  A <em>PrivateMessage</em> provides encryption and authentication for
both Proposal/Commit messages as well as any application data.</t>
      <section anchor="cryptographic-state-and-evolution">
        <name>Cryptographic State and Evolution</name>
        <t>The cryptographic state at the core of MLS is divided into three areas of responsibility:</t>
        <figure>
          <name>Overview of MLS Group Evolution</name>
          <artset>
            <artwork type="svg">
              <svg xmlns="http://www.w3.org/2000/svg" class="diagram" font-family="monospace" font-size="13px" height="400" text-anchor="middle" version="1.1" viewBox="0 0 584 400" width="584">
                <path d="M 8,128 L 8,288" fill="none" stroke="black"/>
                <path d="M 208,48 L 208,200" fill="none" stroke="black"/>
                <path d="M 208,216 L 208,368" fill="none" stroke="black"/>
                <path d="M 272,64 L 272,96" fill="none" stroke="black"/>
                <path d="M 272,120 L 272,192" fill="none" stroke="black"/>
                <path d="M 272,216 L 272,288" fill="none" stroke="black"/>
                <path d="M 272,312 L 272,352" fill="none" stroke="black"/>
                <path d="M 336,48 L 336,200" fill="none" stroke="black"/>
                <path d="M 336,216 L 336,368" fill="none" stroke="black"/>
                <path d="M 576,128 L 576,288" fill="none" stroke="black"/>
                <path d="M 48,208 L 72,208" fill="none" stroke="black"/>
                <path d="M 200,208 L 216,208" fill="none" stroke="black"/>
                <path d="M 336,208 L 352,208" fill="none" stroke="black"/>
                <path d="M 512,208 L 528,208" fill="none" stroke="black"/>
                <path d="M 8,128 L 48,208" fill="none" stroke="black"/>
                <path d="M 536,208 L 576,288" fill="none" stroke="black"/>
                <path d="M 8,288 L 48,208" fill="none" stroke="black"/>
                <path d="M 536,208 L 576,128" fill="none" stroke="black"/>
                <path d="M 224,32 C 215.16936,32 208,39.16936 208,48" fill="none" stroke="black"/>
                <path d="M 320,32 C 328.83064,32 336,39.16936 336,48" fill="none" stroke="black"/>
                <path d="M 224,384 C 215.16936,384 208,376.83064 208,368" fill="none" stroke="black"/>
                <path d="M 320,384 C 328.83064,384 336,376.83064 336,368" fill="none" stroke="black"/>
                <polygon class="arrowhead" fill="black" points="536,208 524,202.4 524,213.6" transform="rotate(0,528,208)"/>
                <polygon class="arrowhead" fill="black" points="360,208 348,202.4 348,213.6" transform="rotate(0,352,208)"/>
                <polygon class="arrowhead" fill="black" points="280,352 268,346.4 268,357.6" transform="rotate(90,272,352)"/>
                <polygon class="arrowhead" fill="black" points="280,288 268,282.4 268,293.6" transform="rotate(90,272,288)"/>
                <polygon class="arrowhead" fill="black" points="280,192 268,186.4 268,197.6" transform="rotate(90,272,192)"/>
                <polygon class="arrowhead" fill="black" points="280,96 268,90.4 268,101.6" transform="rotate(90,272,96)"/>
                <polygon class="arrowhead" fill="black" points="224,208 212,202.4 212,213.6" transform="rotate(0,216,208)"/>
                <polygon class="arrowhead" fill="black" points="80,208 68,202.4 68,213.6" transform="rotate(0,72,208)"/>
                <g class="text">
                  <text x="272" y="36">...</text>
                  <text x="360" y="84">Key</text>
                  <text x="412" y="84">Schedule</text>
                  <text x="276" y="116">epoch_secret</text>
                  <text x="56" y="148">Ratchet</text>
                  <text x="532" y="148">Secret</text>
                  <text x="52" y="164">Tree</text>
                  <text x="532" y="164">Tree</text>
                  <text x="136" y="212">commit_secret</text>
                  <text x="276" y="212">epoch_secret</text>
                  <text x="432" y="212">encryption_secret</text>
                  <text x="276" y="308">epoch_secret</text>
                  <text x="272" y="388">...</text>
                </g>
              </svg>
            </artwork>
            <artwork type="ascii-art">
                          .-    ...    -.
                         |               |
                         |       |       |
                         |       |       | Key Schedule
                         |       V       |
                         |  epoch_secret |
.                        |       |       |                             .
|\ Ratchet               |       |       |                     Secret /|
| \ Tree                 |       |       |                      Tree / |
|  \                     |       |       |                          /  |
|   \                    |       V       |                         /   |
|    +--&gt; commit_secret --&gt; epoch_secret --&gt; encryption_secret --&gt;+    |
|   /                    |       |       |                         \   |
|  /                     |       |       |                          \  |
| /                      |       |       |                           \ |
|/                       |       |       |                            \|
'                        |       V       |                             '
                         |  epoch_secret |
                         |       |       |
                         |       |       |
                         |       V       |
                         |               |
                          '-    ...    -'
</artwork>
          </artset>
        </figure>
        <ul spacing="normal">
          <li>A <em>ratchet tree</em> that represents the membership of the group, providing group
members a way to authenticate each other and efficiently encrypt messages to
subsets of the group.  Each epoch has a distinct ratchet tree. It seeds the
<em>key schedule</em>.</li>
          <li>
            <t>A <em>key schedule</em> that describes the chain of key derivations used to progress from
epoch to epoch (mainly using the <em>init_secret</em> and <em>epoch_secret</em>), as well as the derivation of
a variety of other secrets (see <xref target="epoch-derived-secrets"/>). For example:
            </t>
            <ul spacing="normal">
              <li>An <em>encryption secret</em> that is used to initialize the secret tree for the
epoch.</li>
              <li>An <em>exporter secret</em> that allows other protocols to leverage MLS as a
generic authenticated group key exchange.</li>
              <li>A <em>resumption secret</em> that members can use to prove their membership in the
group, e.g., when creating a subgroup or a successor group.</li>
            </ul>
          </li>
          <li>A <em>secret tree</em> derived from the key schedule that represents shared secrets
used by the members of the group for encrypting and authenticating messages.
Each epoch has a distinct secret tree.</li>
        </ul>
        <t>Each member of the group maintains a partial view of these components of the group's
state.  MLS messages are used to initialize these views and keep them in sync as
the group transitions between epochs.</t>
        <t>Each new epoch is initiated with a Commit message.  The Commit instructs
existing members of the group to update their views of the ratchet tree by applying
a set of Proposals, and uses the updated ratchet tree to distribute fresh
entropy to the group.  This fresh entropy is provided only to members in the new
epoch and not to members who have been removed. Commits thus maintain the property that
the epoch secret is confidential to the members in the current epoch.</t>
        <t>For each Commit that adds one or more members to the group, there are one or more corresponding
Welcome messages.  Each Welcome message provides new members with the information
they need to initialize their views of the key schedule and ratchet tree, so
that these views align with the views held by other members of the group
in this epoch.</t>
      </section>
      <section anchor="example-protocol-execution">
        <name>Example Protocol Execution</name>
        <t>There are three major operations in the life of a group:</t>
        <ul spacing="normal">
          <li>Adding a member, initiated by a current member;</li>
          <li>Updating the keys that represent a member in the tree; and</li>
          <li>Removing a member.</li>
        </ul>
        <t>Each of these operations is "proposed" by sending a message of the corresponding
type (Add / Update / Remove).  The state of the group is not changed, however,
until a Commit message is sent to provide the group with fresh entropy.  In this
section, we show each proposal being committed immediately, but in more advanced
deployment cases, an application might gather several proposals before
committing them all at once.  In the illustrations below, we show the Proposal
and Commit messages directly, while in reality they would be sent encapsulated in
PublicMessage or PrivateMessage objects.</t>
        <t>Before the initialization of a group, clients publish KeyPackages to a directory
provided by the DS (see <xref target="prepublish-flow"/>).</t>
        <figure anchor="prepublish-flow">
          <name>Clients A, B, and C publish KeyPackages to the directory</name>
          <artset>
            <artwork type="svg">
              <svg xmlns="http://www.w3.org/2000/svg" class="diagram" font-family="monospace" font-size="13px" height="288" text-anchor="middle" version="1.1" viewBox="0 0 568 288" width="568">
                <path d="M 8,128 L 8,272" fill="none" stroke="black"/>
                <path d="M 144,128 L 144,152" fill="none" stroke="black"/>
                <path d="M 144,168 L 144,272" fill="none" stroke="black"/>
                <path d="M 280,128 L 280,152" fill="none" stroke="black"/>
                <path d="M 280,168 L 280,200" fill="none" stroke="black"/>
                <path d="M 280,216 L 280,272" fill="none" stroke="black"/>
                <path d="M 416,128 L 416,272" fill="none" stroke="black"/>
                <path d="M 536,128 L 536,272" fill="none" stroke="black"/>
                <path d="M 400,64 L 456,64" fill="none" stroke="black"/>
                <path d="M 488,64 L 544,64" fill="none" stroke="black"/>
                <path d="M 8,160 L 408,160" fill="none" stroke="black"/>
                <path d="M 144,208 L 408,208" fill="none" stroke="black"/>
                <path d="M 280,256 L 408,256" fill="none" stroke="black"/>
                <path d="M 400,64 C 391.16936,64 384,71.16936 384,80" fill="none" stroke="black"/>
                <path d="M 456,64 C 464.83064,64 472,56.83064 472,48" fill="none" stroke="black"/>
                <path d="M 488,64 C 479.16936,64 472,56.83064 472,48" fill="none" stroke="black"/>
                <path d="M 544,64 C 552.83064,64 560,71.16936 560,80" fill="none" stroke="black"/>
                <polygon class="arrowhead" fill="black" points="416,256 404,250.4 404,261.6" transform="rotate(0,408,256)"/>
                <polygon class="arrowhead" fill="black" points="416,208 404,202.4 404,213.6" transform="rotate(0,408,208)"/>
                <polygon class="arrowhead" fill="black" points="416,160 404,154.4 404,165.6" transform="rotate(0,408,160)"/>
                <g class="text">
                  <text x="436" y="36">Delivery</text>
                  <text x="504" y="36">Service</text>
                  <text x="528" y="100">Group</text>
                  <text x="8" y="116">A</text>
                  <text x="144" y="116">B</text>
                  <text x="280" y="116">C</text>
                  <text x="416" y="116">Directory</text>
                  <text x="536" y="116">Channel</text>
                  <text x="64" y="148">KeyPackageA</text>
                  <text x="200" y="196">KeyPackageB</text>
                  <text x="336" y="244">KeyPackageC</text>
                </g>
              </svg>
            </artwork>
            <artwork type="ascii-art">
                                                  Delivery Service
                                                          |
                                                .--------' '--------.
                                               |                     |
                                                               Group
A                B                C            Directory       Channel
|                |                |                |              |
| KeyPackageA    |                |                |              |
+-------------------------------------------------&gt;|              |
|                |                |                |              |
|                | KeyPackageB    |                |              |
|                +--------------------------------&gt;|              |
|                |                |                |              |
|                |                | KeyPackageC    |              |
|                |                +---------------&gt;|              |
|                |                |                |              |
</artwork>
          </artset>
        </figure>
        <t><xref target="create-flow"/> shows how these pre-published KeyPackages are used to create a group.
When client A wants to establish a group with clients B and C, it first initializes a
group state containing only itself and downloads KeyPackages for B and C. For
each member, A generates an Add proposal and a Commit message to add that member and then
broadcasts the two messages to the group. Client A also generates a Welcome message and sends it
directly to the new member (there's no need to send it to the group). Only after
A has received its Commit message back from the Delivery Service does it update its
state to reflect the new member's addition.</t>
        <t>Once A has updated its state, the new member has processed the Welcome, and any
other group members have processed the Commit, they will all have consistent
representations of the group state, including a group secret that is known only
to the members the group. The new member will be able to read and send new
messages to the group, but messages sent before they were added to the group
will not be accessible.</t>
        <figure anchor="create-flow">
          <name>Client A creates a group with clients B and C</name>
          <artset>
            <artwork type="svg">
              <svg xmlns="http://www.w3.org/2000/svg" class="diagram" font-family="monospace" font-size="13px" height="512" text-anchor="middle" version="1.1" viewBox="0 0 560 512" width="560">
                <path d="M 8,64 L 8,496" fill="none" stroke="black"/>
                <path d="M 128,104 L 128,152" fill="none" stroke="black"/>
                <path d="M 128,168 L 128,264" fill="none" stroke="black"/>
                <path d="M 128,280 L 128,344" fill="none" stroke="black"/>
                <path d="M 128,360 L 128,392" fill="none" stroke="black"/>
                <path d="M 128,408 L 128,456" fill="none" stroke="black"/>
                <path d="M 128,472 L 128,496" fill="none" stroke="black"/>
                <path d="M 248,104 L 248,152" fill="none" stroke="black"/>
                <path d="M 248,168 L 248,264" fill="none" stroke="black"/>
                <path d="M 248,280 L 248,344" fill="none" stroke="black"/>
                <path d="M 248,360 L 248,456" fill="none" stroke="black"/>
                <path d="M 368,64 L 368,152" fill="none" stroke="black"/>
                <path d="M 368,168 L 368,264" fill="none" stroke="black"/>
                <path d="M 368,280 L 368,344" fill="none" stroke="black"/>
                <path d="M 368,360 L 368,456" fill="none" stroke="black"/>
                <path d="M 528,64 L 528,496" fill="none" stroke="black"/>
                <path d="M 16,96 L 368,96" fill="none" stroke="black"/>
                <path d="M 8,160 L 520,160" fill="none" stroke="black"/>
                <path d="M 8,208 L 120,208" fill="none" stroke="black"/>
                <path d="M 16,272 L 528,272" fill="none" stroke="black"/>
                <path d="M 8,352 L 520,352" fill="none" stroke="black"/>
                <path d="M 8,400 L 240,400" fill="none" stroke="black"/>
                <path d="M 16,464 L 528,464" fill="none" stroke="black"/>
                <path d="M 136,480 L 528,480" fill="none" stroke="black"/>
                <polygon class="arrowhead" fill="black" points="528,352 516,346.4 516,357.6" transform="rotate(0,520,352)"/>
                <polygon class="arrowhead" fill="black" points="528,160 516,154.4 516,165.6" transform="rotate(0,520,160)"/>
                <polygon class="arrowhead" fill="black" points="248,400 236,394.4 236,405.6" transform="rotate(0,240,400)"/>
                <polygon class="arrowhead" fill="black" points="144,480 132,474.4 132,485.6" transform="rotate(180,136,480)"/>
                <polygon class="arrowhead" fill="black" points="128,208 116,202.4 116,213.6" transform="rotate(0,120,208)"/>
                <polygon class="arrowhead" fill="black" points="24,464 12,458.4 12,469.6" transform="rotate(180,16,464)"/>
                <polygon class="arrowhead" fill="black" points="24,272 12,266.4 12,277.6" transform="rotate(180,16,272)"/>
                <polygon class="arrowhead" fill="black" points="24,96 12,90.4 12,101.6" transform="rotate(180,16,96)"/>
                <g class="text">
                  <text x="528" y="36">Group</text>
                  <text x="8" y="52">A</text>
                  <text x="128" y="52">B</text>
                  <text x="248" y="52">C</text>
                  <text x="368" y="52">Directory</text>
                  <text x="528" y="52">Channel</text>
                  <text x="128" y="68">|</text>
                  <text x="248" y="68">|</text>
                  <text x="132" y="84">KeyPackageB,</text>
                  <text x="232" y="84">KeyPackageC</text>
                  <text x="420" y="132">Add(A-&gt;AB)</text>
                  <text x="424" y="148">Commit(Add)</text>
                  <text x="68" y="196">Welcome(B)</text>
                  <text x="420" y="244">Add(A-&gt;AB)</text>
                  <text x="424" y="260">Commit(Add)</text>
                  <text x="428" y="324">Add(AB-&gt;ABC)</text>
                  <text x="424" y="340">Commit(Add)</text>
                  <text x="188" y="388">Welcome(C)</text>
                  <text x="428" y="436">Add(AB-&gt;ABC)</text>
                  <text x="424" y="452">Commit(Add)</text>
                  <text x="248" y="500">|</text>
                  <text x="368" y="500">|</text>
                </g>
              </svg>
            </artwork>
            <artwork type="ascii-art">
                                                               Group
A              B              C          Directory            Channel
|              |              |              |                   |
|         KeyPackageB, KeyPackageC           |                   |
|&lt;-------------------------------------------+                   |
|              |              |              |                   |
|              |              |              | Add(A-&gt;AB)        |
|              |              |              | Commit(Add)       |
+---------------------------------------------------------------&gt;|
|              |              |              |                   |
|  Welcome(B)  |              |              |                   |
+-------------&gt;|              |              |                   |
|              |              |              |                   |
|              |              |              | Add(A-&gt;AB)        |
|              |              |              | Commit(Add)       |
|&lt;---------------------------------------------------------------+
|              |              |              |                   |
|              |              |              |                   |
|              |              |              | Add(AB-&gt;ABC)      |
|              |              |              | Commit(Add)       |
+---------------------------------------------------------------&gt;|
|              |              |              |                   |
|              |  Welcome(C)  |              |                   |
+----------------------------&gt;|              |                   |
|              |              |              |                   |
|              |              |              | Add(AB-&gt;ABC)      |
|              |              |              | Commit(Add)       |
|&lt;---------------------------------------------------------------+
|              |&lt;------------------------------------------------+
|              |              |              |                   |
</artwork>
          </artset>
        </figure>
        <t>Subsequent additions of group members proceed in the same way.  Any
member of the group can download a KeyPackage for a new client,
broadcast Add and Commit messages that the current group will use to update
their state, and send a Welcome message that the new client can use to
initialize its state and join the group.</t>
        <t>To enforce the forward secrecy and post-compromise security of messages, each
member periodically updates the keys that represent them to the group.  A member
does this by sending a Commit (possibly with no proposals) or by sending an
Update message that is committed by another member (see <xref target="update-flow"/>).
Once the other members of
the group have processed these messages, the group's secrets will be unknown to
an attacker that had compromised the secrets corresponding to the sender's leaf in the tree.
At the end of the scenario shown in <xref target="update-flow"/>, the group has
post-compromise security with respect to both A and B.</t>
        <t>Update messages <bcp14>SHOULD</bcp14> be sent at regular intervals of time as long as the group
is active, and members that don't update <bcp14>SHOULD</bcp14> eventually be removed from the
group. It's left to the application to determine an appropriate amount of time
between Updates. Since the purpose of sending an Update is to proactively
constrain a compromise window, the right frequency is usually on the order of
hours or days, not milliseconds. For example, an application might send an
Update each time a member sends an application message after receiving any
message from another member, or daily if no application messages are sent.</t>
        <t>The MLS architecture recommends that MLS be operated over a secure transport
(see <xref section="7.1" sectionFormat="of" target="I-D.ietf-mls-architecture"/>).  Such transport protocols
will typically provide functions such as congestion control that manage the
impact of an MLS-using application on other applications sharing the same
network.  Applications should take care that they do not send MLS messages at a
rate that will cause problems such as network congestion, especially if they are
not following the above recommendation (e.g., sending MLS directly over UDP instead).</t>
        <figure anchor="update-flow">
          <name>Client B proposes to update its key, and client A commits the proposal</name>
          <artset>
            <artwork type="svg">
              <svg xmlns="http://www.w3.org/2000/svg" class="diagram" font-family="monospace" font-size="13px" height="304" text-anchor="middle" version="1.1" viewBox="0 0 528 304" width="528">
                <path d="M 8,64 L 8,288" fill="none" stroke="black"/>
                <path d="M 128,64 L 128,120" fill="none" stroke="black"/>
                <path d="M 128,136 L 128,200" fill="none" stroke="black"/>
                <path d="M 128,248 L 128,288" fill="none" stroke="black"/>
                <path d="M 248,64 L 248,88" fill="none" stroke="black"/>
                <path d="M 248,152 L 248,200" fill="none" stroke="black"/>
                <path d="M 248,264 L 248,288" fill="none" stroke="black"/>
                <path d="M 368,64 L 368,88" fill="none" stroke="black"/>
                <path d="M 368,168 L 368,200" fill="none" stroke="black"/>
                <path d="M 488,64 L 488,288" fill="none" stroke="black"/>
                <path d="M 128,96 L 480,96" fill="none" stroke="black"/>
                <path d="M 16,128 L 488,128" fill="none" stroke="black"/>
                <path d="M 136,144 L 488,144" fill="none" stroke="black"/>
                <path d="M 256,160 L 488,160" fill="none" stroke="black"/>
                <path d="M 8,208 L 480,208" fill="none" stroke="black"/>
                <path d="M 16,240 L 488,240" fill="none" stroke="black"/>
                <path d="M 136,256 L 488,256" fill="none" stroke="black"/>
                <path d="M 256,272 L 488,272" fill="none" stroke="black"/>
                <polygon class="arrowhead" fill="black" points="488,208 476,202.4 476,213.6" transform="rotate(0,480,208)"/>
                <polygon class="arrowhead" fill="black" points="488,96 476,90.4 476,101.6" transform="rotate(0,480,96)"/>
                <polygon class="arrowhead" fill="black" points="264,272 252,266.4 252,277.6" transform="rotate(180,256,272)"/>
                <polygon class="arrowhead" fill="black" points="264,160 252,154.4 252,165.6" transform="rotate(180,256,160)"/>
                <polygon class="arrowhead" fill="black" points="144,256 132,250.4 132,261.6" transform="rotate(180,136,256)"/>
                <polygon class="arrowhead" fill="black" points="144,144 132,138.4 132,149.6" transform="rotate(180,136,144)"/>
                <polygon class="arrowhead" fill="black" points="24,240 12,234.4 12,245.6" transform="rotate(180,16,240)"/>
                <polygon class="arrowhead" fill="black" points="24,128 12,122.4 12,133.6" transform="rotate(180,16,128)"/>
                <g class="text">
                  <text x="488" y="36">Group</text>
                  <text x="8" y="52">A</text>
                  <text x="128" y="52">B</text>
                  <text x="184" y="52">...</text>
                  <text x="248" y="52">Z</text>
                  <text x="368" y="52">Directory</text>
                  <text x="496" y="52">Channel</text>
                  <text x="176" y="84">Update(B)</text>
                  <text x="248" y="116">|</text>
                  <text x="368" y="116">|</text>
                  <text x="416" y="116">Update(B)</text>
                  <text x="64" y="196">Commit(Upd)</text>
                  <text x="128" y="228">|</text>
                  <text x="248" y="228">|</text>
                  <text x="368" y="228">|</text>
                  <text x="424" y="228">Commit(Upd)</text>
                  <text x="368" y="292">|</text>
                </g>
              </svg>
            </artwork>
            <artwork type="ascii-art">
                                                          Group
A              B     ...      Z          Directory        Channel
|              |              |              |              |
|              | Update(B)    |              |              |
|              +-------------------------------------------&gt;|
|              |              |              | Update(B)    |
|&lt;----------------------------------------------------------+
|              |&lt;-------------------------------------------+
|              |              |&lt;----------------------------+
|              |              |              |              |
| Commit(Upd)  |              |              |              |
+----------------------------------------------------------&gt;|
|              |              |              | Commit(Upd)  |
|&lt;----------------------------------------------------------+
|              |&lt;-------------------------------------------+
|              |              |&lt;----------------------------+
|              |              |              |              |
</artwork>
          </artset>
        </figure>
        <t>Members are removed from the group in a similar way, as shown in <xref target="remove-flow"/>.
Any member of the group can send a Remove proposal followed by a
Commit message.  The Commit message provides new entropy to all members of the
group except the removed member.  This new entropy is added to the epoch secret
for the new epoch so that it is not known to the removed member.
Note that this does not necessarily imply that any member
is actually allowed to evict other members; groups can
enforce access control policies on top of these
basic mechanisms.</t>
        <figure anchor="remove-flow">
          <name>Client Z removes client B from the group</name>
          <artset>
            <artwork type="svg">
              <svg xmlns="http://www.w3.org/2000/svg" class="diagram" font-family="monospace" font-size="13px" height="240" text-anchor="middle" version="1.1" viewBox="0 0 520 240" width="520">
                <path d="M 8,64 L 8,224" fill="none" stroke="black"/>
                <path d="M 128,64 L 128,168" fill="none" stroke="black"/>
                <path d="M 128,184 L 128,224" fill="none" stroke="black"/>
                <path d="M 248,64 L 248,168" fill="none" stroke="black"/>
                <path d="M 248,200 L 248,224" fill="none" stroke="black"/>
                <path d="M 368,64 L 368,104" fill="none" stroke="black"/>
                <path d="M 368,120 L 368,168" fill="none" stroke="black"/>
                <path d="M 488,64 L 488,224" fill="none" stroke="black"/>
                <path d="M 248,112 L 480,112" fill="none" stroke="black"/>
                <path d="M 16,176 L 488,176" fill="none" stroke="black"/>
                <path d="M 136,192 L 488,192" fill="none" stroke="black"/>
                <path d="M 256,208 L 488,208" fill="none" stroke="black"/>
                <polygon class="arrowhead" fill="black" points="488,112 476,106.4 476,117.6" transform="rotate(0,480,112)"/>
                <polygon class="arrowhead" fill="black" points="264,208 252,202.4 252,213.6" transform="rotate(180,256,208)"/>
                <polygon class="arrowhead" fill="black" points="144,192 132,186.4 132,197.6" transform="rotate(180,136,192)"/>
                <polygon class="arrowhead" fill="black" points="24,176 12,170.4 12,181.6" transform="rotate(180,16,176)"/>
                <g class="text">
                  <text x="488" y="36">Group</text>
                  <text x="8" y="52">A</text>
                  <text x="128" y="52">B</text>
                  <text x="184" y="52">...</text>
                  <text x="248" y="52">Z</text>
                  <text x="368" y="52">Directory</text>
                  <text x="488" y="52">Channel</text>
                  <text x="296" y="84">Remove(B)</text>
                  <text x="304" y="100">Commit(Rem)</text>
                  <text x="416" y="148">Remove(B)</text>
                  <text x="424" y="164">Commit(Rem)</text>
                  <text x="368" y="228">|</text>
                </g>
              </svg>
            </artwork>
            <artwork type="ascii-art">
                                                          Group
A              B     ...      Z          Directory       Channel
|              |              |              |              |
|              |              | Remove(B)    |              |
|              |              | Commit(Rem)  |              |
|              |              +----------------------------&gt;|
|              |              |              |              |
|              |              |              | Remove(B)    |
|              |              |              | Commit(Rem)  |
|&lt;----------------------------------------------------------+
|              |&lt;-------------------------------------------+
|              |              |&lt;----------------------------+
|              |              |              |              |
</artwork>
          </artset>
        </figure>
        <t>Note that the flows in this section are examples; applications can arrange
message flows in other ways.  For example:</t>
        <ul spacing="normal">
          <li>Welcome messages don't necessarily need to be sent directly to new joiners.
Since they are encrypted to new joiners, they could be distributed more
broadly, say if the application only had access to a broadcast channel for the
group.</li>
          <li>Proposal messages don't need to be immediately sent to all group members.  They need to
be available to the committer before generating a Commit, and to other members before
processing the Commit.</li>
          <li>The sender of a Commit doesn't necessarily have to wait to receive its own
Commit back before advancing its state. It only needs to know that its Commit
will be the next one applied by the group, say based on a promise from an
orchestration server.</li>
        </ul>
      </section>
      <section anchor="external-joins">
        <name>External Joins</name>
        <t>In addition to the Welcome-based flow for adding a new member to the group, it
is also possible for a new member to join by means of an "external Commit".
This mechanism can be used when the existing members don't have a KeyPackage for
the new member, for example, in the case of an "open" group that can be joined
by new members without asking permission from existing members.</t>
        <t><xref target="groupinfo-flow"/> shows a typical  message flow for an external join. To enable
a new member to join the group in this way, a member of the group (A, B)
publishes a GroupInfo object that includes the GroupContext for the group as
well as a public key that can be used to encrypt a secret to the existing
members of the group.  When the new member Z wishes to join, they download the
GroupInfo object and use it to form a Commit of a special form that adds Z to
the group (as detailed in <xref target="joining-via-external-commits"/>).  The existing
members of the group process this external Commit in a similar way to a normal
Commit, advancing to a new epoch in which Z is now a member of the group.</t>
        <figure anchor="groupinfo-flow">
          <name>Client A publishes a GroupInfo object, and Client Z uses it to join the group</name>
          <artwork>
                                                          Group
A              B              Z          Directory        Channel
|              |              |              |              |
| GroupInfo    |              |              |              |
+-------------------------------------------&gt;|              |
|              |              | GroupInfo    |              |
|              |              |&lt;-------------+              |
|              |              |              |              |
|              |              | Commit(ExtZ) |              |
|              |              +----------------------------&gt;|
|              |              |              | Commit(ExtZ) |
|&lt;----------------------------------------------------------+
|              |&lt;-------------------------------------------+
|              |              |&lt;----------------------------+
|              |              |              |              |
</artwork>
        </figure>
      </section>
      <section anchor="relationships-between-epochs">
        <name>Relationships between Epochs</name>
        <t>A group has a single linear sequence of epochs. Groups and epochs are generally
independent of one another. However, it can sometimes be useful to link epochs
cryptographically, either within a group or across groups. MLS derives a
resumption pre-shared key (PSK) from each epoch to allow entropy extracted from
one epoch to be injected into a future epoch.  A group member that wishes to
inject a PSK issues a PreSharedKey proposal (<xref target="presharedkey"/>) describing the
PSK to be injected.  When this proposal is committed, the corresponding PSK will
be incorporated into the key schedule as described in <xref target="pre-shared-keys"/>.</t>
        <t>Linking epochs in this way
guarantees that members entering the new epoch agree on a key if and only if
they were members of the group during the epoch from which the resumption key
was extracted.</t>
        <t>MLS supports two ways to tie a new group to an existing group, which are illustrated in
Figures <xref format="counter" target="psk-reinit"/> and <xref format="counter" target="psk-branch"/>. Reinitialization
closes one group and creates a new group comprising the same members with
different parameters. Branching starts a new group with a subset of the original
group's participants (with no effect on the original group).  In both cases,
the new group is linked to the old group via a resumption PSK.</t>
        <figure anchor="psk-reinit">
          <name>Reinitializing a Group</name>
          <artset>
            <artwork type="svg">
              <svg xmlns="http://www.w3.org/2000/svg" class="diagram" font-family="monospace" font-size="13px" height="240" text-anchor="middle" version="1.1" viewBox="0 0 272 240" width="272">
                <path d="M 48,40 L 48,112" fill="none" stroke="black"/>
                <path d="M 224,136 L 224,208" fill="none" stroke="black"/>
                <path d="M 56,80 L 72,80" fill="none" stroke="black"/>
                <polygon class="arrowhead" fill="black" points="232,208 220,202.4 220,213.6" transform="rotate(90,224,208)"/>
                <polygon class="arrowhead" fill="black" points="64,80 52,74.4 52,85.6" transform="rotate(180,56,80)"/>
                <polygon class="arrowhead" fill="black" points="56,112 44,106.4 44,117.6" transform="rotate(90,48,112)"/>
                <g class="text">
                  <text x="56" y="36">epoch_A_[n-1]</text>
                  <text x="108" y="84">ReInit</text>
                  <text x="48" y="132">epoch_A_[n]</text>
                  <text x="224" y="132">epoch_B_[0]</text>
                  <text x="48" y="148">.</text>
                  <text x="48" y="164">.</text>
                  <text x="136" y="164">PSK(usage=reinit)</text>
                  <text x="132" y="180">.....................&gt;</text>
                  <text x="224" y="228">epoch_B_[1]</text>
                </g>
              </svg>
            </artwork>
            <artwork type="ascii-art">
epoch_A_[n-1]
     |
     |
     |&lt;-- ReInit
     |
     V
epoch_A_[n]           epoch_B_[0]
     .                     |
     .  PSK(usage=reinit)  |
     .....................&gt;|
                           |
                           V
                      epoch_B_[1]
</artwork>
          </artset>
        </figure>
        <figure anchor="psk-branch">
          <name>Branching a Group</name>
          <artset>
            <artwork type="svg">
              <svg xmlns="http://www.w3.org/2000/svg" class="diagram" font-family="monospace" font-size="13px" height="144" text-anchor="middle" version="1.1" viewBox="0 0 272 144" width="272">
                <path d="M 48,40 L 48,112" fill="none" stroke="black"/>
                <path d="M 224,40 L 224,112" fill="none" stroke="black"/>
                <polygon class="arrowhead" fill="black" points="232,112 220,106.4 220,117.6" transform="rotate(90,224,112)"/>
                <polygon class="arrowhead" fill="black" points="56,112 44,106.4 44,117.6" transform="rotate(90,48,112)"/>
                <g class="text">
                  <text x="48" y="36">epoch_A_[n]</text>
                  <text x="224" y="36">epoch_B_[0]</text>
                  <text x="136" y="68">PSK(usage=branch)</text>
                  <text x="136" y="84">....................&gt;</text>
                  <text x="56" y="132">epoch_A_[n+1]</text>
                  <text x="224" y="132">epoch_B_[1]</text>
                </g>
              </svg>
            </artwork>
            <artwork type="ascii-art">
epoch_A_[n]           epoch_B_[0]
     |                     |
     |  PSK(usage=branch)  |
     |....................&gt;|
     |                     |
     V                     V
epoch_A_[n+1]         epoch_B_[1]
</artwork>
          </artset>
        </figure>
        <t>Applications may also choose to use resumption PSKs to link epochs in other
ways.  For example, <xref target="psk-reinject"/> shows a case where a resumption PSK
from epoch <tt>n</tt> is injected into epoch <tt>n+k</tt>.  This demonstrates that the members
of the group at epoch <tt>n+k</tt> were also members at epoch <tt>n</tt>, irrespective of any
changes to these members' keys due to Updates or Commits.</t>
        <figure anchor="psk-reinject">
          <name>Reinjecting Entropy from an Earlier Epoch</name>
          <artset>
            <artwork type="svg">
              <svg xmlns="http://www.w3.org/2000/svg" class="diagram" font-family="monospace" font-size="13px" height="304" text-anchor="middle" version="1.1" viewBox="0 0 248 304" width="248">
                <path d="M 48,40 L 48,176" fill="none" stroke="black"/>
                <path d="M 48,200 L 48,272" fill="none" stroke="black"/>
                <polygon class="arrowhead" fill="black" points="56,272 44,266.4 44,277.6" transform="rotate(90,48,272)"/>
                <polygon class="arrowhead" fill="black" points="56,176 44,170.4 44,181.6" transform="rotate(90,48,176)"/>
                <g class="text">
                  <text x="48" y="36">epoch_A_[n]</text>
                  <text x="156" y="68">PSK(usage=application)</text>
                  <text x="136" y="84">.....................</text>
                  <text x="216" y="100">.</text>
                  <text x="216" y="116">.</text>
                  <text x="40" y="132">.</text>
                  <text x="56" y="132">.</text>
                  <text x="216" y="132">...</text>
                  <text x="216" y="148">.</text>
                  <text x="216" y="164">.</text>
                  <text x="216" y="180">.</text>
                  <text x="64" y="196">epoch_A_[n+k-1]</text>
                  <text x="216" y="196">.</text>
                  <text x="216" y="212">.</text>
                  <text x="216" y="228">.</text>
                  <text x="136" y="244">&lt;....................</text>
                  <text x="56" y="292">epoch_A_[n+k]</text>
                </g>
              </svg>
            </artwork>
            <artwork type="ascii-art">
epoch_A_[n]
     |
     |  PSK(usage=application)
     |.....................
     |                    .
     |                    .
    ...                  ...
     |                    .
     |                    .
     V                    .
epoch_A_[n+k-1]           .
     |                    .
     |                    .
     |&lt;....................
     |
     V
epoch_A_[n+k]
</artwork>
          </artset>
        </figure>
      </section>
    </section>
    <section anchor="ratchet-tree-concepts">
      <name>Ratchet Tree Concepts</name>
      <t>The protocol uses "ratchet trees" for deriving shared secrets among a group of
clients.  A ratchet tree is an arrangement of secrets and key pairs among the
members of a group in a way that allows for secrets to be efficiently updated to
reflect changes in the group.</t>
      <t>Ratchet trees allow a group to efficiently remove any member by encrypting new
entropy to a subset of the group.  A ratchet tree assigns shared keys to
subgroups of the overall group, so that, for example, encrypting to all but one
member of the group requires only <tt>log(N)</tt> encryptions to subtrees, instead of the <tt>N-1</tt>
encryptions that would be needed to encrypt to each participant individually
(where N is the number of members in the group).</t>
      <t>This remove operation allows MLS to efficiently achieve
post-compromise security.  In an Update proposal or a full Commit message, an old (possibly
compromised) representation of a member is efficiently removed from the group and
replaced with a freshly generated instance.</t>
      <section anchor="ratchet-tree-terminology">
        <name>Ratchet Tree Terminology</name>
        <t>Trees consist of <em>nodes</em>. A node is a
<em>leaf</em> if it has no children; otherwise, it is a <em>parent</em>.
All parents in our trees have precisely
two children, a <em>left</em> child and a <em>right</em> child. A node is the <em>root</em>
of a tree if it has no parent, and <em>intermediate</em> if it has both
children and a parent. The <em>descendants</em> of a node are that node's
children, and the descendants of its children.  We say a tree
<em>contains</em> a node if that node is a descendant of the root of the tree,
or if the node itself is the root of the tree. Nodes are <em>siblings</em> if they share the same parent.</t>
        <t>A <em>subtree</em> of a tree is the tree given by any node (the <em>head</em> of the
subtree) and its descendants. The <em>size</em> of a tree or subtree is the
number of leaf nodes it contains.  For a given parent node, its <em>left
subtree</em> is the subtree with its left child as head and its
<em>right subtree</em> is the subtree with its right child as head.</t>
        <t>Every tree used in this protocol is a perfect binary tree, that is, a complete
balanced binary tree with 2<sup>d</sup> leaves all at the same depth <tt>d</tt>.  This
structure is unique for a given depth <tt>d</tt>.</t>
        <t>There are multiple ways that an implementation might represent a ratchet tree in
memory.  A convenient property of left-balanced binary trees (including the
complete trees used here) is that they can be represented as an array of nodes,
with node relationships computed based on the nodes' indices in the array.  A
more traditional representation based on linked node objects may also be used.
Appendices <xref format="counter" target="array-based-trees"/> and <xref format="counter" target="link-based-trees"/> provide some details on how to
implement the tree operations required for MLS in these representations.  MLS
places no requirements on implementations' internal representations of ratchet
trees.  An implementation may use any tree representation and associated
algorithms, as long as they produce correct protocol messages.</t>
        <section anchor="ratchet-tree-nodes">
          <name>Ratchet Tree Nodes</name>
          <t>Each leaf node in a ratchet tree is given an <em>index</em> (or <em>leaf index</em>), starting
at 0 from the left to 2<sup>d</sup> - 1 at the right (for a tree with 2<sup>d</sup> leaves). A tree
with 2<sup>d</sup> leaves has 2<sup>d+1</sup> - 1 nodes, including parent nodes.</t>
          <t>Each node in a ratchet tree is either <em>blank</em> (containing no value) or it holds
an HPKE public key with some associated data:</t>
          <ul spacing="normal">
            <li>A public key (for the HPKE scheme in use; see <xref target="cipher-suites"/>)</li>
            <li>A credential (only for leaf nodes; see <xref target="credentials"/>)</li>
            <li>An ordered list of "unmerged" leaves (see <xref target="views"/>)</li>
            <li>A hash of certain information about the node's parent, as of the last time the
node was changed (see <xref target="parent-hashes"/>).</li>
          </ul>
          <t>As described in <xref target="views"/>, different members know different subsets of the set
of private keys corresponding to the public keys in nodes in the tree.  The
private key corresponding to a parent node is known only to members at leaf
nodes that are descendants of that node.  The private key corresponding to a leaf
node is known only to the member at that leaf node.  A leaf node is <em>unmerged</em>
relative to one of its ancestor nodes if the member at the leaf node does not
know the private key corresponding to the ancestor node.</t>
          <t>Every node, regardless of whether the node is blank or populated, has
a corresponding <em>hash</em> that summarizes the contents of the subtree
below that node.  The rules for computing these hashes are described
in <xref target="tree-hashes"/>.</t>
          <t>The <em>resolution</em> of a node is an ordered list of non-blank nodes
that collectively cover all non-blank descendants of the node.
The resolution of the root contains the set of keys that are collectively necessary to
encrypt to every node in the group. The resolution
of a node is effectively a depth-first, left-first enumeration of the nearest
non-blank nodes below the node:</t>
          <ul spacing="normal">
            <li>The resolution of a non-blank node comprises the node itself,
followed by its list of unmerged leaves, if any.</li>
            <li>The resolution of a blank leaf node is the empty list.</li>
            <li>The resolution of a blank intermediate node is the result of
concatenating the resolution of its left child with the resolution
of its right child, in that order.</li>
          </ul>
          <t>For example, consider the following subtree, where the <tt>_</tt> character
represents a blank node and unmerged leaves are indicated in square
brackets:</t>
          <figure anchor="resolution-tree">
            <name>A Tree with Blanks and Unmerged Leaves</name>
            <artwork type="ascii-art">
               ...
               /
              _
        ______|______
       /             \
      X[B]            _
    __|__           __|__
   /     \         /     \
  _       _       Y       _
 / \     / \     / \     / \
A   B   _   D   E   F   _   H

0   1   2   3   4   5   6   7
</artwork>
          </figure>
          <t>In this tree, we can see all of the above rules in play:</t>
          <ul spacing="normal">
            <li>The resolution of node X is the list [X, B].</li>
            <li>The resolution of leaf 2 or leaf 6 is the empty list [].</li>
            <li>The resolution of top node is the list [X, B, Y, H].</li>
          </ul>
        </section>
        <section anchor="paths-through-a-ratchet-tree">
          <name>Paths through a Ratchet Tree</name>
          <t>The <em>direct path</em> of a root is the empty list. The direct path of any other node
is the concatenation of that node's parent along with the parent's direct path.</t>
          <t>The <em>copath</em> of a node is the node's sibling concatenated with the list of
siblings of all the nodes in its direct path, excluding the root.</t>
          <t>The <em>filtered direct path</em> of a leaf node L is the node's direct path, with any
node removed whose child on the copath of L has an empty resolution (keeping in
mind that any unmerged leaves of the copath child count toward its resolution).
The removed nodes do not need their own key pairs because encrypting to the
node's key pair would be equivalent to encrypting to its non-copath child.</t>
          <t>For example, consider the following tree (where blank nodes are indicated with
<tt>_</tt>, but also assigned a label for reference):</t>
          <figure anchor="full-tree">
            <name>A Complete Tree with Five Members, with Labels for Blank Parent Nodes</name>
            <artset>
              <artwork type="svg">
                <svg xmlns="http://www.w3.org/2000/svg" class="diagram" font-family="monospace" font-size="13px" height="240" text-anchor="middle" version="1.1" viewBox="0 0 256 240" width="256">
                  <path d="M 56,104 L 56,128" fill="none" stroke="black"/>
                  <path d="M 120,48 L 120,64" fill="none" stroke="black"/>
                  <path d="M 184,112 L 184,128" fill="none" stroke="black"/>
                  <path d="M 72,64 L 168,64" fill="none" stroke="black"/>
                  <path d="M 40,128 L 72,128" fill="none" stroke="black"/>
                  <path d="M 168,128 L 200,128" fill="none" stroke="black"/>
                  <path d="M 72,128 L 80,144" fill="none" stroke="black"/>
                  <path d="M 92,168 L 96,176" fill="none" stroke="black"/>
                  <path d="M 168,64 L 176,80" fill="none" stroke="black"/>
                  <path d="M 200,128 L 208,144" fill="none" stroke="black"/>
                  <path d="M 220,168 L 224,176" fill="none" stroke="black"/>
                  <path d="M 32,144 L 40,128" fill="none" stroke="black"/>
                  <path d="M 64,80 L 72,64" fill="none" stroke="black"/>
                  <path d="M 80,176 L 84,168" fill="none" stroke="black"/>
                  <path d="M 160,144 L 168,128" fill="none" stroke="black"/>
                  <path d="M 208,176 L 212,168" fill="none" stroke="black"/>
                  <g class="text">
                    <text x="120" y="36">W</text>
                    <text x="136" y="36">=</text>
                    <text x="164" y="36">root</text>
                    <text x="64" y="100">_=U</text>
                    <text x="184" y="100">Y</text>
                    <text x="24" y="164">T</text>
                    <text x="96" y="164">_=V</text>
                    <text x="152" y="164">X</text>
                    <text x="224" y="164">_=Z</text>
                    <text x="16" y="180">/</text>
                    <text x="32" y="180">\</text>
                    <text x="144" y="180">/</text>
                    <text x="160" y="180">\</text>
                    <text x="8" y="196">A</text>
                    <text x="40" y="196">B</text>
                    <text x="72" y="196">_</text>
                    <text x="104" y="196">_</text>
                    <text x="136" y="196">E</text>
                    <text x="168" y="196">F</text>
                    <text x="200" y="196">G</text>
                    <text x="240" y="196">_=H</text>
                    <text x="8" y="228">0</text>
                    <text x="40" y="228">1</text>
                    <text x="72" y="228">2</text>
                    <text x="104" y="228">3</text>
                    <text x="136" y="228">4</text>
                    <text x="168" y="228">5</text>
                    <text x="200" y="228">6</text>
                    <text x="232" y="228">7</text>
                  </g>
                </svg>
              </artwork>
              <artwork type="ascii-art">
              W = root
              |
        .-----+-----.
       /             \
      _=U             Y
      |               |
    .-+-.           .-+-.
   /     \         /     \
  T       _=V     X       _=Z
 / \     / \     / \     / \
A   B   _   _   E   F   G   _=H

0   1   2   3   4   5   6   7
</artwork>
            </artset>
          </figure>
          <t>In this tree, the direct paths, copaths, and filtered direct paths for the leaf
nodes are as follows:</t>
          <table>
            <thead>
              <tr>
                <th align="left">Node</th>
                <th align="left">Direct path</th>
                <th align="left">Copath</th>
                <th align="left">Filtered Direct Path</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td align="left">A</td>
                <td align="left">T, U, W</td>
                <td align="left">B, V, Y</td>
                <td align="left">T, W</td>
              </tr>
              <tr>
                <td align="left">B</td>
                <td align="left">T, U, W</td>
                <td align="left">A, V, Y</td>
                <td align="left">T, W</td>
              </tr>
              <tr>
                <td align="left">E</td>
                <td align="left">X, Y, W</td>
                <td align="left">F, Z, U</td>
                <td align="left">X, Y, W</td>
              </tr>
              <tr>
                <td align="left">F</td>
                <td align="left">X, Y, W</td>
                <td align="left">E, Z, U</td>
                <td align="left">X, Y, W</td>
              </tr>
              <tr>
                <td align="left">G</td>
                <td align="left">Z, Y, W</td>
                <td align="left">H, X, U</td>
                <td align="left">Y, W</td>
              </tr>
            </tbody>
          </table>
        </section>
      </section>
      <section anchor="views">
        <name>Views of a Ratchet Tree</name>
        <t>We generally assume that each participant maintains a complete and
up-to-date view of the public state of the group's ratchet tree,
including the public keys for all nodes and the credentials
associated with the leaf nodes.</t>
        <t>No participant in an MLS group knows the private key associated with
every node in the tree. Instead, each member is assigned to a leaf of the tree,
which determines the subset of private keys it knows. The
credential stored at that leaf is one provided by the member.</t>
        <t>In particular, MLS maintains the members' views of the tree in such
a way as to maintain the <em>tree invariant</em>:</t>
        <blockquote>
          The private key for a node in the tree is known to a member of
          the group only if the node's subtree contains that member's leaf.
        </blockquote>
        <t>In other words, if a node is not blank, then it holds a public key.
The corresponding private key is known only to members occupying
leaves below that node.</t>
        <t>The reverse implication is not true: A member may not know the private key of
an intermediate node above them.  Such a member has an <em>unmerged</em> leaf at the
intermediate node.  Encrypting to an intermediate node requires encrypting to
the node's public key, as well as the public keys of all the unmerged leaves
below it.  A leaf is unmerged with regard to all of its ancestors when it is
first added, because the process of adding the leaf does not give it access to
the private keys for all of the nodes above it in the tree.  Leaves are "merged"
as they receive the private keys for nodes, as described in
<xref target="ratchet-tree-evolution"/>.</t>
        <t>For example, consider a four-member group (A, B, C, D) where the node above the
right two members is blank.  (This is what it would look like if A created a
group with B, C, and D.)  Then the public state of the tree and the views of the
private keys of the tree held by each participant would be as follows, where <tt>_</tt>
represents a blank node, <tt>?</tt> represents an unknown private key, and <tt>pk(X)</tt>
represents the public key corresponding to the private key <tt>X</tt>:</t>
        <artwork type="ascii-art">
         Public Tree
============================
            pk(ABCD)
          /          \
    pk(AB)            _
     / \             / \
pk(A)   pk(B)   pk(C)   pk(D)


 Private @ A       Private @ B       Private @ C       Private @ D
=============     =============     =============     =============
     ABCD              ABCD              ABCD              ABCD
    /   \             /   \             /   \             /   \
  AB      _         AB      _         ?       _         ?       _
 / \     / \       / \     / \       / \     / \       / \     / \
A   ?   ?   ?     ?   B   ?   ?     ?   ?   C   ?     ?   ?   ?   D
</artwork>
        <t>Note how the tree invariant applies: Each member knows only their own leaf,
the private key AB is known only to A and B, and the private key ABCD
is known to all four members. This also illustrates another important
point: it is possible for there to be "holes" on the path from a member's leaf
to the root in which the member knows the key both above and below
a given node, but not for that node, as in the case with D.</t>
      </section>
    </section>
    <section anchor="cryptographic-objects">
      <name>Cryptographic Objects</name>
      <section anchor="cipher-suites">
        <name>Cipher Suites</name>
        <t>Each MLS session uses a single cipher suite that specifies the
following primitives to be used in group key computations:</t>
        <ul spacing="normal">
          <li>
            <t>HPKE parameters:
            </t>
            <ul spacing="normal">
              <li>A Key Encapsulation Mechanism (KEM)</li>
              <li>A Key Derivation Function (KDF)</li>
              <li>An Authenticated Encryption with Associated Data (AEAD) encryption algorithm</li>
            </ul>
          </li>
          <li>A hash algorithm</li>
          <li>A Message Authentication Code (MAC) algorithm</li>
          <li>A signature algorithm</li>
        </ul>
        <t>MLS uses HPKE for public key encryption <xref target="RFC9180"/>.  The
<tt>DeriveKeyPair</tt> function associated to the KEM for the cipher suite maps octet
strings to HPKE key pairs.  As in HPKE, MLS assumes that an AEAD algorithm
produces a single ciphertext output from AEAD encryption (aligning with
<xref target="RFC5116"/>), as opposed to a separate ciphertext and tag.</t>
        <t>Cipher suites are represented with the CipherSuite type. The cipher suites are
defined in <xref target="mls-cipher-suites"/>.</t>
        <section anchor="public-keys">
          <name>Public Keys</name>
          <t>HPKE public keys are opaque values in a format defined by the underlying
protocol (see <xref section="4" sectionFormat="of" target="RFC9180"/> for more information).</t>
          <sourcecode type="tls-presentation">
opaque HPKEPublicKey&lt;V&gt;;
</sourcecode>
          <t>Signature public keys are likewise represented as opaque values in a format
defined by the cipher suite's signature scheme.</t>
          <sourcecode type="tls-presentation">
opaque SignaturePublicKey&lt;V&gt;;
</sourcecode>
          <t>For cipher suites using the Edwards-curve Digital Signature Algorithm (EdDSA)
signature schemes (Ed25519 or Ed448), the public key is in the format specified
in <xref target="RFC8032"/>.</t>
          <t>For cipher suites using the Elliptic Curve Digital Signature Algorithm (ECDSA)
with the NIST curves (P-256, P-384, or P-521), the public key is represented as
an encoded UncompressedPointRepresentation struct, as defined in <xref target="RFC8446"/>.</t>
        </section>
        <section anchor="signing">
          <name>Signing</name>
          <t>The signature algorithm specified in a group's cipher suite is the mandatory algorithm
to be used for signing messages within the group.  It
<bcp14>MUST</bcp14> be the same as the signature algorithm specified in the credentials in the
leaves of the tree (including the leaf node information in KeyPackages used to
add new members).</t>
          <t>The signatures used in this document are encoded as specified in <xref target="RFC8446"/>.
In particular, ECDSA signatures are DER encoded, and EdDSA signatures are defined
as the concatenation of <tt>R</tt> and <tt>S</tt>, as specified in <xref target="RFC8032"/>.</t>
          <t>To disambiguate different signatures used in MLS, each signed value is prefixed
by a label as shown below:</t>
          <sourcecode type="pseudocode">
SignWithLabel(SignatureKey, Label, Content) =
    Signature.Sign(SignatureKey, SignContent)

VerifyWithLabel(VerificationKey, Label, Content, SignatureValue) =
    Signature.Verify(VerificationKey, SignContent, SignatureValue)
</sourcecode>
          <t>Where SignContent is specified as:</t>
          <sourcecode type="tls-presentation">
struct {
    opaque label&lt;V&gt;;
    opaque content&lt;V&gt;;
} SignContent;
</sourcecode>
          <t>And its fields are set to:</t>
          <sourcecode type="pseudocode">
label = "MLS 1.0 " + Label;
content = Content;
</sourcecode>
          <t>The functions <tt>Signature.Sign</tt> and <tt>Signature.Verify</tt> are defined by the
signature algorithm.  If MLS extensions require signatures by group members,
they should reuse the SignWithLabel construction, using a distinct label.  To
avoid collisions in these labels, an IANA registry is defined in
<xref target="mls-signature-labels"/>.</t>
        </section>
        <section anchor="public-key-encryption">
          <name>Public Key Encryption</name>
          <t>As with signing, MLS includes a label and context in encryption operations to
avoid confusion between ciphertexts produced for different purposes.  Encryption
and decryption including this label and context are done as follows:</t>
          <sourcecode type="pseudocode">
EncryptWithLabel(PublicKey, Label, Context, Plaintext) =
  SealBase(PublicKey, EncryptContext, "", Plaintext)

DecryptWithLabel(PrivateKey, Label, Context, KEMOutput, Ciphertext) =
  OpenBase(KEMOutput, PrivateKey, EncryptContext, "", Ciphertext)
</sourcecode>
          <t>Where EncryptContext is specified as:</t>
          <sourcecode type="tls-presentation">
struct {
  opaque label&lt;V&gt;;
  opaque context&lt;V&gt;;
} EncryptContext;
</sourcecode>
          <t>And its fields are set to:</t>
          <artwork>
label = "MLS 1.0 " + Label;
context = Context;
</artwork>
          <t>The functions <tt>SealBase</tt> and <tt>OpenBase</tt> are defined in <xref section="6.1" sectionFormat="of" target="RFC9180"/> (with "Base" as the MODE), using the HPKE algorithms specified by the
group's cipher suite.  If MLS extensions require HPKE encryption operations, they
should reuse the EncryptWithLabel construction, using a distinct label.  To
avoid collisions in these labels, an IANA registry is defined in
<xref target="mls-public-key-encryption-labels"/>.</t>
        </section>
      </section>
      <section anchor="hash-based-identifiers">
        <name>Hash-Based Identifiers</name>
        <t>Some MLS messages refer to other MLS objects by hash.  For example, Welcome
messages refer to KeyPackages for the members being welcomed, and Commits refer
to Proposals they cover.  These identifiers are computed as follows:</t>
        <sourcecode type="tls-presentation">
opaque HashReference&lt;V&gt;;

HashReference KeyPackageRef;
HashReference ProposalRef;
</sourcecode>
        <sourcecode type="pseudocode">
MakeKeyPackageRef(value)
  = RefHash("MLS 1.0 KeyPackage Reference", value)

MakeProposalRef(value)
  = RefHash("MLS 1.0 Proposal Reference", value)

RefHash(label, value) = Hash(RefHashInput)
</sourcecode>
        <t>Where RefHashInput is defined as:</t>
        <sourcecode type="tls-presentation">
struct {
  opaque label&lt;V&gt;;
  opaque value&lt;V&gt;;
} RefHashInput;
</sourcecode>
        <t>And its fields are set to:</t>
        <sourcecode type="pseudocode">
label = label;
value = value;
</sourcecode>
        <t>For a KeyPackageRef, the <tt>value</tt> input is the encoded KeyPackage, and the
cipher suite specified in the KeyPackage determines the KDF used.  For a
ProposalRef, the <tt>value</tt> input is the AuthenticatedContent carrying the
Proposal.  In the latter two cases, the KDF is determined by the group's
cipher suite.</t>
      </section>
      <section anchor="credentials">
        <name>Credentials</name>
        <t>Each member of a group presents a credential that provides one or more
identities for the member and associates them with the member's signing key.
The identities and signing key are verified by the Authentication Service in use
for a group.</t>
        <t>It is up to the application to decide which identifiers to use at
the application level.  For example,
a certificate in an X509Credential may attest to several domain names or email
addresses in its subjectAltName extension.  An application may decide to
present all of these to a user, or if it knows a "desired" domain name or email
address, it can check that the desired identifier is among those attested.
Using the terminology from <xref target="RFC6125"/>, a credential provides "presented
identifiers", and it is up to the application to supply a "reference identifier"
for the authenticated client, if any.</t>
        <sourcecode type="tls-presentation">
// See the "MLS Credential Types" IANA registry for values
uint16 CredentialType;

struct {
    opaque cert_data&lt;V&gt;;
} Certificate;

struct {
    CredentialType credential_type;
    select (Credential.credential_type) {
        case basic:
            opaque identity&lt;V&gt;;

        case x509:
            Certificate certificates&lt;V&gt;;
    };
} Credential;
</sourcecode>
        <t>A "basic" credential is a bare assertion of an identity, without any additional
information.  The format of the encoded identity is defined by the application.</t>
        <t>For an X.509 credential, each entry in the <tt>certificates</tt> field represents a single DER-encoded
X.509 certificate. The chain is ordered such that the first entry (certificates[0]) is
the end-entity certificate. The public key encoded in the
<tt>subjectPublicKeyInfo</tt> of the end-entity certificate <bcp14>MUST</bcp14> be identical to the
<tt>signature_key</tt> in the LeafNode containing this credential. A chain <bcp14>MAY</bcp14> omit any
non-leaf certificates that supported peers are known to already possess.</t>
        <section anchor="credential-validation">
          <name>Credential Validation</name>
          <t>The application using MLS is responsible for specifying which identifiers it
finds acceptable for each member in a group.  In other words, following the
model that <xref target="RFC6125"/> describes for TLS, the application maintains a list of
"reference identifiers" for the members of a group, and the credentials provide
"presented identifiers".  A member of a group is authenticated by first
validating that the member's credential legitimately represents some presented
identifiers, and then ensuring that the reference identifiers for the member are
authenticated by those presented identifiers.</t>
          <t>The parts of the system that perform these functions are collectively referred
to as the Authentication Service (AS) <xref target="I-D.ietf-mls-architecture"/>.  A
member's credential is said to be <em>validated with the AS</em> when the AS verifies
that the credential's presented identifiers are correctly associated with the
<tt>signature_key</tt> field in the member's LeafNode, and that those
identifiers match the reference identifiers for the member.</t>
          <t>Whenever a new credential is introduced in the group, it <bcp14>MUST</bcp14> be validated with
the AS.  In particular, at the following events in the protocol:</t>
          <ul spacing="normal">
            <li>When a member receives a KeyPackage that it will use in an Add proposal to add
a new member to the group</li>
            <li>When a member receives a GroupInfo object that it will use to join a group,
either via a Welcome or via an external Commit</li>
            <li>When a member receives an Add proposal adding a member to the group</li>
            <li>When a member receives an Update proposal whose LeafNode has a new credential
for the member</li>
            <li>When a member receives a Commit with an UpdatePath whose LeafNode has a new
credential for the committer</li>
            <li>When an <tt>external_senders</tt> extension is added to the group</li>
            <li>When an existing <tt>external_senders</tt> extension is updated</li>
          </ul>
          <t>In cases where a member's credential is being replaced, such as the Update and
Commit cases above, the AS <bcp14>MUST</bcp14> also verify that the set of presented
identifiers in the new credential is valid as a successor to the set of
presented identifiers in the old credential, according to the application's
policy.</t>
        </section>
        <section anchor="credential-expiry-and-revocation">
          <name>Credential Expiry and Revocation</name>
          <t>In some credential schemes, a valid credential can "expire" or become invalid
after a certain point in time. For example, each X.509 certificate has a
<tt>notAfter</tt> field, expressing a time after which the certificate is not valid.</t>
          <t>Expired credentials can cause operational problems in light of the validation
requirements of <xref target="credential-validation"/>.  Applications can apply some
operational practices and adaptations to Authentication Service policies to
moderate these impacts.</t>
          <t>In general, to avoid operational problems such as new joiners rejecting expired
credentials in a group, applications that use such credentials should ensure to
the extent practical that all of the credentials in use in a group are valid at
all times.</t>
          <t>If a member finds that its credential has expired (or will soon), it should
issue an Update or Commit that replaces it with a valid credential.  For this
reason, members <bcp14>SHOULD</bcp14> accept Update proposals and Commits issued by members
with expired credentials, if the credential in the Update or Commit is valid.</t>
          <t>Similarly, when a client is processing messages sent some time in the past
(e.g., syncing up with a group after being offline), the client <bcp14>SHOULD</bcp14> accept
signatures from members with expired credentials, since the credential may
have been valid at the time the message was sent.</t>
          <t>If a member finds that another member's credential has expired, they may issue a
Remove that removes that member.  For example, an application could require a
member preparing to issue a Commit to check the tree for expired credentials and
include Remove proposals for those members in its Commit.  In situations where
the group tree is known to the DS, the DS could also monitor the tree for
expired credentials and issue external Remove proposals.</t>
          <t>Some credential schemes also allow credentials to be revoked.  Revocation is
similar to expiry in that a previously valid credential becomes invalid.
As such, most of the considerations above also apply to revoked credentials.
However, applications may want to treat revoked credentials differently, e.g.,
by removing members with revoked credentials while allowing members with expired
credentials time to update.</t>
        </section>
        <section anchor="uniquely-identifying-clients">
          <name>Uniquely Identifying Clients</name>
          <t>MLS implementations will presumably provide applications with a way to request
protocol operations with regard to other clients (e.g., removing clients).  Such
functions will need to refer to the other clients using some identifier.  MLS
clients have a few types of identifiers, with different operational properties.</t>
          <t>Internally to the protocol, group members are uniquely identified by their leaf
index. However, a leaf index is only valid for referring to members in a given
epoch. The same leaf index may represent a different member, or no member at
all, in a subsequent epoch.</t>
          <t>The Credentials presented by the clients in a group authenticate
application-level identifiers for the clients.  However, these identifiers may not
uniquely identify clients.  For example, if a user has multiple devices that are
all present in an MLS group, then those devices' clients could all present the
user's application-layer identifiers.</t>
          <t>If needed, applications may add application-specific identifiers to the
<tt>extensions</tt> field of a LeafNode object with the <tt>application_id</tt> extension.</t>
          <sourcecode type="tls-presentation">
opaque application_id&lt;V&gt;;
</sourcecode>
          <t>However, applications <bcp14>MUST NOT</bcp14> rely on the data in an <tt>application_id</tt> extension
as if it were authenticated by the Authentication Service, and <bcp14>SHOULD</bcp14> gracefully
handle cases where the identifier presented is not unique.</t>
        </section>
      </section>
    </section>
    <section anchor="message-framing">
      <name>Message Framing</name>
      <t>Handshake and application messages use a common framing structure.
This framing provides encryption to ensure confidentiality within the
group, as well as signing to authenticate the sender.</t>
      <t>In most of the protocol, messages are handled in the form of
AuthenticatedContent objects.  These structures contain the content of the
message itself as well as information to authenticate the sender (see
<xref target="content-authentication"/>).  The additional protections required to transmit
these messages over an untrusted channel (group membership authentication or
AEAD encryption) are added by encoding the AuthenticatedContent as a
PublicMessage or PrivateMessage message, which can then be sent as an MLSMessage.
Likewise, these protections are enforced (via membership verification or AEAD
decryption) when decoding a PublicMessage or PrivateMessage into an
AuthenticatedContent object.</t>
      <t>PrivateMessage represents a signed and encrypted message, with
protections for both the content of the message and related
metadata.  PublicMessage represents a message that is only signed,
and not encrypted.  Applications <bcp14>MUST</bcp14> use PrivateMessage to encrypt
application messages and <bcp14>SHOULD</bcp14> use PrivateMessage to encode
handshake messages, but they <bcp14>MAY</bcp14> transmit handshake messages encoded
as PublicMessage objects in cases where it is necessary for the
Delivery Service to examine such messages.</t>
      <sourcecode type="tls-presentation">
enum {
    reserved(0),
    mls10(1),
    (65535)
} ProtocolVersion;

enum {
    reserved(0),
    application(1),
    proposal(2),
    commit(3),
    (255)
} ContentType;

enum {
    reserved(0),
    member(1),
    external(2),
    new_member_proposal(3),
    new_member_commit(4),
    (255)
} SenderType;

struct {
    SenderType sender_type;
    select (Sender.sender_type) {
        case member:
            uint32 leaf_index;
        case external:
            uint32 sender_index;
        case new_member_commit:
        case new_member_proposal:
            struct{};
    };
} Sender;

// See the "MLS Wire Formats" IANA registry for values
uint16 WireFormat;

struct {
    opaque group_id&lt;V&gt;;
    uint64 epoch;
    Sender sender;
    opaque authenticated_data&lt;V&gt;;

    ContentType content_type;
    select (FramedContent.content_type) {
        case application:
          opaque application_data&lt;V&gt;;
        case proposal:
          Proposal proposal;
        case commit:
          Commit commit;
    };
} FramedContent;

struct {
    ProtocolVersion version = mls10;
    WireFormat wire_format;
    select (MLSMessage.wire_format) {
        case mls_public_message:
            PublicMessage public_message;
        case mls_private_message:
            PrivateMessage private_message;
        case mls_welcome:
            Welcome welcome;
        case mls_group_info:
            GroupInfo group_info;
        case mls_key_package:
            KeyPackage key_package;
    };
} MLSMessage;
</sourcecode>
      <t>Messages from senders that aren't in the group are sent as PublicMessage. See
Sections <xref format="counter" target="external-proposals"/> and <xref format="counter" target="joining-via-external-commits"/> for more details.</t>
      <t>The following structure is used to fully describe the data transmitted in
plaintexts or ciphertexts.</t>
      <sourcecode type="tls-presentation">
struct {
    WireFormat wire_format;
    FramedContent content;
    FramedContentAuthData auth;
} AuthenticatedContent;
</sourcecode>
      <t>The following figure illustrates how the various structures described in this
section relate to each other, and the high-level operations used to produce and
consume them:</t>
      <figure>
        <name>Relationships among MLS Objects</name>
        <artset>
          <artwork type="svg">
            <svg xmlns="http://www.w3.org/2000/svg" class="diagram" font-family="monospace" font-size="13px" height="480" text-anchor="middle" version="1.1" viewBox="0 0 520 480" width="520">
              <path d="M 64,48 L 64,64" fill="none" stroke="black"/>
              <path d="M 88,144 L 88,176" fill="none" stroke="black"/>
              <path d="M 88,208 L 88,224" fill="none" stroke="black"/>
              <path d="M 112,304 L 112,336" fill="none" stroke="black"/>
              <path d="M 112,368 L 112,416" fill="none" stroke="black"/>
              <path d="M 160,128 L 160,144" fill="none" stroke="black"/>
              <path d="M 160,224 L 160,256" fill="none" stroke="black"/>
              <path d="M 184,48 L 184,96" fill="none" stroke="black"/>
              <path d="M 184,128 L 184,256" fill="none" stroke="black"/>
              <path d="M 184,288 L 184,304" fill="none" stroke="black"/>
              <path d="M 256,304 L 256,336" fill="none" stroke="black"/>
              <path d="M 256,368 L 256,448" fill="none" stroke="black"/>
              <path d="M 304,48 L 304,64" fill="none" stroke="black"/>
              <path d="M 304,400 L 304,416" fill="none" stroke="black"/>
              <path d="M 336,144 L 336,240" fill="none" stroke="black"/>
              <path d="M 336,304 L 336,336" fill="none" stroke="black"/>
              <path d="M 392,400 L 392,416" fill="none" stroke="black"/>
              <path d="M 480,400 L 480,416" fill="none" stroke="black"/>
              <path d="M 64,64 L 304,64" fill="none" stroke="black"/>
              <path d="M 88,144 L 160,144" fill="none" stroke="black"/>
              <path d="M 336,176 L 352,176" fill="none" stroke="black"/>
              <path d="M 88,224 L 160,224" fill="none" stroke="black"/>
              <path d="M 112,304 L 256,304" fill="none" stroke="black"/>
              <path d="M 336,320 L 352,320" fill="none" stroke="black"/>
              <path d="M 112,416 L 480,416" fill="none" stroke="black"/>
              <path d="M 320,128 C 328.83064,128 336,135.16936 336,144" fill="none" stroke="black"/>
              <path d="M 320,256 C 328.83064,256 336,248.83064 336,240" fill="none" stroke="black"/>
              <path d="M 320,288 C 328.83064,288 336,295.16936 336,304" fill="none" stroke="black"/>
              <path d="M 320,352 C 328.83064,352 336,344.83064 336,336" fill="none" stroke="black"/>
              <polygon class="arrowhead" fill="black" points="264,448 252,442.4 252,453.6" transform="rotate(90,256,448)"/>
              <polygon class="arrowhead" fill="black" points="264,336 252,330.4 252,341.6" transform="rotate(90,256,336)"/>
              <polygon class="arrowhead" fill="black" points="192,256 180,250.4 180,261.6" transform="rotate(90,184,256)"/>
              <polygon class="arrowhead" fill="black" points="192,96 180,90.4 180,101.6" transform="rotate(90,184,96)"/>
              <polygon class="arrowhead" fill="black" points="168,256 156,250.4 156,261.6" transform="rotate(90,160,256)"/>
              <polygon class="arrowhead" fill="black" points="120,336 108,330.4 108,341.6" transform="rotate(90,112,336)"/>
              <polygon class="arrowhead" fill="black" points="96,176 84,170.4 84,181.6" transform="rotate(90,88,176)"/>
              <g class="text">
                <text x="68" y="36">Proposal</text>
                <text x="188" y="36">Commit</text>
                <text x="296" y="36">Application</text>
                <text x="364" y="36">Data</text>
                <text x="176" y="116">FramedContent</text>
                <text x="404" y="180">Asymmetric</text>
                <text x="88" y="196">FramedContentAuthData</text>
                <text x="380" y="196">Sign</text>
                <text x="408" y="196">/</text>
                <text x="444" y="196">Verify</text>
                <text x="188" y="276">AuthenticatedContent</text>
                <text x="400" y="324">Symmetric</text>
                <text x="392" y="340">Protect</text>
                <text x="432" y="340">/</text>
                <text x="480" y="340">Unprotect</text>
                <text x="112" y="356">PublicMessage</text>
                <text x="252" y="356">PrivateMessage</text>
                <text x="304" y="388">Welcome</text>
                <text x="388" y="388">KeyPackage</text>
                <text x="480" y="388">GroupInfo</text>
                <text x="260" y="468">MLSMessage</text>
              </g>
            </svg>
          </artwork>
          <artwork type="ascii-art">
    Proposal        Commit     Application Data
       |              |              |
       +--------------+--------------+
                      |
                      V
               FramedContent
                   |  |                -.
          +--------+  |                  |
          |           |                  |
          V           |                  +-- Asymmetric
FramedContentAuthData |                  |   Sign / Verify
          |           |                  |
          +--------+  |                  |
                   |  |                  |
                   V  V                -'
             AuthenticatedContent
                      |                -.
             +--------+--------+         |
             |                 |         +-- Symmetric
             V                 V         |   Protect / Unprotect
       PublicMessage    PrivateMessage -'
             |                 |
             |                 |  Welcome  KeyPackage  GroupInfo
             |                 |     |          |          |
             +-----------------+-----+----------+----------+
                               |
                               V
                           MLSMessage
</artwork>
        </artset>
      </figure>
      <section anchor="content-authentication">
        <name>Content Authentication</name>
        <t>FramedContent is authenticated using the FramedContentAuthData structure.</t>
        <sourcecode type="tls-presentation">
struct {
    ProtocolVersion version = mls10;
    WireFormat wire_format;
    FramedContent content;
    select (FramedContentTBS.content.sender.sender_type) {
        case member:
        case new_member_commit:
            GroupContext context;
        case external:
        case new_member_proposal:
            struct{};
    };
} FramedContentTBS;

opaque MAC&lt;V&gt;;

struct {
    /* SignWithLabel(., "FramedContentTBS", FramedContentTBS) */
    opaque signature&lt;V&gt;;
    select (FramedContent.content_type) {
        case commit:
            /*
              MAC(confirmation_key,
                  GroupContext.confirmed_transcript_hash)
            */
            MAC confirmation_tag;
        case application:
        case proposal:
            struct{};
    };
} FramedContentAuthData;
</sourcecode>
        <t>The signature is computed using <tt>SignWithLabel</tt> with label
<tt>"FramedContentTBS"</tt> and with a content that covers the message content and
the wire format that will be used for this message. If the sender's
<tt>sender_type</tt> is <tt>member</tt>, the content also covers the GroupContext for the
current epoch so that signatures are specific to a given group and epoch.</t>
        <t>The sender <bcp14>MUST</bcp14> use the private key corresponding to the following signature key
depending on the sender's <tt>sender_type</tt>:</t>
        <ul spacing="normal">
          <li><tt>member</tt>: The signature key contained in the LeafNode at the index
indicated by <tt>leaf_index</tt> in the ratchet tree.</li>
          <li><tt>external</tt>: The signature key at the index
indicated by <tt>sender_index</tt> in the <tt>external_senders</tt> group context
extension (see <xref target="external-senders-extension"/>). The
<tt>content_type</tt> of the message <bcp14>MUST</bcp14> be <tt>proposal</tt> and the <tt>proposal_type</tt> <bcp14>MUST</bcp14> be a value that is allowed for external senders.</li>
          <li><tt>new_member_commit</tt>: The signature key in the LeafNode in
  the Commit's path (see <xref target="joining-via-external-commits"/>). The
  <tt>content_type</tt> of the message <bcp14>MUST</bcp14> be <tt>commit</tt>.</li>
          <li><tt>new_member_proposal</tt>: The signature key in the LeafNode in
  the KeyPackage embedded in an external Add proposal. The
  <tt>content_type</tt> of the message <bcp14>MUST</bcp14> be <tt>proposal</tt> and the
  <tt>proposal_type</tt> of the Proposal <bcp14>MUST</bcp14> be <tt>add</tt>.</li>
        </ul>
        <t>Recipients of an MLSMessage <bcp14>MUST</bcp14> verify the signature with the key depending on
the <tt>sender_type</tt> of the sender as described above.</t>
        <t>The confirmation tag value confirms that the members of the group have arrived
at the same state of the group. A FramedContentAuthData is said to be valid when both
the <tt>signature</tt> and <tt>confirmation_tag</tt> fields are valid.</t>
      </section>
      <section anchor="encoding-and-decoding-a-public-message">
        <name>Encoding and Decoding a Public Message</name>
        <t>Messages that are authenticated but not encrypted are encoded using the PublicMessage structure.</t>
        <sourcecode type="tls-presentation">
struct {
    FramedContent content;
    FramedContentAuthData auth;
    select (PublicMessage.content.sender.sender_type) {
        case member:
            MAC membership_tag;
        case external:
        case new_member_commit:
        case new_member_proposal:
            struct{};
    };
} PublicMessage;
</sourcecode>
        <t>The <tt>membership_tag</tt> field in the PublicMessage object authenticates the sender's
membership in the group. For messages sent by members, it <bcp14>MUST</bcp14> be set to the
following value:</t>
        <sourcecode type="tls-presentation">
struct {
  FramedContentTBS content_tbs;
  FramedContentAuthData auth;
} AuthenticatedContentTBM;
</sourcecode>
        <sourcecode type="pseudocode">
membership_tag = MAC(membership_key, AuthenticatedContentTBM)
</sourcecode>
        <t>When decoding a PublicMessage into an AuthenticatedContent,
the application <bcp14>MUST</bcp14> check <tt>membership_tag</tt> and <bcp14>MUST</bcp14> check that the
FramedContentAuthData is valid.</t>
      </section>
      <section anchor="encoding-and-decoding-a-private-message">
        <name>Encoding and Decoding a Private Message</name>
        <t>Authenticated and encrypted messages are encoded using the PrivateMessage structure.</t>
        <sourcecode type="tls-presentation">
struct {
    opaque group_id&lt;V&gt;;
    uint64 epoch;
    ContentType content_type;
    opaque authenticated_data&lt;V&gt;;
    opaque encrypted_sender_data&lt;V&gt;;
    opaque ciphertext&lt;V&gt;;
} PrivateMessage;
</sourcecode>
        <t><tt>encrypted_sender_data</tt> and <tt>ciphertext</tt> are encrypted using the AEAD function
specified by the cipher suite in use, using the SenderData
and PrivateMessageContent structures as input.</t>
        <section anchor="content-encryption">
          <name>Content Encryption</name>
          <t>Content to be encrypted is encoded in a PrivateMessageContent structure.</t>
          <sourcecode type="tls-presentation">
struct {
    select (PrivateMessage.content_type) {
        case application:
          opaque application_data&lt;V&gt;;

        case proposal:
          Proposal proposal;

        case commit:
          Commit commit;
    };

    FramedContentAuthData auth;
    opaque padding[length_of_padding];
} PrivateMessageContent;
</sourcecode>
          <t>The <tt>padding</tt> field is set by the sender, by first encoding the content (via the
<tt>select</tt>) and the <tt>auth</tt> field, and then appending the chosen number of zero bytes.
A receiver identifies the padding field in a plaintext decoded from
<tt>PrivateMessage.ciphertext</tt> by first decoding the content and the <tt>auth</tt> field;
then the <tt>padding</tt> field comprises any remaining octets of plaintext.  The
<tt>padding</tt> field <bcp14>MUST</bcp14> be filled with all zero bytes.  A receiver <bcp14>MUST</bcp14> verify that
there are no non-zero bytes in the <tt>padding</tt> field, and if this check fails, the
enclosing PrivateMessage <bcp14>MUST</bcp14> be rejected as malformed.  This check ensures that
the padding process is deterministic, so that, for example, padding cannot be
used as a covert channel.</t>
          <t>In the MLS key schedule, the sender creates two distinct key ratchets for
handshake and application messages for each member of the group. When encrypting
a message, the sender looks at the ratchets it derived for its own member and
chooses an unused generation from either the handshake ratchet or the application ratchet,
depending on the content type of the message. This generation of the ratchet is
used to derive a provisional nonce and key.</t>
          <t>Before use in the encryption operation, the nonce is XORed with a fresh random
value to guard against reuse.  Because the key schedule generates nonces
deterministically, a client <bcp14>MUST</bcp14> keep persistent state as to where in the key
schedule it is; if this persistent state is lost or corrupted, a client might
reuse a generation that has already been used, causing reuse of a key/nonce pair.</t>
          <t>To avoid this situation, the sender of a message <bcp14>MUST</bcp14> generate a fresh random
four-byte "reuse guard" value and XOR it with the first four bytes of the nonce
from the key schedule before using the nonce for encryption.  The sender <bcp14>MUST</bcp14>
include the reuse guard in the <tt>reuse_guard</tt> field of the sender data object, so
that the recipient of the message can use it to compute the nonce to be used for
decryption.</t>
          <artwork type="ascii-art">
+-+-+-+-+---------...---+
|   Key Schedule Nonce  |
+-+-+-+-+---------...---+
           XOR
+-+-+-+-+---------...---+
| Guard |       0       |
+-+-+-+-+---------...---+
           ===
+-+-+-+-+---------...---+
| Encrypt/Decrypt Nonce |
+-+-+-+-+---------...---+
</artwork>
          <t>The Additional Authenticated Data (AAD) input to the encryption
contains an object of the following form, with the values used to
identify the key and nonce:</t>
          <sourcecode type="tls-presentation">
struct {
    opaque group_id&lt;V&gt;;
    uint64 epoch;
    ContentType content_type;
    opaque authenticated_data&lt;V&gt;;
} PrivateContentAAD;
</sourcecode>
          <t>When decoding a PrivateMessageContent, the application <bcp14>MUST</bcp14> check that the
FramedContentAuthData is valid.</t>
          <t>It is up to the application to decide what <tt>authenticated_data</tt> to provide and
how much padding to add to a given message (if any).  The overall size of the
AAD and ciphertext <bcp14>MUST</bcp14> fit within the limits established for the group's AEAD
algorithm in <xref target="I-D.irtf-cfrg-aead-limits"/>.</t>
        </section>
        <section anchor="sender-data-encryption">
          <name>Sender Data Encryption</name>
          <t>The "sender data" used to look up the key for content encryption is
encrypted with the cipher suite's AEAD with a key and nonce derived from both the
<tt>sender_data_secret</tt> and a sample of the encrypted content. Before being
encrypted, the sender data is encoded as an object of the following form:</t>
          <sourcecode type="tls-presentation">
struct {
    uint32 leaf_index;
    uint32 generation;
    opaque reuse_guard[4];
} SenderData;
</sourcecode>
          <t>When constructing a SenderData object from a Sender object, the sender <bcp14>MUST</bcp14> verify
Sender.sender_type is <tt>member</tt> and use Sender.leaf_index for
SenderData.leaf_index.</t>
          <t>The <tt>reuse_guard</tt> field contains a fresh random value used to avoid nonce reuse
in the case of state loss or corruption, as described in <xref target="content-encryption"/>.</t>
          <t>The key and nonce provided to the AEAD are computed as the KDF of the first
<tt>KDF.Nh</tt> bytes of the ciphertext generated in the previous section. If the
length of the ciphertext is less than <tt>KDF.Nh</tt>, the whole ciphertext is used.
In pseudocode, the key and nonce are derived as:</t>
          <sourcecode type="pseudocode">
ciphertext_sample = ciphertext[0..KDF.Nh-1]

sender_data_key = ExpandWithLabel(sender_data_secret, "key",
                      ciphertext_sample, AEAD.Nk)
sender_data_nonce = ExpandWithLabel(sender_data_secret, "nonce",
                      ciphertext_sample, AEAD.Nn)
</sourcecode>
          <t>The AAD for the SenderData ciphertext is the
first three fields of PrivateMessage:</t>
          <sourcecode type="tls-presentation">
struct {
    opaque group_id&lt;V&gt;;
    uint64 epoch;
    ContentType content_type;
} SenderDataAAD;
</sourcecode>
          <t>When parsing a SenderData struct as part of message decryption, the recipient
<bcp14>MUST</bcp14> verify that the leaf index indicated in the <tt>leaf_index</tt> field identifies a
non-blank node.</t>
        </section>
      </section>
    </section>
    <section anchor="ratchet-tree-operations">
      <name>Ratchet Tree Operations</name>
      <t>The ratchet tree for an epoch describes the membership of a group in that epoch,
providing public key encryption (HPKE) keys that can be used to encrypt to subsets of
the group as well as information to authenticate the members.  In order to
reflect changes to the membership of the group from one epoch to the next,
corresponding changes are made to the ratchet tree.  In this section, we
describe the content of the tree and the required operations.</t>
      <section anchor="parent-node-contents">
        <name>Parent Node Contents</name>
        <t>As discussed in <xref target="ratchet-tree-nodes"/>, the nodes of a ratchet tree contain
several types of data describing individual members (for leaf nodes) or
subgroups of the group (for parent nodes).  Parent nodes are simpler:</t>
        <sourcecode type="tls-presentation">
struct {
    HPKEPublicKey encryption_key;
    opaque parent_hash&lt;V&gt;;
    uint32 unmerged_leaves&lt;V&gt;;
} ParentNode;
</sourcecode>
        <t>The <tt>encryption_key</tt> field contains an HPKE public key whose private key is held only
by the members at the leaves among its descendants.  The <tt>parent_hash</tt> field
contains a hash of this node's parent node, as described in <xref target="parent-hashes"/>.
The <tt>unmerged_leaves</tt> field lists the leaves under this parent node that are
unmerged, according to their indices among all the leaves in the tree.  The
entries in the <tt>unmerged_leaves</tt> vector <bcp14>MUST</bcp14> be sorted in increasing order.</t>
      </section>
      <section anchor="leaf-node-contents">
        <name>Leaf Node Contents</name>
        <t>A leaf node in the tree describes all the details of an individual client's
appearance in the group, signed by that client. It is also used in client
KeyPackage objects to store the information that will be needed to add a
client to a group.</t>
        <sourcecode type="tls-presentation">
enum {
    reserved(0),
    key_package(1),
    update(2),
    commit(3),
    (255)
} LeafNodeSource;

struct {
    ProtocolVersion versions&lt;V&gt;;
    CipherSuite cipher_suites&lt;V&gt;;
    ExtensionType extensions&lt;V&gt;;
    ProposalType proposals&lt;V&gt;;
    CredentialType credentials&lt;V&gt;;
} Capabilities;

struct {
    uint64 not_before;
    uint64 not_after;
} Lifetime;

// See the "MLS Extension Types" IANA registry for values
uint16 ExtensionType;

struct {
    ExtensionType extension_type;
    opaque extension_data&lt;V&gt;;
} Extension;

struct {
    HPKEPublicKey encryption_key;
    SignaturePublicKey signature_key;
    Credential credential;
    Capabilities capabilities;

    LeafNodeSource leaf_node_source;
    select (LeafNode.leaf_node_source) {
        case key_package:
            Lifetime lifetime;

        case update:
            struct{};

        case commit:
            opaque parent_hash&lt;V&gt;;
    };

    Extension extensions&lt;V&gt;;
    /* SignWithLabel(., "LeafNodeTBS", LeafNodeTBS) */
    opaque signature&lt;V&gt;;
} LeafNode;

struct {
    HPKEPublicKey encryption_key;
    SignaturePublicKey signature_key;
    Credential credential;
    Capabilities capabilities;

    LeafNodeSource leaf_node_source;
    select (LeafNodeTBS.leaf_node_source) {
        case key_package:
            Lifetime lifetime;

        case update:
            struct{};

        case commit:
            opaque parent_hash&lt;V&gt;;
    };

    Extension extensions&lt;V&gt;;

    select (LeafNodeTBS.leaf_node_source) {
        case key_package:
            struct{};

        case update:
            opaque group_id&lt;V&gt;;
            uint32 leaf_index;

        case commit:
            opaque group_id&lt;V&gt;;
            uint32 leaf_index;
    };
} LeafNodeTBS;
</sourcecode>
        <t>The <tt>encryption_key</tt> field contains an HPKE public key whose private key is held only
by the member occupying this leaf (or in the case of a LeafNode in a KeyPackage
object, the issuer of the KeyPackage). The <tt>signature_key</tt> field contains the
member's public signing key. The <tt>credential</tt> field contains information
authenticating both the member's identity and the provided signing key, as
described in <xref target="credentials"/>.</t>
        <t>The <tt>capabilities</tt> field indicates the protocol features that the client
supports, including protocol versions, cipher suites, credential types,
non-default proposal types, and non-default extension types.  The following
proposal and extension types are considered "default" and <bcp14>MUST NOT</bcp14> be
listed:</t>
        <ul spacing="normal">
          <li>
            <t>Proposal types:
            </t>
            <ul spacing="normal">
              <li>0x0001 - <tt>add</tt></li>
              <li>0x0002 - <tt>update</tt></li>
              <li>0x0003 - <tt>remove</tt></li>
              <li>0x0004 - <tt>psk</tt></li>
              <li>0x0005 - <tt>reinit</tt></li>
              <li>0x0006 - <tt>external_init</tt></li>
              <li>0x0007 - <tt>group_context_extensions</tt></li>
            </ul>
          </li>
          <li>
            <t>Extension types:
            </t>
            <ul spacing="normal">
              <li>0x0001 - <tt>application_id</tt></li>
              <li>0x0002 - <tt>ratchet_tree</tt></li>
              <li>0x0003 - <tt>required_capabilities</tt></li>
              <li>0x0004 - <tt>external_pub</tt></li>
              <li>0x0005 - <tt>external_senders</tt></li>
            </ul>
          </li>
        </ul>
        <t>There are no default values for the other fields of a capabilities object.  The
client <bcp14>MUST</bcp14> list all values for the respective parameters that it supports.</t>
        <t>The types of any non-default extensions that appear in the <tt>extensions</tt> field of a LeafNode
<bcp14>MUST</bcp14> be included in the <tt>extensions</tt> field of the <tt>capabilities</tt> field, and the
credential type used in the LeafNode <bcp14>MUST</bcp14> be included in the <tt>credentials</tt> field
of the <tt>capabilities</tt> field.</t>
        <t>As discussed in <xref target="extensibility"/>, unknown values
in <tt>capabilities</tt> <bcp14>MUST</bcp14> be ignored, and the creator of a <tt>capabilities</tt> field
<bcp14>SHOULD</bcp14> include some random GREASE values to help ensure that other clients correctly
ignore unknown values.</t>
        <t>The <tt>leaf_node_source</tt> field indicates how this LeafNode came to be added to the
tree.  This signal tells other members of the group whether the leaf node is
required to have a <tt>lifetime</tt> or <tt>parent_hash</tt>, and whether the <tt>group_id</tt> is
added as context to the signature.
These fields are included selectively because the client creating a LeafNode is
not always able to compute all of them.
For example, a KeyPackage is created before the client knows which group it will
be used with, so its signature can't bind to a <tt>group_id</tt>.</t>
        <t>In the case where the leaf was added to the tree based on a pre-published
KeyPackage, the <tt>lifetime</tt> field represents the times between which clients will
consider a LeafNode valid.  These times are represented as absolute times,
measured in seconds since the Unix epoch (1970-01-01T00:00:00Z).  Applications
<bcp14>MUST</bcp14> define a maximum total lifetime that is acceptable for a LeafNode, and
reject any LeafNode where the total lifetime is longer than this duration. In
order to avoid disagreements about whether a LeafNode has a valid lifetime, the
clients in a group <bcp14>SHOULD</bcp14> maintain time synchronization (e.g., using the Network
Time Protocol <xref target="RFC5905"/>).</t>
        <t>In the case where the leaf node was inserted into the tree via a Commit message,
the <tt>parent_hash</tt> field contains the parent hash for this leaf node (see
<xref target="parent-hashes"/>).</t>
        <t>The LeafNodeTBS structure covers the fields above the signature in the LeafNode.
In addition, when the leaf node was created in the context of a group (the
<tt>update</tt> and <tt>commit</tt> cases), the group ID of the group is added as context to the
signature.</t>
        <t>LeafNode objects stored in the group's ratchet tree
are updated according to the evolution of the tree. Each modification of
LeafNode content <bcp14>MUST</bcp14> be reflected by a change in its signature. This allows other
members to verify the validity of the LeafNode at any time, particularly in the
case of a newcomer joining the group.</t>
      </section>
      <section anchor="leaf-node-validation">
        <name>Leaf Node Validation</name>
        <t>The validity of a LeafNode needs to be verified at the following stages:</t>
        <ul spacing="normal">
          <li>When a LeafNode is downloaded in a KeyPackage, before it is used
to add the client to the group</li>
          <li>When a LeafNode is received by a group member in an Add, Update, or Commit
message</li>
          <li>When a client validates a ratchet tree, e.g., when joining a group or after
processing a Commit</li>
        </ul>
        <t>The client verifies the validity of a LeafNode using the following steps:</t>
        <ul spacing="normal">
          <li>Verify that the credential in the LeafNode is valid, as described in
<xref target="credential-validation"/>.</li>
          <li>Verify that the signature on the LeafNode is valid using <tt>signature_key</tt>.</li>
          <li>Verify that the LeafNode is compatible with the group's parameters.  If the
GroupContext has a <tt>required_capabilities</tt> extension, then the required
extensions, proposals, and credential types <bcp14>MUST</bcp14> be listed in the LeafNode's
<tt>capabilities</tt> field.</li>
          <li>Verify that the credential type is supported by all members of the group, as
specified by the <tt>capabilities</tt> field of each member's LeafNode, and that the
<tt>capabilities</tt> field of this LeafNode indicates support for all the credential
types currently in use by other members.</li>
          <li>
            <t>Verify the <tt>lifetime</tt> field:
            </t>
            <ul spacing="normal">
              <li>If the LeafNode appears in a message being sent by the client, e.g., a
Proposal or a Commit, then the client <bcp14>MUST</bcp14> verify that the current time is within
the range of the <tt>lifetime</tt> field.</li>
              <li>If instead the LeafNode appears in a message being received by the client, e.g.,
a Proposal, a Commit, or a ratchet tree of the group the client is joining, it is
<bcp14>RECOMMENDED</bcp14> that the client verifies that the current time is within the range
of the <tt>lifetime</tt> field.  (This check is not mandatory because the LeafNode
might have expired in the time between when the message was sent and when it
was received.)</li>
            </ul>
          </li>
          <li>Verify that the extensions in the LeafNode are supported by checking that the
ID for each extension in the <tt>extensions</tt> field is listed in the
<tt>capabilities.extensions</tt> field of the LeafNode.</li>
          <li>
            <t>Verify the <tt>leaf_node_source</tt> field:
            </t>
            <ul spacing="normal">
              <li>If the LeafNode appears in a KeyPackage, verify that <tt>leaf_node_source</tt> is
set to <tt>key_package</tt>.</li>
              <li>If the LeafNode appears in an Update proposal, verify that <tt>leaf_node_source</tt>
is set to <tt>update</tt> and that <tt>encryption_key</tt> represents a different public
key than the <tt>encryption_key</tt> in the leaf node being replaced by the Update
proposal.</li>
              <li>If the LeafNode appears in the <tt>leaf_node</tt> value of the UpdatePath in
a Commit, verify that <tt>leaf_node_source</tt> is set to <tt>commit</tt>.</li>
            </ul>
          </li>
          <li>
            <t>Verify that the following fields are unique among the members of the group:
            </t>
            <ul spacing="normal">
              <li>
                <tt>signature_key</tt>
              </li>
              <li>
                <tt>encryption_key</tt>
              </li>
            </ul>
          </li>
        </ul>
      </section>
      <section anchor="ratchet-tree-evolution">
        <name>Ratchet Tree Evolution</name>
        <t>Whenever a member initiates an epoch change (i.e., commits; see <xref target="commit"/>),
they may need to refresh the key pairs of their leaf and of the nodes on their
leaf's direct path in order to maintain forward secrecy and post-compromise
security.</t>
        <t>The member initiating the epoch change generates the fresh key pairs using the
following procedure. The procedure is designed in a way that allows group members to
efficiently communicate the fresh secret keys to other group members, as
described in <xref target="update-paths"/>.</t>
        <t>A member updates the nodes along its direct path as follows:</t>
        <ul spacing="normal">
          <li>Blank all the nodes on the direct path from the leaf to the root.</li>
          <li>Generate a fresh HPKE key pair for the leaf.</li>
          <li>Generate a sequence of path secrets, one for each node on the leaf's filtered direct
path, as follows. In this setting, <tt>path_secret[0]</tt> refers to the first parent node
in the filtered direct path, <tt>path_secret[1]</tt> to the second parent node, and so on.</li>
        </ul>
        <sourcecode type="pseudocode">
path_secret[0] is sampled at random
path_secret[n] = DeriveSecret(path_secret[n-1], "path")
</sourcecode>
        <ul spacing="normal">
          <li>Compute the sequence of HPKE key pairs <tt>(node_priv,node_pub)</tt>, one for each
node on the leaf's direct path, as follows.</li>
        </ul>
        <sourcecode type="pseudocode">
node_secret[n] = DeriveSecret(path_secret[n], "node")
node_priv[n], node_pub[n] = KEM.DeriveKeyPair(node_secret[n])
</sourcecode>
        <t>The node secret is derived as a temporary intermediate secret so that each
secret is only used with one algorithm: The path secret is used as an input to
DeriveSecret, and the node secret is used as an input to DeriveKeyPair.</t>
        <t>For example, suppose there is a group with four members, with C an unmerged leaf
at Z:</t>
        <figure anchor="evolution-tree">
          <name>A Full Tree with One Unmerged Leaf</name>
          <artset>
            <artwork type="svg">
              <svg xmlns="http://www.w3.org/2000/svg" class="diagram" font-family="monospace" font-size="13px" height="176" text-anchor="middle" version="1.1" viewBox="0 0 120 176" width="120">
                <path d="M 56,48 L 56,64" fill="none" stroke="black"/>
                <path d="M 40,64 L 72,64" fill="none" stroke="black"/>
                <path d="M 72,64 L 80,80" fill="none" stroke="black"/>
                <path d="M 32,80 L 40,64" fill="none" stroke="black"/>
                <g class="text">
                  <text x="56" y="36">Y</text>
                  <text x="24" y="100">X</text>
                  <text x="100" y="100">Z[C]</text>
                  <text x="16" y="116">/</text>
                  <text x="32" y="116">\</text>
                  <text x="80" y="116">/</text>
                  <text x="96" y="116">\</text>
                  <text x="8" y="132">A</text>
                  <text x="40" y="132">B</text>
                  <text x="72" y="132">C</text>
                  <text x="104" y="132">D</text>
                  <text x="8" y="164">0</text>
                  <text x="40" y="164">1</text>
                  <text x="72" y="164">2</text>
                  <text x="104" y="164">3</text>
                </g>
              </svg>
            </artwork>
            <artwork type="ascii-art">
      Y
      |
    .-+-.
   /     \
  X       Z[C]
 / \     / \
A   B   C   D

0   1   2   3
</artwork>
          </artset>
        </figure>
        <t>If member B subsequently generates an UpdatePath based on a secret
"leaf_secret", then it would generate the following sequence
of path secrets:</t>
        <figure>
          <name>Derivation of Ratchet Tree Keys along a Direct Path</name>
          <artset>
            <artwork type="svg">
              <svg xmlns="http://www.w3.org/2000/svg" class="diagram" font-family="monospace" font-size="13px" height="272" text-anchor="middle" version="1.1" viewBox="0 0 560 272" width="560">
                <path d="M 48,64 L 48,96" fill="none" stroke="black"/>
                <path d="M 48,144 L 48,176" fill="none" stroke="black"/>
                <path d="M 128,32 L 152,32" fill="none" stroke="black"/>
                <path d="M 288,32 L 344,32" fill="none" stroke="black"/>
                <path d="M 128,112 L 152,112" fill="none" stroke="black"/>
                <path d="M 288,112 L 344,112" fill="none" stroke="black"/>
                <path d="M 104,192 L 152,192" fill="none" stroke="black"/>
                <path d="M 304,192 L 344,192" fill="none" stroke="black"/>
                <path d="M 368,224 L 416,224" fill="none" stroke="black"/>
                <path d="M 448,224 L 496,224" fill="none" stroke="black"/>
                <path d="M 368,224 C 359.16936,224 352,216.83064 352,208" fill="none" stroke="black"/>
                <path d="M 416,224 C 424.83064,224 432,231.16936 432,240" fill="none" stroke="black"/>
                <path d="M 448,224 C 439.16936,224 432,231.16936 432,240" fill="none" stroke="black"/>
                <path d="M 496,224 C 504.83064,224 512,216.83064 512,208" fill="none" stroke="black"/>
                <polygon class="arrowhead" fill="black" points="352,192 340,186.4 340,197.6" transform="rotate(0,344,192)"/>
                <polygon class="arrowhead" fill="black" points="352,112 340,106.4 340,117.6" transform="rotate(0,344,112)"/>
                <polygon class="arrowhead" fill="black" points="352,32 340,26.4 340,37.6" transform="rotate(0,344,32)"/>
                <polygon class="arrowhead" fill="black" points="160,192 148,186.4 148,197.6" transform="rotate(0,152,192)"/>
                <polygon class="arrowhead" fill="black" points="160,112 148,106.4 148,117.6" transform="rotate(0,152,112)"/>
                <polygon class="arrowhead" fill="black" points="160,32 148,26.4 148,37.6" transform="rotate(0,152,32)"/>
                <polygon class="arrowhead" fill="black" points="56,144 44,138.4 44,149.6" transform="rotate(270,48,144)"/>
                <polygon class="arrowhead" fill="black" points="56,64 44,58.4 44,69.6" transform="rotate(270,48,64)"/>
                <g class="text">
                  <text x="60" y="36">path_secret[1]</text>
                  <text x="220" y="36">node_secret[1]</text>
                  <text x="408" y="36">node_priv[1],</text>
                  <text x="512" y="36">node_pub[1]</text>
                  <text x="60" y="116">path_secret[0]</text>
                  <text x="220" y="116">node_secret[0]</text>
                  <text x="408" y="116">node_priv[0],</text>
                  <text x="512" y="116">node_pub[0]</text>
                  <text x="48" y="196">leaf_secret</text>
                  <text x="228" y="196">leaf_node_secret</text>
                  <text x="396" y="196">leaf_priv,</text>
                  <text x="476" y="196">leaf_pub</text>
                  <text x="432" y="260">leaf_node</text>
                </g>
              </svg>
            </artwork>
            <artwork type="ascii-art">
path_secret[1] ---&gt; node_secret[1] -------&gt; node_priv[1], node_pub[1]

     ^
     |
     |
path_secret[0] ---&gt; node_secret[0] -------&gt; node_priv[0], node_pub[0]

     ^
     |
     |
leaf_secret ------&gt; leaf_node_secret --+--&gt; leaf_priv, leaf_pub
                                           |                   |
                                            '-------. .-------'
                                                     |
                                                 leaf_node
</artwork>
          </artset>
        </figure>
        <t>After applying the UpdatePath, the tree will have the following structure:</t>
        <figure>
          <name>Placement of Keys in a Ratchet Tree</name>
          <artset>
            <artwork type="svg">
              <svg xmlns="http://www.w3.org/2000/svg" class="diagram" font-family="monospace" font-size="13px" height="192" text-anchor="middle" version="1.1" viewBox="0 0 256 192" width="256">
                <path d="M 176,144 L 176,160" fill="none" stroke="black"/>
                <path d="M 192,48 L 192,64" fill="none" stroke="black"/>
                <path d="M 112,32 L 176,32" fill="none" stroke="black"/>
                <path d="M 176,64 L 208,64" fill="none" stroke="black"/>
                <path d="M 112,96 L 144,96" fill="none" stroke="black"/>
                <path d="M 88,160 L 176,160" fill="none" stroke="black"/>
                <path d="M 208,64 L 216,80" fill="none" stroke="black"/>
                <path d="M 168,80 L 176,64" fill="none" stroke="black"/>
                <polygon class="arrowhead" fill="black" points="184,144 172,138.4 172,149.6" transform="rotate(270,176,144)"/>
                <polygon class="arrowhead" fill="black" points="184,32 172,26.4 172,37.6" transform="rotate(0,176,32)"/>
                <polygon class="arrowhead" fill="black" points="152,96 140,90.4 140,101.6" transform="rotate(0,144,96)"/>
                <g class="text">
                  <text x="52" y="36">node_priv[1]</text>
                  <text x="196" y="36">Y'</text>
                  <text x="52" y="100">node_priv[0]</text>
                  <text x="164" y="100">X'</text>
                  <text x="236" y="100">Z[C]</text>
                  <text x="152" y="116">/</text>
                  <text x="168" y="116">\</text>
                  <text x="216" y="116">/</text>
                  <text x="232" y="116">\</text>
                  <text x="144" y="132">A</text>
                  <text x="176" y="132">B</text>
                  <text x="208" y="132">C</text>
                  <text x="240" y="132">D</text>
                  <text x="40" y="164">leaf_priv</text>
                  <text x="144" y="180">0</text>
                  <text x="176" y="180">1</text>
                  <text x="208" y="180">2</text>
                  <text x="240" y="180">3</text>
                </g>
              </svg>
            </artwork>
            <artwork type="ascii-art">
node_priv[1] --------&gt; Y'
                       |
                     .-+-.
                    /     \
node_priv[0] ----&gt; X'      Z[C]
                  / \     / \
                 A   B   C   D
                     ^
leaf_priv -----------+
                 0   1   2   3
</artwork>
          </artset>
        </figure>
      </section>
      <section anchor="synchronizing-views-of-the-tree">
        <name>Synchronizing Views of the Tree</name>
        <t>After generating fresh key material and applying it to update their
local tree state as described in <xref target="ratchet-tree-evolution"/>, the
generator broadcasts
this update to other members of the group in a Commit message, who
apply it to keep their local views of the tree in
sync with the sender's.  More specifically, when a member commits a change to
the tree (e.g., to add or remove a member), it transmits an UpdatePath
containing a set of public keys and encrypted path secrets
for intermediate nodes in the filtered direct path of its leaf. The
other members of the group use these values to update
their view of the tree, aligning their copy of the tree to the
sender's.</t>
        <t>An UpdatePath contains
the following information for each node in the filtered direct path of the
sender's leaf, including the root:</t>
        <ul spacing="normal">
          <li>The public key for the node</li>
          <li>One or more encrypted copies of the path secret corresponding to
the node</li>
        </ul>
        <t>The path secret value for a given node is encrypted to the subtree
rooted at the parent's non-updated child, i.e., the child
on the copath of the sender's leaf node.
There is one encryption of the path secret to each public key in the resolution
of the non-updated child.</t>
        <t>A member of the group <em>updates their direct path</em> by computing new values for
their leaf node and the nodes along their filtered direct path as follows:</t>
        <ol spacing="normal" type="1">
          <li>Blank all nodes along the direct path of the sender's leaf.</li>
          <li>
            <t>Compute updated path secrets and public keys for the nodes on the sender's
filtered direct path.
            </t>
            <ul spacing="normal">
              <li>Generate a sequence of path secrets of the same length as the filtered
direct path, as defined in <xref target="ratchet-tree-evolution"/>.</li>
              <li>For each node in the filtered direct path, replace the node's public key
with the <tt>node_pub[n]</tt> value derived from the corresponding path secret
<tt>path_secret[n]</tt>.</li>
            </ul>
          </li>
          <li>Compute the new parent hashes for the nodes along the filtered direct path
and the sender's leaf node.</li>
          <li>
            <t>Update the leaf node for the sender.
            </t>
            <ul spacing="normal">
              <li>Set the <tt>leaf_node_source</tt> to <tt>commit</tt>.</li>
              <li>Set the <tt>encryption_key</tt> to the public key of a freshly sampled key pair.</li>
              <li>Set the parent hash to the parent hash for the leaf.</li>
              <li>Re-sign the leaf node with its new contents.</li>
            </ul>
          </li>
        </ol>
        <t>Since the new leaf node effectively updates an existing leaf node in the group,
it <bcp14>MUST</bcp14> adhere to the same restrictions as LeafNodes used in Update proposals
(aside from <tt>leaf_node_source</tt>). The application <bcp14>MAY</bcp14> specify other changes to
the leaf node, e.g., providing a new signature key, updated capabilities, or
different extensions.</t>
        <t>The member then <em>encrypts path secrets to the group</em>.  For each node in the
member's filtered direct path, the member takes the following steps:</t>
        <ol spacing="normal" type="1">
          <li>Compute the resolution of the node's child that is on the copath of the
sender (the child that is not in the direct path of the sender).  Any new
member (from an Add proposal) added in the same Commit <bcp14>MUST</bcp14> be excluded from
this resolution.</li>
          <li>For each node in the resolution, encrypt the path secret for the direct
path node using the public key of the resolution node, as defined in
<xref target="update-paths"/>.</li>
        </ol>
        <t>The recipient of an UpdatePath performs the corresponding steps. First, the
recipient <em>merges UpdatePath into the tree</em>:</t>
        <ol spacing="normal" type="1">
          <li>Blank all nodes on the direct path of the sender's leaf.</li>
          <li>
            <t>For all nodes on the filtered direct path of the sender's leaf,
            </t>
            <ul spacing="normal">
              <li>Set the public key to the public key in the UpdatePath.</li>
              <li>Set the list of unmerged leaves to the empty list.</li>
            </ul>
          </li>
          <li>
            <t>Compute parent hashes for the nodes in the sender's filtered direct path,
and verify that the <tt>parent_hash</tt> field of the leaf node matches the parent
hash for the first node in its filtered direct path.
            </t>
            <ul spacing="normal">
              <li>Note that these hashes are computed from root to leaf, so that
each hash incorporates all the non-blank nodes above it. The root node
always has a zero-length hash for its parent hash.</li>
            </ul>
          </li>
        </ol>
        <t>Second, the recipient <em>decrypts the path secrets</em>:</t>
        <ol spacing="normal" type="1">
          <li>Identify a node in the filtered direct path for which the recipient
is in the subtree of the non-updated child.</li>
          <li>Identify a node in the resolution of the copath node for
which the recipient has a private key.</li>
          <li>Decrypt the path secret for the parent of the copath node using
the private key from the resolution node.</li>
          <li>Derive path secrets for ancestors of that node in the sender's filtered
direct path using the algorithm described above.</li>
          <li>Derive the node secrets and node key pairs from the path secrets.</li>
          <li>Verify that the derived public keys are the same as the corresponding public
keys sent in the UpdatePath.</li>
          <li>Store the derived private keys in the corresponding ratchet tree nodes.</li>
        </ol>
        <t>For example, in order to communicate the example update described in
<xref target="ratchet-tree-evolution"/>, the member at node B would transmit the following
values:</t>
        <table>
          <thead>
            <tr>
              <th align="left">Public Key</th>
              <th align="left">Ciphertext(s)</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td align="left">
                <tt>node_pub[1]</tt>
              </td>
              <td align="left"><tt>E(pk(Z), path_secret[1])</tt>, <tt>E(pk(C), path_secret[1]</tt>)</td>
            </tr>
            <tr>
              <td align="left">
                <tt>node_pub[0]</tt>
              </td>
              <td align="left">
                <tt>E(pk(A), path_secret[0])</tt>
              </td>
            </tr>
          </tbody>
        </table>
        <t>In this table, the value node_pub[i] represents the public key
derived from node_secret[i], pk(X) represents the current public key
of node X, and E(K, S) represents
the public key encryption of the path secret S to the
public key K (using HPKE).</t>
        <t>A recipient at node A would decrypt <tt>E(pk(A), path_secret\[0\])</tt> to obtain
<tt>path_secret\[0\]</tt>, then use it to derive <tt>path_secret[1]</tt> and the resulting
node secrets and key pairs.  Thus, A would have the private keys to nodes X'
and Y', in accordance with the tree invariant.</t>
        <t>Similarly, a recipient at node D would decrypt <tt>E(pk(Z), path_secret[1])</tt> to
obtain <tt>path_secret[1]</tt>, then use it to derive the node secret and key pair
for the node Y'.  As required to maintain the tree invariant, node D does not
receive the private key for the node X', since X' is not an ancestor of D.</t>
        <t>After processing the update, each recipient <bcp14>MUST</bcp14> delete outdated key material,
specifically:</t>
        <ul spacing="normal">
          <li>The path secrets and node secrets used to derive each updated node key pair.</li>
          <li>Each outdated node key pair that was replaced by the update.</li>
        </ul>
      </section>
      <section anchor="update-paths">
        <name>Update Paths</name>
        <t>As described in <xref target="commit"/>, each Commit message may optionally contain an
UpdatePath, with a new LeafNode and set of parent nodes for the sender's
filtered direct path. For each parent node, the UpdatePath contains a new
public key and encrypted path secret. The parent nodes are kept in the same
order as the filtered direct path.</t>
        <sourcecode type="tls-presentation">
struct {
    opaque kem_output&lt;V&gt;;
    opaque ciphertext&lt;V&gt;;
} HPKECiphertext;

struct {
    HPKEPublicKey encryption_key;
    HPKECiphertext encrypted_path_secret&lt;V&gt;;
} UpdatePathNode;

struct {
    LeafNode leaf_node;
    UpdatePathNode nodes&lt;V&gt;;
} UpdatePath;
</sourcecode>
        <t>For each UpdatePathNode, the resolution of the corresponding copath node <bcp14>MUST</bcp14>
exclude all new leaf nodes added as part of the current Commit. The length of
the <tt>encrypted_path_secret</tt> vector <bcp14>MUST</bcp14> be equal to the length of the resolution
of the copath node (excluding new leaf nodes), with each ciphertext being the
encryption to the respective resolution node.</t>
        <t>The HPKECiphertext values are encrypted and decrypted as follows:</t>
        <sourcecode type="pseudocode">
(kem_output, ciphertext) =
  EncryptWithLabel(node_public_key, "UpdatePathNode",
                   group_context, path_secret)

path_secret =
  DecryptWithLabel(node_private_key, "UpdatePathNode",
                   group_context, kem_output, ciphertext)
</sourcecode>
        <t>Here <tt>node_public_key</tt> is the public key of the node for which the path secret is
encrypted, <tt>group_context</tt> is the provisional GroupContext object for
the group, and the <tt>EncryptWithLabel</tt> function is as defined in
<xref target="public-key-encryption"/>.</t>
      </section>
      <section anchor="adding-and-removing-leaves">
        <name>Adding and Removing Leaves</name>
        <t>In addition to the path-based updates to the tree described above, it is also
necessary to add and remove leaves of the tree in order to reflect changes to
the membership of the group (see Sections <xref format="counter" target="add"/> and <xref format="counter" target="remove"/>).  Since the tree is
always full, adding or removing leaves corresponds to increasing or decreasing
the depth of the tree, resulting in the number of leaves being doubled or
halved. These operations are also known as <em>extending</em> and <em>truncating</em> the
tree.</t>
        <t>Leaves are always added and removed at the right edge of the tree.  When the
size of the tree needs to be increased, a new blank root node is added, whose
left subtree is the existing tree and right subtree is a new all-blank subtree.
This operation is typically done when adding a member to the group.</t>
        <figure>
          <name>Extending the Tree to Make Room for a Third Member</name>
          <artwork type="ascii-art">
                  _ &lt;-- new blank root                    _
                __|__                                   __|__
               /     \                                 /     \
  X    ===&gt;   X       _ &lt;-- new blank subtree ===&gt;    X       _
 / \         / \     / \                             / \     / \
A   B       A   B   _   _                           A   B   C   _
                                                            ^
                                                            |
                                               new member --+
</artwork>
        </figure>
        <t>When the right subtree of the tree no longer has any non-blank nodes, it can be
safely removed.  The root of the tree and the right subtree are discarded
(whether or not the root node is blank). The left child of the root becomes the
new root node, and the left subtree becomes the new tree.  This operation is
typically done after removing a member from the group.</t>
        <figure>
          <name>Cleaning Up after Removing Member C</name>
          <artwork type="ascii-art">
               Y                  Y
             __|__              __|__
            /     \            /     \
           X       _   ===&gt;   X       _   ==&gt;   X &lt;-- new root
          / \     / \        / \     / \       / \
         A   B   C   _      A   B   _   _     A   B
                 ^
                 |
removed member --+
</artwork>
        </figure>
        <t>Concrete algorithms for these operations on array-based and link-based trees are
provided in Appendices <xref format="counter" target="array-based-trees"/> and <xref format="counter" target="link-based-trees"/>.  The concrete
algorithms are non-normative.  An implementation may use any algorithm that
produces the correct tree in its internal representation.</t>
      </section>
      <section anchor="tree-hashes">
        <name>Tree Hashes</name>
        <t>MLS hashes the contents of the tree in two ways to authenticate different
properties of the tree.  <em>Tree hashes</em> are defined in this section, and <em>parent
hashes</em> are defined in <xref target="parent-hashes"/>.</t>
        <t>Each node in a ratchet tree has a tree hash that summarizes the subtree below
that node.  The tree hash of the root is used in the GroupContext to confirm
that the group agrees on the whole tree.  Tree hashes are computed recursively
from the leaves up to the root.</t>
        <figure>
          <name>Composition of the Tree Hash</name>
          <artset>
            <artwork type="svg">
              <svg xmlns="http://www.w3.org/2000/svg" class="diagram" font-family="monospace" font-size="13px" height="112" text-anchor="middle" version="1.1" viewBox="0 0 128 112" width="128">
                <path d="M 24,32 L 40,32" fill="none" stroke="black"/>
                <path d="M 72,48 L 88,80" fill="none" stroke="black"/>
                <path d="M 40,80 L 56,48" fill="none" stroke="black"/>
                <polygon class="arrowhead" fill="black" points="80,48 68,42.4 68,53.6" transform="rotate(243.43494882292202,72,48)"/>
                <polygon class="arrowhead" fill="black" points="64,48 52,42.4 52,53.6" transform="rotate(296.565051177078,56,48)"/>
                <polygon class="arrowhead" fill="black" points="48,32 36,26.4 36,37.6" transform="rotate(0,40,32)"/>
                <g class="text">
                  <text x="8" y="36">P</text>
                  <text x="72" y="36">th(P)</text>
                  <text x="24" y="100">th(L)</text>
                  <text x="104" y="100">th(R)</text>
                </g>
              </svg>
            </artwork>
            <artwork type="ascii-art">
P --&gt; th(P)
      ^ ^
     /   \
    /     \
th(L)     th(R)
</artwork>
          </artset>
        </figure>
        <t>The tree hash of an individual node is the hash of the node's TreeHashInput
object, which may contain either a LeafNodeHashInput or a
ParentNodeHashInput depending on the type of node. LeafNodeHashInput objects
contain the <tt>leaf_index</tt> and the LeafNode (if any). ParentNodeHashInput
objects contain the ParentNode (if any) and the tree hash of the node's left
and right children.  For both parent and leaf nodes, the optional node value
<bcp14>MUST</bcp14> be absent if the node is blank and present if the node contains a value.</t>
        <sourcecode type="tls-presentation">
enum {
    reserved(0),
    leaf(1),
    parent(2),
    (255)
} NodeType;

struct {
  NodeType node_type;
  select (TreeHashInput.node_type) {
    case leaf:   LeafNodeHashInput leaf_node;
    case parent: ParentNodeHashInput parent_node;
  };
} TreeHashInput;

struct {
    uint32 leaf_index;
    optional&lt;LeafNode&gt; leaf_node;
} LeafNodeHashInput;

struct {
    optional&lt;ParentNode&gt; parent_node;
    opaque left_hash&lt;V&gt;;
    opaque right_hash&lt;V&gt;;
} ParentNodeHashInput;
</sourcecode>
        <t>The tree hash of an entire tree corresponds to the tree hash of the root node,
which is computed recursively by starting at the leaf nodes and building up.</t>
      </section>
      <section anchor="parent-hashes">
        <name>Parent Hashes</name>
        <t>While tree hashes summarize the state of a tree at point in time, parent hashes
capture information about how keys in the tree were populated.</t>
        <t>When a client sends a Commit to change a group, it can include an UpdatePath to
assign new keys to the nodes along its filtered direct path.  When a client
computes an UpdatePath (as defined in <xref target="synchronizing-views-of-the-tree"/>), it
computes and signs a parent hash that summarizes the state of the tree after the
UpdatePath has been applied.  These summaries are constructed in a chain from
the root to the member's leaf so that the part of the chain closer to the root
can be overwritten as nodes set in one UpdatePath are reset by a later
UpdatePath.</t>
        <figure>
          <name>Inputs to a Parent Hash</name>
          <artset>
            <artwork type="svg">
              <svg xmlns="http://www.w3.org/2000/svg" class="diagram" font-family="monospace" font-size="13px" height="176" text-anchor="middle" version="1.1" viewBox="0 0 216 176" width="216">
                <path d="M 112,96 L 128,96" fill="none" stroke="black"/>
                <path d="M 160,112 L 176,144" fill="none" stroke="black"/>
                <path d="M 128,144 L 144,112" fill="none" stroke="black"/>
                <path d="M 160,80 L 176,48" fill="none" stroke="black"/>
                <polygon class="arrowhead" fill="black" points="168,112 156,106.4 156,117.6" transform="rotate(243.43494882292202,160,112)"/>
                <polygon class="arrowhead" fill="black" points="168,80 156,74.4 156,85.6" transform="rotate(116.56505117707799,160,80)"/>
                <polygon class="arrowhead" fill="black" points="136,144 124,138.4 124,149.6" transform="rotate(116.56505117707799,128,144)"/>
                <polygon class="arrowhead" fill="black" points="136,96 124,90.4 124,101.6" transform="rotate(0,128,96)"/>
                <g class="text">
                  <text x="192" y="36">ph(Q)</text>
                  <text x="52" y="100">P.public_key</text>
                  <text x="160" y="100">ph(P)</text>
                  <text x="80" y="164">N.parent_hash</text>
                  <text x="192" y="164">th(S)</text>
                </g>
              </svg>
            </artwork>
            <artwork type="ascii-art">
                     ph(Q)
                     /
                    /
                   V
P.public_key --&gt; ph(P)
                 / ^
                /   \
               V     \
   N.parent_hash     th(S)
</artwork>
          </artset>
        </figure>
        <t>As a result, the signature over the parent hash in each member's leaf
effectively signs the subtree of the tree that hasn't been changed since that
leaf was last changed in an UpdatePath.  A new member joining the group uses
these parent hashes to verify that the parent nodes in the tree were set by
members of the group, not chosen by an external attacker.  For an example of how
this works, see <xref target="ph-evolution"/>.</t>
        <t>Consider a ratchet tree with a non-blank parent node P and children D and S (for
"parent", "direct path", and "sibling"), with D and P in the direct path of a
leaf node L (for "leaf"):</t>
        <figure anchor="parent-hash-nodes">
          <name>Nodes Involved in a Parent Hash Computation</name>
          <artwork type="ascii-art">
         ...
         /
        P
      __|__
     /     \
    D       S
   / \     / \
 ... ... ... ...
 /
L
</artwork>
        </figure>
        <t>The parent hash of P changes whenever an UpdatePath object is applied to
the ratchet tree along a path from a leaf L traversing node D (and hence also
P). The new "Parent hash of P (with copath child S)" is obtained by hashing P's
ParentHashInput struct.</t>
        <sourcecode type="tls-presentation">
struct {
    HPKEPublicKey encryption_key;
    opaque parent_hash&lt;V&gt;;
    opaque original_sibling_tree_hash&lt;V&gt;;
} ParentHashInput;
</sourcecode>
        <t>The field <tt>encryption_key</tt> contains the HPKE public key of P. If P is the root,
then the <tt>parent_hash</tt> field is set to a zero-length octet string. Otherwise,
<tt>parent_hash</tt> is the parent hash of the next node after P on the filtered
direct path of the leaf L. This way, P's parent hash fixes
the new HPKE public key of each non-blank node on the path from P to the root. Note
that the path from P to the root may contain some blank nodes that are not
fixed by P's parent hash. However, for each node that has an HPKE key, this key
is fixed by P's parent hash.</t>
        <t>Finally, <tt>original_sibling_tree_hash</tt> is the tree hash of S in the ratchet tree
modified as follows: For each leaf L in <tt>P.unmerged_leaves</tt>, blank L and remove
it from the <tt>unmerged_leaves</tt> sets of all parent nodes.</t>
        <t>Observe that <tt>original_sibling_tree_hash</tt> does not change between updates of P.
This property is crucial for the correctness of the protocol.</t>
        <t>Note that <tt>original_sibling_tree_hash</tt> is the tree hash of S, not the parent
hash.  The <tt>parent_hash</tt> field in ParentHashInput captures information about the
nodes above P. the <tt>original_sibling_tree_hash</tt> captures information about the
subtree under S that is not being updated (and thus the subtree to which a path
secret for P would be encrypted according to <xref target="synchronizing-views-of-the-tree"/>).</t>
        <t>For example, in the following tree:</t>
        <figure anchor="parent-hash-tree">
          <name>A Tree Illustrating Parent Hash Computations</name>
          <artwork type="ascii-art">
              W [F]
        ______|_____
       /             \
      U               Y [F]
    __|__           __|__
   /     \         /     \
  T       _       _       _
 / \     / \     / \     / \
A   B   C   D   E   F   G   _
</artwork>
        </figure>
        <t>With P = W and S = Y, <tt>original_sibling_tree_hash</tt> is the tree hash of the
following tree:</t>
        <artwork type="ascii-art">
      Y
    __|__
   /     \
  _       _
 / \     / \
E   _   G   _
</artwork>
        <t>Because <tt>W.unmerged_leaves</tt> includes F, F is blanked and removed from
<tt>Y.unmerged_leaves</tt>.</t>
        <t>Note that no recomputation is needed if the tree hash of S is unchanged since
the last time P was updated. This is the case for computing or processing a
Commit whose UpdatePath traverses P, since the Commit itself resets P. (In
other words, it is only necessary to recompute the original sibling tree hash
when validating a group's tree on joining.) More generally, if none of the entries
in <tt>P.unmerged_leaves</tt> are in the subtree under S (and thus no leaves were blanked),
then the original tree hash at S is the tree hash of S in the current tree.</t>
        <t>If it is necessary to recompute the original tree hash of a node, the efficiency
of recomputation can be improved by caching intermediate tree hashes, to avoid
recomputing over the subtree when the subtree is included in multiple parent
hashes.  A subtree hash can be reused as long as the intersection of the
parent's unmerged leaves with the subtree is the same as in the earlier
computation.</t>
        <section anchor="using-parent-hashes">
          <name>Using Parent Hashes</name>
          <t>In ParentNode objects and LeafNode objects with <tt>leaf_node_source</tt> set to
<tt>commit</tt>, the value of the <tt>parent_hash</tt> field is the parent hash of the next
non-blank parent node above the node in question (the next node in the filtered
direct path).  Using the node labels in <xref target="parent-hash-nodes"/>, the
<tt>parent_hash</tt> field of D is equal to the parent hash of P with copath child S.
This is the case even when the node D is a leaf node.</t>
          <t>The <tt>parent_hash</tt> field of a LeafNode is signed by the member.  The signature of
such a LeafNode thus attests to which keys the group member introduced into
the ratchet tree and to whom the corresponding secret keys were sent, in
addition to the other contents of the LeafNode. This
prevents malicious insiders from constructing artificial ratchet trees with a
node D whose HPKE secret key is known to the insider, yet where the insider isn't
assigned a leaf in the subtree rooted at D. Indeed, such a ratchet tree would
violate the tree invariant.</t>
        </section>
        <section anchor="verifying-parent-hashes">
          <name>Verifying Parent Hashes</name>
          <t>Parent hashes are verified at two points in the protocol: When joining a group
and when processing a Commit.</t>
          <t>The parent hash in a node D is valid with respect to a parent node P if the
following criteria hold.  Here C and S are the children of P (for "child" and
"sibling"), with C being the child that is on the direct path of D (possibly D
itself) and S being the other child:</t>
          <ul spacing="normal">
            <li>D is a descendant of P in the tree.</li>
            <li>The <tt>parent_hash</tt> field of D is equal to the parent hash of P with copath
child S.</li>
            <li>D is in the resolution of C, and the intersection of P's <tt>unmerged_leaves</tt>
with the subtree under C is equal to the resolution of C with D removed.</li>
          </ul>
          <t>These checks verify that D and P were updated at the same time (in the same
UpdatePath), and that they were neighbors in the UpdatePath because the nodes in
between them would have omitted from the filtered direct path.</t>
          <t>A parent node P is "parent-hash valid" if it can be chained back to a leaf node
in this way.  That is, if there is leaf node L and a sequence of parent nodes
P_1, ..., P_N such that P_N = P and each step in the chain is authenticated
by a parent hash, then L's parent hash is valid with respect to P_1, P_1's parent
hash is valid with respect to P_2, and so on.</t>
          <t>When joining a group, the new member <bcp14>MUST</bcp14> authenticate that each non-blank
parent node P is parent-hash valid.  This can be done "bottom up" by building
chains up from leaves and verifying that all non-blank parent nodes are covered
by exactly one such chain, or "top down" by verifying that there is exactly one
descendant of each non-blank parent node for which the parent node is
parent-hash valid.</t>
          <t>When processing a Commit message that includes an UpdatePath, clients <bcp14>MUST</bcp14>
recompute the expected value of <tt>parent_hash</tt> for the committer's new leaf and
verify that it matches the <tt>parent_hash</tt> value in the supplied <tt>leaf_node</tt>.
After being merged into the tree, the nodes in the UpdatePath form a parent-hash
chain from the committer's leaf to the root.</t>
        </section>
      </section>
    </section>
    <section anchor="key-schedule">
      <name>Key Schedule</name>
      <t>Group keys are derived using the <tt>Extract</tt> and <tt>Expand</tt> functions from the KDF
for the group's cipher suite, as well as the functions defined below:</t>
      <sourcecode type="pseudocode">
ExpandWithLabel(Secret, Label, Context, Length) =
    KDF.Expand(Secret, KDFLabel, Length)

DeriveSecret(Secret, Label) =
    ExpandWithLabel(Secret, Label, "", KDF.Nh)
</sourcecode>
      <t>Where KDFLabel is specified as:</t>
      <sourcecode type="tls-presentation">
struct {
    uint16 length;
    opaque label&lt;V&gt;;
    opaque context&lt;V&gt;;
} KDFLabel;
</sourcecode>
      <t>And its fields are set to:</t>
      <sourcecode type="pseudocode">
length = Length;
label = "MLS 1.0 " + Label;
context = Context;
</sourcecode>
      <t>The value <tt>KDF.Nh</tt> is the size of an output from <tt>KDF.Extract</tt>, in bytes.  In
the below diagram:</t>
      <ul spacing="normal">
        <li>KDF.Extract takes its salt argument from the top and its Input
Keying Material (IKM) argument from the left.</li>
        <li>DeriveSecret takes its Secret argument from the incoming arrow.</li>
        <li><tt>0</tt> represents an all-zero byte string of length <tt>KDF.Nh</tt>.</li>
      </ul>
      <t>When processing a handshake message, a client combines the
following information to derive new epoch secrets:</t>
      <ul spacing="normal">
        <li>The init secret from the previous epoch</li>
        <li>The commit secret for the current epoch</li>
        <li>The GroupContext object for current epoch</li>
      </ul>
      <t>Given these inputs, the derivation of secrets for an epoch
proceeds as shown in the following diagram:</t>
      <figure>
        <name>The MLS Key Schedule</name>
        <artset>
          <artwork type="svg">
            <svg xmlns="http://www.w3.org/2000/svg" class="diagram" font-family="monospace" font-size="13px" height="656" text-anchor="middle" version="1.1" viewBox="0 0 584 656" width="584">
              <path d="M 216,48 L 216,80" fill="none" stroke="black"/>
              <path d="M 216,112 L 216,144" fill="none" stroke="black"/>
              <path d="M 216,176 L 216,208" fill="none" stroke="black"/>
              <path d="M 216,232 L 216,272" fill="none" stroke="black"/>
              <path d="M 216,304 L 216,384" fill="none" stroke="black"/>
              <path d="M 216,416 L 216,448" fill="none" stroke="black"/>
              <path d="M 216,472 L 216,560" fill="none" stroke="black"/>
              <path d="M 216,592 L 216,624" fill="none" stroke="black"/>
              <path d="M 152,96 L 168,96" fill="none" stroke="black"/>
              <path d="M 152,288 L 168,288" fill="none" stroke="black"/>
              <path d="M 216,336 L 240,336" fill="none" stroke="black"/>
              <path d="M 216,512 L 240,512" fill="none" stroke="black"/>
              <polygon class="arrowhead" fill="black" points="248,512 236,506.4 236,517.6" transform="rotate(0,240,512)"/>
              <polygon class="arrowhead" fill="black" points="248,336 236,330.4 236,341.6" transform="rotate(0,240,336)"/>
              <polygon class="arrowhead" fill="black" points="224,624 212,618.4 212,629.6" transform="rotate(90,216,624)"/>
              <polygon class="arrowhead" fill="black" points="224,560 212,554.4 212,565.6" transform="rotate(90,216,560)"/>
              <polygon class="arrowhead" fill="black" points="224,448 212,442.4 212,453.6" transform="rotate(90,216,448)"/>
              <polygon class="arrowhead" fill="black" points="224,384 212,378.4 212,389.6" transform="rotate(90,216,384)"/>
              <polygon class="arrowhead" fill="black" points="224,272 212,266.4 212,277.6" transform="rotate(90,216,272)"/>
              <polygon class="arrowhead" fill="black" points="224,208 212,202.4 212,213.6" transform="rotate(90,216,208)"/>
              <polygon class="arrowhead" fill="black" points="224,144 212,138.4 212,149.6" transform="rotate(90,216,144)"/>
              <polygon class="arrowhead" fill="black" points="224,80 212,74.4 212,85.6" transform="rotate(90,216,80)"/>
              <polygon class="arrowhead" fill="black" points="176,288 164,282.4 164,293.6" transform="rotate(0,168,288)"/>
              <polygon class="arrowhead" fill="black" points="176,96 164,90.4 164,101.6" transform="rotate(0,168,96)"/>
              <g class="text">
                <text x="232" y="36">init_secret_[n-1]</text>
                <text x="88" y="100">commit_secret</text>
                <text x="224" y="100">KDF.Extract</text>
                <text x="220" y="164">ExpandWithLabel(.,</text>
                <text x="336" y="164">"joiner",</text>
                <text x="448" y="164">GroupContext_[n],</text>
                <text x="552" y="164">KDF.Nh)</text>
                <text x="224" y="228">joiner_secret</text>
                <text x="44" y="292">psk_secret</text>
                <text x="104" y="292">(or</text>
                <text x="132" y="292">0)</text>
                <text x="224" y="292">KDF.Extract</text>
                <text x="312" y="340">DeriveSecret(.,</text>
                <text x="420" y="340">"welcome")</text>
                <text x="256" y="356">=</text>
                <text x="324" y="356">welcome_secret</text>
                <text x="220" y="404">ExpandWithLabel(.,</text>
                <text x="332" y="404">"epoch",</text>
                <text x="440" y="404">GroupContext_[n],</text>
                <text x="544" y="404">KDF.Nh)</text>
                <text x="220" y="468">epoch_secret</text>
                <text x="312" y="516">DeriveSecret(.,</text>
                <text x="412" y="516">&lt;label&gt;)</text>
                <text x="256" y="532">=</text>
                <text x="300" y="532">&lt;secret&gt;</text>
                <text x="224" y="580">DeriveSecret(.,</text>
                <text x="320" y="580">"init")</text>
                <text x="224" y="644">init_secret_[n]</text>
              </g>
            </svg>
          </artwork>
          <artwork type="ascii-art">
                    init_secret_[n-1]
                          |
                          |
                          V
    commit_secret --&gt; KDF.Extract
                          |
                          |
                          V
                  ExpandWithLabel(., "joiner", GroupContext_[n], KDF.Nh)
                          |
                          |
                          V
                     joiner_secret
                          |
                          |
                          V
psk_secret (or 0) --&gt; KDF.Extract
                          |
                          |
                          +--&gt; DeriveSecret(., "welcome")
                          |    = welcome_secret
                          |
                          V
                  ExpandWithLabel(., "epoch", GroupContext_[n], KDF.Nh)
                          |
                          |
                          V
                     epoch_secret
                          |
                          |
                          +--&gt; DeriveSecret(., &lt;label&gt;)
                          |    = &lt;secret&gt;
                          |
                          V
                    DeriveSecret(., "init")
                          |
                          |
                          V
                    init_secret_[n]
</artwork>
        </artset>
      </figure>
      <t>A number of values are derived from the epoch secret for different purposes:</t>
      <table anchor="epoch-derived-secrets">
        <name>Epoch-Derived Secrets</name>
        <thead>
          <tr>
            <th align="left">Label</th>
            <th align="left">Secret</th>
            <th align="left">Purpose</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td align="left">"sender data"</td>
            <td align="left">
              <tt>sender_data_secret</tt>
            </td>
            <td align="left">Deriving keys to encrypt sender data</td>
          </tr>
          <tr>
            <td align="left">"encryption"</td>
            <td align="left">
              <tt>encryption_secret</tt>
            </td>
            <td align="left">Deriving message encryption keys (via the secret tree)</td>
          </tr>
          <tr>
            <td align="left">"exporter"</td>
            <td align="left">
              <tt>exporter_secret</tt>
            </td>
            <td align="left">Deriving exported secrets</td>
          </tr>
          <tr>
            <td align="left">"external"</td>
            <td align="left">
              <tt>external_secret</tt>
            </td>
            <td align="left">Deriving the external init key</td>
          </tr>
          <tr>
            <td align="left">"confirm"</td>
            <td align="left">
              <tt>confirmation_key</tt>
            </td>
            <td align="left">Computing the confirmation MAC for an epoch</td>
          </tr>
          <tr>
            <td align="left">"membership"</td>
            <td align="left">
              <tt>membership_key</tt>
            </td>
            <td align="left">Computing the membership MAC for a PublicMessage</td>
          </tr>
          <tr>
            <td align="left">"resumption"</td>
            <td align="left">
              <tt>resumption_psk</tt>
            </td>
            <td align="left">Proving membership in this epoch (via a PSK injected later)</td>
          </tr>
          <tr>
            <td align="left">"authentication"</td>
            <td align="left">
              <tt>epoch_authenticator</tt>
            </td>
            <td align="left">Confirming that two clients have the same view of the group</td>
          </tr>
        </tbody>
      </table>
      <t>The <tt>external_secret</tt> is used to derive an HPKE key pair whose private key is
held by the entire group:</t>
      <sourcecode type="pseudocode">
external_priv, external_pub = KEM.DeriveKeyPair(external_secret)
</sourcecode>
      <t>The public key <tt>external_pub</tt> can be published as part of the GroupInfo struct
in order to allow non-members to join the group using an external Commit.</t>
      <section anchor="group-context">
        <name>Group Context</name>
        <t>Each member of the group maintains a GroupContext object that
summarizes the state of the group:</t>
        <sourcecode type="tls-presentation">
struct {
    ProtocolVersion version = mls10;
    CipherSuite cipher_suite;
    opaque group_id&lt;V&gt;;
    uint64 epoch;
    opaque tree_hash&lt;V&gt;;
    opaque confirmed_transcript_hash&lt;V&gt;;
    Extension extensions&lt;V&gt;;
} GroupContext;
</sourcecode>
        <t>The fields in this state have the following semantics:</t>
        <ul spacing="normal">
          <li>The <tt>cipher_suite</tt> is the cipher suite used by the group.</li>
          <li>The <tt>group_id</tt> field is an application-defined identifier for the
group.</li>
          <li>The <tt>epoch</tt> field represents the current version of the group.</li>
          <li>The <tt>tree_hash</tt> field contains a commitment to the contents of the
group's ratchet tree and the credentials for the members of the
group, as described in <xref target="tree-hashes"/>.</li>
          <li>The <tt>confirmed_transcript_hash</tt> field contains a running hash over
the messages that led to this state.</li>
          <li>The <tt>extensions</tt> field contains the details of any protocol extensions that
apply to the group.</li>
        </ul>
        <t>When a new member is added to the group, an existing member of the
group provides the new member with a Welcome message.  The Welcome
message provides the information the new member needs to initialize
its GroupContext.</t>
        <t>Different changes to the group will have different effects on the group state.
These effects are described in their respective subsections of <xref target="proposals"/>.
The following general rules apply:</t>
        <ul spacing="normal">
          <li>The <tt>group_id</tt> field is constant.</li>
          <li>The <tt>epoch</tt> field increments by one for each Commit message that
is processed.</li>
          <li>The <tt>tree_hash</tt> is updated to represent the current tree and
credentials.</li>
          <li>The <tt>confirmed_transcript_hash</tt> field is updated with the data for an
AuthenticatedContent encoding a Commit message, as described below.</li>
          <li>The <tt>extensions</tt> field changes when a GroupContextExtensions proposal is
committed.</li>
        </ul>
      </section>
      <section anchor="transcript-hashes">
        <name>Transcript Hashes</name>
        <t>The transcript hashes computed in MLS represent a running hash over all Proposal
and Commit messages that have ever been sent in a group.  Commit messages are
included directly. Proposal messages are indirectly included via the Commit that
applied them. Messages of both types are included by hashing the AuthenticatedContent
object in which they were sent.</t>
        <t>The transcript hash comprises two individual hashes:</t>
        <ul spacing="normal">
          <li>A <tt>confirmed_transcript_hash</tt> that represents a transcript over the whole
history of Commit messages, up to and including the signature of the most
recent Commit.</li>
          <li>An <tt>interim_transcript_hash</tt> that covers the confirmed transcript hash plus
the <tt>confirmation_tag</tt> of the most recent Commit.</li>
        </ul>
        <t>New members compute the interim transcript hash using the <tt>confirmation_tag</tt>
field of the GroupInfo struct, while existing members can compute it directly.</t>
        <t>Each Commit message updates these hashes by way of its enclosing
AuthenticatedContent.  The AuthenticatedContent struct is split into
ConfirmedTranscriptHashInput and InterimTranscriptHashInput. The former is used to
update the confirmed transcript hash and the latter is used to update the interim
transcript hash.</t>
        <sourcecode type="tls-presentation">
struct {
    WireFormat wire_format;
    FramedContent content; /* with content_type == commit */
    opaque signature&lt;V&gt;;
} ConfirmedTranscriptHashInput;

struct {
    MAC confirmation_tag;
} InterimTranscriptHashInput;
</sourcecode>
        <sourcecode type="pseudocode">
confirmed_transcript_hash_[0] = ""; /* zero-length octet string */
interim_transcript_hash_[0] = ""; /* zero-length octet string */

confirmed_transcript_hash_[epoch] =
    Hash(interim_transcript_hash_[epoch - 1] ||
        ConfirmedTranscriptHashInput_[epoch]);

interim_transcript_hash_[epoch] =
    Hash(confirmed_transcript_hash_[epoch] ||
        InterimTranscriptHashInput_[epoch]);
</sourcecode>
        <t>In this notation, <tt>ConfirmedTranscriptHashInput_[epoch]</tt> and
<tt>InterimTranscriptHashInput_[epoch]</tt> are based on the Commit that initiated the
epoch with epoch number <tt>epoch.  (Note that the </tt>epoch<tt> field in this
Commit will be set to </tt>epoch - 1`, since it is sent within the previous epoch.)</t>
        <t>The transcript hash <tt>ConfirmedTranscriptHashInput_[epoch]</tt> is used as the
<tt>confirmed_transcript_hash</tt> input to the <tt>confirmation_tag</tt> field for this
Commit. Each Commit thus confirms the whole transcript of Commits up to that
point, except for the latest Commit's confirmation tag.</t>
        <figure>
          <name>Evolution of the Transcript Hashes through Two Epoch Changes</name>
          <artset>
            <artwork type="svg">
              <svg xmlns="http://www.w3.org/2000/svg" class="diagram" font-family="monospace" font-size="13px" height="720" text-anchor="middle" version="1.1" viewBox="0 0 576 720" width="576">
                <path d="M 8,272 L 8,304" fill="none" stroke="black"/>
                <path d="M 8,512 L 8,544" fill="none" stroke="black"/>
                <path d="M 32,192 L 32,208" fill="none" stroke="black"/>
                <path d="M 32,432 L 32,448" fill="none" stroke="black"/>
                <path d="M 104,224 L 104,264" fill="none" stroke="black"/>
                <path d="M 104,464 L 104,504" fill="none" stroke="black"/>
                <path d="M 168,192 L 168,208" fill="none" stroke="black"/>
                <path d="M 168,432 L 168,448" fill="none" stroke="black"/>
                <path d="M 208,272 L 208,304" fill="none" stroke="black"/>
                <path d="M 208,512 L 208,544" fill="none" stroke="black"/>
                <path d="M 240,176 L 240,304" fill="none" stroke="black"/>
                <path d="M 240,416 L 240,544" fill="none" stroke="black"/>
                <path d="M 312,304 L 312,368" fill="none" stroke="black"/>
                <path d="M 312,544 L 312,608" fill="none" stroke="black"/>
                <path d="M 392,176 L 392,304" fill="none" stroke="black"/>
                <path d="M 392,416 L 392,544" fill="none" stroke="black"/>
                <path d="M 424,112 L 424,144" fill="none" stroke="black"/>
                <path d="M 424,272 L 424,304" fill="none" stroke="black"/>
                <path d="M 424,352 L 424,384" fill="none" stroke="black"/>
                <path d="M 424,512 L 424,544" fill="none" stroke="black"/>
                <path d="M 424,592 L 424,624" fill="none" stroke="black"/>
                <path d="M 496,64 L 496,104" fill="none" stroke="black"/>
                <path d="M 496,144 L 496,264" fill="none" stroke="black"/>
                <path d="M 496,304 L 496,344" fill="none" stroke="black"/>
                <path d="M 496,384 L 496,504" fill="none" stroke="black"/>
                <path d="M 496,544 L 496,584" fill="none" stroke="black"/>
                <path d="M 496,624 L 496,656" fill="none" stroke="black"/>
                <path d="M 568,112 L 568,144" fill="none" stroke="black"/>
                <path d="M 568,272 L 568,304" fill="none" stroke="black"/>
                <path d="M 568,352 L 568,384" fill="none" stroke="black"/>
                <path d="M 568,512 L 568,544" fill="none" stroke="black"/>
                <path d="M 568,592 L 568,624" fill="none" stroke="black"/>
                <path d="M 424,112 L 568,112" fill="none" stroke="black"/>
                <path d="M 424,144 L 568,144" fill="none" stroke="black"/>
                <path d="M 48,176 L 152,176" fill="none" stroke="black"/>
                <path d="M 240,176 L 392,176" fill="none" stroke="black"/>
                <path d="M 176,208 L 240,208" fill="none" stroke="black"/>
                <path d="M 48,224 L 152,224" fill="none" stroke="black"/>
                <path d="M 392,224 L 496,224" fill="none" stroke="black"/>
                <path d="M 8,272 L 208,272" fill="none" stroke="black"/>
                <path d="M 240,272 L 392,272" fill="none" stroke="black"/>
                <path d="M 424,272 L 568,272" fill="none" stroke="black"/>
                <path d="M 208,288 L 232,288" fill="none" stroke="black"/>
                <path d="M 400,288 L 424,288" fill="none" stroke="black"/>
                <path d="M 8,304 L 208,304" fill="none" stroke="black"/>
                <path d="M 240,304 L 392,304" fill="none" stroke="black"/>
                <path d="M 424,304 L 568,304" fill="none" stroke="black"/>
                <path d="M 424,352 L 568,352" fill="none" stroke="black"/>
                <path d="M 312,368 L 416,368" fill="none" stroke="black"/>
                <path d="M 424,384 L 568,384" fill="none" stroke="black"/>
                <path d="M 48,416 L 152,416" fill="none" stroke="black"/>
                <path d="M 240,416 L 392,416" fill="none" stroke="black"/>
                <path d="M 176,448 L 240,448" fill="none" stroke="black"/>
                <path d="M 48,464 L 152,464" fill="none" stroke="black"/>
                <path d="M 392,464 L 496,464" fill="none" stroke="black"/>
                <path d="M 8,512 L 208,512" fill="none" stroke="black"/>
                <path d="M 240,512 L 392,512" fill="none" stroke="black"/>
                <path d="M 424,512 L 568,512" fill="none" stroke="black"/>
                <path d="M 208,528 L 232,528" fill="none" stroke="black"/>
                <path d="M 400,528 L 424,528" fill="none" stroke="black"/>
                <path d="M 8,544 L 208,544" fill="none" stroke="black"/>
                <path d="M 240,544 L 392,544" fill="none" stroke="black"/>
                <path d="M 424,544 L 568,544" fill="none" stroke="black"/>
                <path d="M 424,592 L 568,592" fill="none" stroke="black"/>
                <path d="M 312,608 L 416,608" fill="none" stroke="black"/>
                <path d="M 424,624 L 568,624" fill="none" stroke="black"/>
                <path d="M 48,176 C 39.16936,176 32,183.16936 32,192" fill="none" stroke="black"/>
                <path d="M 152,176 C 160.83064,176 168,183.16936 168,192" fill="none" stroke="black"/>
                <path d="M 48,224 C 39.16936,224 32,216.83064 32,208" fill="none" stroke="black"/>
                <path d="M 152,224 C 160.83064,224 168,216.83064 168,208" fill="none" stroke="black"/>
                <path d="M 48,416 C 39.16936,416 32,423.16936 32,432" fill="none" stroke="black"/>
                <path d="M 152,416 C 160.83064,416 168,423.16936 168,432" fill="none" stroke="black"/>
                <path d="M 48,464 C 39.16936,464 32,456.83064 32,448" fill="none" stroke="black"/>
                <path d="M 152,464 C 160.83064,464 168,456.83064 168,448" fill="none" stroke="black"/>
                <polygon class="arrowhead" fill="black" points="504,656 492,650.4 492,661.6" transform="rotate(90,496,656)"/>
                <polygon class="arrowhead" fill="black" points="504,584 492,578.4 492,589.6" transform="rotate(90,496,584)"/>
                <polygon class="arrowhead" fill="black" points="504,504 492,498.4 492,509.6" transform="rotate(90,496,504)"/>
                <polygon class="arrowhead" fill="black" points="504,344 492,338.4 492,349.6" transform="rotate(90,496,344)"/>
                <polygon class="arrowhead" fill="black" points="504,264 492,258.4 492,269.6" transform="rotate(90,496,264)"/>
                <polygon class="arrowhead" fill="black" points="504,104 492,98.4 492,109.6" transform="rotate(90,496,104)"/>
                <polygon class="arrowhead" fill="black" points="424,608 412,602.4 412,613.6" transform="rotate(0,416,608)"/>
                <polygon class="arrowhead" fill="black" points="424,368 412,362.4 412,373.6" transform="rotate(0,416,368)"/>
                <polygon class="arrowhead" fill="black" points="408,528 396,522.4 396,533.6" transform="rotate(180,400,528)"/>
                <polygon class="arrowhead" fill="black" points="408,288 396,282.4 396,293.6" transform="rotate(180,400,288)"/>
                <polygon class="arrowhead" fill="black" points="240,528 228,522.4 228,533.6" transform="rotate(0,232,528)"/>
                <polygon class="arrowhead" fill="black" points="240,288 228,282.4 228,293.6" transform="rotate(0,232,288)"/>
                <polygon class="arrowhead" fill="black" points="184,448 172,442.4 172,453.6" transform="rotate(180,176,448)"/>
                <polygon class="arrowhead" fill="black" points="184,208 172,202.4 172,213.6" transform="rotate(180,176,208)"/>
                <polygon class="arrowhead" fill="black" points="112,504 100,498.4 100,509.6" transform="rotate(90,104,504)"/>
                <polygon class="arrowhead" fill="black" points="112,264 100,258.4 100,269.6" transform="rotate(90,104,264)"/>
                <g class="text">
                  <text x="496" y="36">...</text>
                  <text x="496" y="132">interim_[N-1]</text>
                  <text x="80" y="196">Ratchet</text>
                  <text x="132" y="196">Tree</text>
                  <text x="296" y="196">wire_format</text>
                  <text x="64" y="212">Key</text>
                  <text x="116" y="212">Schedule</text>
                  <text x="280" y="212">content</text>
                  <text x="288" y="228">epoch</text>
                  <text x="320" y="228">=</text>
                  <text x="344" y="228">N-1</text>
                  <text x="292" y="244">commit</text>
                  <text x="288" y="260">signature</text>
                  <text x="108" y="292">confirmation_key_[N]</text>
                  <text x="316" y="292">confirmation_tag</text>
                  <text x="496" y="292">confirmed_[N]</text>
                  <text x="496" y="372">interim_[N]</text>
                  <text x="80" y="436">Ratchet</text>
                  <text x="132" y="436">Tree</text>
                  <text x="296" y="436">wire_format</text>
                  <text x="64" y="452">Key</text>
                  <text x="116" y="452">Schedule</text>
                  <text x="280" y="452">content</text>
                  <text x="288" y="468">epoch</text>
                  <text x="320" y="468">=</text>
                  <text x="336" y="468">N</text>
                  <text x="292" y="484">commit</text>
                  <text x="288" y="500">signature</text>
                  <text x="108" y="532">confirmation_key_[N+1]</text>
                  <text x="316" y="532">confirmation_tag</text>
                  <text x="496" y="532">confirmed_[N+1]</text>
                  <text x="496" y="612">interim_[N+1]</text>
                  <text x="496" y="692">...</text>
                </g>
              </svg>
            </artwork>
            <artwork type="ascii-art">
                                                             ...

                                                              |
                                                              |
                                                              V
                                                     +-----------------+
                                                     |  interim_[N-1]  |
                                                     +--------+--------+
                                                              |
     .--------------.         +------------------+            |
    |  Ratchet Tree  |        | wire_format      |            |
    |  Key Schedule  |&lt;-------+ content          |            |
     '-------+------'         |   epoch = N-1    +------------+
             |                |   commit         |            |
             V                | signature        |            V
 +------------------------+   +------------------+   +-----------------+
 |  confirmation_key_[N]  +--&gt;| confirmation_tag |&lt;--+  confirmed_[N]  |
 +------------------------+   +--------+---------+   +--------+--------+
                                       |                      |
                                       |                      V
                                       |             +-----------------+
                                       +------------&gt;|   interim_[N]   |
                                                     +--------+--------+
                                                              |
     .--------------.         +------------------+            |
    |  Ratchet Tree  |        | wire_format      |            |
    |  Key Schedule  |&lt;-------+ content          |            |
     '-------+------'         |   epoch = N      +------------+
             |                |   commit         |            |
             V                | signature        |            V
 +------------------------+   +------------------+   +-----------------+
 | confirmation_key_[N+1] +--&gt;| confirmation_tag |&lt;--+ confirmed_[N+1] |
 +------------------------+   +--------+---------+   +--------+--------+
                                       |                      |
                                       |                      V
                                       |             +-----------------+
                                       +------------&gt;|  interim_[N+1]  |
                                                     +--------+--------+
                                                              |
                                                              V

                                                             ...
</artwork>
          </artset>
        </figure>
      </section>
      <section anchor="external-initialization">
        <name>External Initialization</name>
        <t>In addition to initializing a new epoch via KDF invocations as described above,
an MLS group can also initialize a new epoch via an asymmetric interaction using
the external key pair for the previous epoch.  This is done when a new member
is joining via an external commit.</t>
        <t>In this process, the joiner sends a new <tt>init_secret</tt> value to the group using
the HPKE export method.  The joiner then uses that <tt>init_secret</tt> with
information provided in the GroupInfo and an external Commit to initialize
their copy of the key schedule for the new epoch.</t>
        <sourcecode type="pseudocode">
kem_output, context = SetupBaseS(external_pub, "")
init_secret = context.export("MLS 1.0 external init secret", KDF.Nh)
</sourcecode>
        <t>Members of the group receive the <tt>kem_output</tt> in an ExternalInit proposal and
perform the corresponding calculation to retrieve the <tt>init_secret</tt> value.</t>
        <sourcecode type="pseudocode">
context = SetupBaseR(kem_output, external_priv, "")
init_secret = context.export("MLS 1.0 external init secret", KDF.Nh)
</sourcecode>
      </section>
      <section anchor="pre-shared-keys">
        <name>Pre-Shared Keys</name>
        <t>Groups that already have an out-of-band mechanism to generate
shared group secrets can inject them into the MLS key schedule to
incorporate this external entropy in the computation of MLS group secrets.</t>
        <t>Injecting an external PSK can improve security in the case
where having a full run of Updates across members is too expensive, or if
the external group key establishment mechanism provides
stronger security against classical or quantum adversaries.</t>
        <t>Note that, as a PSK may have a different lifetime than an Update, it does not
necessarily provide the same forward secrecy or post-compromise security
guarantees as a Commit message.  Unlike the key pairs populated in the
tree by an Update or Commit, which are always freshly generated, PSKs may be
pre-distributed and stored. This creates the risk that a PSK may be compromised
in the process of distribution and storage. The security that the group gets
from injecting a PSK thus depends on both the entropy of the PSK and the risk of
compromise.  These factors are outside of the scope of this document, but they should
be considered by application designers relying on PSKs.</t>
        <t>Each PSK in MLS has a type that designates how it was provisioned.
External PSKs are provided by the application, while resumption PSKs
are derived from the MLS key schedule and used in cases where it is
necessary to authenticate a member's participation in a prior epoch.</t>
        <t>The injection of one or more PSKs into the key schedule is signaled in two ways:
Existing members are informed via PreSharedKey proposals covered by a Commit,
and new members added in the Commit are informed by the GroupSecrets object in the
Welcome message corresponding to the Commit.  To ensure that existing and new
members compute the same PSK input to the key schedule, the Commit and
GroupSecrets objects <bcp14>MUST</bcp14> indicate the same set of PSKs, in the same order.</t>
        <sourcecode type="tls-presentation">
enum {
  reserved(0),
  external(1),
  resumption(2),
  (255)
} PSKType;

enum {
  reserved(0),
  application(1),
  reinit(2),
  branch(3),
  (255)
} ResumptionPSKUsage;

struct {
  PSKType psktype;
  select (PreSharedKeyID.psktype) {
    case external:
      opaque psk_id&lt;V&gt;;

    case resumption:
      ResumptionPSKUsage usage;
      opaque psk_group_id&lt;V&gt;;
      uint64 psk_epoch;
  };
  opaque psk_nonce&lt;V&gt;;
} PreSharedKeyID;
</sourcecode>
        <t>Each time a client injects a PSK into a group, the <tt>psk_nonce</tt> of its
PreSharedKeyID <bcp14>MUST</bcp14> be set to a fresh random value of length <tt>KDF.Nh</tt>, where
<tt>KDF</tt> is the KDF for the cipher suite of the group into which the PSK is being
injected. This ensures that even when a PSK is used multiple times, the value
used as an input into the key schedule is different each time.</t>
        <t>Upon receiving a Commit with a PreSharedKey proposal or a GroupSecrets object
with the <tt>psks</tt> field set, the receiving client includes them in the key
schedule in the order listed in the Commit, or in the <tt>psks</tt> field, respectively.
For resumption PSKs, the PSK is defined as the <tt>resumption_psk</tt> of the group and
epoch specified in the PreSharedKeyID object. Specifically, <tt>psk_secret</tt> is
computed as follows:</t>
        <sourcecode type="tls-presentation">
struct {
    PreSharedKeyID id;
    uint16 index;
    uint16 count;
} PSKLabel;
</sourcecode>
        <sourcecode type="pseudocode">
psk_extracted_[i] = KDF.Extract(0, psk_[i])
psk_input_[i] = ExpandWithLabel(psk_extracted_[i], "derived psk",
                  PSKLabel, KDF.Nh)

psk_secret_[0] = 0
psk_secret_[i] = KDF.Extract(psk_input_[i-1], psk_secret_[i-1])
psk_secret     = psk_secret_[n]
</sourcecode>
        <t>Here <tt>0</tt> represents the all-zero vector of length <tt>KDF.Nh</tt>. The <tt>index</tt> field in
PSKLabel corresponds to the index of the PSK in the <tt>psk</tt> array, while the
<tt>count</tt> field contains the total number of PSKs.  In other words, the PSKs are
chained together with KDF.Extract invocations (labeled "Extract" for brevity
in the diagram), as follows:</t>
        <figure>
          <name>Computation of a PSK Secret from a Set of PSKs</name>
          <artset>
            <artwork type="svg">
              <svg xmlns="http://www.w3.org/2000/svg" class="diagram" font-family="monospace" font-size="13px" height="256" text-anchor="middle" version="1.1" viewBox="0 0 568 256" width="568">
                <path d="M 400,96 L 400,144" fill="none" stroke="black"/>
                <path d="M 400,192 L 400,224" fill="none" stroke="black"/>
                <path d="M 88,80 L 104,80" fill="none" stroke="black"/>
                <path d="M 184,80 L 200,80" fill="none" stroke="black"/>
                <path d="M 344,80 L 360,80" fill="none" stroke="black"/>
                <path d="M 88,160 L 104,160" fill="none" stroke="black"/>
                <path d="M 184,160 L 200,160" fill="none" stroke="black"/>
                <path d="M 344,160 L 360,160" fill="none" stroke="black"/>
                <path d="M 88,240 L 104,240" fill="none" stroke="black"/>
                <path d="M 184,240 L 200,240" fill="none" stroke="black"/>
                <path d="M 344,240 L 360,240" fill="none" stroke="black"/>
                <polygon class="arrowhead" fill="black" points="408,224 396,218.4 396,229.6" transform="rotate(90,400,224)"/>
                <polygon class="arrowhead" fill="black" points="408,144 396,138.4 396,149.6" transform="rotate(90,400,144)"/>
                <polygon class="arrowhead" fill="black" points="368,240 356,234.4 356,245.6" transform="rotate(0,360,240)"/>
                <polygon class="arrowhead" fill="black" points="368,160 356,154.4 356,165.6" transform="rotate(0,360,160)"/>
                <polygon class="arrowhead" fill="black" points="368,80 356,74.4 356,85.6" transform="rotate(0,360,80)"/>
                <polygon class="arrowhead" fill="black" points="208,240 196,234.4 196,245.6" transform="rotate(0,200,240)"/>
                <polygon class="arrowhead" fill="black" points="208,160 196,154.4 196,165.6" transform="rotate(0,200,160)"/>
                <polygon class="arrowhead" fill="black" points="208,80 196,74.4 196,85.6" transform="rotate(0,200,80)"/>
                <polygon class="arrowhead" fill="black" points="112,240 100,234.4 100,245.6" transform="rotate(0,104,240)"/>
                <polygon class="arrowhead" fill="black" points="112,160 100,154.4 100,165.6" transform="rotate(0,104,160)"/>
                <polygon class="arrowhead" fill="black" points="112,80 100,74.4 100,85.6" transform="rotate(0,104,80)"/>
                <g class="text">
                  <text x="144" y="36">0</text>
                  <text x="400" y="36">0</text>
                  <text x="440" y="36">=</text>
                  <text x="508" y="36">psk_secret_[0]</text>
                  <text x="144" y="52">|</text>
                  <text x="400" y="52">|</text>
                  <text x="32" y="84">psk_[0]</text>
                  <text x="144" y="84">Extract</text>
                  <text x="272" y="84">ExpandWithLabel</text>
                  <text x="400" y="84">Extract</text>
                  <text x="440" y="84">=</text>
                  <text x="508" y="84">psk_secret_[1]</text>
                  <text x="144" y="116">0</text>
                  <text x="144" y="132">|</text>
                  <text x="32" y="164">psk_[1]</text>
                  <text x="144" y="164">Extract</text>
                  <text x="272" y="164">ExpandWithLabel</text>
                  <text x="400" y="164">Extract</text>
                  <text x="440" y="164">=</text>
                  <text x="508" y="164">psk_secret_[2]</text>
                  <text x="400" y="180">|</text>
                  <text x="144" y="196">0</text>
                  <text x="392" y="196">.</text>
                  <text x="408" y="196">.</text>
                  <text x="144" y="212">|</text>
                  <text x="40" y="244">psk_[n-1]</text>
                  <text x="144" y="244">Extract</text>
                  <text x="272" y="244">ExpandWithLabel</text>
                  <text x="400" y="244">Extract</text>
                  <text x="440" y="244">=</text>
                  <text x="508" y="244">psk_secret_[n]</text>
                </g>
              </svg>
            </artwork>
            <artwork type="ascii-art">
                 0                               0    = psk_secret_[0]
                 |                               |
                 V                               V
psk_[0]   --&gt; Extract --&gt; ExpandWithLabel --&gt; Extract = psk_secret_[1]
                                                 |
                 0                               |
                 |                               |
                 V                               V
psk_[1]   --&gt; Extract --&gt; ExpandWithLabel --&gt; Extract = psk_secret_[2]
                                                 |
                 0                              ...
                 |                               |
                 V                               V
psk_[n-1] --&gt; Extract --&gt; ExpandWithLabel --&gt; Extract = psk_secret_[n]
</artwork>
          </artset>
        </figure>
        <t>In particular, if there are no PreSharedKey proposals in a given Commit, then
the resulting <tt>psk_secret</tt> is <tt>psk_secret_[0]</tt>, the all-zero vector.</t>
      </section>
      <section anchor="exporters">
        <name>Exporters</name>
        <t>The main MLS key schedule provides an <tt>exporter_secret</tt> that can
be used by an application to derive new secrets for use outside of MLS.</t>
        <sourcecode type="pseudocode">
MLS-Exporter(Label, Context, Length) =
       ExpandWithLabel(DeriveSecret(exporter_secret, Label),
                         "exported", Hash(Context), Length)
</sourcecode>
        <t>Applications <bcp14>SHOULD</bcp14> provide a unique label to <tt>MLS-Exporter</tt> that
identifies the secret's intended purpose. This is to help prevent the same
secret from being generated and used in two different places. To help avoid
the same label being used in different applications, an IANA registry for these
labels has been defined in <xref target="mls-exporter-labels"/>.</t>
        <t>The exported values are bound to the group epoch from which the
<tt>exporter_secret</tt> is derived, and hence reflect a particular state of
the group.</t>
        <t>It is <bcp14>RECOMMENDED</bcp14> for the application generating exported values
to refresh those values after a Commit is processed.</t>
      </section>
      <section anchor="resumption-psk">
        <name>Resumption PSK</name>
        <t>The main MLS key schedule provides a <tt>resumption_psk</tt> that is used as a PSK
to inject entropy from one epoch into another.  This functionality is used in the
reinitialization and branching processes described in Sections <xref format="counter" target="reinitialization"/> and
<xref format="counter" target="subgroup-branching"/>, but it may be used by applications for other purposes.</t>
        <t>Some uses of resumption PSKs might call for the use of PSKs from historical
epochs. The application <bcp14>SHOULD</bcp14> specify an upper limit on the number of past
epochs for which the <tt>resumption_psk</tt> may be stored.</t>
      </section>
      <section anchor="epoch-authenticators">
        <name>Epoch Authenticators</name>
        <t>The main MLS key schedule provides a per-epoch <tt>epoch_authenticator</tt>. If one
member of the group is being impersonated by an active attacker, the
<tt>epoch_authenticator</tt> computed by their client will differ from those computed
by the other group members.</t>
        <t>This property can be used to construct defenses against impersonation attacks
that are effective even if members' signature keys are compromised. As a trivial
example, if the users of the clients in an MLS group were to meet in person and
reliably confirm that their epoch authenticator values were equal (using some
suitable user interface), then each user would be assured that the others were
not being impersonated in the current epoch. As soon as the epoch changed,
though, they would need to redo this confirmation. The state of the group would
have changed, possibly introducing an attacker.</t>
        <t>More generally, in order for the members of an MLS group to obtain concrete
authentication protections using the <tt>epoch_authenticator</tt>, they will need to
use it in some secondary protocol (such as the face-to-face protocol above).
The details of that protocol will then determine the specific authentication
protections provided to the MLS group.</t>
      </section>
    </section>
    <section anchor="secret-tree">
      <name>Secret Tree</name>
      <t>For the generation of encryption keys and nonces, the key schedule begins with
the <tt>encryption_secret</tt> at the root and derives a tree of secrets with the same
structure as the group's ratchet tree. Each leaf in the secret tree is
associated with the same group member as the corresponding leaf in the ratchet
tree.</t>
      <t>If N is a parent node in the secret tree, then the secrets of the children of N
are defined as follows (where left(N) and right(N) denote the children of N):</t>
      <figure>
        <name>Derivation of Secrets from Parent to Children within a Secret Tree</name>
        <artset>
          <artwork type="svg">
            <svg xmlns="http://www.w3.org/2000/svg" class="diagram" font-family="monospace" font-size="13px" height="160" text-anchor="middle" version="1.1" viewBox="0 0 456 160" width="456">
              <path d="M 72,40 L 72,128" fill="none" stroke="black"/>
              <path d="M 248,80 L 248,88" fill="none" stroke="black"/>
              <path d="M 72,80 L 96,80" fill="none" stroke="black"/>
              <path d="M 72,128 L 96,128" fill="none" stroke="black"/>
              <polygon class="arrowhead" fill="black" points="104,128 92,122.4 92,133.6" transform="rotate(0,96,128)"/>
              <polygon class="arrowhead" fill="black" points="104,80 92,74.4 92,85.6" transform="rotate(0,96,80)"/>
              <g class="text">
                <text x="84" y="36">tree_node_[N]_secret</text>
                <text x="176" y="84">ExpandWithLabel(.</text>
                <text x="288" y="84">"tree",</text>
                <text x="352" y="84">"left",</text>
                <text x="416" y="84">KDF.Nh)</text>
                <text x="112" y="100">=</text>
                <text x="228" y="100">tree_node_[left(N)]_secret</text>
                <text x="180" y="132">ExpandWithLabel(.,</text>
                <text x="288" y="132">"tree",</text>
                <text x="356" y="132">"right",</text>
                <text x="424" y="132">KDF.Nh)</text>
                <text x="112" y="148">=</text>
                <text x="232" y="148">tree_node_[right(N)]_secret</text>
              </g>
            </svg>
          </artwork>
          <artwork type="ascii-art">
tree_node_[N]_secret
        |
        |
        +--&gt; ExpandWithLabel(., "tree", "left", KDF.Nh)
        |    = tree_node_[left(N)]_secret
        |
        +--&gt; ExpandWithLabel(., "tree", "right", KDF.Nh)
             = tree_node_[right(N)]_secret
</artwork>
        </artset>
      </figure>
      <t>The secret in the leaf of the secret tree is used to initiate two symmetric hash
ratchets, from which a sequence of single-use keys and nonces are derived, as
described in <xref target="encryption-keys"/>. The root of each ratchet is computed as:</t>
      <figure>
        <name>Initialization of the Hash Ratchets from the Leaves of a Secret Tree</name>
        <artset>
          <artwork type="svg">
            <svg xmlns="http://www.w3.org/2000/svg" class="diagram" font-family="monospace" font-size="13px" height="160" text-anchor="middle" version="1.1" viewBox="0 0 472 160" width="472">
              <path d="M 72,40 L 72,128" fill="none" stroke="black"/>
              <path d="M 72,80 L 96,80" fill="none" stroke="black"/>
              <path d="M 72,128 L 96,128" fill="none" stroke="black"/>
              <polygon class="arrowhead" fill="black" points="104,128 92,122.4 92,133.6" transform="rotate(0,96,128)"/>
              <polygon class="arrowhead" fill="black" points="104,80 92,74.4 92,85.6" transform="rotate(0,96,80)"/>
              <g class="text">
                <text x="84" y="36">tree_node_[N]_secret</text>
                <text x="180" y="84">ExpandWithLabel(.,</text>
                <text x="308" y="84">"handshake",</text>
                <text x="376" y="84">"",</text>
                <text x="424" y="84">KDF.Nh)</text>
                <text x="112" y="100">=</text>
                <text x="252" y="100">handshake_ratchet_secret_[N]_[0]</text>
                <text x="180" y="132">ExpandWithLabel(.,</text>
                <text x="316" y="132">"application",</text>
                <text x="392" y="132">"",</text>
                <text x="440" y="132">KDF.Nh)</text>
                <text x="112" y="148">=</text>
                <text x="260" y="148">application_ratchet_secret_[N]_[0]</text>
              </g>
            </svg>
          </artwork>
          <artwork type="ascii-art">
tree_node_[N]_secret
        |
        |
        +--&gt; ExpandWithLabel(., "handshake", "", KDF.Nh)
        |    = handshake_ratchet_secret_[N]_[0]
        |
        +--&gt; ExpandWithLabel(., "application", "", KDF.Nh)
             = application_ratchet_secret_[N]_[0]
</artwork>
        </artset>
      </figure>
      <section anchor="encryption-keys">
        <name>Encryption Keys</name>
        <t>As described in <xref target="message-framing"/>, MLS encrypts three different
types of information:</t>
        <ul spacing="normal">
          <li>Metadata (sender information)</li>
          <li>Handshake messages (Proposal and Commit)</li>
          <li>Application messages</li>
        </ul>
        <t>The sender information used to look up the key for content encryption is
encrypted with an AEAD where the key and nonce are derived from both
<tt>sender_data_secret</tt> and a sample of the encrypted message content.</t>
        <t>For handshake and application messages, a sequence of keys is derived via a
"sender ratchet".  Each sender has their own sender ratchet, and each step along
the ratchet is called a "generation".</t>
        <t>The following figure shows a secret tree for a four-member group, with the
handshake and application ratchets that member D will use for sending and the
first two application keys and nonces.</t>
        <figure anchor="secret-tree-example">
          <name>Secret Tree for a Four-Member Group</name>
          <artset>
            <artwork type="svg">
              <svg xmlns="http://www.w3.org/2000/svg" class="diagram" font-family="monospace" font-size="13px" height="320" text-anchor="middle" version="1.1" viewBox="0 0 200 320" width="200">
                <path d="M 56,48 L 56,64" fill="none" stroke="black"/>
                <path d="M 128,176 L 128,208" fill="none" stroke="black"/>
                <path d="M 128,240 L 128,272" fill="none" stroke="black"/>
                <path d="M 160,160 L 160,192" fill="none" stroke="black"/>
                <path d="M 160,224 L 160,256" fill="none" stroke="black"/>
                <path d="M 40,64 L 72,64" fill="none" stroke="black"/>
                <path d="M 144,160 L 176,160" fill="none" stroke="black"/>
                <path d="M 160,192 L 176,192" fill="none" stroke="black"/>
                <path d="M 144,224 L 176,224" fill="none" stroke="black"/>
                <path d="M 160,256 L 176,256" fill="none" stroke="black"/>
                <path d="M 72,64 L 80,80" fill="none" stroke="black"/>
                <path d="M 32,80 L 40,64" fill="none" stroke="black"/>
                <g class="text">
                  <text x="56" y="36">G</text>
                  <text x="24" y="100">E</text>
                  <text x="88" y="100">F</text>
                  <text x="16" y="116">/</text>
                  <text x="32" y="116">\</text>
                  <text x="80" y="116">/</text>
                  <text x="96" y="116">\</text>
                  <text x="8" y="132">A</text>
                  <text x="40" y="132">B</text>
                  <text x="72" y="132">C</text>
                  <text x="104" y="132">D</text>
                  <text x="96" y="148">/</text>
                  <text x="112" y="148">\</text>
                  <text x="88" y="164">HR0</text>
                  <text x="128" y="164">AR0</text>
                  <text x="188" y="164">K0</text>
                  <text x="188" y="196">N0</text>
                  <text x="128" y="228">AR1</text>
                  <text x="188" y="228">K1</text>
                  <text x="188" y="260">N1</text>
                  <text x="128" y="292">AR2</text>
                </g>
              </svg>
            </artwork>
            <artwork type="ascii-art">
       G
       |
     .-+-.
    /     \
   E       F
  / \     / \
 A   B   C   D
            / \
          HR0  AR0--+--K0
                |   |
                |   +--N0
                |
               AR1--+--K1
                |   |
                |   +--N1
                |
               AR2
</artwork>
          </artset>
        </figure>
        <t>A sender ratchet starts from a per-sender base secret derived from a Secret
Tree, as described in <xref target="secret-tree"/>. The base secret initiates a symmetric
hash ratchet, which generates a sequence of keys and nonces. The sender uses the
j-th key/nonce pair in the sequence to encrypt (using the AEAD) the j-th message
they send during that epoch. Each key/nonce pair <bcp14>MUST NOT</bcp14> be used to encrypt
more than one message.</t>
        <t>Keys, nonces, and the secrets in ratchets are derived using
DeriveTreeSecret. The context in a given call consists of the current position
in the ratchet.</t>
        <sourcecode type="pseudocode">
DeriveTreeSecret(Secret, Label, Generation, Length) =
    ExpandWithLabel(Secret, Label, Generation, Length)
</sourcecode>
        <t>Where <tt>Generation</tt> is encoded as a big endian uint32.</t>
        <artset>
          <artwork type="svg">
            <svg xmlns="http://www.w3.org/2000/svg" class="diagram" font-family="monospace" font-size="13px" height="208" text-anchor="middle" version="1.1" viewBox="0 0 416 208" width="416">
              <path d="M 56,40 L 56,160" fill="none" stroke="black"/>
              <path d="M 56,64 L 80,64" fill="none" stroke="black"/>
              <path d="M 56,112 L 80,112" fill="none" stroke="black"/>
              <polygon class="arrowhead" fill="black" points="88,112 76,106.4 76,117.6" transform="rotate(0,80,112)"/>
              <polygon class="arrowhead" fill="black" points="88,64 76,58.4 76,69.6" transform="rotate(0,80,64)"/>
              <polygon class="arrowhead" fill="black" points="64,160 52,154.4 52,165.6" transform="rotate(90,56,160)"/>
              <g class="text">
                <text x="92" y="36">ratchet_secret_[N]_[j]</text>
                <text x="168" y="68">DeriveTreeSecret(.,</text>
                <text x="284" y="68">"nonce",</text>
                <text x="332" y="68">j,</text>
                <text x="380" y="68">AEAD.Nn)</text>
                <text x="96" y="84">=</text>
                <text x="192" y="84">ratchet_nonce_[N]_[j]</text>
                <text x="168" y="116">DeriveTreeSecret(.,</text>
                <text x="276" y="116">"key",</text>
                <text x="316" y="116">j,</text>
                <text x="372" y="116">AEAD.Nk)</text>
                <text x="96" y="132">=</text>
                <text x="184" y="132">ratchet_key_[N]_[j]</text>
                <text x="80" y="180">DeriveTreeSecret(.,</text>
                <text x="200" y="180">"secret",</text>
                <text x="252" y="180">j,</text>
                <text x="296" y="180">KDF.Nh)</text>
                <text x="8" y="196">=</text>
                <text x="116" y="196">ratchet_secret_[N]_[j+1]</text>
              </g>
            </svg>
          </artwork>
          <artwork type="ascii-art">
ratchet_secret_[N]_[j]
      |
      +--&gt; DeriveTreeSecret(., "nonce", j, AEAD.Nn)
      |    = ratchet_nonce_[N]_[j]
      |
      +--&gt; DeriveTreeSecret(., "key", j,  AEAD.Nk)
      |    = ratchet_key_[N]_[j]
      |
      V
DeriveTreeSecret(., "secret", j, KDF.Nh)
= ratchet_secret_[N]_[j+1]
</artwork>
        </artset>
        <t>Here <tt>AEAD.Nn</tt> and <tt>AEAD.Nk</tt> denote the lengths
in bytes of the nonce and key for the AEAD scheme defined by
the cipher suite.</t>
      </section>
      <section anchor="deletion-schedule">
        <name>Deletion Schedule</name>
        <t>It is important to delete all security-sensitive values as soon as they are
<em>consumed</em>. A sensitive value S is said to be <em>consumed</em> if:</t>
        <ul spacing="normal">
          <li>S was used to encrypt or (successfully) decrypt a message, or</li>
          <li>a key, nonce, or secret derived from S has been consumed. (This goes for
values derived via DeriveSecret as well as ExpandWithLabel.)</li>
        </ul>
        <t>Here S may be the <tt>init_secret</tt>, <tt>commit_secret</tt>, <tt>epoch_secret</tt>, or
<tt>encryption_secret</tt> as well as any secret in a secret tree or one of the
ratchets.</t>
        <t>As soon as a group member consumes a value, they <bcp14>MUST</bcp14> immediately delete
(all representations of) that value. This is crucial to ensuring
forward secrecy for past messages. Members <bcp14>MAY</bcp14> keep unconsumed values around
for some reasonable amount of time to handle out-of-order message delivery.</t>
        <t>For example, suppose a group member encrypts or (successfully) decrypts an
application message using the j-th key and nonce in the ratchet of leaf node
L in some epoch n. Then, for that member, at least the following
values have been consumed and <bcp14>MUST</bcp14> be deleted:</t>
        <ul spacing="normal">
          <li>the <tt>commit_secret</tt>, <tt>joiner_secret</tt>, <tt>epoch_secret</tt>, and <tt>encryption_secret</tt> of
that epoch n as well as the <tt>init_secret</tt> of the previous epoch n-1,</li>
          <li>all node secrets in the secret tree on the path from the root to the leaf with
node L,</li>
          <li>the first j secrets in the application data ratchet of node L, and</li>
          <li><tt>application_ratchet_nonce_[L]_[j]</tt> and <tt>application_ratchet_key_[L]_[j]</tt>.</li>
        </ul>
        <t>Concretely, consider the secret tree shown in <xref target="secret-tree-example"/>.  Client
A, B, or C would generate the illustrated values on receiving a message from D
with generation equal to 1, having not received a message with generation 0
(e.g., due to out-of-order delivery).  In such a case, the following values
would be consumed:</t>
        <ul spacing="normal">
          <li>The key K1 and nonce N1 used to decrypt the message</li>
          <li>The application ratchet secrets AR1 and AR0</li>
          <li>The tree secrets D, F, and G (recall that G is the <tt>encryption_secret</tt> for the
epoch)</li>
          <li>The <tt>epoch_secret</tt>, <tt>commit_secret</tt>, <tt>psk_secret</tt>, and <tt>joiner_secret</tt> for the
current epoch</li>
        </ul>
        <t>Other values may be retained (not consumed):</t>
        <ul spacing="normal">
          <li>K0 and N0 for decryption of an out-of-order message with generation 0</li>
          <li>AR2 for derivation of further message decryption keys and nonces</li>
          <li>HR0 for protection of handshake messages from D</li>
          <li>E and C for deriving secrets used by senders A, B, and C</li>
        </ul>
      </section>
    </section>
    <section anchor="key-packages">
      <name>Key Packages</name>
      <t>In order to facilitate the asynchronous addition of clients to a
group, clients can pre-publish KeyPackage objects that
provide some public information about a user. A KeyPackage object specifies:</t>
      <ol spacing="normal" type="1">
        <li>a protocol version and cipher suite that the client supports,</li>
        <li>a public key that others can use to encrypt a Welcome message to this client
(an "init key"), and</li>
        <li>the content of the leaf node that should be added to the tree to represent
this client.</li>
      </ol>
      <t>KeyPackages are intended to be used only once and <bcp14>SHOULD NOT</bcp14>
be reused except in the case of a "last resort" KeyPackage (see <xref target="keypackage-reuse"/>).
Clients <bcp14>MAY</bcp14> generate and publish multiple KeyPackages to
support multiple cipher suites.</t>
      <t>The value for <tt>init_key</tt> <bcp14>MUST</bcp14> be a public key for the asymmetric encryption
scheme defined by <tt>cipher_suite</tt>, and it <bcp14>MUST</bcp14> be unique among the set of
KeyPackages created by this client.  Likewise, the <tt>leaf_node</tt> field <bcp14>MUST</bcp14> be
valid for the cipher suite, including both the <tt>encryption_key</tt> and
<tt>signature_key</tt> fields.  The whole structure is signed using the client's
signature key. A KeyPackage object with an invalid signature field <bcp14>MUST</bcp14> be
considered malformed.</t>
      <t>The signature is computed by the function <tt>SignWithLabel</tt> with a label
<tt>"KeyPackageTBS"</tt> and a <tt>Content</tt> input comprising all of the fields except for the
signature field.</t>
      <sourcecode type="tls-presentation">
struct {
    ProtocolVersion version;
    CipherSuite cipher_suite;
    HPKEPublicKey init_key;
    LeafNode leaf_node;
    Extension extensions&lt;V&gt;;
    /* SignWithLabel(., "KeyPackageTBS", KeyPackageTBS) */
    opaque signature&lt;V&gt;;
} KeyPackage;

struct {
    ProtocolVersion version;
    CipherSuite cipher_suite;
    HPKEPublicKey init_key;
    LeafNode leaf_node;
    Extension extensions&lt;V&gt;;
} KeyPackageTBS;
</sourcecode>
      <t>If a client receives a KeyPackage carried within an MLSMessage object, then it
<bcp14>MUST</bcp14> verify that the <tt>version</tt> field of the KeyPackage has the same value as the
<tt>version</tt> field of the MLSMessage.  The <tt>version</tt> field in the KeyPackage
provides an explicit signal of the intended version to the other members of
group when they receive the KeyPackage in an Add proposal.</t>
      <t>The field <tt>leaf_node.capabilities</tt> indicates what protocol versions,
cipher suites, credential types, and non-default proposal/extension types are supported
by the client.  (As discussed in <xref target="leaf-node-contents"/>, some proposal and extension types defined in this document are considered
"default" and thus are not listed.)  This information allows MLS session
establishment to be safe from downgrade attacks on the parameters described (as
discussed in <xref target="group-creation"/>), while still only advertising one version and
one cipher suite per KeyPackage.</t>
      <t>The field <tt>leaf_node.leaf_node_source</tt> of the LeafNode in a KeyPackage <bcp14>MUST</bcp14> be
set to <tt>key_package</tt>.</t>
      <t>Extensions included in the <tt>extensions</tt> or <tt>leaf_node.extensions</tt> fields <bcp14>MUST</bcp14>
be included in the <tt>leaf_node.capabilities</tt> field.  As discussed in
<xref target="extensibility"/>, unknown extensions in <tt>KeyPackage.extensions</tt> <bcp14>MUST</bcp14> be
ignored, and the creator of a KeyPackage object <bcp14>SHOULD</bcp14> include some random GREASE
extensions to help ensure that other clients correctly ignore unknown
extensions.</t>
      <section anchor="keypackage-validation">
        <name>KeyPackage Validation</name>
        <t>The validity of a KeyPackage needs to be verified at a few stages:</t>
        <ul spacing="normal">
          <li>When a KeyPackage is downloaded by a group member, before it is used
to add the client to the group</li>
          <li>When a KeyPackage is received by a group member in an Add message</li>
        </ul>
        <t>The client verifies the validity of a KeyPackage using the following steps:</t>
        <ul spacing="normal">
          <li>Verify that the cipher suite and protocol version of the KeyPackage match
those in the GroupContext.</li>
          <li>Verify that the <tt>leaf_node</tt> of the KeyPackage is valid for a KeyPackage
according to <xref target="leaf-node-validation"/>.</li>
          <li>Verify that the signature on the KeyPackage is valid using the public key
in <tt>leaf_node.credential</tt>.</li>
          <li>Verify that the value of <tt>leaf_node.encryption_key</tt> is different from the value of
the <tt>init_key</tt> field.</li>
        </ul>
      </section>
    </section>
    <section anchor="group-creation">
      <name>Group Creation</name>
      <t>A group is always created with a single member, the "creator".  Other members
are then added to the group using the usual Add/Commit mechanism.</t>
      <t>The creator of a group is responsible for setting the group ID, cipher suite, and
initial extensions for the group.  If the creator intends to add other members
at the time of creation, then it <bcp14>SHOULD</bcp14> fetch KeyPackages for the members to be
added, and select a cipher suite and extensions according to the capabilities of
the members.  To protect against downgrade attacks, the creator <bcp14>MUST</bcp14> use the
<tt>capabilities</tt> information in these KeyPackages to verify that the chosen
version and cipher suite is the best option supported by all members.</t>
      <t>Group IDs <bcp14>SHOULD</bcp14> be constructed in such a way that there is an overwhelmingly low
probability of honest group creators generating the same group ID, even without
assistance from the Delivery Service. This can be done, for example, by making the group ID a
freshly generated random value of size <tt>KDF.Nh</tt>. The Delivery Service <bcp14>MAY</bcp14>
attempt to ensure that group IDs are globally unique by rejecting the creation
of new groups with a previously used ID.</t>
      <t>To initialize a group, the creator of the group <bcp14>MUST</bcp14> take the
following steps:</t>
      <ul spacing="normal">
        <li>
          <t>Initialize a one-member group with the following initial values:
          </t>
          <ul spacing="normal">
            <li>Ratchet tree: A tree with a single node, a leaf node containing an HPKE public
key and credential for the creator</li>
            <li>Group ID: A value set by the creator</li>
            <li>Epoch: 0</li>
            <li>Tree hash: The root hash of the above ratchet tree</li>
            <li>Confirmed transcript hash: The zero-length octet string</li>
            <li>Epoch secret: A fresh random value of size <tt>KDF.Nh</tt></li>
            <li>Extensions: Any values of the creator's choosing</li>
          </ul>
        </li>
        <li>
          <t>Calculate the interim transcript hash:
          </t>
          <ul spacing="normal">
            <li>Derive the <tt>confirmation_key</tt> for the epoch as described in
<xref target="key-schedule"/>.</li>
            <li>Compute a <tt>confirmation_tag</tt> over the empty <tt>confirmed_transcript_hash</tt>
using the <tt>confirmation_key</tt> as described in <xref target="content-authentication"/>.</li>
            <li>Compute the updated <tt>interim_transcript_hash</tt> from the
<tt>confirmed_transcript_hash</tt> and the <tt>confirmation_tag</tt> as described in
<xref target="transcript-hashes"/>.</li>
          </ul>
        </li>
      </ul>
      <t>At this point, the creator's state represents a one-member group with a fully
initialized key schedule, transcript hashes, etc.  Proposals and Commits can be
generated for this group state just like any other state of the group, such as
Add proposals and Commits to add other members to the group.  A GroupInfo object
for this group state can also be published to facilitate external joins.</t>
      <t>Members other than the creator join either by being sent a Welcome message (as
described in <xref target="joining-via-welcome-message"/>) or by sending an external Commit
(see <xref target="joining-via-external-commits"/>).</t>
      <t>In principle, the above process could be streamlined by having the
creator directly create a tree and choose a random value for first
epoch's epoch secret.  We follow the steps above because it removes
unnecessary choices, by which, for example, bad randomness could be
introduced.  The only choices the creator makes here are its own
KeyPackage and the leaf secret from which the Commit is built.</t>
      <section anchor="required-capabilities">
        <name>Required Capabilities</name>
        <t>The configuration of a group imposes certain requirements on clients in the
group.  At a minimum, all members of the group need to support the cipher suite
and protocol version in use.  Additional requirements can be imposed by
including a <tt>required_capabilities</tt> extension in the GroupContext.</t>
        <sourcecode type="tls-presentation">
struct {
    ExtensionType extension_types&lt;V&gt;;
    ProposalType proposal_types&lt;V&gt;;
    CredentialType credential_types&lt;V&gt;;
} RequiredCapabilities;
</sourcecode>
        <t>This extension lists the extensions, proposals, and credential types that must be supported by
all members of the group. The "default" proposal and extension types defined in this
document are assumed to be implemented by all clients, and need not be listed in
RequiredCapabilities in order to be safely used. Note that this is not true for
credential types.</t>
        <t>For new members, support for required capabilities is enforced by existing
members during the application of Add commits.  Existing members should of
course be in compliance already.  In order to ensure this continues to be the
case even as the group's extensions are updated, a GroupContextExtensions
proposal is deemed invalid if it contains a <tt>required_capabilities</tt> extension that
requires non-default capabilities not supported by all current members.</t>
      </section>
      <section anchor="reinitialization">
        <name>Reinitialization</name>
        <t>A group may be reinitialized by creating a new group with the same membership
and different parameters, and linking it to the old group via a resumption PSK.
The members of a group reinitialize it using the following steps:</t>
        <ol spacing="normal" type="1">
          <li>A member of the old group sends a ReInit proposal (see <xref target="reinit"/>).</li>
          <li>A member of the old group sends a Commit covering the ReInit proposal.</li>
          <li>
            <t>A member of the old group creates an initial Commit that sets up a new group
that matches the ReInit and sends a Welcome message:
            </t>
            <ul spacing="normal">
              <li>The <tt>version</tt>, <tt>cipher_suite</tt>, <tt>group_id</tt>, and <tt>extensions</tt> fields of the GroupContext object in the Welcome
message <bcp14>MUST</bcp14> be the same as the corresponding fields in the ReInit
proposal. The <tt>epoch</tt> in the Welcome message <bcp14>MUST</bcp14> be 1.</li>
              <li>The Welcome message <bcp14>MUST</bcp14> specify a PreSharedKeyID of type <tt>resumption</tt> with usage
<tt>reinit</tt>, where the <tt>group_id</tt> field matches the old group and the <tt>epoch</tt>
field indicates the epoch after the Commit covering the ReInit.</li>
            </ul>
          </li>
        </ol>
        <t>Note that these three steps may be done by the same group member or different
members.  For example, if a group member sends a Commit with an inline ReInit
proposal (steps 1 and 2) but then goes offline, another group member may
recreate the group instead.  This flexibility avoids situations where a group
gets stuck between steps 2 and 3.</t>
        <t>Resumption PSKs with usage <tt>reinit</tt> <bcp14>MUST NOT</bcp14> be used in other contexts.  A
PreSharedKey proposal with type <tt>resumption</tt> and usage <tt>reinit</tt> <bcp14>MUST</bcp14> be
considered invalid.</t>
      </section>
      <section anchor="subgroup-branching">
        <name>Subgroup Branching</name>
        <t>A new group can be formed from a subset of an existing group's members, using
the same parameters as the old group.</t>
        <t>A member can create a subgroup by performing the following steps:</t>
        <ol spacing="normal" type="1">
          <li>Fetch a new KeyPackage for each group member that should be included in the
subgroup.</li>
          <li>Create an initial Commit message that sets up the new group and contains a
PreSharedKey proposal of type <tt>resumption</tt> with usage <tt>branch</tt>. To avoid key
reuse, the <tt>psk_nonce</tt> included in the PreSharedKeyID object <bcp14>MUST</bcp14> be a
randomly sampled nonce of length <tt>KDF.Nh</tt>.</li>
          <li>Send the corresponding Welcome message to the subgroup members.</li>
        </ol>
        <t>A client receiving a Welcome message including a PreSharedKey of type <tt>resumption</tt> with
usage <tt>branch</tt> <bcp14>MUST</bcp14> verify that the new group reflects a subgroup branched from
the referenced group by checking that:</t>
        <ul spacing="normal">
          <li>The <tt>version</tt> and <tt>cipher_suite</tt> values in the Welcome message are the same as
those used by the old group.</li>
          <li>The <tt>epoch</tt> in the Welcome message <bcp14>MUST</bcp14> be 1.</li>
          <li>Each LeafNode in a new subgroup <bcp14>MUST</bcp14> match some LeafNode in the original
group. In this context, a pair of LeafNodes is said to "match" if the
identifiers presented by their respective credentials are considered
equivalent by the application.</li>
        </ul>
        <t>Resumption PSKs with usage <tt>branch</tt> <bcp14>MUST NOT</bcp14> be used in other contexts.  A
PreSharedKey proposal with type <tt>resumption</tt> and usage <tt>branch</tt> <bcp14>MUST</bcp14> be
considered invalid.</t>
      </section>
    </section>
    <section anchor="group-evolution">
      <name>Group Evolution</name>
      <t>Over the lifetime of a group, its membership can change, and existing members
might want to change their keys in order to achieve post-compromise security.
In MLS, each such change is accomplished by a two-step process:</t>
      <ol spacing="normal" type="1">
        <li>A proposal to make the change is broadcast to the group in a Proposal
message.</li>
        <li>A member of the group or a new member broadcasts a Commit message that causes
one or more proposed changes to enter into effect.</li>
      </ol>
      <t>In cases where the Proposal and Commit are sent by the same member, these two steps
can be combined by sending the proposals in the commit.</t>
      <t>The group thus evolves from one cryptographic state to another each time a
Commit message is sent and processed.  These states are referred to as "epochs"
and are uniquely identified among states of the group by eight-octet epoch values.
When a new group is initialized, its initial state epoch is 0x0000000000000000.  Each time
a state transition occurs, the epoch number is incremented by one.</t>
      <section anchor="proposals">
        <name>Proposals</name>
        <t>Proposals are included in a FramedContent by way of a Proposal structure
that indicates their type:</t>
        <sourcecode type="tls-presentation">
// See the "MLS Proposal Types" IANA registry for values
uint16 ProposalType;

struct {
    ProposalType proposal_type;
    select (Proposal.proposal_type) {
        case add:                      Add;
        case update:                   Update;
        case remove:                   Remove;
        case psk:                      PreSharedKey;
        case reinit:                   ReInit;
        case external_init:            ExternalInit;
        case group_context_extensions: GroupContextExtensions;
    };
} Proposal;
</sourcecode>
        <t>On receiving a FramedContent containing a Proposal, a client <bcp14>MUST</bcp14> verify the
signature inside FramedContentAuthData and that the <tt>epoch</tt> field of the enclosing
FramedContent is equal to the <tt>epoch</tt> field of the current GroupContext object.
If the verification is successful, then the Proposal should be cached in such a way
that it can be retrieved by hash (as a ProposalOrRef object) in a later Commit message.</t>
        <section anchor="add">
          <name>Add</name>
          <t>An Add proposal requests that a client with a specified KeyPackage be added
to the group.</t>
          <sourcecode type="tls-presentation">
struct {
    KeyPackage key_package;
} Add;
</sourcecode>
          <t>An Add proposal is invalid if the KeyPackage is invalid according to
<xref target="keypackage-validation"/>.</t>
          <t>An Add is applied after being included in a Commit message.  The position of the
Add in the list of proposals determines the leaf node where the new member will
be added.  For the first Add in the Commit, the corresponding new member will be
placed in the leftmost empty leaf in the tree, for the second Add, the next
empty leaf to the right, etc. If no empty leaf exists, the tree is extended to
the right.</t>
          <ul spacing="normal">
            <li>Identify the leaf L for the new member: if there are empty leaves in the tree,
L is the leftmost empty leaf. Otherwise, the tree is extended to the right as
described in <xref target="adding-and-removing-leaves"/>, and L is assigned the leftmost new
blank leaf.</li>
            <li>For each non-blank intermediate node along the path from the leaf L
to the root, add L's leaf index to the <tt>unmerged_leaves</tt> list for the node.</li>
            <li>Set the leaf node L to a new node containing the LeafNode object carried in
the <tt>leaf_node</tt> field of the KeyPackage in the Add.</li>
          </ul>
        </section>
        <section anchor="update">
          <name>Update</name>
          <t>An Update proposal is a similar mechanism to Add with the distinction
that it replaces the sender's LeafNode in the tree instead of adding a new leaf
to the tree.</t>
          <sourcecode type="tls-presentation">
struct {
    LeafNode leaf_node;
} Update;
</sourcecode>
          <t>An Update proposal is invalid if the LeafNode is invalid for an Update
proposal according to <xref target="leaf-node-validation"/>.</t>
          <t>A member of the group applies an Update message by taking the following steps:</t>
          <ul spacing="normal">
            <li>Replace the sender's LeafNode with the one contained in the Update proposal.</li>
            <li>Blank the intermediate nodes along the path from the sender's leaf to the
root.</li>
          </ul>
        </section>
        <section anchor="remove">
          <name>Remove</name>
          <t>A Remove proposal requests that the member with the leaf index <tt>removed</tt> be removed
from the group.</t>
          <sourcecode type="tls-presentation">
struct {
    uint32 removed;
} Remove;
</sourcecode>
          <t>A Remove proposal is invalid if the <tt>removed</tt> field does not identify a non-blank
leaf node.</t>
          <t>A member of the group applies a Remove message by taking the following steps:</t>
          <ul spacing="normal">
            <li>Identify the leaf node matching <tt>removed</tt>.  Let L be this leaf node.</li>
            <li>Replace the leaf node L with a blank node.</li>
            <li>Blank the intermediate nodes along the path from L to the root.</li>
            <li>Truncate the tree by removing the right subtree until there is at least one
non-blank leaf node in the right subtree.  If the rightmost non-blank leaf has
index L, then this will result in the tree having 2<sup>d</sup> leaves, where <tt>d</tt> is
the smallest value such that 2<sup>d</sup> &gt; <tt>L</tt>.</li>
          </ul>
        </section>
        <section anchor="presharedkey">
          <name>PreSharedKey</name>
          <t>A PreSharedKey proposal can be used to request that a pre-shared key be
injected into the key schedule in the process of advancing the epoch.</t>
          <sourcecode type="tls-presentation">
struct {
    PreSharedKeyID psk;
} PreSharedKey;
</sourcecode>
          <t>A PreSharedKey proposal is invalid if any of the following is true:</t>
          <ul spacing="normal">
            <li>The PreSharedKey proposal is not being processed as part of a reinitialization
of the group (see <xref target="reinitialization"/>), and the PreSharedKeyID has <tt>psktype</tt>
set to <tt>resumption</tt> and <tt>usage</tt> set to <tt>reinit</tt>.</li>
            <li>The PreSharedKey proposal is not being processed as part of a subgroup
branching operation (see <xref target="subgroup-branching"/>), and the PreSharedKeyID has
<tt>psktype</tt> set to <tt>resumption</tt> and <tt>usage</tt> set to <tt>branch</tt>.</li>
            <li>The <tt>psk_nonce</tt> is not of length <tt>KDF.Nh</tt>.</li>
          </ul>
          <t>The <tt>psk_nonce</tt> <bcp14>MUST</bcp14> be randomly sampled. When processing
a Commit message that includes one or more PreSharedKey proposals, group
members derive <tt>psk_secret</tt> as described in <xref target="pre-shared-keys"/>, where the
order of the PSKs corresponds to the order of the PreSharedKey proposals
in the Commit.</t>
        </section>
        <section anchor="reinit">
          <name>ReInit</name>
          <t>A ReInit proposal represents a request to reinitialize the group with different
parameters, for example, to increase the version number or to change the
cipher suite. The reinitialization is done by creating a completely new group
and shutting down the old one.</t>
          <sourcecode type="tls-presentation">
struct {
    opaque group_id&lt;V&gt;;
    ProtocolVersion version;
    CipherSuite cipher_suite;
    Extension extensions&lt;V&gt;;
} ReInit;
</sourcecode>
          <t>A ReInit proposal is invalid if the <tt>version</tt> field is less than the version
for the current group.</t>
          <t>A member of the group applies a ReInit proposal by waiting for the committer to
send the Welcome message that matches the ReInit, according to the criteria in
<xref target="reinitialization"/>.</t>
        </section>
        <section anchor="externalinit">
          <name>ExternalInit</name>
          <t>An ExternalInit proposal is used by new members that want to join a group by
using an external commit. This proposal can only be used in that context.</t>
          <sourcecode type="tls-presentation">
struct {
  opaque kem_output&lt;V&gt;;
} ExternalInit;
</sourcecode>
          <t>A member of the group applies an ExternalInit message by initializing the next
epoch using an init secret computed as described in <xref target="external-initialization"/>.
The <tt>kem_output</tt> field contains the required KEM output.</t>
        </section>
        <section anchor="groupcontextextensions">
          <name>GroupContextExtensions</name>
          <t>A GroupContextExtensions proposal is used to update the list of extensions in
the GroupContext for the group.</t>
          <sourcecode type="tls-presentation">
struct {
  Extension extensions&lt;V&gt;;
} GroupContextExtensions;
</sourcecode>
          <t>A GroupContextExtensions proposal is invalid if it includes a
<tt>required_capabilities</tt> extension and some members of the group do not support
some of the required capabilities (including those added in the same Commit,
and excluding those removed).</t>
          <t>A member of the group applies a GroupContextExtensions proposal with the
following steps:</t>
          <ul spacing="normal">
            <li>Remove all of the existing extensions from the GroupContext object for the
group and replace them with the list of extensions in the proposal.  (This
is a wholesale replacement, not a merge. An extension is only carried over if
the sender of the proposal includes it in the new list.)</li>
          </ul>
          <t>Note that once the GroupContext is updated, its inclusion in the
<tt>confirmation_tag</tt> by way of the key schedule will confirm that all members of the
group agree on the extensions in use.</t>
        </section>
        <section anchor="external-proposals">
          <name>External Proposals</name>
          <t>Proposals can be constructed and sent to the group by a party
that is outside the group in two cases. One case, indicated by the <tt>external</tt> SenderType,
allows an entity outside the group to submit proposals to the group.
For example, an automated service might propose
removing a member of a group who has been inactive for a long time, or propose adding
a newly hired staff member to a group representing a real-world team.
An <tt>external</tt> sender might send a ReInit proposal to enforce a changed policy
regarding MLS versions or cipher suites.</t>
          <t>The <tt>external</tt> SenderType requires that signers are pre-provisioned
to the clients within a group and can only be used if the
<tt>external_senders</tt> extension is present in the group's GroupContext.</t>
          <t>The other case, indicated by the <tt>new_member_proposal</tt> SenderType, is useful
when existing members of the group can independenly verify that an Add proposal
sent by the new joiner itself (not an existing member) is authorized. External
proposals that are not authorized are considered invalid.</t>
          <t>An external proposal <bcp14>MUST</bcp14> be sent as a PublicMessage object, since the sender
will not have the keys necessary to construct a PrivateMessage object.</t>
          <t>Proposals of some types cannot be sent by an <tt>external</tt> sender.  Among the
proposal types defined in this document, only the following types may be sent by
an <tt>external</tt> sender:</t>
          <ul spacing="normal">
            <li>
              <tt>add</tt>
            </li>
            <li>
              <tt>remove</tt>
            </li>
            <li>
              <tt>psk</tt>
            </li>
            <li>
              <tt>reinit</tt>
            </li>
            <li>
              <tt>group_context_extensions</tt>
            </li>
          </ul>
          <t>Messages from <tt>external</tt> senders containing proposal types other than the above
<bcp14>MUST</bcp14> be rejected as malformed.  New proposal types defined in the future <bcp14>MUST</bcp14>
define whether they may be sent by <tt>external</tt> senders.  The "Ext" column in
the "MLS Proposal Types" registry (<xref target="mls-proposal-types"/>) reflects this property.</t>
          <section anchor="external-senders-extension">
            <name>External Senders Extension</name>
            <t>The <tt>external_senders</tt> extension is a group context extension that contains
the credentials and signature keys of senders that are permitted to send
external proposals to the group.</t>
            <sourcecode type="tls-presentation">
struct {
  SignaturePublicKey signature_key;
  Credential credential;
} ExternalSender;

ExternalSender external_senders&lt;V&gt;;
</sourcecode>
          </section>
        </section>
      </section>
      <section anchor="proposal-list-validation">
        <name>Proposal List Validation</name>
        <t>A group member creating a Commit and a group member processing a Commit
<bcp14>MUST</bcp14> verify that the list of committed proposals is valid using one of the following
procedures, depending on whether the Commit is external or not.  If the list of
proposals is invalid, then the Commit message <bcp14>MUST</bcp14> be rejected as invalid.</t>
        <t>For a regular, i.e., not external, Commit, the list is invalid if any of the
following occurs:</t>
        <ul spacing="normal">
          <li>It contains an individual proposal that is invalid as specified in <xref target="proposals"/>.</li>
          <li>It contains an Update proposal generated by the committer.</li>
          <li>It contains a Remove proposal that removes the committer.</li>
          <li>It contains multiple Update and/or Remove proposals that apply to the same leaf.
If the committer has received multiple such proposals they <bcp14>SHOULD</bcp14> prefer any Remove
received, or the most recent Update if there are no Removes.</li>
          <li>It contains multiple Add proposals that contain KeyPackages that represent the same
client according to the application (for example, identical signature keys).</li>
          <li>It contains an Add proposal with a KeyPackage that represents a client already
in the group according to the application, unless there is a Remove proposal
in the list removing the matching client from the group.</li>
          <li>It contains multiple PreSharedKey proposals that reference the same PreSharedKeyID.</li>
          <li>It contains multiple GroupContextExtensions proposals.</li>
          <li>It contains a ReInit proposal together with any other proposal. If the committer has
received other proposals during the epoch, they <bcp14>SHOULD</bcp14> prefer them over the
ReInit proposal, allowing the ReInit to be resent and applied in a subsequent
epoch.</li>
          <li>It contains an ExternalInit proposal.</li>
          <li>It contains a Proposal with a non-default proposal type that is not supported by some
members of the group that will process the Commit (i.e., members being added
or removed by the Commit do not need to support the proposal type).</li>
          <li>After processing the Commit the ratchet tree is invalid, in particular, if it
contains any leaf node that is invalid according to <xref target="leaf-node-validation"/>.</li>
        </ul>
        <t>An application may extend the above procedure by additional rules, for example,
requiring application-level permissions to add members, or rules concerning
non-default proposal types.</t>
        <t>For an external Commit, the list is valid if it contains only the following proposals
(not necessarily in this order):</t>
        <ul spacing="normal">
          <li>Exactly one ExternalInit</li>
          <li>At most one Remove proposal, with which the joiner removes an
old version of themselves. If a Remove proposal is present, then the LeafNode in the
<tt>path</tt> field of the external Commit <bcp14>MUST</bcp14> meet the same criteria as would the LeafNode
in an Update for the removed leaf (see <xref target="update"/>). In particular, the <tt>credential</tt>
in the LeafNode <bcp14>MUST</bcp14> present a set of identifiers that is acceptable to the
application for the removed participant.</li>
          <li>Zero or more PreSharedKey proposals</li>
          <li>No other proposals</li>
        </ul>
        <t>Proposal types defined in the future may make updates to the above validation
logic to incorporate considerations related to proposals of the new type.</t>
      </section>
      <section anchor="applying-a-proposal-list">
        <name>Applying a Proposal List</name>
        <t>The sections above defining each proposal type describe how each individual
proposal is applied.  When creating or processing a Commit, a client applies a
list of proposals to the ratchet tree and GroupContext. The client <bcp14>MUST</bcp14> apply
the proposals in the list in the following order:</t>
        <ul spacing="normal">
          <li>If there is a GroupContextExtensions proposal, replace the <tt>extensions</tt> field
of the GroupContext for the group with the contents of the proposal.  The
new <tt>extensions</tt> <bcp14>MUST</bcp14> be used when evaluating other proposals in this list. For
example, if a GroupContextExtensions proposal adds a <tt>required_capabilities</tt>
extension, then any Add proposals need to indicate support for those
capabilities.</li>
          <li>Apply any Update proposals to the ratchet tree, in any order.</li>
          <li>Apply any Remove proposals to the ratchet tree, in any order.</li>
          <li>Apply any Add proposals to the ratchet tree, in the order they appear in the list.</li>
          <li>Look up the PSK secrets for any PreSharedKey proposals, in the order they
appear in the list.  These secrets are then used to advance the key schedule
later in Commit processing.</li>
          <li>If there is an ExternalInit proposal, use it to derive the <tt>init_secret</tt> for
use later in Commit processing.</li>
          <li>If there is a ReInit proposal, note its parameters for application later in
Commit processing.</li>
        </ul>
        <t>Proposal types defined in the future <bcp14>MUST</bcp14> specify how the above steps are to be
adjusted to accommodate the application of proposals of the new type.</t>
      </section>
      <section anchor="commit">
        <name>Commit</name>
        <t>A Commit message initiates a new epoch for the group, based on a collection of
Proposals. It instructs group members to update their representation of the
state of the group by applying the proposals and advancing the key schedule.</t>
        <t>Each proposal covered by the Commit is included by a ProposalOrRef value, which
identifies the proposal to be applied by value or by reference.  Commits that
refer to new Proposals from the committer can be included by value. Commits
for previously sent proposals from anyone (including the committer) can be sent
by reference.  Proposals sent by reference are specified by including the hash of
the AuthenticatedContent object in which the proposal was sent (see <xref target="hash-based-identifiers"/>).</t>
        <sourcecode type="tls-presentation">
enum {
  reserved(0),
  proposal(1),
  reference(2),
  (255)
} ProposalOrRefType;

struct {
  ProposalOrRefType type;
  select (ProposalOrRef.type) {
    case proposal:  Proposal proposal;
    case reference: ProposalRef reference;
  };
} ProposalOrRef;

struct {
    ProposalOrRef proposals&lt;V&gt;;
    optional&lt;UpdatePath&gt; path;
} Commit;
</sourcecode>
        <t>A group member that has observed one or more valid proposals within an epoch <bcp14>MUST</bcp14> send
a Commit message before sending application data. This ensures, for example,
that any members whose removal was proposed during the epoch are actually
removed before any application data is transmitted.</t>
        <t>A sender and a receiver of a Commit <bcp14>MUST</bcp14> verify that the committed list of
proposals is valid as specified in <xref target="proposal-list-validation"/>. A list is invalid if, for example,
it includes an Update and a Remove for the same member, or an Add when the sender does not have
the application-level permission to add new users.</t>
        <t>The sender of a Commit <bcp14>SHOULD</bcp14> include all proposals that it has received
during the current epoch that are valid according to the rules for their
proposal types and according to application policy, as long as this results in
a valid proposal list.</t>
        <t>Due to the asynchronous nature of proposals, receivers of a Commit <bcp14>SHOULD NOT</bcp14> enforce
that all valid proposals sent within the current epoch are referenced by the next
Commit. In the event that a valid proposal is omitted from the next Commit, and
that proposal is still valid in the current epoch, the sender of the proposal
<bcp14>MAY</bcp14> resend it after updating it to reflect the current epoch.</t>
        <t>A member of the group <bcp14>MAY</bcp14> send a Commit that references no proposals at all,
which would thus have an empty <tt>proposals</tt> vector.  Such
a Commit resets the sender's leaf and the nodes along its direct path, and
provides forward secrecy and post-compromise security with regard to the sender
of the Commit.  An Update proposal can be regarded as a "lazy" version of this
operation, where only the leaf changes and intermediate nodes are blanked out.</t>
        <t>By default, the <tt>path</tt> field of a Commit <bcp14>MUST</bcp14> be populated.  The <tt>path</tt> field
<bcp14>MAY</bcp14> be omitted if (a) it covers at least one proposal and (b) none of the proposals
covered by the Commit are of "path required" types.  A proposal type requires a
path if it cannot change the group membership in a way that requires the forward
secrecy and post-compromise security guarantees that an UpdatePath provides.
The only proposal types defined in this document that do not require a path are:</t>
        <ul spacing="normal">
          <li>
            <tt>add</tt>
          </li>
          <li>
            <tt>psk</tt>
          </li>
          <li>
            <tt>reinit</tt>
          </li>
        </ul>
        <t>New proposal types <bcp14>MUST</bcp14> state whether they require a path. If any instance of a
proposal type requires a path, then the proposal type requires a path. This
attribute of a proposal type is reflected in the "Path Required" field of the
"MLS Proposal Types" registry defined in <xref target="mls-proposal-types"/>.</t>
        <t>Update and Remove proposals are the clearest examples of proposals that require
a path.  An UpdatePath is required to evict the removed member or the old
appearance of the updated member.</t>
        <t>In pseudocode, the logic for validating the <tt>path</tt> field of a Commit is as
follows:</t>
        <sourcecode type="pseudocode">
pathRequiredTypes = [
    update,
    remove,
    external_init,
    group_context_extensions
]

pathRequired = false

for proposal in commit.proposals:
    pathRequired = pathRequired ||
                   (proposal.msg_type in pathRequiredTypes)

if len(commit.proposals) == 0 || pathRequired:
    assert(commit.path != null)
</sourcecode>
        <t>To summarize, a Commit can have three different configurations, with different
uses:</t>
        <ol spacing="normal" type="1">
          <li>An "empty" Commit that references no proposals, which updates the committer's
contribution to the group and provides PCS with regard to the committer.</li>
          <li>A "partial" Commit that references proposals that do not require a path, and
where the path is empty. Such a Commit doesn't provide PCS with regard to the
committer.</li>
          <li>A "full" Commit that references proposals of any type, which provides FS with
regard to any removed members and PCS for the committer and any updated
members.</li>
        </ol>
        <section anchor="creating-a-commit">
          <name>Creating a Commit</name>
          <t>When creating or processing a Commit, a client updates the ratchet tree and
GroupContext for the group.  These values advance from an "old" state reflecting
the current epoch to a "new" state reflecting the new epoch initiated by the
Commit.  When the Commit includes an UpdatePath, a "provisional" group context
is constructed that reflects changes due to the proposals and UpdatePath, but
with the old confirmed transcript hash.</t>
          <t>A member of the group creates a Commit message and the corresponding Welcome
message at the same time, by taking the following steps:</t>
          <ul spacing="normal">
            <li>Verify that the list of proposals to be committed is valid as specified in
<xref target="proposal-list-validation"/>.</li>
            <li>Construct an initial Commit object with the <tt>proposals</tt> field populated from
Proposals received during the current epoch, and with the <tt>path</tt> field empty.</li>
            <li>Create the new ratchet tree and GroupContext by applying the list of proposals
to the old ratchet tree and GroupContext, as defined in
<xref target="applying-a-proposal-list"/>.</li>
            <li>Decide whether to populate the <tt>path</tt> field: If the <tt>path</tt> field is required
based on the proposals that are in the Commit (see above), then it <bcp14>MUST</bcp14> be
populated.  Otherwise, the sender <bcp14>MAY</bcp14> omit the <tt>path</tt> field at its discretion.</li>
            <li>
              <t>If populating the <tt>path</tt> field:  </t>
              <ul spacing="normal">
                <li>If this is an external Commit, assign the sender the leftmost blank leaf
node in the new ratchet tree.  If there are no blank leaf nodes in the new
ratchet tree, expand the tree to the right as defined in
<xref target="adding-and-removing-leaves"/> and assign the leftmost new blank leaf to the
sender.</li>
                <li>Update the sender's direct path in the ratchet tree as described in
<xref target="synchronizing-views-of-the-tree"/>.  Define
<tt>commit_secret</tt> as the value <tt>path_secret[n+1]</tt> derived from the
last path secret value (<tt>path_secret[n]</tt>) derived for the UpdatePath.</li>
                <li>
                  <t>Construct a provisional GroupContext object containing the following values:
                  </t>
                  <ul spacing="normal">
                    <li><tt>group_id</tt>: Same as the old GroupContext</li>
                    <li><tt>epoch</tt>: The epoch number for the new epoch</li>
                    <li><tt>tree_hash</tt>: The tree hash of the new ratchet tree</li>
                    <li><tt>confirmed_transcript_hash</tt>: Same as the old GroupContext</li>
                    <li><tt>extensions</tt>: The new GroupContext extensions (possibly updated by a
GroupContextExtensions proposal)</li>
                  </ul>
                </li>
                <li>Encrypt the path secrets resulting from the tree update to the group as
described in <xref target="synchronizing-views-of-the-tree"/>, using the provisional
group context as the context for HPKE encryption.</li>
                <li>Create an UpdatePath containing the sender's new leaf node and the new
public keys and encrypted path secrets along the sender's filtered direct
path.  Assign this UpdatePath to the <tt>path</tt> field in the Commit.</li>
              </ul>
            </li>
            <li>If not populating the <tt>path</tt> field: Set the <tt>path</tt> field in the Commit to the
null optional.  Define <tt>commit_secret</tt> as the all-zero vector of length
<tt>KDF.Nh</tt> (the same length as a <tt>path_secret</tt> value would be).</li>
            <li>Derive the <tt>psk_secret</tt> as specified in <xref target="pre-shared-keys"/>, where the order
of PSKs in the derivation corresponds to the order of PreSharedKey proposals
in the <tt>proposals</tt> vector.</li>
            <li>
              <t>Construct a FramedContent object containing the Commit object. Sign the
FramedContent using the old GroupContext as context.
              </t>
              <ul spacing="normal">
                <li>Use the FramedContent to update the confirmed transcript hash and update
the new GroupContext.</li>
                <li>Use the <tt>init_secret</tt> from the previous epoch, the <tt>commit_secret</tt> and
<tt>psk_secret</tt> defined in the previous steps, and the new GroupContext to
compute the new <tt>joiner_secret</tt>, <tt>welcome_secret</tt>, <tt>epoch_secret</tt>, and
derived secrets for the new epoch.</li>
                <li>Use the <tt>confirmation_key</tt> for the new epoch to compute the
<tt>confirmation_tag</tt> value.</li>
                <li>Calculate the interim transcript hash using the new confirmed transcript
hash and the <tt>confirmation_tag</tt> from the FramedContentAuthData.</li>
              </ul>
            </li>
            <li>
              <t>Protect the AuthenticatedContent object using keys from the old epoch:
              </t>
              <ul spacing="normal">
                <li>If encoding as PublicMessage, compute the <tt>membership_tag</tt> value using the
<tt>membership_key</tt>.</li>
                <li>If encoding as a PrivateMessage, encrypt the message using the
<tt>sender_data_secret</tt> and the next (key, nonce) pair from the sender's
handshake ratchet.</li>
              </ul>
            </li>
            <li>
              <t>Construct a GroupInfo reflecting the new state:
              </t>
              <ul spacing="normal">
                <li>Set the <tt>group_id</tt>, <tt>epoch</tt>, <tt>tree</tt>, <tt>confirmed_transcript_hash</tt>,
<tt>interim_transcript_hash</tt>, and <tt>group_context_extensions</tt> fields to reflect
the new state.</li>
                <li>Set the <tt>confirmation_tag</tt> field to the value of the corresponding field in
the FramedContentAuthData object.</li>
                <li>Add any other extensions as defined by the application.</li>
                <li>Optionally derive an external key pair as described in <xref target="key-schedule"/>.
(required for external Commits, see <xref target="joining-via-external-commits"/>).</li>
                <li>Sign the GroupInfo using the member's private signing key.</li>
                <li>Encrypt the GroupInfo using the key and nonce derived from the <tt>joiner_secret</tt>.
for the new epoch (see <xref target="joining-via-welcome-message"/>).</li>
              </ul>
            </li>
            <li>
              <t>For each new member in the group:
              </t>
              <ul spacing="normal">
                <li>Identify the lowest common ancestor in the tree of the new member's
leaf node and the member sending the Commit.</li>
                <li>If the <tt>path</tt> field was populated above: Compute the path secret
corresponding to the common ancestor node.</li>
                <li>Compute an EncryptedGroupSecrets object that encapsulates the <tt>init_secret</tt>
for the current epoch and the path secret (if present).</li>
              </ul>
            </li>
            <li>Construct one or more Welcome messages from the encrypted GroupInfo object,
the encrypted key packages, and any PSKs for which a proposal was included in
the Commit. The order of the <tt>psks</tt> <bcp14>MUST</bcp14> be the same as the order of
PreSharedKey proposals in the <tt>proposals</tt> vector.  As discussed in
<xref target="joining-via-welcome-message"/>, the committer is free to choose how many
Welcome messages to construct.  However, the set of Welcome messages produced
in this step <bcp14>MUST</bcp14> cover every new member added in the Commit.</li>
            <li>
              <t>If a ReInit proposal was part of the Commit, the committer <bcp14>MUST</bcp14> create a new
group with the parameters specified in the ReInit proposal,
and with the same members as the original group.
The Welcome message <bcp14>MUST</bcp14> include a PreSharedKeyID with the following
parameters:
              </t>
              <ul spacing="normal">
                <li><tt>psktype</tt>: <tt>resumption</tt></li>
                <li><tt>usage</tt>: <tt>reinit</tt></li>
                <li><tt>group_id</tt>: The group ID for the current group</li>
                <li><tt>epoch</tt>: The epoch that the group will be in after this Commit</li>
              </ul>
            </li>
          </ul>
        </section>
        <section anchor="processing-a-commit">
          <name>Processing a Commit</name>
          <t>A member of the group applies a Commit message by taking the following steps:</t>
          <ul spacing="normal">
            <li>Verify that the <tt>epoch</tt> field of the enclosing FramedContent is equal
to the <tt>epoch</tt> field of the current GroupContext object.</li>
            <li>
              <t>Unprotect the Commit using the keys from the current epoch:
              </t>
              <ul spacing="normal">
                <li>If the message is encoded as PublicMessage, verify the membership MAC using
the <tt>membership_key</tt>.</li>
                <li>If the message is encoded as PrivateMessage, decrypt the message using the
<tt>sender_data_secret</tt> and the (key, nonce) pair from the step on the sender's
hash ratchet indicated by the <tt>generation</tt> field.</li>
              </ul>
            </li>
            <li>Verify that the signature on the FramedContent message as described in
<xref target="content-authentication"/>.</li>
            <li>Verify that the <tt>proposals</tt> vector is valid according to the rules in
<xref target="proposal-list-validation"/>.</li>
            <li>Verify that all PreSharedKey proposals in the <tt>proposals</tt> vector are available.</li>
            <li>Create the new ratchet tree and GroupContext by applying the list of proposals
to the old ratchet tree and GroupContext, as defined in
<xref target="applying-a-proposal-list"/>.</li>
            <li>Verify that the <tt>path</tt> value is populated if the <tt>proposals</tt> vector contains
any Update or Remove proposals, or if it's empty. Otherwise, the <tt>path</tt> value
<bcp14>MAY</bcp14> be omitted.</li>
            <li>
              <t>If the <tt>path</tt> value is populated, validate it and apply it to the tree:  </t>
              <ul spacing="normal">
                <li>If this is an external Commit, assign the sender the leftmost blank leaf
node in the new ratchet tree.  If there are no blank leaf nodes in the new
ratchet tree, add a blank leaf to the right side of the new ratchet tree and
assign it to the sender.</li>
                <li>Validate the LeafNode as specified in <xref target="leaf-node-validation"/>.  The
<tt>leaf_node_source</tt> field <bcp14>MUST</bcp14> be set to <tt>commit</tt>.</li>
                <li>Verify that the <tt>encryption_key</tt> value in the LeafNode is different from the
committer's current leaf node.</li>
                <li>Verify that none of the public keys in the UpdatePath appear in any node of
the new ratchet tree.</li>
                <li>Merge the UpdatePath into the new ratchet tree, as described in
<xref target="synchronizing-views-of-the-tree"/>.</li>
                <li>
                  <t>Construct a provisional GroupContext object containing the following values:
                  </t>
                  <ul spacing="normal">
                    <li><tt>group_id</tt>: Same as the old GroupContext</li>
                    <li><tt>epoch</tt>: The epoch number for the new epoch</li>
                    <li><tt>tree_hash</tt>: The tree hash of the new ratchet tree</li>
                    <li><tt>confirmed_transcript_hash</tt>: Same as the old GroupContext</li>
                    <li><tt>extensions</tt>: The new GroupContext extensions (possibly updated by a
GroupContextExtensions proposal)</li>
                  </ul>
                </li>
                <li>Decrypt the path secrets for UpdatePath as described in
<xref target="synchronizing-views-of-the-tree"/>, using the provisional GroupContext as
the context for HPKE decryption.</li>
                <li>Define <tt>commit_secret</tt> as the value <tt>path_secret[n+1]</tt> derived from the
last path secret value (<tt>path_secret[n]</tt>) derived for the UpdatePath.</li>
              </ul>
            </li>
            <li>If the <tt>path</tt> value is not populated, define <tt>commit_secret</tt> as the all-zero
vector of length <tt>KDF.Nh</tt> (the same length as a <tt>path_secret</tt> value would be).</li>
            <li>Update the confirmed and interim transcript hashes using the new Commit, and
generate the new GroupContext.</li>
            <li>Derive the <tt>psk_secret</tt> as specified in <xref target="pre-shared-keys"/>, where the order
of PSKs in the derivation corresponds to the order of PreSharedKey proposals
in the <tt>proposals</tt> vector.</li>
            <li>Use the <tt>init_secret</tt> from the previous epoch, the <tt>commit_secret</tt> and
<tt>psk_secret</tt> defined in the previous steps, and the new GroupContext to
compute the new <tt>joiner_secret</tt>, <tt>welcome_secret</tt>, <tt>epoch_secret</tt>, and
derived secrets for the new epoch.</li>
            <li>Use the <tt>confirmation_key</tt> for the new epoch to compute the confirmation tag
for this message, as described below, and verify that it is the same as the
<tt>confirmation_tag</tt> field in the FramedContentAuthData object.</li>
            <li>If the above checks are successful, consider the new GroupContext object
as the current state of the group.</li>
            <li>If the Commit included a ReInit proposal, the client <bcp14>MUST NOT</bcp14> use the group to
send messages anymore. Instead, it <bcp14>MUST</bcp14> wait for a Welcome message from the committer
meeting the requirements of <xref target="reinitialization"/>.</li>
          </ul>
          <t>Note that clients need to be prepared to receive a valid Commit message that removes
them from the group. In this case, the client cannot send any more messages in the
group and <bcp14>SHOULD</bcp14> promptly delete its group state and secret tree. (A client might keep
the secret tree for a short time to decrypt late messages in the previous epoch.)</t>
        </section>
        <section anchor="adding-members-to-the-group">
          <name>Adding Members to the Group</name>
          <t>New members can join the group in two ways: by being added by a group
member or by adding themselves through an external Commit. In both cases, the
new members need information to bootstrap their local group state.</t>
          <sourcecode type="tls-presentation">
struct {
    GroupContext group_context;
    Extension extensions&lt;V&gt;;
    MAC confirmation_tag;
    uint32 signer;
    /* SignWithLabel(., "GroupInfoTBS", GroupInfoTBS) */
    opaque signature&lt;V&gt;;
} GroupInfo;
</sourcecode>
          <t>The <tt>group_context</tt> field represents the current state of the group.  The
<tt>extensions</tt> field allows the sender to provide additional data that might be
useful to new joiners.  The <tt>confirmation_tag</tt> represents the  confirmation tag
from the Commit that initiated the current epoch, or for epoch 0, the
confirmation tag computed in the creation of the group (see <xref target="group-creation"/>).
(In either case, the creator of a GroupInfo may recompute the confirmation tag
as <tt>MAC(confirmation_key, confirmed_transcript_hash)</tt>.)</t>
          <t>As discussed in <xref target="extensibility"/>, unknown extensions in <tt>GroupInfo.extensions</tt> <bcp14>MUST</bcp14> be ignored, and the creator of a GroupInfo object <bcp14>SHOULD</bcp14> include some
random GREASE extensions to help ensure that other clients correctly ignore unknown
extensions.  Extensions in <tt>GroupInfo.group_context.extensions</tt>, however, <bcp14>MUST</bcp14>
be supported by the new joiner.</t>
          <t>New members <bcp14>MUST</bcp14> verify that <tt>group_id</tt> is unique among the groups they are
currently participating in.</t>
          <t>New members also <bcp14>MUST</bcp14> verify the <tt>signature</tt> using the public key taken from the
leaf node of the ratchet tree with leaf index <tt>signer</tt>. The
signature covers the following structure, comprising all the fields in the
GroupInfo above <tt>signature</tt>:</t>
          <sourcecode type="tls-presentation">
struct {
    GroupContext group_context;
    Extension extensions&lt;V&gt;;
    MAC confirmation_tag;
    uint32 signer;
} GroupInfoTBS;
</sourcecode>
          <section anchor="joining-via-welcome-message">
            <name>Joining via Welcome Message</name>
            <t>The sender of a Commit message is responsible for sending a Welcome message to
each new member added via Add proposals.  The format of the Welcome message
allows a single Welcome message to be encrypted for multiple new members.  It is
up to the committer to decide how many Welcome messages to create for a given
Commit. The committer could create one Welcome that is encrypted for all new
members, a different Welcome for each new member, or Welcome messages for
batches of new members (according to some batching scheme that works well for
the application).  The processes for creating and processing the Welcome are the
same in all cases, aside from the set of new members for whom a given Welcome is
encrypted.</t>
            <t>The Welcome message provides the new
members with the current state of the group after the application of the Commit
message.  The new members will not be able to decrypt or verify the Commit
message, but they will have the secrets they need to participate in the epoch
initiated by the Commit message.</t>
            <t>In order to allow the same Welcome message to be sent to multiple new members,
information describing the group is encrypted with a symmetric key and nonce
derived from the <tt>joiner_secret</tt> for the new epoch.  The <tt>joiner_secret</tt> is
then encrypted to each new member using HPKE.  In the same encrypted package,
the committer transmits the path secret for the lowest (closest to the leaf) node
that is contained in the direct paths of both the committer and the new member.
This allows the new
member to compute private keys for nodes in its direct path that are being
reset by the corresponding Commit.</t>
            <t>If the sender of the Welcome message wants the receiving member to include a PSK
in the derivation of the <tt>epoch_secret</tt>, they can populate the <tt>psks</tt> field
indicating which PSK to use.</t>
            <sourcecode type="tls-presentation">
struct {
  opaque path_secret&lt;V&gt;;
} PathSecret;

struct {
  opaque joiner_secret&lt;V&gt;;
  optional&lt;PathSecret&gt; path_secret;
  PreSharedKeyID psks&lt;V&gt;;
} GroupSecrets;

struct {
  KeyPackageRef new_member;
  HPKECiphertext encrypted_group_secrets;
} EncryptedGroupSecrets;

struct {
  CipherSuite cipher_suite;
  EncryptedGroupSecrets secrets&lt;V&gt;;
  opaque encrypted_group_info&lt;V&gt;;
} Welcome;
</sourcecode>
            <t>The client processing a Welcome message will need to have a copy of the group's
ratchet tree.  The tree can be provided in the Welcome message, in an extension
of type <tt>ratchet_tree</tt>.  If it is sent otherwise (e.g., provided by a caching
service on the Delivery Service), then the client <bcp14>MUST</bcp14> download the tree before
processing the Welcome.</t>
            <t>On receiving a Welcome message, a client processes it using the following steps:</t>
            <ul spacing="normal">
              <li>Identify an entry in the <tt>secrets</tt> array where the <tt>new_member</tt>
value corresponds to one of this client's KeyPackages, using the hash
indicated by the <tt>cipher_suite</tt> field. If no such field exists, or if the
cipher suite indicated in the KeyPackage does not match the one in the
Welcome message, return an error.</li>
              <li>Decrypt the <tt>encrypted_group_secrets</tt> value with the algorithms indicated by
the cipher suite and the private key <tt>init_key_priv</tt> corresponding to
<tt>init_key</tt> in the referenced KeyPackage.</li>
            </ul>
            <sourcecode type="pseudocode">
encrypted_group_secrets =
  EncryptWithLabel(init_key, "Welcome",
                   encrypted_group_info, group_secrets)

group_secrets =
  DecryptWithLabel(init_key_priv, "Welcome",
                   encrypted_group_info, kem_output, ciphertext)
</sourcecode>
            <ul spacing="normal">
              <li>If a PreSharedKeyID is part of the GroupSecrets and the client is not in
possession of the corresponding PSK, return an error. Additionally, if a
PreSharedKeyID has type <tt>resumption</tt> with usage <tt>reinit</tt> or <tt>branch</tt>, verify
that it is the only such PSK.</li>
              <li>From the <tt>joiner_secret</tt> in the decrypted GroupSecrets object and the PSKs
specified in the GroupSecrets, derive the <tt>welcome_secret</tt> and then
the <tt>welcome_key</tt> and <tt>welcome_nonce</tt>. Use the key and nonce to decrypt the
<tt>encrypted_group_info</tt> field.</li>
            </ul>
            <sourcecode type="pseudocode">
welcome_nonce = ExpandWithLabel(welcome_secret, "nonce", "", AEAD.Nn)
welcome_key = ExpandWithLabel(welcome_secret, "key", "", AEAD.Nk)
</sourcecode>
            <ul spacing="normal">
              <li>Verify the signature on the GroupInfo object. The signature input comprises
all of the fields in the GroupInfo object except the signature field. The
public key is taken from the LeafNode of the
ratchet tree with leaf index <tt>signer</tt>. If the node is blank or if
signature verification fails, return an error.</li>
              <li>Verify that the <tt>group_id</tt> is unique among the groups that the client is
currently participating in.</li>
              <li>Verify that the <tt>cipher_suite</tt> in the GroupInfo matches the <tt>cipher_suite</tt> in
the KeyPackage.</li>
              <li>
                <t>Verify the integrity of the ratchet tree.  </t>
                <ul spacing="normal">
                  <li>Verify that the tree hash of the ratchet tree matches the <tt>tree_hash</tt> field
in GroupInfo.</li>
                  <li>For each non-empty parent node, verify that it is "parent-hash valid",
as described in <xref target="verifying-parent-hashes"/>.</li>
                  <li>For each non-empty leaf node, validate the LeafNode as described in
<xref target="leaf-node-validation"/>.</li>
                  <li>
                    <t>For each non-empty parent node and each entry in the node's
<tt>unmerged_leaves</tt> field:      </t>
                    <ul spacing="normal">
                      <li>Verify that the entry represents a non-blank leaf node that is a
descendant of the parent node.</li>
                      <li>Verify that every non-blank intermediate node between the leaf node and the
parent node also has an entry for the leaf node in its <tt>unmerged_leaves</tt>.</li>
                      <li>Verify that the encryption key in the parent node does not appear in any
other node of the tree.</li>
                    </ul>
                  </li>
                </ul>
              </li>
              <li>Identify a leaf whose LeafNode is
identical to the one in the KeyPackage.  If no such field exists, return an
error.  Let <tt>my_leaf</tt> represent this leaf in the tree.</li>
              <li>
                <t>Construct a new group state using the information in the GroupInfo object.  </t>
                <ul spacing="normal">
                  <li>Initialize the GroupContext for the group from the <tt>group_context</tt> field
from the GroupInfo object.</li>
                  <li>Update the leaf <tt>my_leaf</tt> with the private key corresponding to the
public key in the node, where <tt>my_leaf</tt> is the new member's leaf node in
the ratchet tree, as defined above.</li>
                  <li>If the <tt>path_secret</tt> value is set in the GroupSecrets object: Identify the
lowest common ancestor of the leaf node <tt>my_leaf</tt> and of the node of
the member with leaf index <tt>GroupInfo.signer</tt>. Set the private key for
this node to the private key derived from the <tt>path_secret</tt>.</li>
                  <li>For each parent of the common ancestor, up to the root of the tree, derive
a new path secret, and set the private key for the node to the private key
derived from the path secret.  The private key <bcp14>MUST</bcp14> be the private key
that corresponds to the public key in the node.</li>
                </ul>
              </li>
              <li>Use the <tt>joiner_secret</tt> from the GroupSecrets object to generate the epoch secret
and other derived secrets for the current epoch.</li>
              <li>Set the confirmed transcript hash in the new state to the value of the
<tt>confirmed_transcript_hash</tt> in the GroupInfo.</li>
              <li>Verify the confirmation tag in the GroupInfo using the derived confirmation
key and the <tt>confirmed_transcript_hash</tt> from the GroupInfo.</li>
              <li>Use the confirmed transcript hash and confirmation tag to compute the interim
transcript hash in the new state.</li>
              <li>
                <t>If a PreSharedKeyID was used that has type <tt>resumption</tt> with usage <tt>reinit</tt>
or <tt>branch</tt>, verify that the <tt>epoch</tt> field in the GroupInfo is equal to 1.  </t>
                <ul spacing="normal">
                  <li>For usage <tt>reinit</tt>, verify that the last Commit to the referenced group
contains a ReInit proposal and that the <tt>group_id</tt>, <tt>version</tt>,
<tt>cipher_suite</tt>, and <tt>group_context.extensions</tt> fields of the GroupInfo match
the ReInit proposal. Additionally, verify that all the members of the old
group are also members of the new group, according to the application.</li>
                  <li>For usage <tt>branch</tt>, verify that the <tt>version</tt> and <tt>cipher_suite</tt> of the new
group match those of the old group, and that the members of the new group
compose a subset of the members of the old group, according to the
application.</li>
                </ul>
              </li>
            </ul>
          </section>
          <section anchor="joining-via-external-commits">
            <name>Joining via External Commits</name>
            <t>External Commits are a mechanism for new members (external parties that want to
become members of the group) to add themselves to a group, without requiring
that an existing member has to come online to issue a Commit that references an
Add proposal.</t>
            <t>Whether existing members of the group will accept or reject an external Commit
follows the same rules that are applied to other handshake messages.</t>
            <t>New members can create and issue an external Commit if they have access to the
following information for the group's current epoch:</t>
            <ul spacing="normal">
              <li>group ID</li>
              <li>epoch ID</li>
              <li>cipher suite</li>
              <li>public tree hash</li>
              <li>confirmed transcript hash</li>
              <li>confirmation tag of the most recent Commit</li>
              <li>group extensions</li>
              <li>external public key</li>
            </ul>
            <t>In other words, to join a group via an external Commit, a new member needs a
GroupInfo with an <tt>external_pub</tt> extension present in its <tt>extensions</tt> field.</t>
            <sourcecode type="tls-presentation">
struct {
    HPKEPublicKey external_pub;
} ExternalPub;
</sourcecode>
            <t>Thus, a member of the group can enable new clients to join by making a GroupInfo
object available to them. Note that because a GroupInfo object is specific to an
epoch, it will need to be updated as the group advances. In particular, each
GroupInfo object can be used for one external join, since that external join
will cause the epoch to change.</t>
            <t>Note that the <tt>tree_hash</tt> field is used the same way as in the Welcome message.
The full tree can be included via the <tt>ratchet_tree</tt> extension
(see <xref target="ratchet-tree-extension"/>).</t>
            <t>The information in a GroupInfo is not generally public information, but applications
can choose to make it available to new members in order to allow External
Commits.</t>
            <t>In principle, external Commits work like regular Commits. However, their content
has to meet a specific set of requirements:</t>
            <ul spacing="normal">
              <li>External Commits <bcp14>MUST</bcp14> contain a <tt>path</tt> field (and is therefore a "full"
Commit).  The joiner is added at the leftmost free leaf node (just as if they
were added with an Add proposal), and the path is calculated relative to that
leaf node.</li>
              <li>The Commit <bcp14>MUST NOT</bcp14> include any proposals by reference, since an external
joiner cannot determine the validity of proposals sent within the group.</li>
              <li>External Commits <bcp14>MUST</bcp14> be signed by the new member.  In particular, the
signature on the enclosing AuthenticatedContent <bcp14>MUST</bcp14> verify using the public key for
the credential in the <tt>leaf_node</tt> of the <tt>path</tt> field.</li>
              <li>When processing a Commit, both existing and new members <bcp14>MUST</bcp14> use the external
init secret as described in <xref target="external-initialization"/>.</li>
              <li>The sender type for the AuthenticatedContent encapsulating the external Commit <bcp14>MUST</bcp14> be
<tt>new_member_commit</tt>.</li>
            </ul>
            <t>External Commits come in two "flavors" -- a "join" Commit that
adds the sender to the group or a "resync" Commit that replaces a member's prior
appearance with a new one.</t>
            <t>Note that the "resync" operation allows an attacker that has compromised a
member's signature private key to introduce themselves into the group and remove the
prior, legitimate member in a single Commit.  Without resync, this
can still be done, but it requires two operations: the external Commit to join and
a second Commit to remove the old appearance.  Applications for whom this
distinction is salient can choose to disallow external commits that contain a
Remove, or to allow such resync commits only if they contain a "reinit" PSK
proposal that demonstrates the joining member's presence in a prior epoch of the
group.  With the latter approach, the attacker would need to compromise the PSK
as well as the signing key, but the application will need to ensure that
continuing, non-resynchronizing members have the required PSK.</t>
          </section>
          <section anchor="ratchet-tree-extension">
            <name>Ratchet Tree Extension</name>
            <t>By default, a GroupInfo message only provides the joiner with a hash of
the group's ratchet tree.  In order to process or generate handshake
messages, the joiner will need to get a copy of the ratchet tree from some other
source.  (For example, the DS might provide a cached copy.)  The inclusion of
the tree hash in the GroupInfo message means that the source of the ratchet
tree need not be trusted to maintain the integrity of the tree.</t>
            <t>In cases where the application does not wish to provide such an external source,
the whole public state of the ratchet tree can be provided in an extension of
type <tt>ratchet_tree</tt>, containing a <tt>ratchet_tree</tt> object of the following form:</t>
            <sourcecode type="tls-presentation">
struct {
    NodeType node_type;
    select (Node.node_type) {
        case leaf:   LeafNode leaf_node;
        case parent: ParentNode parent_node;
    };
} Node;

optional&lt;Node&gt; ratchet_tree&lt;V&gt;;
</sourcecode>
            <t>Each entry in the <tt>ratchet_tree</tt> vector provides the value for a node in the
tree, or the null optional for a blank node.</t>
            <t>The nodes are listed in the order specified by a left-to-right in-order
traversal of the ratchet tree. Each node is listed between its left subtree and
its right subtree.  (This is the same ordering as specified for the array-based
trees outlined in <xref target="array-based-trees"/>.)</t>
            <t>If the tree has 2<sup>d</sup> leaves, then it has 2<sup>d+1</sup> - 1 nodes.  The
<tt>ratchet_tree</tt> vector logically has this number of entries, but the sender
<bcp14>MUST NOT</bcp14> include blank nodes after the last non-blank node.  The receiver <bcp14>MUST</bcp14>
check that the last node in <tt>ratchet_tree</tt> is non-blank, and then extend the tree to the
right until it has a length of the form 2<sup>d+1</sup> - 1, adding the minimum number
of blank values possible.  (Obviously, this may be done "virtually", by
synthesizing blank nodes when required, as opposed to actually changing the
structure in memory.)</t>
            <t>The leaves of the tree are stored in even-numbered entries in the array (the
leaf with index <tt>L</tt> in array position <tt>2*L</tt>). The root node of the tree is at
position 2<sup>d</sup> - 1 of the array. Intermediate parent nodes can be identified by
performing the same calculation to the subarrays to the left and right of the
root, following something like the following algorithm:</t>
            <sourcecode type="python">
# Assuming a class Node that has left and right members
def subtree_root(nodes):
    # If there is only one node in the array, return it
    if len(nodes) == 1:
        return Node(nodes[0])

    # Otherwise, the length of the array MUST be odd
    if len(nodes) % 2 == 0:
        raise Exception("Malformed node array {}", len(nodes))

    # Identify the root of the subtree
    d = 0
    while (2**(d+1)) &lt; len(nodes):
       d += 1
    R = 2**d - 1
    root = Node(nodes[R])
    root.left = subtree_root(nodes[:R])
    root.right = subtree_root(nodes[(R+1):])
    return root
</sourcecode>
            <t>(Note that this is the same ordering of nodes as in the array-based tree representation
described in <xref target="array-based-trees"/>.  The algorithms in that section may be used to
simplify decoding this extension into other representations.)</t>
            <t>For example, the following tree with six non-blank leaves would be represented
as an array of eleven elements, <tt>[A, W, B, X, C, _, D, Y, E, Z, F]</tt>.  The above
decoding procedure would identify the subtree roots as follows (using R to
represent a subtree root):</t>
            <figure>
              <name>Left-to-Right In-Order Traversal of a Six-Member Tree</name>
              <artset>
                <artwork type="svg">
                  <svg xmlns="http://www.w3.org/2000/svg" class="diagram" font-family="monospace" font-size="13px" height="304" text-anchor="middle" version="1.1" viewBox="0 0 240 304" width="240">
                    <path d="M 56,112 L 56,128" fill="none" stroke="black"/>
                    <path d="M 120,48 L 120,64" fill="none" stroke="black"/>
                    <path d="M 184,104 L 184,128" fill="none" stroke="black"/>
                    <path d="M 72,64 L 168,64" fill="none" stroke="black"/>
                    <path d="M 40,128 L 72,128" fill="none" stroke="black"/>
                    <path d="M 168,128 L 200,128" fill="none" stroke="black"/>
                    <path d="M 8,256 L 104,256" fill="none" stroke="black"/>
                    <path d="M 136,256 L 232,256" fill="none" stroke="black"/>
                    <path d="M 8,272 L 40,272" fill="none" stroke="black"/>
                    <path d="M 72,272 L 104,272" fill="none" stroke="black"/>
                    <path d="M 136,272 L 168,272" fill="none" stroke="black"/>
                    <path d="M 200,272 L 232,272" fill="none" stroke="black"/>
                    <path d="M 72,128 L 80,144" fill="none" stroke="black"/>
                    <path d="M 92,168 L 96,176" fill="none" stroke="black"/>
                    <path d="M 168,64 L 176,80" fill="none" stroke="black"/>
                    <path d="M 200,128 L 208,144" fill="none" stroke="black"/>
                    <path d="M 220,168 L 224,176" fill="none" stroke="black"/>
                    <path d="M 32,144 L 40,128" fill="none" stroke="black"/>
                    <path d="M 64,80 L 72,64" fill="none" stroke="black"/>
                    <path d="M 80,176 L 84,168" fill="none" stroke="black"/>
                    <path d="M 160,144 L 168,128" fill="none" stroke="black"/>
                    <path d="M 208,176 L 212,168" fill="none" stroke="black"/>
                    <polygon class="arrowhead" fill="black" points="240,272 228,266.4 228,277.6" transform="rotate(0,232,272)"/>
                    <polygon class="arrowhead" fill="black" points="240,256 228,250.4 228,261.6" transform="rotate(0,232,256)"/>
                    <polygon class="arrowhead" fill="black" points="208,272 196,266.4 196,277.6" transform="rotate(180,200,272)"/>
                    <polygon class="arrowhead" fill="black" points="176,272 164,266.4 164,277.6" transform="rotate(0,168,272)"/>
                    <polygon class="arrowhead" fill="black" points="144,272 132,266.4 132,277.6" transform="rotate(180,136,272)"/>
                    <polygon class="arrowhead" fill="black" points="144,256 132,250.4 132,261.6" transform="rotate(180,136,256)"/>
                    <polygon class="arrowhead" fill="black" points="112,272 100,266.4 100,277.6" transform="rotate(0,104,272)"/>
                    <polygon class="arrowhead" fill="black" points="112,256 100,250.4 100,261.6" transform="rotate(0,104,256)"/>
                    <polygon class="arrowhead" fill="black" points="80,272 68,266.4 68,277.6" transform="rotate(180,72,272)"/>
                    <polygon class="arrowhead" fill="black" points="48,272 36,266.4 36,277.6" transform="rotate(0,40,272)"/>
                    <polygon class="arrowhead" fill="black" points="16,272 4,266.4 4,277.6" transform="rotate(180,8,272)"/>
                    <polygon class="arrowhead" fill="black" points="16,256 4,250.4 4,261.6" transform="rotate(180,8,256)"/>
                    <g class="text">
                      <text x="120" y="36">Y</text>
                      <text x="56" y="100">X</text>
                      <text x="184" y="100">_</text>
                      <text x="24" y="164">W</text>
                      <text x="88" y="164">_</text>
                      <text x="152" y="164">Z</text>
                      <text x="216" y="164">_</text>
                      <text x="16" y="180">/</text>
                      <text x="32" y="180">\</text>
                      <text x="144" y="180">/</text>
                      <text x="160" y="180">\</text>
                      <text x="8" y="196">A</text>
                      <text x="40" y="196">B</text>
                      <text x="72" y="196">C</text>
                      <text x="104" y="196">D</text>
                      <text x="136" y="196">E</text>
                      <text x="168" y="196">F</text>
                      <text x="200" y="196">_</text>
                      <text x="232" y="196">_</text>
                      <text x="168" y="228">1</text>
                      <text x="8" y="244">0</text>
                      <text x="24" y="244">1</text>
                      <text x="40" y="244">2</text>
                      <text x="56" y="244">3</text>
                      <text x="72" y="244">4</text>
                      <text x="88" y="244">5</text>
                      <text x="104" y="244">6</text>
                      <text x="120" y="244">7</text>
                      <text x="136" y="244">8</text>
                      <text x="152" y="244">9</text>
                      <text x="168" y="244">0</text>
                      <text x="120" y="260">R</text>
                      <text x="56" y="276">R</text>
                      <text x="184" y="276">R</text>
                      <text x="8" y="292">-</text>
                      <text x="24" y="292">R</text>
                      <text x="40" y="292">-</text>
                      <text x="72" y="292">-</text>
                      <text x="88" y="292">R</text>
                      <text x="104" y="292">-</text>
                      <text x="136" y="292">-</text>
                      <text x="152" y="292">R</text>
                      <text x="168" y="292">-</text>
                      <text x="200" y="292">-</text>
                      <text x="216" y="292">R</text>
                      <text x="232" y="292">-</text>
                    </g>
                  </svg>
                </artwork>
                <artwork type="ascii-art">
              Y
              |
        .-----+-----.
       /             \
      X               _
      |               |
    .-+-.           .-+-.
   /     \         /     \
  W       _       Z       _
 / \     / \     / \     / \
A   B   C   D   E   F   _   _

                    1
0 1 2 3 4 5 6 7 8 9 0
&lt;-----------&gt; R &lt;-----------&gt;
&lt;---&gt; R &lt;---&gt;   &lt;---&gt; R &lt;---&gt;
- R -   - R -   - R -   - R -
</artwork>
              </artset>
            </figure>
            <t>The presence of a <tt>ratchet_tree</tt> extension in a GroupInfo message does not
result in any changes to the GroupContext extensions for the group.  The ratchet
tree provided is simply stored by the client and used for MLS operations.</t>
            <t>If this extension is not provided in a Welcome message, then the client will
need to fetch the ratchet tree over some other channel before it can generate or
process Commit messages.  Applications should ensure that this out-of-band
channel is provided with security protections equivalent to the protections that
are afforded to Proposal and Commit messages.  For example, an application that
encrypts Proposal and Commit messages might distribute ratchet trees encrypted
using a key exchanged over the MLS channel.</t>
            <t>Regardless of how the client obtains the tree, the client <bcp14>MUST</bcp14> verify that the
root hash of the ratchet tree matches the <tt>tree_hash</tt> of the GroupContext before
using the tree for MLS operations.</t>
          </section>
        </section>
      </section>
    </section>
    <section anchor="extensibility">
      <name>Extensibility</name>
      <t>The base MLS protocol can be extended in a few ways.  New cipher suites can be
added to enable the use of new cryptographic algorithms.  New types of proposals
can be used to perform new actions within an epoch.  Extension fields can be
used to add additional information to the protocol.  In this section, we discuss
some constraints on these extensibility mechanisms that are necessary to ensure
broad interoperability.</t>
      <section anchor="additional-cipher-suites">
        <name>Additional Cipher Suites</name>
        <t>As discussed in <xref target="cipher-suites"/>, MLS allows the participants in a group to
negotiate the cryptographic algorithms used within the group.  This
extensibility is important for maintaining the security of the protocol over
time <xref target="RFC7696"/>.  It also creates a risk of interoperability failure due to
clients not supporting a common cipher suite.</t>
        <t>The cipher suite registry defined in <xref target="mls-cipher-suites"/> attempts to strike a
balance on this point.  On the one hand, the base policy for the registry is
Specification Required, a fairly low bar designed to avoid the need for
standards work in cases where different ciphers are needed for niche
applications.  On the other hand, there is a higher bar (Standards Action) for ciphers to set the
Recommended field in the registry.  This higher bar is there in part to ensure
that the interoperability implications of new cipher suites are considered.</t>
        <t>MLS cipher suites are defined independent of MLS versions, so that in principle,
the same cipher suite can be used across versions.  Standards work defining new
versions of MLS should consider whether it is desirable for the new version to
be compatible with existing cipher suites, or whether the new version should rule
out some cipher suites. For example, a new version could follow the example of
HTTP/2, which restricted the set of allowed TLS ciphers (see <xref section="9.2.2" sectionFormat="of" target="RFC9113"/>).</t>
      </section>
      <section anchor="proposals-1">
        <name>Proposals</name>
        <t>Commit messages do not have an extension field because the set of proposals is
extensible.  As discussed in <xref target="commit"/>, Proposals with a non-default proposal
type <bcp14>MUST NOT</bcp14> be included in a commit unless the proposal type is supported by
all the members of the group that will process the Commit.</t>
      </section>
      <section anchor="credential-extensibility">
        <name>Credential Extensibility</name>
        <t>In order to ensure that MLS provides meaningful authentication, it is important
that each member is able to authenticate some identity information for each
other member.  Identity information is encoded in Credentials, so this property
is provided by ensuring that members use compatible credential types.</t>
        <t>The only types of credential that may be used in a group are those that all
members of the group support, as specified by the <tt>capabilities</tt> field of each
LeafNode in the ratchet tree. An application can introduce new credential types
by choosing an unallocated identifier from the registry in
<xref target="mls-credential-types"/> and indicating support for the credential type in
published LeafNodes, whether in Update proposals to existing groups or
KeyPackages that are added to new groups. Once all members in a group indicate
support for the credential type, members can start using LeafNodes with the new
credential. Application may enforce that certain credential types always remain
supported by adding a <tt>required_capabilities</tt> extension to the group's
GroupContext, which would prevent any member from being added to the group that
doesn't support them.</t>
        <t>In future extensions to MLS, it may be useful to allow a member to present more
than one credential.  For example, such credentials might present different
attributes attested by different authorities.  To be consistent with the general
principle stated at the beginning of this section, such an extension would need
to ensure that each member can authenticate some identity for each other member.
For each pair of members (Alice, Bob), Alice would need to present at least one
credential of a type that Bob supports.</t>
      </section>
      <section anchor="extensions">
        <name>Extensions</name>
        <t>This protocol includes a mechanism for negotiating extension parameters similar
to the one in TLS <xref target="RFC8446"/>.  In TLS, extension negotiation is one-to-one: The
client offers extensions in its ClientHello message, and the server expresses
its choices for the session with extensions in its ServerHello and
EncryptedExtensions messages.  In MLS, extensions appear in the following
places:</t>
        <ul spacing="normal">
          <li>In KeyPackages, to describe additional information related to the client</li>
          <li>In LeafNodes, to describe additional information about the client or its
participation in the group (once in the ratchet tree)</li>
          <li>In the GroupInfo, to tell new members of a group what parameters are
being used by the group, and to provide any additional details required to
join the group</li>
          <li>In the GroupContext object, to ensure that all members of the group have the
same view of the parameters in use</li>
        </ul>
        <t>In other words, an application can use GroupContext extensions to ensure that
all members of the group agree on a set of parameters. Clients indicate their
support for parameters in the <tt>capabilities</tt> field of their LeafNode. New
members of a group are informed of the group's GroupContext extensions via the
<tt>extensions</tt> field in the <tt>group_context</tt> field of the GroupInfo object. The
<tt>extensions</tt> field in a GroupInfo object (outside of the <tt>group_context</tt> field)
can be used to provide additional parameters to new joiners that are used to
join the group.</t>
        <t>This extension mechanism is designed to allow for the secure and forward-compatible
negotiation of extensions.  For this to work, implementations <bcp14>MUST</bcp14> correctly
handle extensible fields:</t>
        <ul spacing="normal">
          <li>A client that posts a KeyPackage <bcp14>MUST</bcp14> support all parameters advertised in
it. Otherwise, another client might fail to interoperate by selecting one of
those parameters.</li>
          <li>A client processing a KeyPackage object <bcp14>MUST</bcp14> ignore all unrecognized values
in the <tt>capabilities</tt> field of the LeafNode and all unknown extensions in
the <tt>extensions</tt> and <tt>leaf_node.extensions</tt> fields.  Otherwise, it could fail
to interoperate with newer clients.</li>
          <li>A client processing a GroupInfo object <bcp14>MUST</bcp14> ignore all unrecognized
extensions in the <tt>extensions</tt> field.</li>
          <li>Any field containing a list of extensions <bcp14>MUST NOT</bcp14> have more than one
extension of any given type.</li>
          <li>A client adding a new member to a group <bcp14>MUST</bcp14> verify that the LeafNode for the
new member is compatible with the group's extensions.  The <tt>capabilities</tt>
field <bcp14>MUST</bcp14> indicate support for each extension in the GroupContext.</li>
          <li>A client joining a group <bcp14>MUST</bcp14> verify that it supports every extension in the
GroupContext for the group.  Otherwise, it <bcp14>MUST</bcp14> treat the enclosing
GroupInfo message as invalid and not join the group.</li>
        </ul>
        <t>Note that the latter two requirements mean that all MLS GroupContext extensions
are mandatory, in the sense that an extension in use by the group <bcp14>MUST</bcp14> be
supported by all members of the group.</t>
        <t>The parameters of a group may be changed by sending a GroupContextExtensions
proposal to enable additional extensions (<xref target="groupcontextextensions"/>), or
by reinitializing the group (<xref target="reinitialization"/>).</t>
      </section>
      <section anchor="grease">
        <name>GREASE</name>
        <t>As described in <xref target="extensions"/>, clients are required to ignore unknown values
for certain parameters.  To help ensure that other clients implement this
behavior, a client can follow the "Generate Random Extensions And Sustain
Extensibility" or GREASE approach described in <xref target="RFC8701"/>.  In the context of
MLS, this means that a client generating a KeyPackage, LeafNode, or GroupInfo object includes
random values in certain fields which would be ignored by a
correctly implemented client processing the message.  A client that incorrectly
rejects unknown code points will fail to process such a message, providing a
signal to its implementer that the client needs to be fixed.</t>
        <t>When generating the following fields, an MLS client <bcp14>SHOULD</bcp14> include a random
selection of values chosen from these GREASE values:</t>
        <ul spacing="normal">
          <li>
            <tt>LeafNode.capabilities.cipher_suites</tt>
          </li>
          <li>
            <tt>LeafNode.capabilities.extensions</tt>
          </li>
          <li>
            <tt>LeafNode.capabilities.proposals</tt>
          </li>
          <li>
            <tt>LeafNode.capabilities.credentials</tt>
          </li>
          <li>
            <tt>LeafNode.extensions</tt>
          </li>
          <li>
            <tt>KeyPackage.extensions</tt>
          </li>
          <li>
            <tt>GroupInfo.extensions</tt>
          </li>
        </ul>
        <t>For the KeyPackage and GroupInfo extensions, the <tt>extension_data</tt> for GREASE
extensions <bcp14>MAY</bcp14> have any contents selected by the sender, since they will be
ignored by a correctly implemented receiver.  For example, a sender might
populate these extensions with a randomly sized amount of random data.</t>
        <t>Note that any GREASE values added to <tt>LeafNode.extensions</tt> need to be reflected
in <tt>LeafNode.capabilities.extensions</tt>, since the LeafNode validation process
described in <xref target="leaf-node-validation"/> requires that these two fields be
consistent.</t>
        <t>GREASE values <bcp14>MUST NOT</bcp14> be sent in the following fields, because an unsupported
value in one these fields (including a GREASE value) will cause the enclosing
message to be rejected:</t>
        <ul spacing="normal">
          <li>
            <tt>Proposal.proposal_type</tt>
          </li>
          <li>
            <tt>Credential.credential_type</tt>
          </li>
          <li>
            <tt>GroupContext.extensions</tt>
          </li>
          <li>
            <tt>GroupContextExtensions.extensions</tt>
          </li>
        </ul>
        <t>Values reserved for GREASE have been registered in the various
registries in <xref target="iana-considerations"/>.  This prevents conflict between GREASE
and real future values.  The following values are reserved in each registry:
<tt>0x0A0A</tt>, <tt>0x1A1A</tt>, <tt>0x2A2A</tt>, <tt>0x3A3A</tt>, <tt>0x4A4A</tt>, <tt>0x5A5A</tt>, <tt>0x6A6A</tt>, <tt>0x7A7A</tt>,
<tt>0x8A8A</tt>, <tt>0x9A9A</tt>, <tt>0xAAAA</tt>, <tt>0xBABA</tt>, <tt>0xCACA</tt>, <tt>0xDADA</tt>, and <tt>0xEAEA</tt>.  (The
value <tt>0xFAFA</tt> falls within the private use range.) These values <bcp14>MUST</bcp14> only
appear in the fields listed above, and not, for example, in the <tt>proposal_type</tt>
field of a Proposal.  Clients <bcp14>MUST NOT</bcp14> implement any special processing rules
for how to handle these values when receiving them, since this negates their
utility for detecting extensibility failures.</t>
        <t>GREASE values <bcp14>MUST</bcp14> be handled using normal logic for processing unsupported
values.  When comparing lists of capabilities to identify mutually supported
capabilities, clients <bcp14>MUST</bcp14> represent their own capabilities with a list
containing only the capabilities actually supported, without any GREASE values.
In other words, lists including GREASE values are only sent to other clients;
representations of a client's own capabilities <bcp14>MUST NOT</bcp14> contain GREASE values.</t>
      </section>
    </section>
    <section anchor="sequencing">
      <name>Sequencing of State Changes</name>
      <t>Each Commit message is premised on a given starting state,
indicated by the <tt>epoch</tt> field of the enclosing FramedContent.
If the changes implied by a Commit message are made
starting from a different state, the results will be incorrect.</t>
      <t>This need for sequencing is not a problem as long as each time a
group member sends a Commit message, it is based on the most
current state of the group.  In practice, however, there is a risk
that two members will generate Commit messages simultaneously
based on the same state.</t>
      <t>Applications <bcp14>MUST</bcp14> have an established way to resolve conflicting Commit messages
for the same epoch. They can do this either by preventing conflicting messages
from occurring in the first place, or by developing rules for deciding which
Commit out of several sent in an epoch will be canonical. The approach chosen
<bcp14>MUST</bcp14> minimize the amount of time that forked or previous group states are kept
in memory, and promptly delete them once they're no longer necessary to ensure
forward secrecy.</t>
      <t>The generation of Commit messages <bcp14>MUST NOT</bcp14> modify a client's state, since the
client doesn't know at that time whether the changes implied by the Commit
message will conflict with another Commit or not. Similarly, the Welcome
message corresponding to a Commit <bcp14>MUST NOT</bcp14> be delivered to a new
joiner until it's clear that the Commit has been accepted.</t>
      <t>Regardless of how messages are kept in sequence, there is a risk that
in a sufficiently busy group, a given member may never
be able to send a Commit message because they always lose to other
members. The degree to which this is a practical problem will depend
on the dynamics of the application.</t>
    </section>
    <section anchor="application-messages">
      <name>Application Messages</name>
      <t>The primary purpose of handshake messages is to provide an authenticated group
key exchange to clients. In order to protect application messages sent among the
members of a group, the <tt>encryption_secret</tt> provided by the key schedule is used
to derive a sequence of nonces and keys for message encryption. Every epoch
moves the key schedule forward, which triggers the creation of a new secret
tree, as described in <xref target="secret-tree"/>, along with a new set of symmetric
ratchets of nonces and keys for each member.</t>
      <t>Each client maintains their own local copy of the key
schedule for each epoch during which they are a group member. They
derive new keys, nonces, and secrets as needed while deleting old
ones as soon as they have been used.</t>
      <t>The group identifier and epoch allow a recipient to know which group secrets
should be used and from which <tt>epoch_secret</tt> to start computing other secrets.
The sender identifier and content type are used to identify which
symmetric ratchet to use from the secret tree. The
<tt>generation</tt> counter determines how far into the ratchet to iterate in
order to produce the required nonce and key for encryption or decryption.</t>
      <section anchor="padding">
        <name>Padding</name>
        <t>Application messages <bcp14>MAY</bcp14> be padded to provide some resistance
against traffic analysis techniques over encrypted traffic
<xref target="CLINIC"/> <xref target="HCJ16"/>.
While MLS might deliver the same payload less frequently across
a lot of ciphertexts than traditional web servers, it might still provide
the attacker enough information to mount an attack. If Alice asks Bob
"When are we going to the movie?", then the answer "Wednesday" could be leaked
to an adversary solely by the ciphertext length.</t>
        <t>The length of the <tt>padding</tt> field in PrivateMessageContent can be
chosen by the sender at the time of message encryption. Senders may use padding
to reduce the ability of attackers outside the group to infer the size of the
encrypted content.  Note, however, that the transports used to carry MLS
messages may have maximum message sizes, so padding schemes <bcp14>SHOULD</bcp14> avoid
increasing message size beyond any such limits that exist in a given
deployment scenario.</t>
      </section>
      <section anchor="restrictions">
        <name>Restrictions</name>
        <t>During each epoch, senders <bcp14>MUST NOT</bcp14> encrypt more data than permitted by the
security bounds of the AEAD scheme used <xref target="I-D.irtf-cfrg-aead-limits"/>.</t>
        <t>Note that each change to the group through a handshake message will also set a
new <tt>encryption_secret</tt>. Hence this change <bcp14>MUST</bcp14> be applied before encrypting
any new application message. This is required both to ensure that any users
removed from the group can no longer receive messages and to (potentially)
recover confidentiality and authenticity for future messages despite a past
state compromise.</t>
      </section>
      <section anchor="delayed-and-reordered-application-messages">
        <name>Delayed and Reordered Application Messages</name>
        <t>Since each application message contains the group identifier, the epoch, and a
generation counter, a client can receive messages out of order. When messages
are received out of order, the client moves the sender ratchet forward to match
the received generation counter. Any unused nonce and key pairs from the ratchet
are potentially stored so that they can be used to decrypt the messages that
were delayed or reordered.</t>
        <t>Applications <bcp14>SHOULD</bcp14> define a policy on how long to keep unused nonce and key
pairs for a sender, and the maximum number to keep. This is in addition to
ensuring that these secrets are deleted according to the deletion schedule
defined in <xref target="deletion-schedule"/>. Applications <bcp14>SHOULD</bcp14> also define a policy
limiting the maximum number of steps that clients will move the ratchet forward
in response to a new message.  Messages received with a generation counter
that is too much higher than the last message received would then be rejected.
This avoids causing a denial-of-service attack by requiring the recipient to
perform an excessive number of key derivations. For example, a malicious group
member could send a message with <tt>generation = 0xffffffff</tt> at the beginning of a
new epoch, forcing recipients to perform billions of key derivations unless they
apply limits of the type discussed above.</t>
      </section>
    </section>
    <section anchor="security-considerations">
      <name>Security Considerations</name>
      <t>The security goals of MLS are described in <xref target="I-D.ietf-mls-architecture"/>.
We describe here how the protocol achieves its goals at a high level,
though a complete security analysis is outside of the scope of this
document.  The Security Considerations section of <xref target="I-D.ietf-mls-architecture"/>
provides some citations to detailed security analyses.</t>
      <section anchor="transport-security">
        <name>Transport Security</name>
        <t>Because MLS messages are protected at the message level, the
confidentiality and integrity of the group state do not depend on
those messages being protected in transit. However, an attacker who
can observe those messages in transit will be able to learn about the
group state, including potentially the group membership (see
<xref target="group-membership"/> below). Such an attacker might also be able to
mount denial-of-service attacks on the group or exclude new members by
selectively removing messages in transit. In order to prevent this
form of attack, it is <bcp14>RECOMMENDED</bcp14> that all MLS messages be carried
over a secure transport such as TLS <xref target="RFC8446"/> or QUIC <xref target="RFC9000"/>.</t>
      </section>
      <section anchor="confidentiality-of-group-secrets">
        <name>Confidentiality of Group Secrets</name>
        <t>Group secrets are partly derived from the output of a ratchet tree. Ratchet
trees work by assigning each member of the group to a leaf in the tree and
maintaining the following property: the private key of a node in the tree is
known only to members of the group that are assigned a leaf in the node's
subtree. This is called the <em>tree invariant</em>, and it makes it possible to
encrypt to all group members except one, with a number of ciphertexts that is
logarithmic in the number of group members.</t>
        <t>The ability to efficiently encrypt to all members except one allows members to
be securely removed from a group. It also allows a member to rotate their
key pair such that the old private key can no longer be used to decrypt new
messages.</t>
      </section>
      <section anchor="confidentiality-of-sender-data">
        <name>Confidentiality of Sender Data</name>
        <t>The PrivateMessage framing encrypts "sender data" that identifies which group
member sent an encrypted message, as described in <xref target="sender-data-encryption"/>.
As with the QUIC header protection scheme <xref section="5.4" sectionFormat="comma" target="RFC9001"/>, this scheme
is a variant of the HN1 construction analyzed in <xref target="NAN"/>.  A sample of the
ciphertext is combined with a <tt>sender_data_secret</tt> to derive a key and nonce
that are used for AEAD encryption of the sender data.</t>
        <sourcecode type="pseudocode">
(key, nonce) = PRF(sender_data_secret, sample)
encrypted_sender_data =
  AEAD.Seal(key, nonce, sender_data_aad, sender_data)
</sourcecode>
        <t>The only differences between this construction and HN1 as described in <xref target="NAN"/>
are that it (1) uses authenticated encryption instead of unauthenticated
encryption and (2) protects information used to derive a nonce instead of the
nonce itself.</t>
        <t>Since the <tt>sender_data_secret</tt> is distinct from the content encryption key, it
follows that the sender data encryption scheme achieves AE2 security as defined
in <xref target="NAN"/>, and therefore guarantees the confidentiality of the sender data.</t>
        <t>Use of the same <tt>sender_data_secret</tt> and ciphertext sample more than once risks
compromising sender data protection by reusing an AEAD (key, nonce) pair.  For
example, in many AEAD schemes, reusing a key and nonce reveals the exclusive OR
of the two plaintexts. Assuming the ciphertext output of the AEAD algorithm is
indistinguishable from random data (i.e., the AEAD is AE1-secure in the phrasing
of <xref target="NAN"/>), the odds of two ciphertext samples being identical is roughly
2<sup>-L/2</sup>, i.e., the birthday bound.</t>
        <t>The AEAD algorithms for cipher suites defined in this document all provide this
property. The size of the sample depends on the cipher suite's hash function, but
in all cases, the probability of collision is no more than 2<sup>-128</sup>.
Any future cipher suite <bcp14>MUST</bcp14> use an AE1-secure AEAD algorithm.</t>
      </section>
      <section anchor="confidentiality-of-group-metadata">
        <name>Confidentiality of Group Metadata</name>
        <t>MLS does not provide confidentiality protection to some messages and fields
within messages:</t>
        <ul spacing="normal">
          <li>KeyPackage messages</li>
          <li>GroupInfo messages</li>
          <li>The unencrypted portion of a Welcome message</li>
          <li>Any Proposal or Commit messages sent as PublicMessage messages</li>
          <li>The unencrypted header fields in PrivateMessage messages</li>
          <li>The lengths of encrypted Welcome and PrivateMessage messages</li>
        </ul>
        <t>The only mechanism MLS provides for confidentially distributing a group's
ratchet tree to new members is to send it in a Welcome message as a
<tt>ratchet_tree</tt> extension.  If an application distributes the tree in some other
way, its security will depend on that application mechanism.</t>
        <t>A party observing these fields might be able to infer certain properties of the
group:</t>
        <ul spacing="normal">
          <li>Group ID</li>
          <li>Current epoch and frequency of epoch changes</li>
          <li>Frequency of messages within an epoch</li>
          <li>Group extensions</li>
          <li>Group membership</li>
        </ul>
        <t>The amount of metadata exposed to parties outside the group, and thus the
ability of these parties to infer the group's properties, depends on several
aspects of the DS design, such as:</t>
        <ul spacing="normal">
          <li>How KeyPackages are distributed</li>
          <li>How the ratchet tree is distributed</li>
          <li>How prospective external joiners get a GroupInfo object for the group</li>
          <li>Whether Proposal and Commit messages are sent as PublicMessage or PrivateMessage</li>
        </ul>
        <t>In the remainder of this section, we note the ways that the above properties of
the group are reflected in unprotected group messages, as a guide to
understanding how they might be exposed or protected in a given application.</t>
        <section anchor="groupid-epoch-and-message-frequency">
          <name>GroupID, Epoch, and Message Frequency</name>
          <t>MLS provides no mechanism to protect the group ID and epoch of a message from
the DS, so the group ID and the frequency of messages and epoch changes are not
protected against inspection by the DS. However, any modifications to these
will cause decryption failure.</t>
        </section>
        <section anchor="group-extensions">
          <name>Group Extensions</name>
          <t>A group's extensions are first set by the group's creator and then updated by
GroupContextExtensions proposals.  A GroupContextExtensions proposal sent as
a PublicMessage leaks the group's extensions.</t>
          <t>A new member learns the group's extensions via a GroupInfo object.  When the new
member joins via a Welcome message, the Welcome message's encryption protects
the GroupInfo message.  When the new member joins via an external join, they
must be provided with a GroupInfo object.  Protection of this GroupInfo object
is up to the application -- if it is transmitted over a channel that is not
confidential to the group and the new joiner, then it will leak the group's
extensions.</t>
        </section>
        <section anchor="group-membership">
          <name>Group Membership</name>
          <t>The group's membership is represented directly by its ratchet tree, since each
member's LeafNode contains members' cryptographic keys, a credential that
contains information about the member's identity, and possibly other
identifiers.  Applications that expose the group's ratchet tree outside the
group also leak the group's membership.</t>
          <t>Changes to the group's membership are made by means of Add and Remove proposals.
If these proposals are sent as PublicMessage, then information will be leaked
about the corresponding changes to the group's membership.  A party that sees
all of these changes can reconstruct the group membership.</t>
          <t>Welcome messages contain a hash of each KeyPackage for which the Welcome message
is encrypted.  If a party has access to a pool of KeyPackages and observes a
Welcome message, then they can identify the KeyPackage representing the new
member.  If the party can also associate the Welcome with a group, then the
party can infer that the identified new member was added to that group.</t>
          <t>Note that these information leaks reveal the group's membership only to the degree
that membership is revealed by the contents of a member's LeafNode in the
ratchet tree.  In some cases, this may be quite direct, e.g., due to credentials
attesting to identifiers such as email addresses.  An application could
construct a member's leaf node to be less identifying, e.g., by using a
pseudonymous credential and frequently rotating encryption and signature keys.</t>
        </section>
      </section>
      <section anchor="authentication">
        <name>Authentication</name>
        <t>The first form of authentication we provide is that group members can verify a
message originated from one of the members of the group. For encrypted messages,
this is guaranteed because messages are encrypted with an AEAD under a key
derived from the group secrets. For plaintext messages, this is guaranteed by
the use of a <tt>membership_tag</tt>, which constitutes a MAC over the message, under a
key derived from the group secrets.</t>
        <t>The second form of authentication is that group members can verify a message
originated from a particular member of the group. This is guaranteed by a
digital signature on each message from the sender's signature key.</t>
        <t>The signature keys held by group members are critical to the security of MLS
against active attacks.  If a member's signature key is compromised, then an
attacker can create LeafNodes and KeyPackages impersonating the member; depending on the
application, this can then allow the attacker to join the group with the
compromised member's identity.  For example, if a group has enabled external
parties to join via external commits, then an attacker that has compromised a
member's signature key could use an external Commit to insert themselves into
the group -- even using a "resync"-style external Commit to replace the
compromised member in the group.</t>
        <t>Applications can mitigate the risks of signature key compromise using pre-shared
keys.  If a group requires joiners to know a PSK in addition to authenticating
with a credential, then in order to mount an impersonation attack, the attacker
would need to compromise the relevant PSK as well as the victim's signature key.
The cost of this mitigation is that the application needs some external
arrangement that ensures that the legitimate members of the group have the
required PSKs.</t>
      </section>
      <section anchor="forward-secrecy-and-post-compromise-security">
        <name>Forward Secrecy and Post-Compromise Security</name>
        <t>Forward secrecy and post-compromise security are important security notions for
long-lived MLS groups.  Forward secrecy means that messages sent at a certain
point in time are secure in the face of later compromise of a group member.
Post-compromise security means that messages are secure even if a group member
was compromised at some point in the past.</t>
        <figure>
          <name>Forward Secrecy and Post-Compromise Security</name>
          <artset>
            <artwork type="svg">
              <svg xmlns="http://www.w3.org/2000/svg" class="diagram" font-family="monospace" font-size="13px" height="176" text-anchor="middle" version="1.1" viewBox="0 0 448 176" width="448">
                <path d="M 152,80 L 152,160" fill="none" stroke="black"/>
                <path d="M 192,48 L 192,88" fill="none" stroke="black"/>
                <path d="M 232,80 L 232,160" fill="none" stroke="black"/>
                <path d="M 8,96 L 144,96" fill="none" stroke="black"/>
                <path d="M 160,96 L 224,96" fill="none" stroke="black"/>
                <path d="M 240,96 L 440,96" fill="none" stroke="black"/>
                <path d="M 8,128 L 144,128" fill="none" stroke="black"/>
                <path d="M 240,128 L 368,128" fill="none" stroke="black"/>
                <polygon class="arrowhead" fill="black" points="448,96 436,90.4 436,101.6" transform="rotate(0,440,96)"/>
                <polygon class="arrowhead" fill="black" points="376,128 364,122.4 364,133.6" transform="rotate(0,368,128)"/>
                <polygon class="arrowhead" fill="black" points="200,88 188,82.4 188,93.6" transform="rotate(90,192,88)"/>
                <polygon class="arrowhead" fill="black" points="16,128 4,122.4 4,133.6" transform="rotate(180,8,128)"/>
                <g class="text">
                  <text x="196" y="36">Compromise</text>
                  <text x="420" y="116">Time</text>
                  <text x="48" y="148">Forward</text>
                  <text x="112" y="148">Secrecy</text>
                  <text x="304" y="148">Post-Compromise</text>
                  <text x="292" y="164">Security</text>
                </g>
              </svg>
            </artwork>
            <artwork type="ascii-art">
                   Compromise
                       |
                       |
                  |    V    |
------------------|---------|-------------------------&gt;
                  |         |                     Time
&lt;-----------------|         |----------------&gt;
  Forward Secrecy |         | Post-Compromise
                  |         |   Security
</artwork>
          </artset>
        </figure>
        <t>Post-compromise security is provided between epochs by members
regularly updating their leaf key in the ratchet tree. Updating their
leaf key prevents group secrets from continuing to be encrypted to
public keys whose private keys had previously been compromised. Note
that sending an Update proposal does not achieve PCS until another
member includes it in a Commit. Members can achieve immediate PCS by
sending their own Commit and populating the <tt>path</tt> field, as described
in <xref target="commit"/>. To be clear, in all these cases, the PCS guarantees
come into effect when the members of the group process the relevant
Commit, not when the sender creates it.</t>
        <t>Forward secrecy between epochs is provided by deleting private keys from past
versions of the ratchet tree, as this prevents old group secrets from being
re-derived. Forward secrecy <em>within</em> an epoch is provided by deleting message
encryption keys once they've been used to encrypt or decrypt a message.
Note that group secrets and message encryption keys are shared by the
group.  There is thus a risk to forward secrecy as long as any
member has not deleted these keys. This is a particular risk if a member
is offline for a long period of time. Applications <bcp14>SHOULD</bcp14> have mechanisms
for evicting group members that are offline for too long (i.e., have
not changed their key within some period).</t>
        <t>New groups are also at risk of using previously compromised keys (as with
post-compromise security) if a member is added to a new group via an old
KeyPackage whose corresponding private key has been compromised.  This risk can
be mitigated by having clients regularly generate new KeyPackages and upload
them to the Delivery Service.  This way, the key material used to add a member
to a new group is more likely to be fresh and less likely to be compromised.</t>
      </section>
      <section anchor="uniqueness-of-ratchet-tree-key-pairs">
        <name>Uniqueness of Ratchet Tree Key Pairs</name>
        <t>The encryption and signature keys stored in the <tt>encryption_key</tt> and
<tt>signature_key</tt> fields of ratchet tree nodes <bcp14>MUST</bcp14> be distinct from one another.
If two members' leaf nodes have the same signature key, for example, then the
data origin authentication properties afforded by signatures within the group
are degraded.</t>
        <t>Uniqueness of keys in leaf nodes is assured by explicitly checking each leaf node
as it is added to the tree, whether in an Add proposal, in an Update proposal, or in the <tt>path</tt> field of a
Commit.  Details can be found in Sections <xref format="counter" target="leaf-node-validation"/>,
<xref format="counter" target="proposal-list-validation"/>, and <xref format="counter" target="processing-a-commit"/>.  Uniqueness of
encryption keys in parent nodes is assured by checking that the keys in an
UpdatePath are not found elsewhere in the tree (see <xref target="processing-a-commit"/>).</t>
      </section>
      <section anchor="keypackage-reuse">
        <name>KeyPackage Reuse</name>
        <t>KeyPackages are intended to be used only once.  That is, once a KeyPackage
has been used to introduce the corresponding client to a group, it <bcp14>SHOULD</bcp14> be
deleted from the KeyPackage publication system.  Reuse of KeyPackages can lead
to replay attacks.</t>
        <t>An application <bcp14>MAY</bcp14> allow for reuse of a "last resort" KeyPackage in order to
prevent denial-of-service attacks.  Since a KeyPackage is needed to add a
client to a new group, an attacker could prevent a client from being added to new
groups by exhausting all available KeyPackages. To prevent such a denial-of-service
attack, the KeyPackage publication system <bcp14>SHOULD</bcp14> rate-limit KeyPackage
requests, especially if not authenticated.</t>
      </section>
      <section anchor="delivery-service-compromise">
        <name>Delivery Service Compromise</name>
        <t>MLS is designed to protect the confidentiality and integrity of
the group data even in the face of a compromised DS. However, a compromised
DS can still mount some attacks. While it cannot forge messages,
it can selectively delay or remove them. In some cases, this can be
observed by detecting gaps in the per-sender generation counter,
though it may not always be possible to distinguish an attack from message
loss. In addition, the DS can permanently block messages to and from
a group member. This will not always be detectable by other members.
If an application uses the DS to resolve conflicts between
simultaneous Commits (see <xref target="sequencing"/>), it is also possible for the
DS to influence which Commit is applied, even to the point of
preventing a member from ever having its Commits applied.</t>
        <t>When put together, these abilities potentially allow a DS to collude
with an attacker who has compromised a member's state to defeat PCS by
suppressing the valid Update and Commit messages from the member that
would lock out the attacker and update the member's leaf to a new,
uncompromised state. Aside from the SenderData.generation value, MLS
leaves loss detection up to the application.</t>
      </section>
      <section anchor="authentication-service-compromise">
        <name>Authentication Service Compromise</name>
        <t>Authentication Service compromise is much more serious than compromise
of the Delivery Service. A compromised AS can assert a binding for a
signature key and identity pair of its choice, thus allowing
impersonation of a given user. This ability is sufficient to allow the
AS to join new groups as if it were that user. Depending on the
application architecture, it may also be sufficient to allow the
compromised AS to join the group as an existing user, for instance, as
if it were a new device associated with the same user. If
the application uses a transparency mechanism such as CONIKS
<xref target="CONIKS"/> or Key Transparency <xref target="KT"/>, then it may be possible for end
users to detect this kind of misbehavior by the AS.  It is also possible to
construct schemes in which the various clients owned by a user vouch
for each other, e.g., by signing each others' keys.</t>
      </section>
      <section anchor="additional-policy-enforcement">
        <name>Additional Policy Enforcement</name>
        <t>The DS and AS may also apply additional policies to MLS operations to obtain
additional security properties. For example, MLS enables any participant to add
or remove members of a group; a DS could enforce a policy that only certain
members are allowed to perform these operations. MLS authenticates all members
of a group; a DS could help ensure that only clients with certain types of
credentials are admitted. MLS provides no inherent protection against denial of
service; a DS could also enforce rate limits in order to mitigate
these risks.</t>
      </section>
      <section anchor="group-fragmentation-by-malicious-insiders">
        <name>Group Fragmentation by Malicious Insiders</name>
        <t>It is possible for a malicious member of a group to "fragment" the group by
crafting an invalid UpdatePath.  Recall that an UpdatePath encrypts a sequence
of path secrets to different subtrees of the group's ratchet trees.  These path
secrets should be derived in a sequence as described in
<xref target="ratchet-tree-evolution"/>, but the UpdatePath syntax allows the sender to
encrypt arbitrary, unrelated secrets.  The syntax also does not guarantee that
the encrypted path secret for a given node corresponds to the public
key provided for that node.</t>
        <t>Both of these types of corruption will cause processing of a Commit to fail for
some members of the group.  If the public key for a node does not match the path
secret, then the members that decrypt that path secret will reject the Commit
based on this mismatch.  If the path secret sequence is incorrect at some point,
then members that can decrypt nodes before that point will compute a different
public key for the mismatched node than the one in the UpdatePath, which also
causes the Commit to fail.  Applications <bcp14>SHOULD</bcp14> provide mechanisms for failed
commits to be reported, so that group members who were not able to recognize the
error themselves can reinitialize the group if necessary.</t>
        <t>Even with such an error reporting mechanism in place, however, it is still
possible for members to get locked out of the group by a malformed Commit.
Since malformed Commits can only be recognized by certain members of the group,
in an asynchronous application, it may be the case that all members that could
detect a fault in a Commit are offline.  In such a case, the Commit will be
accepted by the group, and the resulting state will possibly be used as the basis for
further Commits.  When the affected members come back online, they will reject
the first Commit, and thus be unable to catch up with the group. These members
will need to either add themselves back with an external Commit or reinitialize
the group from scratch.</t>
        <t>Applications can address this risk by requiring certain members of the group to
acknowledge successful processing of a Commit before the group regards the
Commit as accepted.  The minimum set of acknowledgements necessary to verify
that a Commit is well-formed comprises an acknowledgement from one member per
node in the UpdatePath, that is, one member from each subtree rooted in the
copath node corresponding to the node in the UpdatePath. MLS does not
provide a built-in mechanism for such acknowledgements, but they can
be added at the application layer.</t>
      </section>
    </section>
    <section anchor="iana-considerations">
      <name>IANA Considerations</name>
      <t>IANA has created the following registries:</t>
      <ul spacing="normal">
        <li>MLS Cipher Suites (<xref target="mls-cipher-suites"/>)</li>
        <li>MLS Wire Formats (<xref target="mls-wire-formats"/>)</li>
        <li>MLS Extension Types (<xref target="mls-extension-types"/>)</li>
        <li>MLS Proposal Types (<xref target="mls-proposal-types"/>)</li>
        <li>MLS Credential Types (<xref target="mls-credential-types"/>)</li>
        <li>MLS Signature Labels (<xref target="mls-signature-labels"/>)</li>
        <li>MLS Public Key Encryption Labels (<xref target="mls-public-key-encryption-labels"/>)</li>
        <li>MLS Exporter Labels (<xref target="mls-exporter-labels"/>)</li>
      </ul>
      <t>All of these registries are under the "Messaging Layer Security" group registry heading,
and assignments are made via the Specification Required policy <xref target="RFC8126"/>. See
<xref target="de"/> for additional information about the MLS Designated Experts (DEs).</t>
      <section anchor="mls-cipher-suites">
        <name>MLS Cipher Suites</name>
        <t>A cipher suite is a combination of a protocol version and the set of
cryptographic algorithms that should be used.</t>
        <t>Cipher suite names follow the naming convention:</t>
        <sourcecode type="pseudocode">
CipherSuite MLS_LVL_KEM_AEAD_HASH_SIG = VALUE;
</sourcecode>
        <t>Where VALUE is represented as a 16-bit integer:</t>
        <sourcecode type="tls-presentation">
uint16 CipherSuite;
</sourcecode>
        <table>
          <thead>
            <tr>
              <th align="left">Component</th>
              <th align="left">Contents</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td align="left">LVL</td>
              <td align="left">The security level (in bits)</td>
            </tr>
            <tr>
              <td align="left">KEM</td>
              <td align="left">The KEM algorithm used for HPKE in ratchet tree operations</td>
            </tr>
            <tr>
              <td align="left">AEAD</td>
              <td align="left">The AEAD algorithm used for HPKE and message protection</td>
            </tr>
            <tr>
              <td align="left">HASH</td>
              <td align="left">The hash algorithm used for HPKE and the MLS transcript hash</td>
            </tr>
            <tr>
              <td align="left">SIG</td>
              <td align="left">The signature algorithm used for message authentication</td>
            </tr>
          </tbody>
        </table>
        <t>The columns in the registry are as follows:</t>
        <ul spacing="normal">
          <li>Value: The numeric value of the cipher suite</li>
          <li>Name: The name of the cipher suite</li>
          <li>
            <t>Recommended: Whether support for this cipher suite is recommended by the IETF.
Valid values are "Y", "N", and "D", as described below.  The default
value of the "Recommended" column is "N".  Setting the Recommended item to "Y"
or "D", or changing an item whose current value is "Y" or "D", requires
Standards Action <xref target="RFC8126"/>.  </t>
            <ul spacing="normal">
              <li>Y: Indicates that the IETF has consensus that the item is <bcp14>RECOMMENDED</bcp14>. This
only means that the associated mechanism is fit for the purpose for which it
was defined. Careful reading of the documentation for the mechanism is
necessary to understand the applicability of that mechanism. The IETF could
recommend mechanisms that have limited applicability, but it will provide
applicability statements that describe any limitations of the mechanism or
necessary constraints on its use.</li>
              <li>N: Indicates that the item has not been evaluated by the IETF and that the
IETF has made no statement about the suitability of the associated
mechanism. This does not necessarily mean that the mechanism is flawed, only
that no consensus exists. The IETF might have consensus to leave an item
marked as "N" on the basis of it having limited applicability or usage
constraints.</li>
              <li>D: Indicates that the item is discouraged and <bcp14>SHOULD NOT</bcp14> or <bcp14>MUST NOT</bcp14> be
used. This marking could be used to identify mechanisms that might result in
problems if they are used, such as a weak cryptographic algorithm or a
mechanism that might cause interoperability problems in deployment.</li>
            </ul>
          </li>
          <li>Reference: The document where this cipher suite is defined</li>
        </ul>
        <t>Initial contents:</t>
        <table>
          <name>MLS Extension Types Registry</name>
          <thead>
            <tr>
              <th align="left">Value</th>
              <th align="left">Name</th>
              <th align="left">R</th>
              <th align="left">Ref</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td align="left">0x0000</td>
              <td align="left">RESERVED</td>
              <td align="left">-</td>
              <td align="left">RFC 9420</td>
            </tr>
            <tr>
              <td align="left">0x0001</td>
              <td align="left">MLS_128_DHKEMX25519_AES128GCM_SHA256_Ed25519</td>
              <td align="left">Y</td>
              <td align="left">RFC 9420</td>
            </tr>
            <tr>
              <td align="left">0x0002</td>
              <td align="left">MLS_128_DHKEMP256_AES128GCM_SHA256_P256</td>
              <td align="left">Y</td>
              <td align="left">RFC 9420</td>
            </tr>
            <tr>
              <td align="left">0x0003</td>
              <td align="left">MLS_128_DHKEMX25519_CHACHA20POLY1305_SHA256_Ed25519</td>
              <td align="left">Y</td>
              <td align="left">RFC 9420</td>
            </tr>
            <tr>
              <td align="left">0x0004</td>
              <td align="left">MLS_256_DHKEMX448_AES256GCM_SHA512_Ed448</td>
              <td align="left">Y</td>
              <td align="left">RFC 9420</td>
            </tr>
            <tr>
              <td align="left">0x0005</td>
              <td align="left">MLS_256_DHKEMP521_AES256GCM_SHA512_P521</td>
              <td align="left">Y</td>
              <td align="left">RFC 9420</td>
            </tr>
            <tr>
              <td align="left">0x0006</td>
              <td align="left">MLS_256_DHKEMX448_CHACHA20POLY1305_SHA512_Ed448</td>
              <td align="left">Y</td>
              <td align="left">RFC 9420</td>
            </tr>
            <tr>
              <td align="left">0x0007</td>
              <td align="left">MLS_256_DHKEMP384_AES256GCM_SHA384_P384</td>
              <td align="left">Y</td>
              <td align="left">RFC 9420</td>
            </tr>
            <tr>
              <td align="left">0x0A0A</td>
              <td align="left">GREASE</td>
              <td align="left">Y</td>
              <td align="left">RFC 9420</td>
            </tr>
            <tr>
              <td align="left">0x1A1A</td>
              <td align="left">GREASE</td>
              <td align="left">Y</td>
              <td align="left">RFC 9420</td>
            </tr>
            <tr>
              <td align="left">0x2A2A</td>
              <td align="left">GREASE</td>
              <td align="left">Y</td>
              <td align="left">RFC 9420</td>
            </tr>
            <tr>
              <td align="left">0x3A3A</td>
              <td align="left">GREASE</td>
              <td align="left">Y</td>
              <td align="left">RFC 9420</td>
            </tr>
            <tr>
              <td align="left">0x4A4A</td>
              <td align="left">GREASE</td>
              <td align="left">Y</td>
              <td align="left">RFC 9420</td>
            </tr>
            <tr>
              <td align="left">0x5A5A</td>
              <td align="left">GREASE</td>
              <td align="left">Y</td>
              <td align="left">RFC 9420</td>
            </tr>
            <tr>
              <td align="left">0x6A6A</td>
              <td align="left">GREASE</td>
              <td align="left">Y</td>
              <td align="left">RFC 9420</td>
            </tr>
            <tr>
              <td align="left">0x7A7A</td>
              <td align="left">GREASE</td>
              <td align="left">Y</td>
              <td align="left">RFC 9420</td>
            </tr>
            <tr>
              <td align="left">0x8A8A</td>
              <td align="left">GREASE</td>
              <td align="left">Y</td>
              <td align="left">RFC 9420</td>
            </tr>
            <tr>
              <td align="left">0x9A9A</td>
              <td align="left">GREASE</td>
              <td align="left">Y</td>
              <td align="left">RFC 9420</td>
            </tr>
            <tr>
              <td align="left">0xAAAA</td>
              <td align="left">GREASE</td>
              <td align="left">Y</td>
              <td align="left">RFC 9420</td>
            </tr>
            <tr>
              <td align="left">0xBABA</td>
              <td align="left">GREASE</td>
              <td align="left">Y</td>
              <td align="left">RFC 9420</td>
            </tr>
            <tr>
              <td align="left">0xCACA</td>
              <td align="left">GREASE</td>
              <td align="left">Y</td>
              <td align="left">RFC 9420</td>
            </tr>
            <tr>
              <td align="left">0xDADA</td>
              <td align="left">GREASE</td>
              <td align="left">Y</td>
              <td align="left">RFC 9420</td>
            </tr>
            <tr>
              <td align="left">0xEAEA</td>
              <td align="left">GREASE</td>
              <td align="left">Y</td>
              <td align="left">RFC 9420</td>
            </tr>
            <tr>
              <td align="left">0xF000 - 0xFFFF</td>
              <td align="left">Reserved for Private Use</td>
              <td align="left">-</td>
              <td align="left">RFC 9420</td>
            </tr>
          </tbody>
        </table>
        <t>All of the non-GREASE cipher suites use HMAC <xref target="RFC2104"/> as their MAC function, with
different hashes per cipher suite.  The mapping of cipher suites to HPKE
primitives <xref target="RFC9180"/>, HMAC hash functions, and TLS signature schemes
<xref target="RFC8446"/> is as follows:</t>
        <table>
          <thead>
            <tr>
              <th align="left">Value</th>
              <th align="left">KEM</th>
              <th align="left">KDF</th>
              <th align="left">AEAD</th>
              <th align="left">Hash</th>
              <th align="left">Signature</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td align="left">0x0001</td>
              <td align="left">0x0020</td>
              <td align="left">0x0001</td>
              <td align="left">0x0001</td>
              <td align="left">SHA256</td>
              <td align="left">ed25519</td>
            </tr>
            <tr>
              <td align="left">0x0002</td>
              <td align="left">0x0010</td>
              <td align="left">0x0001</td>
              <td align="left">0x0001</td>
              <td align="left">SHA256</td>
              <td align="left">ecdsa_secp256r1_sha256</td>
            </tr>
            <tr>
              <td align="left">0x0003</td>
              <td align="left">0x0020</td>
              <td align="left">0x0001</td>
              <td align="left">0x0003</td>
              <td align="left">SHA256</td>
              <td align="left">ed25519</td>
            </tr>
            <tr>
              <td align="left">0x0004</td>
              <td align="left">0x0021</td>
              <td align="left">0x0003</td>
              <td align="left">0x0002</td>
              <td align="left">SHA512</td>
              <td align="left">ed448</td>
            </tr>
            <tr>
              <td align="left">0x0005</td>
              <td align="left">0x0012</td>
              <td align="left">0x0003</td>
              <td align="left">0x0002</td>
              <td align="left">SHA512</td>
              <td align="left">ecdsa_secp521r1_sha512</td>
            </tr>
            <tr>
              <td align="left">0x0006</td>
              <td align="left">0x0021</td>
              <td align="left">0x0003</td>
              <td align="left">0x0003</td>
              <td align="left">SHA512</td>
              <td align="left">ed448</td>
            </tr>
            <tr>
              <td align="left">0x0007</td>
              <td align="left">0x0011</td>
              <td align="left">0x0002</td>
              <td align="left">0x0002</td>
              <td align="left">SHA384</td>
              <td align="left">ecdsa_secp384r1_sha384</td>
            </tr>
          </tbody>
        </table>
        <t>The hash used for the MLS transcript hash is the one referenced in the
cipher suite name.  In the cipher suites defined above, "SHA256", "SHA384", and
"SHA512" refer, respectively, to the SHA-256, SHA-384, and SHA-512 functions
defined in <xref target="SHS"/>.</t>
        <t>In addition to the general requirements of <xref target="additional-cipher-suites"/>, future
cipher suites <bcp14>MUST</bcp14> meet the requirements of <xref target="confidentiality-of-sender-data"/>.</t>
        <t>It is advisable to keep the number of cipher suites low to increase the likelihood
that clients can interoperate in a federated environment. The cipher suites therefore
include only modern, yet well-established algorithms.  Depending on their
requirements, clients can choose between two security levels (roughly 128-bit
and 256-bit). Within the security levels, clients can choose between faster
X25519/X448 curves and curves compliant with FIPS 140-2 for Diffie-Hellman key
negotiations. Clients may also choose ChaCha20Poly1305 or AES-GCM, e.g., for
performance reasons. Since ChaCha20Poly1305 is not listed by FIPS 140-2, it is
not paired with curves compliant with FIPS 140-2. The security level of symmetric
encryption algorithms and hash functions is paired with the security level of
the curves.</t>
        <t>The mandatory-to-implement cipher suite for MLS 1.0 is
<tt>MLS_128_DHKEMX25519_AES128GCM_SHA256_Ed25519</tt>, which uses
Curve25519 for key exchange, AES-128-GCM for HPKE, HKDF over SHA2-256, and
Ed25519 for signatures.  MLS clients <bcp14>MUST</bcp14> implement this cipher suite.</t>
      </section>
      <section anchor="mls-wire-formats">
        <name>MLS Wire Formats</name>
        <t>The "MLS Wire Formats" registry lists identifiers for the types of messages that can be sent in
MLS.  The wire format field is two bytes wide, so the valid wire format values
are in the range 0x0000 to 0xFFFF.</t>
        <t>Template:</t>
        <ul spacing="normal">
          <li>Value: The numeric value of the wire format</li>
          <li>Name: The name of the wire format</li>
          <li>Recommended: Same as in <xref target="mls-cipher-suites"/></li>
          <li>Reference: The document where this wire format is defined</li>
        </ul>
        <t>Initial contents:</t>
        <table>
          <name>MLS Wire Formats Registry</name>
          <thead>
            <tr>
              <th align="left">Value</th>
              <th align="left">Name</th>
              <th align="left">R</th>
              <th align="left">Ref</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td align="left">0x0000</td>
              <td align="left">RESERVED</td>
              <td align="left">-</td>
              <td align="left">RFC 9420</td>
            </tr>
            <tr>
              <td align="left">0x0001</td>
              <td align="left">mls_public_message</td>
              <td align="left">Y</td>
              <td align="left">RFC 9420</td>
            </tr>
            <tr>
              <td align="left">0x0002</td>
              <td align="left">mls_private_message</td>
              <td align="left">Y</td>
              <td align="left">RFC 9420</td>
            </tr>
            <tr>
              <td align="left">0x0003</td>
              <td align="left">mls_welcome</td>
              <td align="left">Y</td>
              <td align="left">RFC 9420</td>
            </tr>
            <tr>
              <td align="left">0x0004</td>
              <td align="left">mls_group_info</td>
              <td align="left">Y</td>
              <td align="left">RFC 9420</td>
            </tr>
            <tr>
              <td align="left">0x0005</td>
              <td align="left">mls_key_package</td>
              <td align="left">Y</td>
              <td align="left">RFC 9420</td>
            </tr>
            <tr>
              <td align="left">0xF000 - 0xFFFF</td>
              <td align="left">Reserved for Private Use</td>
              <td align="left">-</td>
              <td align="left">RFC 9420</td>
            </tr>
          </tbody>
        </table>
      </section>
      <section anchor="mls-extension-types">
        <name>MLS Extension Types</name>
        <t>The "MLS Extension Types" registry lists identifiers for extensions to the MLS protocol.  The
extension type field is two bytes wide, so valid extension type values are in
the range 0x0000 to 0xFFFF.</t>
        <t>Template:</t>
        <ul spacing="normal">
          <li>Value: The numeric value of the extension type</li>
          <li>Name: The name of the extension type</li>
          <li>
            <t>Message(s): The messages in which the extension may appear, drawn from the following
list:  </t>
            <ul spacing="normal">
              <li>KP: KeyPackage objects</li>
              <li>LN: LeafNode objects</li>
              <li>GC: GroupContext objects</li>
              <li>GI: GroupInfo objects</li>
            </ul>
          </li>
          <li>Recommended: Same as in <xref target="mls-cipher-suites"/></li>
          <li>Reference: The document where this extension is defined</li>
        </ul>
        <t>Initial contents:</t>
        <table>
          <name>MLS Extension Types Registry</name>
          <thead>
            <tr>
              <th align="left">Value</th>
              <th align="left">Name</th>
              <th align="left">Message(s)</th>
              <th align="left">R</th>
              <th align="left">Ref</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td align="left">0x0000</td>
              <td align="left">RESERVED</td>
              <td align="left">N/A</td>
              <td align="left">-</td>
              <td align="left">RFC 9420</td>
            </tr>
            <tr>
              <td align="left">0x0001</td>
              <td align="left">application_id</td>
              <td align="left">LN</td>
              <td align="left">Y</td>
              <td align="left">RFC 9420</td>
            </tr>
            <tr>
              <td align="left">0x0002</td>
              <td align="left">ratchet_tree</td>
              <td align="left">GI</td>
              <td align="left">Y</td>
              <td align="left">RFC 9420</td>
            </tr>
            <tr>
              <td align="left">0x0003</td>
              <td align="left">required_capabilities</td>
              <td align="left">GC</td>
              <td align="left">Y</td>
              <td align="left">RFC 9420</td>
            </tr>
            <tr>
              <td align="left">0x0004</td>
              <td align="left">external_pub</td>
              <td align="left">GI</td>
              <td align="left">Y</td>
              <td align="left">RFC 9420</td>
            </tr>
            <tr>
              <td align="left">0x0005</td>
              <td align="left">external_senders</td>
              <td align="left">GC</td>
              <td align="left">Y</td>
              <td align="left">RFC 9420</td>
            </tr>
            <tr>
              <td align="left">0x0A0A</td>
              <td align="left">GREASE</td>
              <td align="left">KP, GI, LN</td>
              <td align="left">Y</td>
              <td align="left">RFC 9420</td>
            </tr>
            <tr>
              <td align="left">0x1A1A</td>
              <td align="left">GREASE</td>
              <td align="left">KP, GI, LN</td>
              <td align="left">Y</td>
              <td align="left">RFC 9420</td>
            </tr>
            <tr>
              <td align="left">0x2A2A</td>
              <td align="left">GREASE</td>
              <td align="left">KP, GI, LN</td>
              <td align="left">Y</td>
              <td align="left">RFC 9420</td>
            </tr>
            <tr>
              <td align="left">0x3A3A</td>
              <td align="left">GREASE</td>
              <td align="left">KP, GI, LN</td>
              <td align="left">Y</td>
              <td align="left">RFC 9420</td>
            </tr>
            <tr>
              <td align="left">0x4A4A</td>
              <td align="left">GREASE</td>
              <td align="left">KP, GI, LN</td>
              <td align="left">Y</td>
              <td align="left">RFC 9420</td>
            </tr>
            <tr>
              <td align="left">0x5A5A</td>
              <td align="left">GREASE</td>
              <td align="left">KP, GI, LN</td>
              <td align="left">Y</td>
              <td align="left">RFC 9420</td>
            </tr>
            <tr>
              <td align="left">0x6A6A</td>
              <td align="left">GREASE</td>
              <td align="left">KP, GI, LN</td>
              <td align="left">Y</td>
              <td align="left">RFC 9420</td>
            </tr>
            <tr>
              <td align="left">0x7A7A</td>
              <td align="left">GREASE</td>
              <td align="left">KP, GI, LN</td>
              <td align="left">Y</td>
              <td align="left">RFC 9420</td>
            </tr>
            <tr>
              <td align="left">0x8A8A</td>
              <td align="left">GREASE</td>
              <td align="left">KP, GI, LN</td>
              <td align="left">Y</td>
              <td align="left">RFC 9420</td>
            </tr>
            <tr>
              <td align="left">0x9A9A</td>
              <td align="left">GREASE</td>
              <td align="left">KP, GI, LN</td>
              <td align="left">Y</td>
              <td align="left">RFC 9420</td>
            </tr>
            <tr>
              <td align="left">0xAAAA</td>
              <td align="left">GREASE</td>
              <td align="left">KP, GI, LN</td>
              <td align="left">Y</td>
              <td align="left">RFC 9420</td>
            </tr>
            <tr>
              <td align="left">0xBABA</td>
              <td align="left">GREASE</td>
              <td align="left">KP, GI, LN</td>
              <td align="left">Y</td>
              <td align="left">RFC 9420</td>
            </tr>
            <tr>
              <td align="left">0xCACA</td>
              <td align="left">GREASE</td>
              <td align="left">KP, GI, LN</td>
              <td align="left">Y</td>
              <td align="left">RFC 9420</td>
            </tr>
            <tr>
              <td align="left">0xDADA</td>
              <td align="left">GREASE</td>
              <td align="left">KP, GI, LN</td>
              <td align="left">Y</td>
              <td align="left">RFC 9420</td>
            </tr>
            <tr>
              <td align="left">0xEAEA</td>
              <td align="left">GREASE</td>
              <td align="left">KP, GI, LN</td>
              <td align="left">Y</td>
              <td align="left">RFC 9420</td>
            </tr>
            <tr>
              <td align="left">0xF000  - 0xFFFF</td>
              <td align="left">Reserved for Private Use</td>
              <td align="left">N/A</td>
              <td align="left">-</td>
              <td align="left">RFC 9420</td>
            </tr>
          </tbody>
        </table>
      </section>
      <section anchor="mls-proposal-types">
        <name>MLS Proposal Types</name>
        <t>The "MLS Proposal Types" registry lists identifiers for types of proposals that can be made for
changes to an MLS group.  The extension type field is two bytes wide, so valid
extension type values are in the range 0x0000 to 0xFFFF.</t>
        <t>Template:</t>
        <ul spacing="normal">
          <li>Value: The numeric value of the proposal type</li>
          <li>Name: The name of the proposal type</li>
          <li>Recommended: Same as in <xref target="mls-cipher-suites"/></li>
          <li>External: Whether a proposal of this type may be sent by an <tt>external</tt> sender
(see <xref target="external-proposals"/>)</li>
          <li>Path Required: Whether a Commit covering a proposal of this type is required
to have its <tt>path</tt> field populated (see <xref target="commit"/>)</li>
          <li>Reference: The document where this extension is defined</li>
        </ul>
        <t>Initial contents:</t>
        <table>
          <name>MLS Proposal Types Registry</name>
          <thead>
            <tr>
              <th align="left">Value</th>
              <th align="left">Name</th>
              <th align="left">R</th>
              <th align="left">Ext</th>
              <th align="left">Path</th>
              <th align="left">Ref</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td align="left">0x0000</td>
              <td align="left">RESERVED</td>
              <td align="left">-</td>
              <td align="left">-</td>
              <td align="left">-</td>
              <td align="left">RFC 9420</td>
            </tr>
            <tr>
              <td align="left">0x0001</td>
              <td align="left">add</td>
              <td align="left">Y</td>
              <td align="left">Y</td>
              <td align="left">N</td>
              <td align="left">RFC 9420</td>
            </tr>
            <tr>
              <td align="left">0x0002</td>
              <td align="left">update</td>
              <td align="left">Y</td>
              <td align="left">N</td>
              <td align="left">Y</td>
              <td align="left">RFC 9420</td>
            </tr>
            <tr>
              <td align="left">0x0003</td>
              <td align="left">remove</td>
              <td align="left">Y</td>
              <td align="left">Y</td>
              <td align="left">Y</td>
              <td align="left">RFC 9420</td>
            </tr>
            <tr>
              <td align="left">0x0004</td>
              <td align="left">psk</td>
              <td align="left">Y</td>
              <td align="left">Y</td>
              <td align="left">N</td>
              <td align="left">RFC 9420</td>
            </tr>
            <tr>
              <td align="left">0x0005</td>
              <td align="left">reinit</td>
              <td align="left">Y</td>
              <td align="left">Y</td>
              <td align="left">N</td>
              <td align="left">RFC 9420</td>
            </tr>
            <tr>
              <td align="left">0x0006</td>
              <td align="left">external_init</td>
              <td align="left">Y</td>
              <td align="left">N</td>
              <td align="left">Y</td>
              <td align="left">RFC 9420</td>
            </tr>
            <tr>
              <td align="left">0x0007</td>
              <td align="left">group_context_extensions</td>
              <td align="left">Y</td>
              <td align="left">Y</td>
              <td align="left">Y</td>
              <td align="left">RFC 9420</td>
            </tr>
            <tr>
              <td align="left">0x0A0A</td>
              <td align="left">GREASE</td>
              <td align="left">Y</td>
              <td align="left">-</td>
              <td align="left">-</td>
              <td align="left">RFC 9420</td>
            </tr>
            <tr>
              <td align="left">0x1A1A</td>
              <td align="left">GREASE</td>
              <td align="left">Y</td>
              <td align="left">-</td>
              <td align="left">-</td>
              <td align="left">RFC 9420</td>
            </tr>
            <tr>
              <td align="left">0x2A2A</td>
              <td align="left">GREASE</td>
              <td align="left">Y</td>
              <td align="left">-</td>
              <td align="left">-</td>
              <td align="left">RFC 9420</td>
            </tr>
            <tr>
              <td align="left">0x3A3A</td>
              <td align="left">GREASE</td>
              <td align="left">Y</td>
              <td align="left">-</td>
              <td align="left">-</td>
              <td align="left">RFC 9420</td>
            </tr>
            <tr>
              <td align="left">0x4A4A</td>
              <td align="left">GREASE</td>
              <td align="left">Y</td>
              <td align="left">-</td>
              <td align="left">-</td>
              <td align="left">RFC 9420</td>
            </tr>
            <tr>
              <td align="left">0x5A5A</td>
              <td align="left">GREASE</td>
              <td align="left">Y</td>
              <td align="left">-</td>
              <td align="left">-</td>
              <td align="left">RFC 9420</td>
            </tr>
            <tr>
              <td align="left">0x6A6A</td>
              <td align="left">GREASE</td>
              <td align="left">Y</td>
              <td align="left">-</td>
              <td align="left">-</td>
              <td align="left">RFC 9420</td>
            </tr>
            <tr>
              <td align="left">0x7A7A</td>
              <td align="left">GREASE</td>
              <td align="left">Y</td>
              <td align="left">-</td>
              <td align="left">-</td>
              <td align="left">RFC 9420</td>
            </tr>
            <tr>
              <td align="left">0x8A8A</td>
              <td align="left">GREASE</td>
              <td align="left">Y</td>
              <td align="left">-</td>
              <td align="left">-</td>
              <td align="left">RFC 9420</td>
            </tr>
            <tr>
              <td align="left">0x9A9A</td>
              <td align="left">GREASE</td>
              <td align="left">Y</td>
              <td align="left">-</td>
              <td align="left">-</td>
              <td align="left">RFC 9420</td>
            </tr>
            <tr>
              <td align="left">0xAAAA</td>
              <td align="left">GREASE</td>
              <td align="left">Y</td>
              <td align="left">-</td>
              <td align="left">-</td>
              <td align="left">RFC 9420</td>
            </tr>
            <tr>
              <td align="left">0xBABA</td>
              <td align="left">GREASE</td>
              <td align="left">Y</td>
              <td align="left">-</td>
              <td align="left">-</td>
              <td align="left">RFC 9420</td>
            </tr>
            <tr>
              <td align="left">0xCACA</td>
              <td align="left">GREASE</td>
              <td align="left">Y</td>
              <td align="left">-</td>
              <td align="left">-</td>
              <td align="left">RFC 9420</td>
            </tr>
            <tr>
              <td align="left">0xDADA</td>
              <td align="left">GREASE</td>
              <td align="left">Y</td>
              <td align="left">-</td>
              <td align="left">-</td>
              <td align="left">RFC 9420</td>
            </tr>
            <tr>
              <td align="left">0xEAEA</td>
              <td align="left">GREASE</td>
              <td align="left">Y</td>
              <td align="left">-</td>
              <td align="left">-</td>
              <td align="left">RFC 9420</td>
            </tr>
            <tr>
              <td align="left">0xF000  - 0xFFFF</td>
              <td align="left">Reserved for Private Use</td>
              <td align="left">-</td>
              <td align="left">-</td>
              <td align="left">-</td>
              <td align="left">RFC 9420</td>
            </tr>
          </tbody>
        </table>
      </section>
      <section anchor="mls-credential-types">
        <name>MLS Credential Types</name>
        <t>The "MLS Credential Types" registry lists identifiers for types of credentials that can be used for
authentication in the MLS protocol.  The credential type field is two bytes wide,
so valid credential type values are in the range 0x0000 to 0xFFFF.</t>
        <t>Template:</t>
        <ul spacing="normal">
          <li>Value: The numeric value of the credential type</li>
          <li>Name: The name of the credential type</li>
          <li>Recommended: Same as in <xref target="mls-cipher-suites"/></li>
          <li>Reference: The document where this credential is defined</li>
        </ul>
        <t>Initial contents:</t>
        <table>
          <name>MLS Credential Types Registry</name>
          <thead>
            <tr>
              <th align="left">Value</th>
              <th align="left">Name</th>
              <th align="left">R</th>
              <th align="left">Ref</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td align="left">0x0000</td>
              <td align="left">RESERVED</td>
              <td align="left">-</td>
              <td align="left">RFC 9420</td>
            </tr>
            <tr>
              <td align="left">0x0001</td>
              <td align="left">basic</td>
              <td align="left">Y</td>
              <td align="left">RFC 9420</td>
            </tr>
            <tr>
              <td align="left">0x0002</td>
              <td align="left">x509</td>
              <td align="left">Y</td>
              <td align="left">RFC 9420</td>
            </tr>
            <tr>
              <td align="left">0x0A0A</td>
              <td align="left">GREASE</td>
              <td align="left">Y</td>
              <td align="left">RFC 9420</td>
            </tr>
            <tr>
              <td align="left">0x1A1A</td>
              <td align="left">GREASE</td>
              <td align="left">Y</td>
              <td align="left">RFC 9420</td>
            </tr>
            <tr>
              <td align="left">0x2A2A</td>
              <td align="left">GREASE</td>
              <td align="left">Y</td>
              <td align="left">RFC 9420</td>
            </tr>
            <tr>
              <td align="left">0x3A3A</td>
              <td align="left">GREASE</td>
              <td align="left">Y</td>
              <td align="left">RFC 9420</td>
            </tr>
            <tr>
              <td align="left">0x4A4A</td>
              <td align="left">GREASE</td>
              <td align="left">Y</td>
              <td align="left">RFC 9420</td>
            </tr>
            <tr>
              <td align="left">0x5A5A</td>
              <td align="left">GREASE</td>
              <td align="left">Y</td>
              <td align="left">RFC 9420</td>
            </tr>
            <tr>
              <td align="left">0x6A6A</td>
              <td align="left">GREASE</td>
              <td align="left">Y</td>
              <td align="left">RFC 9420</td>
            </tr>
            <tr>
              <td align="left">0x7A7A</td>
              <td align="left">GREASE</td>
              <td align="left">Y</td>
              <td align="left">RFC 9420</td>
            </tr>
            <tr>
              <td align="left">0x8A8A</td>
              <td align="left">GREASE</td>
              <td align="left">Y</td>
              <td align="left">RFC 9420</td>
            </tr>
            <tr>
              <td align="left">0x9A9A</td>
              <td align="left">GREASE</td>
              <td align="left">Y</td>
              <td align="left">RFC 9420</td>
            </tr>
            <tr>
              <td align="left">0xAAAA</td>
              <td align="left">GREASE</td>
              <td align="left">Y</td>
              <td align="left">RFC 9420</td>
            </tr>
            <tr>
              <td align="left">0xBABA</td>
              <td align="left">GREASE</td>
              <td align="left">Y</td>
              <td align="left">RFC 9420</td>
            </tr>
            <tr>
              <td align="left">0xCACA</td>
              <td align="left">GREASE</td>
              <td align="left">Y</td>
              <td align="left">RFC 9420</td>
            </tr>
            <tr>
              <td align="left">0xDADA</td>
              <td align="left">GREASE</td>
              <td align="left">Y</td>
              <td align="left">RFC 9420</td>
            </tr>
            <tr>
              <td align="left">0xEAEA</td>
              <td align="left">GREASE</td>
              <td align="left">Y</td>
              <td align="left">RFC 9420</td>
            </tr>
            <tr>
              <td align="left">0xF000  - 0xFFFF</td>
              <td align="left">Reserved for Private Use</td>
              <td align="left">-</td>
              <td align="left">RFC 9420</td>
            </tr>
          </tbody>
        </table>
      </section>
      <section anchor="mls-signature-labels">
        <name>MLS Signature Labels</name>
        <t>The <tt>SignWithLabel</tt> function defined in <xref target="signing"/> avoids the risk of
confusion between signatures in different contexts.  Each context is assigned a
distinct label that is incorporated into the signature.  The "MLS Signature Labels" registry records
the labels defined in this document and allows additional labels to be
registered in case extensions add other types of signatures using the same
signature keys used elsewhere in MLS.</t>
        <t>Template:</t>
        <ul spacing="normal">
          <li>Label: The string to be used as the <tt>Label</tt> parameter to <tt>SignWithLabel</tt></li>
          <li>Recommended: Same as in <xref target="mls-cipher-suites"/></li>
          <li>Reference: The document where this label is defined</li>
        </ul>
        <t>Initial contents:</t>
        <table>
          <name>MLS Signature Labels Registry</name>
          <thead>
            <tr>
              <th align="left">Label</th>
              <th align="left">R</th>
              <th align="left">Ref</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td align="left">"FramedContentTBS"</td>
              <td align="left">Y</td>
              <td align="left">RFC 9420</td>
            </tr>
            <tr>
              <td align="left">"LeafNodeTBS"</td>
              <td align="left">Y</td>
              <td align="left">RFC 9420</td>
            </tr>
            <tr>
              <td align="left">"KeyPackageTBS"</td>
              <td align="left">Y</td>
              <td align="left">RFC 9420</td>
            </tr>
            <tr>
              <td align="left">"GroupInfoTBS"</td>
              <td align="left">Y</td>
              <td align="left">RFC 9420</td>
            </tr>
          </tbody>
        </table>
      </section>
      <section anchor="mls-public-key-encryption-labels">
        <name>MLS Public Key Encryption Labels</name>
        <t>The <tt>EncryptWithLabel</tt> function defined in <xref target="public-key-encryption"/> avoids the
risk of confusion between ciphertexts produced for different purposes in
different contexts.  Each context is assigned a distinct label that is
incorporated into the signature.  The "MLS Public Key Encryption Labels" registry records the labels defined in
this document and allows additional labels to be registered in case extensions
add other types of public key encryption using the same HPKE keys used elsewhere
in MLS.</t>
        <t>Template:</t>
        <ul spacing="normal">
          <li>Label: The string to be used as the <tt>Label</tt> parameter to <tt>EncryptWithLabel</tt></li>
          <li>Recommended: Same as in <xref target="mls-cipher-suites"/></li>
          <li>Reference: The document where this label is defined</li>
        </ul>
        <t>Initial contents:</t>
        <table>
          <name>MLS Public Key Encryption Labels Registry</name>
          <thead>
            <tr>
              <th align="left">Label</th>
              <th align="left">R</th>
              <th align="left">Ref</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td align="left">"UpdatePathNode"</td>
              <td align="left">Y</td>
              <td align="left">RFC 9420</td>
            </tr>
            <tr>
              <td align="left">"Welcome"</td>
              <td align="left">Y</td>
              <td align="left">RFC 9420</td>
            </tr>
          </tbody>
        </table>
      </section>
      <section anchor="mls-exporter-labels">
        <name>MLS Exporter Labels</name>
        <t>The exporter function defined in <xref target="exporters"/> allows applications to derive key
material from the MLS key schedule.  Like the TLS exporter <xref target="RFC8446"/>, the MLS
exporter uses a label to distinguish between different applications' use of the
exporter.  The "MLS Exporter Labels" registry allows applications to register their usage to avoid
collisions.</t>
        <t>Template:</t>
        <ul spacing="normal">
          <li>Label: The string to be used as the <tt>Label</tt> parameter to <tt>MLS-Exporter</tt></li>
          <li>Recommended: Same as in <xref target="mls-cipher-suites"/></li>
          <li>Reference: The document where this label is defined</li>
        </ul>
        <t>The registry has no initial contents, since it is intended to be used by
applications, not the core protocol.  The table below is intended only to show
the column layout of the registry.</t>
        <table>
          <name>MLS Exporter Labels Registry</name>
          <thead>
            <tr>
              <th align="left">Label</th>
              <th align="left">Recommended</th>
              <th align="left">Reference</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td align="left">(N/A)</td>
              <td align="left">(N/A)</td>
              <td align="left">(N/A)</td>
            </tr>
          </tbody>
        </table>
      </section>
      <section anchor="de">
        <name>MLS Designated Expert Pool</name>
        <t>Specification Required <xref target="RFC8126"/> registry requests are registered
after a three-week review period on the MLS Designated Expert (DE) mailing list
<eref brackets="angle" target="mailto:mls-reg-review@ietf.org"/> on the advice of one or more of the MLS DEs. However,
to allow for the allocation of values prior to publication, the MLS
DEs may approve registration once they are satisfied that such a
specification will be published.</t>
        <t>Registration requests sent to the MLS DEs' mailing list for review
<bcp14>SHOULD</bcp14> use an appropriate subject (e.g., "Request to register value
in MLS Bar registry").</t>
        <t>Within the review period, the MLS DEs will either approve or deny
the registration request, communicating this decision to the MLS DEs'
mailing list and IANA. Denials <bcp14>SHOULD</bcp14> include an explanation and, if
applicable, suggestions as to how to make the request successful.
Registration requests that are undetermined for a period longer than
21 days can be brought to the IESG's attention for resolution using
the <eref brackets="angle" target="mailto:iesg@ietf.org"/> mailing list.</t>
        <t>Criteria that <bcp14>SHOULD</bcp14> be applied by the MLS DEs includes determining
whether the proposed registration duplicates existing functionality,
whether it is likely to be of general applicability or useful only
for a single application, and whether the registration description
is clear. For example, for cipher suite registrations, the MLS DEs will apply the
advisory found in <xref target="mls-cipher-suites"/>.</t>
        <t>IANA <bcp14>MUST</bcp14> only accept registry updates from the MLS DEs and <bcp14>SHOULD</bcp14>
direct all requests for registration to the MLS DEs' mailing list.</t>
        <t>It is suggested that multiple MLS DEs who are able to
represent the perspectives of different applications using this
specification be appointed, in order to enable a broadly informed review of
registration decisions. In cases where a registration decision could
be perceived as creating a conflict of interest for a particular
MLS DE, that MLS DE <bcp14>SHOULD</bcp14> defer to the judgment of the other MLS DEs.</t>
      </section>
      <section anchor="the-messagemls-media-type">
        <name>The "message/mls" Media Type</name>
        <t>This document registers the "message/mls" media type in the "message" registry in order to allow other
protocols (e.g., HTTP <xref target="RFC9113"/>) to convey MLS messages.</t>
        <dl>
          <dt>Type name:</dt>
          <dd>message</dd>
          <dt>Subtype name:</dt>
          <dd>mls</dd>
          <dt>Required parameters:</dt>
          <dd>none</dd>
          <dt>Optional parameters:</dt>
          <dd>
            <dl>
              <dt>version</dt>
              <dd/>
              <dt>  version:</dt>
              <dd>The MLS protocol version expressed as a string
  <tt>&lt;major&gt;.&lt;minor&gt;</tt>.  If omitted, the version is "1.0", which
  corresponds to MLS ProtocolVersion mls10. If for some reason
  the version number in the media type parameter differs from the
  ProtocolVersion embedded in the protocol, the protocol takes
  precedence.</dd>
            </dl>
          </dd>
          <dt>Encoding considerations:</dt>
          <dd>MLS messages are represented using the TLS
presentation language <xref target="RFC8446"/>. Therefore, MLS messages need to be
treated as binary data.</dd>
          <dt>Security considerations:</dt>
          <dd>MLS is an encrypted messaging layer designed
to be transmitted over arbitrary lower-layer protocols. The
security considerations in this document (RFC 9420) also apply.</dd>
          <dt>Interoperability considerations:</dt>
          <dd>N/A</dd>
          <dt>Published specification:</dt>
          <dd>RFC 9420</dd>
          <dt>Applications that use this media type:</dt>
          <dd>MLS-based messaging applications</dd>
          <dt>Fragment identifier considerations:</dt>
          <dd>N/A</dd>
          <dt>Additional information:</dt>
          <dd>
            <t>
              <br/>
            </t>
            <dl indent="3" newline="false" spacing="compact">
              <dt>Deprecated alias names for this type:</dt>
              <dd>N/A</dd>
              <dt>Magic number(s):</dt>
              <dd>N/A</dd>
              <dt>File extension(s):</dt>
              <dd>N/A</dd>
              <dt>Macintosh file type code(s):</dt>
              <dd>N/A</dd>
            </dl>
          </dd>
        </dl>
        <dl>
          <dt>Person &amp; email address to contact for further information:</dt>
          <dd>
            <t>IETF MLS Working Group <eref brackets="angle" target="mailto:mls@ietf.org"/></t>
          </dd>
          <dt>Intended usage:</dt>
          <dd>
            <t>COMMON</t>
          </dd>
          <dt>Restrictions on usage:</dt>
          <dd>
            <t>N/A</t>
          </dd>
          <dt>Author:</dt>
          <dd>
            <t>IETF MLS Working Group</t>
          </dd>
          <dt>Change controller:</dt>
          <dd>
            <t>IETF</t>
          </dd>
        </dl>
      </section>
    </section>
  </middle>
  <back>
    <displayreference target="I-D.ietf-mls-architecture" to="MLS-ARCH"/>
    <displayreference target="I-D.irtf-cfrg-aead-limits" to="CFRG-AEAD-LIMITS"/>
    <references>
      <name>References</name>
      <references>
        <name>Normative References</name>
        <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.2119.xml"/>
        <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.8174.xml"/>
        <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.9180.xml"/>
        <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.8446.xml"/>
        <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.8126.xml"/>
        <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.2104.xml"/>
      </references>
      <references>
        <name>Informative References</name>
        <reference anchor="ART" target="https://eprint.iacr.org/2017/666.pdf">
          <front>
            <title>On Ends-to-Ends Encryption: Asynchronous Group Messaging with Strong Security Guarantees</title>
            <author fullname="Katriel Cohn-Gordon" initials="K." surname="Cohn-Gordon">
              <organization/>
            </author>
            <author fullname="Cas Cremers" initials="C." surname="Cremers">
              <organization/>
            </author>
            <author fullname="Luke Garratt" initials="L." surname="Garratt">
              <organization/>
            </author>
            <author fullname="Jon Millican" initials="J." surname="Millican">
              <organization/>
            </author>
            <author fullname="Kevin Milner" initials="K." surname="Milner">
              <organization/>
            </author>
            <date month="March" year="2020"/>
          </front>
          <refcontent>Version 2.3</refcontent>
          <seriesInfo name="DOI" value="10.1145/3243734.3243747"/>
        </reference>
        <reference anchor="DoubleRatchet">
          <front>
            <title>A Formal Security Analysis of the Signal Messaging Protocol</title>
            <author fullname="Katriel Cohn-Gordon" initials="K." surname="Cohn-Gordon">
              <organization/>
            </author>
            <author fullname="Cas Cremers" initials="C." surname="Cremers">
              <organization/>
            </author>
            <author fullname="Benjamin Dowling" initials="B." surname="Dowling">
              <organization/>
            </author>
            <author fullname="Luke Garratt" initials="L." surname="Garratt">
              <organization/>
            </author>
            <author fullname="Douglas Stebila" initials="D." surname="Stebila">
              <organization/>
            </author>
            <date month="April" year="2017"/>
          </front>
          <refcontent>2017 IEEE European Symposium on Security and Privacy (EuroS&amp;P)</refcontent>
          <seriesInfo name="DOI" value="10.1109/eurosp.2017.27"/>
        </reference>
        <reference anchor="Signal" target="https://www.signal.org/docs/specifications/doubleratchet/">
          <front>
            <title>The Double Ratchet Algorithm</title>
            <author fullname="Trevor Perrin(ed)" initials="T." surname="Perrin(ed)">
              <organization/>
            </author>
            <author fullname="Moxie Marlinspike" initials="M." surname="Marlinspike">
              <organization/>
            </author>
            <date month="November" year="2016"/>
          </front>
          <refcontent>Revision 1</refcontent>
        </reference>
        <reference anchor="SHS" target="https://doi.org/10.6028/NIST.FIPS.180-4">
          <front>
            <title>Secure Hash Standard (SHS)</title>
            <author>
              <organization>National Institute of Standards and Technology (NIST)</organization>
            </author>
            <date month="August" year="2015"/>
          </front>
          <seriesInfo name="FIPS PUB" value="180-4"/>
          <seriesInfo name="DOI" value="10.6028/NIST.FIPS.180-4"/>
        </reference>
        <reference anchor="NAN">
          <front>
            <title>Nonces Are Noticed: AEAD Revisited</title>
            <author fullname="Mihir Bellare" initials="M." surname="Bellare">
              <organization/>
            </author>
            <author fullname="Ruth Ng" initials="R." surname="Ng">
              <organization/>
            </author>
            <author fullname="Bj&#xF6;rn Tackmann" initials="B." surname="Tackmann">
              <organization/>
            </author>
            <date month="August" year="2019"/>
          </front>
          <refcontent>Advances in Cryptology - CRYPTO 2019, pp. 235-265</refcontent>
          <seriesInfo name="DOI" value="10.1007/978-3-030-26948-7_9"/>
        </reference>
        <reference anchor="CONIKS" target="https://www.usenix.org/system/files/conference/usenixsecurity15/sec15-paper-melara.pdf">
          <front>
            <title>CONIKS: Bringing Key Transparency to End Users</title>
            <author fullname="Marcela S. Melara" initials="M. S." surname="Melara">
              <organization/>
            </author>
            <author fullname="Aaron Blankstein" initials="A." surname="Blankstein">
              <organization/>
            </author>
            <author fullname="Joseph Bonneau" initials="J." surname="Bonneau">
              <organization/>
            </author>
            <author fullname="Edward W. Felten" initials="E. W." surname="Felten">
              <organization/>
            </author>
            <author fullname="Michael J. Freedman" initials="M. J." surname="Freedman">
              <organization/>
            </author>
            <date month="August" year="2015"/>
          </front>
          <refcontent>Proceedings of the 24th USENIX Security Symposium</refcontent>
          <refcontent>ISBN 978-1-939133-11-3</refcontent>
        </reference>
        <reference anchor="KT" target="https://github.com/google/keytransparency/blob/master/docs/design.md">
          <front>
            <title>Key Transparency Design Doc</title>
            <author>
              <organization/>
            </author>
            <date month="June" year="2020"/>
          </front>
          <refcontent>commit fb0f87f</refcontent>
        </reference>
        <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.9000.xml"/>
        <!--[I-D.ietf-mls-architecture] IESG state IESG Evaluation::Revised I-D Needed -->
        <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="https://datatracker.ietf.org/doc/bibxml3/reference.I-D.ietf-mls-architecture.xml"/>
        <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.5116.xml"/>
        <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.8032.xml"/>
        <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.6125.xml"/>
        <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.5905.xml"/>
        <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.7696.xml"/>
        <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.9113.xml"/>
        <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.8701.xml"/>
        <reference anchor="CLINIC">
          <front>
            <title>I Know Why You Went to the Clinic: Risks and Realization of HTTPS Traffic Analysis</title>
            <author fullname="Brad Miller" initials="B." surname="Miller">
              <organization/>
            </author>
            <author fullname="Ling Huang" initials="L." surname="Huang">
              <organization/>
            </author>
            <author fullname="A. D. Joseph" initials="A." surname="Joseph">
              <organization/>
            </author>
            <author fullname="J. D. Tygar" initials="J." surname="Tygar">
              <organization/>
            </author>
            <date year="2014"/>
          </front>
          <refcontent>Privacy Enhancing Technologies, pp. 143-163</refcontent>
          <seriesInfo name="DOI" value="10.1007/978-3-319-08506-7_8"/>
        </reference>
        <reference anchor="HCJ16">
          <front>
            <title>HTTPS traffic analysis and client identification using passive SSL/TLS fingerprinting</title>
            <author fullname="Martin Hus&#xE1;k" initials="M." surname="Hus&#xE1;k">
              <organization/>
            </author>
            <author fullname="Milan &#x10C;erm&#xE1;k" initials="M." surname="&#x10C;erm&#xE1;k">
              <organization/>
            </author>
            <author fullname="Tom&#xE1;&#x161; Jirs&#xED;k" initials="T." surname="Jirs&#xED;k">
              <organization/>
            </author>
            <author fullname="Pavel &#x10C;eleda" initials="P." surname="&#x10C;eleda">
              <organization/>
            </author>
            <date month="February" year="2016"/>
          </front>
          <refcontent>EURASIP Journal on Information Security, Vol. 2016, Issue 1</refcontent>
          <seriesInfo name="DOI" value="10.1186/s13635-016-0030-7"/>
        </reference>
        <!--[I-D.irtf-cfrg-aead-limits] IESG state I-D Exists -->
        <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="https://datatracker.ietf.org/doc/bibxml3/reference.I-D.irtf-cfrg-aead-limits.xml"/>
        <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="https://bib.ietf.org/public/rfc/bibxml/reference.RFC.9001.xml"/>
      </references>
    </references>
    <section anchor="protocol-origins-of-example-trees">
      <name>Protocol Origins of Example Trees</name>
      <t>Protocol operations in MLS give rise to specific forms of ratchet tree,
typically affecting a whole direct path at once.  In this section, we describe
the protocol operations that could have given rise to the various example trees
in this document.</t>
      <t>To construct the tree in <xref target="full-tree"/>:</t>
      <ul spacing="normal">
        <li>A creates a group with B, ..., G</li>
        <li>F sends an empty Commit, setting X, Y, and W</li>
        <li>G removes C and D, blanking V, U, and setting Y and W</li>
        <li>B sends an empty Commit, setting T and W</li>
      </ul>
      <t>To construct the tree in <xref target="resolution-tree"/>:</t>
      <ul spacing="normal">
        <li>A creates a group with B, ..., H, as well as some members outside this subtree</li>
        <li>F sends an empty Commit, setting Y and its ancestors</li>
        <li>
          <t>D removes B and C, with the following effects:
          </t>
          <ul spacing="normal">
            <li>Blank the direct paths of B and C</li>
            <li>Set X, the top node, and any further nodes in the direct path of D</li>
          </ul>
        </li>
        <li>Someone outside this subtree removes G, blanking the direct path of G</li>
        <li>A adds a new member at B with a partial Commit, adding B as unmerged at X</li>
      </ul>
      <t>To construct the tree in <xref target="evolution-tree"/>:</t>
      <ul spacing="normal">
        <li>A creates a group with B, C, and D</li>
        <li>B sends a full Commit, setting X and Y</li>
        <li>D removes C, setting Z and Y</li>
        <li>
          <t>B adds a new member at C with a full Commit
          </t>
          <ul spacing="normal">
            <li>The Add proposal adds C as unmerged at Z and Y</li>
            <li>The path in the Commit resets X and Y, clearing Y's unmerged leaves</li>
          </ul>
        </li>
      </ul>
      <t>To construct the tree in <xref target="parent-hash-tree"/>:</t>
      <ul spacing="normal">
        <li>A creates a group with B, ..., G</li>
        <li>A removes F in a full Commit, setting T, U, and W</li>
        <li>E sends an empty Commit, setting Y and W</li>
        <li>A adds a new member at F in a partial Commit, adding F as unmerged at Y and W</li>
      </ul>
    </section>
    <section anchor="ph-evolution">
      <name>Evolution of Parent Hashes</name>
      <t>To better understand how parent hashes are maintained, let's look in detail at
how they evolve in a small group.  Consider the following sequence of
operations:</t>
      <ol spacing="normal" type="1">
        <li>A initializes a new group</li>
        <li>A adds B to the group with a full Commit</li>
        <li>B adds C and D to the group with a full Commit</li>
        <li>C sends an empty Commit</li>
      </ol>
      <figure>
        <name>Building a Four-Member Tree to Illustrate Parent Hashes</name>
        <artset>
          <artwork type="svg">
            <svg xmlns="http://www.w3.org/2000/svg" class="diagram" font-family="monospace" font-size="13px" height="144" text-anchor="middle" version="1.1" viewBox="0 0 432 144" width="432">
              <path d="M 216,48 L 216,64" fill="none" stroke="black"/>
              <path d="M 376,48 L 376,64" fill="none" stroke="black"/>
              <path d="M 200,64 L 232,64" fill="none" stroke="black"/>
              <path d="M 360,64 L 392,64" fill="none" stroke="black"/>
              <path d="M 32,78 L 48,78" fill="none" stroke="black"/>
              <path d="M 32,82 L 48,82" fill="none" stroke="black"/>
              <path d="M 128,78 L 144,78" fill="none" stroke="black"/>
              <path d="M 128,82 L 144,82" fill="none" stroke="black"/>
              <path d="M 288,78 L 304,78" fill="none" stroke="black"/>
              <path d="M 288,82 L 304,82" fill="none" stroke="black"/>
              <path d="M 232,64 L 240,80" fill="none" stroke="black"/>
              <path d="M 252,104 L 256,112" fill="none" stroke="black"/>
              <path d="M 392,64 L 400,80" fill="none" stroke="black"/>
              <path d="M 192,80 L 200,64" fill="none" stroke="black"/>
              <path d="M 240,112 L 244,104" fill="none" stroke="black"/>
              <path d="M 352,80 L 360,64" fill="none" stroke="black"/>
              <polygon class="arrowhead" fill="black" points="312,80 300,74.4 300,85.6" transform="rotate(0,304,80)"/>
              <polygon class="arrowhead" fill="black" points="152,80 140,74.4 140,85.6" transform="rotate(0,144,80)"/>
              <polygon class="arrowhead" fill="black" points="56,80 44,74.4 44,85.6" transform="rotate(0,48,80)"/>
              <g class="text">
                <text x="216" y="36">Y</text>
                <text x="380" y="36">Y'</text>
                <text x="88" y="100">X</text>
                <text x="188" y="100">X'</text>
                <text x="256" y="100">_=Z</text>
                <text x="348" y="100">X'</text>
                <text x="412" y="100">Z'</text>
                <text x="80" y="116">/</text>
                <text x="96" y="116">\</text>
                <text x="176" y="116">/</text>
                <text x="192" y="116">\</text>
                <text x="336" y="116">/</text>
                <text x="352" y="116">\</text>
                <text x="400" y="116">/</text>
                <text x="416" y="116">\</text>
                <text x="8" y="132">A</text>
                <text x="72" y="132">A</text>
                <text x="104" y="132">B</text>
                <text x="168" y="132">A</text>
                <text x="200" y="132">B</text>
                <text x="232" y="132">C</text>
                <text x="264" y="132">D</text>
                <text x="328" y="132">A</text>
                <text x="360" y="132">B</text>
                <text x="392" y="132">C</text>
                <text x="424" y="132">D</text>
              </g>
            </svg>
          </artwork>
          <artwork type="ascii-art">
                          Y                   Y'
                          |                   |
                        .-+-.               .-+-.
   ==&gt;         ==&gt;     /     \     ==&gt;     /     \
          X           X'      _=Z         X'      Z'
         / \         / \     / \         / \     / \
A       A   B       A   B   C   D       A   B   C   D
</artwork>
        </artset>
      </figure>
      <t>Then the parent hashes associated to the nodes will be updated as follows (where
we use the shorthand <tt>ph</tt> for parent hash, <tt>th</tt> for tree hash, and <tt>osth</tt> for
original sibling tree hash):</t>
      <ol spacing="normal" type="1">
        <li>
          <t>A adds B: set X  </t>
          <ul spacing="normal">
            <li>
              <tt>A.parent_hash = ph(X) = H(X, ph="", osth=th(B))</tt>
            </li>
          </ul>
        </li>
        <li>
          <t>B adds C, D: set B', X', and Y  </t>
          <ul spacing="normal">
            <li><tt>X'.parent_hash = ph(Y)  = H(Y, ph="", osth=th(Z))</tt>,
where <tt>th(Z)</tt> covers <tt>(C, _, D)</tt></li>
            <li>
              <tt>B'.parent_hash = ph(X') = H(X', ph=X'.parent_hash, osth=th(A))</tt>
            </li>
          </ul>
        </li>
        <li>
          <t>C sends empty Commit: set C', Z', Y'  </t>
          <ul spacing="normal">
            <li><tt>Z'.parent_hash = ph(Y') = H(Y', ph="", osth=th(X'))</tt>, where
<tt>th(X')</tt> covers <tt>(A, X', B')</tt></li>
            <li>
              <tt>C'.parent_hash = ph(Z') = H(Z', ph=Z'.parent_hash, osth=th(D))</tt>
            </li>
          </ul>
        </li>
      </ol>
      <t>When a new member joins, they will receive a tree that has the following parent
hash values and compute the indicated parent hash validity relationships:</t>
      <table>
        <thead>
          <tr>
            <th align="left">Node</th>
            <th align="left">Parent Hash Value</th>
            <th align="left">Valid?</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td align="left">A</td>
            <td align="left">H(X, ph="", osth=th(B))</td>
            <td align="left">No, B changed</td>
          </tr>
          <tr>
            <td align="left">B'</td>
            <td align="left">H(X', ph=X'.parent_hash, osth=th(A))</td>
            <td align="left">Yes</td>
          </tr>
          <tr>
            <td align="left">C'</td>
            <td align="left">H(Z', ph=Z'.parent_hash, osth=th(D))</td>
            <td align="left">Yes</td>
          </tr>
          <tr>
            <td align="left">D</td>
            <td align="left">(none, never sent an UpdatePath)</td>
            <td align="left">N/A</td>
          </tr>
          <tr>
            <td align="left">X'</td>
            <td align="left">H(Y, ph="", osth=th(Z))</td>
            <td align="left">No, Y and Z changed</td>
          </tr>
          <tr>
            <td align="left">Z'</td>
            <td align="left">H(Y', ph="", osth=th(X'))</td>
            <td align="left">Yes</td>
          </tr>
        </tbody>
      </table>
      <t>In other words, the joiner will find the following path-hash links in the tree:</t>
      <figure>
        <name>Parent-hash links connect all non-empty parent nodes to leaves</name>
        <artset>
          <artwork type="svg">
            <svg xmlns="http://www.w3.org/2000/svg" class="diagram" font-family="monospace" font-size="13px" height="160" text-anchor="middle" version="1.1" viewBox="0 0 112 160" width="112">
              <path d="M 56,48 L 56,64" fill="none" stroke="black"/>
              <path d="M 56,64 L 72,64" fill="none" stroke="black"/>
              <path d="M 72,64 L 80,80" fill="none" stroke="black"/>
              <g class="text">
                <text x="60" y="36">Y'</text>
                <text x="28" y="100">X'</text>
                <text x="92" y="100">Z'</text>
                <text x="32" y="116">\</text>
                <text x="80" y="116">/</text>
                <text x="8" y="132">A</text>
                <text x="44" y="132">B'</text>
                <text x="76" y="132">C'</text>
                <text x="104" y="132">D</text>
              </g>
            </svg>
          </artwork>
          <artwork type="ascii-art">
       Y'
       |
       +-.
          \
   X'      Z'
    \     /
 A   B'  C'  D
</artwork>
        </artset>
      </figure>
      <t>Since these chains collectively cover all non-blank parent nodes in the tree,
the tree is parent-hash valid.</t>
      <t>Note that this tree, though valid, contains invalid parent-hash links. If a
client were checking parent hashes top-down from Y', for example, they would
find that X' has an invalid parent hash relative to Y', but that Z' has a valid
parent hash.  Likewise, if the client were checking bottom-up, they would find
that the chain from B' ends in an invalid link from X' to Y'.  These invalid
links are the natural result of multiple clients having committed.</t>
      <t>Note also the way the tree hash and the parent hash interact.  The parent hash
of node C' includes the tree hash of node D.  The parent hash of node Z'
includes the tree hash of X', which covers nodes A and B' (including the parent
hash of B').  Although the tree hash and the parent hash depend on each other,
the dependency relationships are structured so that there is never a circular
dependency.</t>
      <t>In the particular case where a new member first receives the tree for a group
(e.g., in a ratchet tree GroupInfo extension <xref target="ratchet-tree-extension"/>), the
parent hashes will be expressed in the tree representation, but the tree hash
need not be.  Instead, the new member will recompute the tree hashes for all the
nodes in the tree, verifying that this matches the tree hash in the GroupInfo
object.  If the tree is valid, then the subtree hashes computed in this
way will align with the inputs needed for parent hash validation (except where
recomputation is needed to account for unmerged leaves).</t>
    </section>
    <section anchor="array-based-trees">
      <name>Array-Based Trees</name>
      <t>One benefit of using complete balanced trees is that they admit a simple
flat array representation.  In this representation, leaf nodes are
even-numbered nodes, with the <tt>n</tt>-th leaf at <tt>2*n</tt>.  Intermediate nodes
are held in odd-numbered nodes.  For example, the tree with 8 leaves has
the following structure:</t>
      <figure>
        <name>An Eight-Member Tree Represented as an Array</name>
        <artset>
          <artwork type="svg">
            <svg xmlns="http://www.w3.org/2000/svg" class="diagram" font-family="monospace" font-size="13px" height="288" text-anchor="middle" version="1.1" viewBox="0 0 400 288" width="400">
              <path d="M 128,112 L 128,128" fill="none" stroke="black"/>
              <path d="M 224,48 L 224,64" fill="none" stroke="black"/>
              <path d="M 320,112 L 320,128" fill="none" stroke="black"/>
              <path d="M 144,64 L 304,64" fill="none" stroke="black"/>
              <path d="M 96,128 L 160,128" fill="none" stroke="black"/>
              <path d="M 288,128 L 352,128" fill="none" stroke="black"/>
              <path d="M 88,176 L 96,192" fill="none" stroke="black"/>
              <path d="M 160,128 L 168,144" fill="none" stroke="black"/>
              <path d="M 184,176 L 192,192" fill="none" stroke="black"/>
              <path d="M 280,176 L 288,192" fill="none" stroke="black"/>
              <path d="M 304,64 L 312,80" fill="none" stroke="black"/>
              <path d="M 352,128 L 360,144" fill="none" stroke="black"/>
              <path d="M 376,176 L 384,192" fill="none" stroke="black"/>
              <path d="M 64,192 L 72,176" fill="none" stroke="black"/>
              <path d="M 88,144 L 96,128" fill="none" stroke="black"/>
              <path d="M 136,80 L 144,64" fill="none" stroke="black"/>
              <path d="M 160,192 L 168,176" fill="none" stroke="black"/>
              <path d="M 256,192 L 264,176" fill="none" stroke="black"/>
              <path d="M 280,144 L 288,128" fill="none" stroke="black"/>
              <path d="M 352,192 L 360,176" fill="none" stroke="black"/>
              <g class="text">
                <text x="224" y="36">X</text>
                <text x="128" y="100">X</text>
                <text x="320" y="100">X</text>
                <text x="80" y="164">X</text>
                <text x="176" y="164">X</text>
                <text x="272" y="164">X</text>
                <text x="368" y="164">X</text>
                <text x="56" y="212">X</text>
                <text x="104" y="212">X</text>
                <text x="152" y="212">X</text>
                <text x="200" y="212">X</text>
                <text x="248" y="212">X</text>
                <text x="296" y="212">X</text>
                <text x="344" y="212">X</text>
                <text x="392" y="212">X</text>
                <text x="24" y="244">Node:</text>
                <text x="56" y="244">0</text>
                <text x="80" y="244">1</text>
                <text x="104" y="244">2</text>
                <text x="128" y="244">3</text>
                <text x="152" y="244">4</text>
                <text x="176" y="244">5</text>
                <text x="200" y="244">6</text>
                <text x="224" y="244">7</text>
                <text x="248" y="244">8</text>
                <text x="272" y="244">9</text>
                <text x="292" y="244">10</text>
                <text x="316" y="244">11</text>
                <text x="340" y="244">12</text>
                <text x="364" y="244">13</text>
                <text x="388" y="244">14</text>
                <text x="24" y="276">Leaf:</text>
                <text x="56" y="276">0</text>
                <text x="104" y="276">1</text>
                <text x="152" y="276">2</text>
                <text x="200" y="276">3</text>
                <text x="248" y="276">4</text>
                <text x="296" y="276">5</text>
                <text x="344" y="276">6</text>
                <text x="392" y="276">7</text>
              </g>
            </svg>
          </artwork>
          <artwork type="ascii-art">
                           X
                           |
                 .---------+---------.
                /                     \
               X                       X
               |                       |
           .---+---.               .---+---.
          /         \             /         \
         X           X           X           X
        / \         / \         / \         / \
       /   \       /   \       /   \       /   \
      X     X     X     X     X     X     X     X

Node: 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14

Leaf: 0     1     2     3     4     5     6     7
</artwork>
        </artset>
      </figure>
      <t>This allows us to compute relationships between tree nodes simply by
manipulating indices, rather than having to maintain complicated structures in
memory. The basic rule is that the high-order bits of parent and child nodes
indices have the following relation (where <tt>x</tt> is an arbitrary bit string):</t>
      <sourcecode type="pseudocode">
parent=01x =&gt; left=00x, right=10x
</sourcecode>
      <t>Since node relationships are implicit, the algorithms for adding and removing
nodes at the right edge of the tree are quite simple.  If there are <tt>N</tt> nodes in
the array:</t>
      <ul spacing="normal">
        <li>Add: Append <tt>N + 1</tt> blank values to the end of the array.</li>
        <li>Remove: Truncate the array to its first <tt>(N-1) / 2</tt> entries.</li>
      </ul>
      <t>The following python code demonstrates the tree computations necessary to use an
array-based tree for MLS.</t>
      <sourcecode type="python">
# The exponent of the largest power of 2 less than x. Equivalent to:
#   int(math.floor(math.log(x, 2)))
def log2(x):
    if x == 0:
        return 0

    k = 0
    while (x &gt;&gt; k) &gt; 0:
        k += 1
    return k-1

# The level of a node in the tree. Leaves are level 0, their parents
# are level 1, etc. If a node's children are at different levels,
# then its level is the max level of its children plus one.
def level(x):
    if x &amp; 0x01 == 0:
        return 0

    k = 0
    while ((x &gt;&gt; k) &amp; 0x01) == 1:
        k += 1
    return k

# The number of nodes needed to represent a tree with n leaves.
def node_width(n):
    if n == 0:
        return 0
    else:
        return 2*(n - 1) + 1

# The index of the root node of a tree with n leaves.
def root(n):
    w = node_width(n)
    return (1 &lt;&lt; log2(w)) - 1

# The left child of an intermediate node.
def left(x):
    k = level(x)
    if k == 0:
        raise Exception('leaf node has no children')

    return x ^ (0x01 &lt;&lt; (k - 1))

# The right child of an intermediate node.
def right(x):
    k = level(x)
    if k == 0:
        raise Exception('leaf node has no children')

    return x ^ (0x03 &lt;&lt; (k - 1))

# The parent of a node.
def parent(x, n):
    if x == root(n):
        raise Exception('root node has no parent')

    k = level(x)
    b = (x &gt;&gt; (k + 1)) &amp; 0x01
    return (x | (1 &lt;&lt; k)) ^ (b &lt;&lt; (k + 1))

# The other child of the node's parent.
def sibling(x, n):
    p = parent(x, n)
    if x &lt; p:
        return right(p)
    else:
        return left(p)

# The direct path of a node, ordered from leaf to root.
def direct_path(x, n):
    r = root(n)
    if x == r:
        return []

    d = []
    while x != r:
        x = parent(x, n)
        d.append(x)
    return d

# The copath of a node, ordered from leaf to root.
def copath(x, n):
    if x == root(n):
        return []

    d = direct_path(x, n)
    d.insert(0, x)
    d.pop()
    return [sibling(y, n) for y in d]

# The common ancestor of two nodes is the lowest node that is in the
# direct paths of both leaves.
def common_ancestor_semantic(x, y, n):
    dx = set([x]) | set(direct_path(x, n))
    dy = set([y]) | set(direct_path(y, n))
    dxy = dx &amp; dy
    if len(dxy) == 0:
        raise Exception('failed to find common ancestor')

    return min(dxy, key=level)

# The common ancestor of two nodes is the lowest node that is in the
# direct paths of both leaves.
def common_ancestor_direct(x, y, _):
    # Handle cases where one is an ancestor of the other
    lx, ly = level(x)+1, level(y)+1
    if (lx &lt;= ly) and (x&gt;&gt;ly == y&gt;&gt;ly):
      return y
    elif (ly &lt;= lx) and (x&gt;&gt;lx == y&gt;&gt;lx):
      return x

    # Handle other cases
    xn, yn = x, y
    k = 0
    while xn != yn:
       xn, yn = xn &gt;&gt; 1, yn &gt;&gt; 1
       k += 1
    return (xn &lt;&lt; k) + (1 &lt;&lt; (k-1)) - 1
</sourcecode>
    </section>
    <section anchor="link-based-trees">
      <name>Link-Based Trees</name>
      <t>An implementation may choose to store ratchet trees in a "link-based"
representation, where each node stores references to its parents and/or
children (as opposed to the array-based representation suggested above, where
these relationships are computed from relationships between nodes' indices in
the array). Such an implementation needs to update these links to maintain the
balanced structure of the tree as the tree is extended to add new members
or truncated when members are removed.</t>
      <t>The following code snippet shows how these algorithms could be implemented in
Python.</t>
      <sourcecode type="python">
class Node:
    def __init__(self, value, left=None, right=None):
        self.value = value    # Value of the node
        self.left = left      # Left child node
        self.right = right    # Right child node

    @staticmethod
    def blank_subtree(depth):
        if depth == 1:
            return Node(None)

        L = Node.blank_subtree(depth-1)
        R = Node.blank_subtree(depth-1)
        return Node(None, left=L, right=R)

    def empty(self):
        L_empty = (self.left == None) or self.left.empty()
        R_empty = (self.right == None) or self.right.empty()
        return (self.value == None) and L_empty and R_empty

class Tree:
    def __init__(self):
        self.depth = 0    # Depth of the tree
        self.root = None  # Root node of the tree, initially empty

    # Add a blank subtree to the right
    def extend(self):
        if self.depth == 0:
            self.depth = 1
            self.root = Node(None)

        L = self.root
        R = Node.blank_subtree(self.depth)
        self.root = Node(None, left=L, right=R)
        self.depth += 1

    # Truncate the right subtree
    def truncate(self):
        if self.root == None:
            return

        if not self.root.right.empty():
            raise Exception("Cannot truncate non-blank subtree")

        self.depth -= 1
        self.root = self.root.left
</sourcecode>
    </section>
    <section anchor="contributors" numbered="false" removeInRFC="false" toc="include">
      <name>Contributors</name>
      <contact fullname="Joel Alwen">
        <organization>Amazon</organization>
        <address>
          <email>alwenjo@amazon.com</email>
        </address>
      </contact>
      <contact fullname="Karthikeyan Bhargavan">
        <organization>Inria</organization>
        <address>
          <email>karthikeyan.bhargavan@inria.fr</email>
        </address>
      </contact>
      <contact fullname="Cas Cremers">
        <organization>CISPA</organization>
        <address>
          <email>cremers@cispa.de</email>
        </address>
      </contact>
      <contact fullname="Alan Duric">
        <organization>Wire</organization>
        <address>
          <email>alan@wire.com</email>
        </address>
      </contact>
      <contact fullname="Britta Hale">
        <organization>Naval Postgraduate School</organization>
        <address>
          <email>britta.hale@nps.edu</email>
        </address>
      </contact>
      <contact fullname="Srinivas Inguva">
        <organization/>
        <address>
          <email>singuva@yahoo.com</email>
        </address>
      </contact>
      <contact fullname="Konrad Kohbrok">
        <organization>Phoenix R&amp;D</organization>
        <address>
          <email>konrad.kohbrok@datashrine.de</email>
        </address>
      </contact>
      <contact fullname="Albert Kwon">
        <organization>MIT</organization>
        <address>
          <email>kwonal@mit.edu</email>
        </address>
      </contact>
      <contact fullname="Tom Leavy">
        <organization>Amazon</organization>
        <address>
          <email>tomleavy@amazon.com</email>
        </address>
      </contact>
      <contact fullname="Brendan McMillion">
        <organization/>
        <address>
          <email>brendanmcmillion@gmail.com</email>
        </address>
      </contact>
      <contact fullname="Marta Mularczyk">
        <organization>Amazon</organization>
        <address>
          <email>mulmarta@amazon.com</email>
        </address>
      </contact>
      <contact fullname="Eric Rescorla">
        <organization>Mozilla</organization>
        <address>
          <email>ekr@rtfm.com</email>
        </address>
      </contact>
      <contact fullname="Michael Rosenberg">
        <organization>Trail of Bits</organization>
        <address>
          <email>michael.rosenberg@trailofbits.com</email>
        </address>
      </contact>
      <contact fullname="Th&#xE9;ophile Wallez">
        <organization>Inria</organization>
        <address>
          <email>theophile.wallez@inria.fr</email>
        </address>
      </contact>
      <contact fullname="Thyla van der Merwe">
        <organization>Royal Holloway, University of London</organization>
        <address>
          <email>tjvdmerwe@gmail.com</email>
        </address>
      </contact>
    </section>
  </back>
</rfc>

