{
  "magic": "E!vIA5L86J2I",
  "timestamp": "2024-02-01T01:12:35.562804+00:00",
  "repo": "mlswg/mls-protocol",
  "labels": [
    {
      "name": "bug",
      "description": "",
      "color": "ce373a"
    },
    {
      "name": "duplicate",
      "description": "",
      "color": "ffffff"
    },
    {
      "name": "enhancement",
      "description": "",
      "color": "95c9f4"
    },
    {
      "name": "help wanted",
      "description": "",
      "color": "73e29a"
    },
    {
      "name": "invalid",
      "description": "",
      "color": "ffffff"
    },
    {
      "name": "question",
      "description": "",
      "color": "d4dd54"
    },
    {
      "name": "wontfix",
      "description": "",
      "color": "ffffff"
    },
    {
      "name": "editorial",
      "description": "",
      "color": "ffc6d6"
    },
    {
      "name": "security",
      "description": "",
      "color": "ce373a"
    },
    {
      "name": "recommendation",
      "description": "",
      "color": "f7c9b7"
    },
    {
      "name": "work in progress",
      "description": "",
      "color": "08768e"
    },
    {
      "name": "terminology",
      "description": "",
      "color": "ffc6d6"
    },
    {
      "name": "weekly-digest",
      "description": "",
      "color": "ffffff"
    },
    {
      "name": "privacy",
      "description": "",
      "color": "ce373a"
    },
    {
      "name": "performance",
      "description": "",
      "color": "2c52aa"
    },
    {
      "name": "? stall",
      "description": "",
      "color": "FFFFFF"
    },
    {
      "name": "discussion",
      "description": "",
      "color": "08768e"
    },
    {
      "name": "functionality",
      "description": "",
      "color": "95c9f4"
    },
    {
      "name": "? follow-up",
      "description": "",
      "color": "ffffff"
    },
    {
      "name": "ready to merge",
      "description": "",
      "color": "08768e"
    },
    {
      "name": "ready for review (by editors)",
      "description": "",
      "color": "08768e"
    },
    {
      "name": "? invalid",
      "description": "",
      "color": "ffffff"
    },
    {
      "name": "build",
      "description": "",
      "color": "fcd058"
    },
    {
      "name": "today! (?)",
      "description": "Things that can probably be dispatched on today's call",
      "color": "c2e0c6"
    },
    {
      "name": "key schedule",
      "description": "",
      "color": "0052cc"
    },
    {
      "name": "analysis",
      "description": "",
      "color": "ce373a"
    },
    {
      "name": "interoperability",
      "description": "",
      "color": "2c52aa"
    },
    {
      "name": "ready for PR",
      "description": "",
      "color": "1C8340"
    },
    {
      "name": "discuss",
      "description": "",
      "color": "B60205"
    },
    {
      "name": "comment",
      "description": "",
      "color": "FBCA04"
    },
    {
      "name": "nit",
      "description": "",
      "color": "CCCCCC"
    },
    {
      "name": "review",
      "description": "",
      "color": "C5DEF5"
    },
    {
      "name": "to close",
      "description": "",
      "color": "333333"
    }
  ],
  "issues": [
    {
      "number": 7,
      "id": "MDU6SXNzdWUyOTA0NjMwNzM=",
      "title": "Discuss all the *ART deletion options",
      "url": "https://github.com/mlswg/mls-protocol/issues/7",
      "state": "CLOSED",
      "author": "katrielalex",
      "authorAssociation": "MEMBER",
      "assignees": [
        "jmillican"
      ],
      "labels": [
        "wontfix",
        "functionality"
      ],
      "body": "We talked about quite a number of different ways to do deletion in *ART groups. Give at least a high-level overview of the main ones, and mention their pros and cons. These include:\r\n\r\n- just rebuild the tree\r\n  - Pros: simple, easy, no extra operations\r\n  - Cons: inefficient, puts the deleter in a trusted position in the group until _every_ remaining member has updated\r\n- update deletee's key to blank\r\n  - Pros: fairly simple, no extra operations\r\n  - Cons: puts the deleter in a trusted position until the sibling or cousin of the deletee has updated\r\n- send a delete secret over pairwise channels\r\n  - Pros: no trusted positions\r\n  - Cons: O(N), leaves a potentially-compromised leaf node in the tree\r\n- send a delete secret by KEMing to everyone else\r\n  - Pros: no trusted positions, efficient\r\n  - Cons: leaves a potentially-compromised leaf node in the tree, multiple deletes interact in a complex way",
      "createdAt": "2018-01-22T13:20:52Z",
      "updatedAt": "2019-12-17T10:42:13Z",
      "closedAt": "2019-01-07T22:55:25Z",
      "comments": [
        {
          "author": "katrielalex",
          "authorAssociation": "MEMBER",
          "body": "I don't quite follow the deletion algorithm that's in there at the moment. Does it require double-join bookkeeping, @bifurcation? If so I can add a note about that.",
          "createdAt": "2018-01-29T15:50:07Z",
          "updatedAt": "2018-01-29T15:50:07Z"
        },
        {
          "author": "jmillican",
          "authorAssociation": "COLLABORATOR",
          "body": "I'm going to look at clarifying deletion in the doc; but essentially we're going for replace-then-blank in this initial draft. Keeping punctured trees is an option we should discuss once it's out there.",
          "createdAt": "2018-01-30T01:12:55Z",
          "updatedAt": "2018-01-30T01:12:55Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "@katrielalex I think the algorithm in #59 is explicitly double-joined.  When I get time, I'll file another PR to move to the delete-without-double-join algorithm I posted to the list (i.e., puncture the tree).",
          "createdAt": "2018-09-10T22:10:45Z",
          "updatedAt": "2018-09-10T22:10:45Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Since we're no longer using ART, I think this issue is no longer relevant.",
          "createdAt": "2019-01-07T22:55:25Z",
          "updatedAt": "2019-01-07T22:55:25Z"
        }
      ]
    },
    {
      "number": 21,
      "id": "MDU6SXNzdWUyOTMyNDk0NjM=",
      "title": "Trivial DoS by a malicious client",
      "url": "https://github.com/mlswg/mls-protocol/issues/21",
      "state": "CLOSED",
      "author": "katrielalex",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "functionality",
        "? follow-up"
      ],
      "body": "At the end of the London meetup we discussed a potential problem: malicious clients can send a bad copath (e.g. just random group elements), which will totally screw up the group state of anyone who processes the update. This was not considered a valid attack in ART, which does not consider malicious clients or DoS, but is more of a problem here. In particular, one can imagine a group with the convention \"invite anybody, delete people who misbehave\" (e.g. like many IRC channels).\r\n\r\nThere are a few ways to handle this:\r\n\r\n- Ignore it: if you add someone malicious and they screw up your group state, well, you shouldn't have done that.\r\n- Wait for confirmation: when you receive a copath, don't trust it until someone else from the other part of the tree has sent an update, proving that they know the new DH value.\r\n- Something else",
      "createdAt": "2018-01-31T17:40:36Z",
      "updatedAt": "2019-12-17T10:41:26Z",
      "closedAt": "2019-10-30T21:51:36Z",
      "comments": [
        {
          "author": "cascremers",
          "authorAssociation": "COLLABORATOR",
          "body": "I think as Richard suggested in the London meeting, there may be a\r\nrelatively simple way to leverage log N zero knowledge proofs here. From\r\nthe top of my head, at the lowest level, the thing to prove is that a\r\nkey on the copath is in fact g^(a b') for a secret new b' and known g^b'\r\nand g^a, without revealing b'. If we can make this work, it probably can\r\nbe made to work for the whole copath.\r\n",
          "createdAt": "2018-01-31T23:35:36Z",
          "updatedAt": "2018-02-01T06:53:20Z"
        },
        {
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "body": "Since the model for TreeKEM is \"replace the public key for node X by encrypting the new private key to one of the child public keys\", you could prevent malicious key updates with publicly verifiable key escrow. The Delivery Service would verify the escrow and could then discard the proof -- users don't need to check it.\r\n\r\nThere's a construction for non-ECC Diffie-Hellman [here](https://link.springer.com/content/pdf/10.1007/3-540-68339-9_17.pdf). I was also looking at [NTRUEncrypt](https://en.wikipedia.org/wiki/NTRUEncrypt) and you could probably do key escrow like this:\r\n\r\n1. Encrypt the new private key `(f, g)` to public key `h` in two separate ciphertexts:\r\n    `e_1 = r_1*h + f` and `e_2 = r_2*h + g`\r\n    and publish the new public key:\r\n    `h' = p * f_q * g`\r\n2. User provides Pedersen commitments on an Elliptic Curve to the coefficients of `r_1` and `r_2`.\r\n3. User proves that the commitments are all to small values, -1 / 0 / 1.\r\n4. DS can use knowledge of `e_{1,2}` and `h` to derive commitments to `f` and `g`.\r\n5. User proves that these commitments are all to small values as well.\r\n6. DS derives a secondary commitment to `g` by following `g = f * (1/p) * h'` with its commitment to `f`.\r\n7. User proves that the two commitments to `g` are equivalent.\r\n\r\nSecond encryption of the same private key to a different public key:\r\n1. User provides Pedersen commitments on an Elliptic Curve to the coefficients of `r_3` and `r_4`.\r\n2. DS uses knowledge of `e_{3,4}` and `h_2` to derive commitments to `f` and `g`.\r\n3. User proves that these commitments are the same as the first commitments to `f` and `g`.\r\n\r\nI think proof size is around 200-300kb. Pedersen commitments are computationally binding and perfectly hiding, so I can't *currently* forge a proof and a *future* quantum computer can't use the commitments to decrypt the private key.",
          "createdAt": "2018-10-08T20:47:33Z",
          "updatedAt": "2018-10-08T20:47:33Z"
        },
        {
          "author": "grittygrease",
          "authorAssociation": "NONE",
          "body": "Another option that was discussed at the second interim is to use message franking to achieve a weaker property: the ability to prove to the server and other group members that a bad update was sent retroactively.  This doesn't allow the server to block broken updates from being distributed but does allow a broken member to report that the group has been split. This has the downside that there is no good general recovery strategy other than tearing down the group.\r\n\r\nNote: This would only protect against KEMing the wrong secret key to the correct public key (The DoS scenario), not KEMing to the wrong public key.",
          "createdAt": "2019-01-15T22:45:23Z",
          "updatedAt": "2019-01-15T22:45:23Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "On further discussion, two options:\r\n\r\n* ECIES uses committing AEAD, and the reporting party reveals the ephemeral symmetric key\r\n* Add a DLEQ proof of the ephemeral symmetric key\r\n* If the public key encryption scheme is determinstic given some randomness, you could reveal the randomness\r\n\r\nIn either case, the reporting party reveals the (incorrect) secret that was ECIES encrypted to it.",
          "createdAt": "2019-01-15T23:00:00Z",
          "updatedAt": "2019-01-15T23:05:42Z"
        },
        {
          "author": "grittygrease",
          "authorAssociation": "NONE",
          "body": "I sat down and white-boarded this with some colleagues and I *think* we came up with something that works. I would love someone to poke a hole in it immediately. I came up with one attack below and a potential mitigation.\r\n\r\nModifications to the protocol:\r\n- Every update message for a node should additionally include a salted hash of the secret value of that node (e.g. H(H(k), salt) or H(H^5(k), salt)). Given an \"incorrect\" node secret value, a verifier can use this to find an inconsistent node message.\r\n- Adding a Schnorr NIZK of knowledge (RFC 8235) of the random value *r* with every ECIES ciphertext \r\n\r\nSay node A with the private key *a* (and public key *aP) was given an incorrect update consisting of an ECIES ciphertext: (c, rP), where *c* is the encryption of the node secret, *r* is the random value and *P* is the public group point. Node A can provide a proof that this value is inconsistent with the other updates in the tree without revealing their private key with the following reveal:\r\n\r\narP, DLEQ(arP:rP :: P:aP)\r\n\r\nWith this information, any validator would compute k = KDF(arP), decrypt *c* with *k*, then know the node secret that was encrypted to node A. Since this node secret is bogus, they would hash it upwards with the public salt and compare with the salted hashes provided with the other updates until the discrepancy is found.\r\n\r\n\r\nWhy the Schnorr NIZK is necessary:\r\nAt first look, this seemed to be a valid solution since the DLEQ proof prevented A from lying about their ECIES key in the computation of k. However, while writing this down, I came up with a potential adversarial construction that makes this reveal more dangerous. A crafty adversary could choose the random value *r* to be related to a previously used random value in such a way that revealing arP would compromise a previous group state. For example, say that a previous update to A used the random value *r* (and therefore rP is public). The attacker B could choose the random value rP that they would include as part of their ECIES ciphertext to be rP+P = (r+1)P and a random ciphertext c. In this case, party A would be forced to reveal a(r+1)P, which anyone can subtract a known public value for aP to get arP, which was used to protect previous group state. This makes it far less likely that A would report the attack since doing so would reveal the previous group state and compromise confidentiality. The Schnorr NIZK proves that an rP chosen by the attacker can't just be a manipulation of previous r values. They really have to know r. The caveat here is that the attacker can still choose the same r as in a previous message and break confidentiality, but repeated r values should be strictly disallowed anyway.\r\n",
          "createdAt": "2019-01-18T01:16:58Z",
          "updatedAt": "2019-01-18T01:16:58Z"
        }
      ]
    },
    {
      "number": 35,
      "id": "MDU6SXNzdWUyOTM2OTU4OTU=",
      "title": "Fix Terminology alignment",
      "url": "https://github.com/mlswg/mls-protocol/issues/35",
      "state": "CLOSED",
      "author": "beurdouche",
      "authorAssociation": "MEMBER",
      "assignees": [
        "beurdouche"
      ],
      "labels": [
        "terminology"
      ],
      "body": "We need to discuss and agree on consistent definitions and terminology across documents.\r\nI'll implement the changes for -02",
      "createdAt": "2018-02-01T21:49:39Z",
      "updatedAt": "2019-12-17T10:41:05Z",
      "closedAt": "2018-10-14T12:25:44Z",
      "comments": [
        {
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "body": "The Architecture document is moving to use the same terminology as the Protocol document\r\nhttps://github.com/mlswg/mls-architecture/pull/40\r\n\r\nClosing here.",
          "createdAt": "2018-10-14T12:25:44Z",
          "updatedAt": "2018-10-14T12:25:44Z"
        }
      ]
    },
    {
      "number": 47,
      "id": "MDU6SXNzdWUzMDI5Nzk4NDU=",
      "title": "Possible typo in diagram?",
      "url": "https://github.com/mlswg/mls-protocol/issues/47",
      "state": "CLOSED",
      "author": "sylph01",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "Please correct me if my understanding is wrong:\r\n\r\n* The diagram of \"user-initiated join\" shows `UserAdd(.->D)` and `state.add(D)` initiated by user `Z`. Isn't it `UserAdd(.->Z)` and `state.add(Z)`?\r\n* The diagram of Update shows `Update(A)` message from server telling A and B to `state.upd(D)` and Z to `state.upd(A)`. Shouldn't all of them be `state.upd(A)`, because A initiated the update?",
      "createdAt": "2018-03-07T06:30:37Z",
      "updatedAt": "2019-12-17T10:40:54Z",
      "closedAt": "2018-07-16T16:50:11Z",
      "comments": [
        {
          "author": "josephlhall",
          "authorAssociation": "CONTRIBUTOR",
          "body": "+1 I was going to fix this with a PR today but some of these ladder diagrams are just mysterious enough to make it probably something @bifurcation should look at in his copious free time.",
          "createdAt": "2018-07-15T13:56:40Z",
          "updatedAt": "2018-07-15T13:56:40Z"
        },
        {
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "body": "Fixed in https://github.com/ekr/mls-protocol/commit/c81dd324d4e8a894766d5965c78f6d4ad68907ad ...\r\nThanks ! :)",
          "createdAt": "2018-07-16T16:50:11Z",
          "updatedAt": "2018-07-16T16:50:30Z"
        }
      ]
    },
    {
      "number": 57,
      "id": "MDU6SXNzdWUzNTM5ODY0NTk=",
      "title": "When can we use it?",
      "url": "https://github.com/mlswg/mls-protocol/issues/57",
      "state": "CLOSED",
      "author": "cbwang2016",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "question"
      ],
      "body": "I can't wait to see the implementations. ",
      "createdAt": "2018-08-25T05:52:41Z",
      "updatedAt": "2019-12-17T10:40:44Z",
      "closedAt": "2018-09-10T22:09:25Z",
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks for the enthusiasm, but I don't think this is a spec issue :)\r\n\r\n",
          "createdAt": "2018-09-10T22:09:25Z",
          "updatedAt": "2018-09-10T22:09:25Z"
        }
      ]
    },
    {
      "number": 70,
      "id": "MDU6SXNzdWUzNjk4NTc5NzU=",
      "title": "s5.1. _subtree_ definition",
      "url": "https://github.com/mlswg/mls-protocol/issues/70",
      "state": "CLOSED",
      "author": "seanturner",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "I think there's something missing from the following sentence in s5.1:\r\n\r\n    A _subtree_ of a tree is the tree given by the descendants of any\r\n    node, the _head_ of the subtree The _size_ of a tree or subtree is\r\n    the number of leaf nodes it contains.",
      "createdAt": "2018-10-14T01:34:41Z",
      "updatedAt": "2019-01-07T22:54:30Z",
      "closedAt": "2019-01-07T22:54:30Z",
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "It's a missing period.  This is fixed in master now, not sure which commit.",
          "createdAt": "2019-01-07T22:54:30Z",
          "updatedAt": "2019-01-07T22:54:30Z"
        }
      ]
    },
    {
      "number": 76,
      "id": "MDU6SXNzdWUzNzMwMzk4MjQ=",
      "title": "Retry considerations",
      "url": "https://github.com/mlswg/mls-protocol/issues/76",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "enhancement",
        "recommendation",
        "performance"
      ],
      "body": "We have some text about how Handshake messages need to be sequenced, but clients will need some retry logic to deal with cases where there's a gap between the premise for their action and the state of the group when the action can be taken.  We should describe the logic a client should follow for retrying with each of the available operations.  For example, Update can just be retried, but Add and Remove should be checked for duplication before retrying.",
      "createdAt": "2018-10-23T14:44:39Z",
      "updatedAt": "2020-01-31T15:13:53Z",
      "closedAt": "2020-01-31T15:13:53Z",
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Notes from interim 2019-01:\r\n* Unclear whether this should be done in the protocol or the architecture document.\r\n* For cases where the server assists / rejects messages, should that be part of the protocol?",
          "createdAt": "2019-01-14T18:21:14Z",
          "updatedAt": "2019-01-14T18:21:14Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "I think this issue falls under the same general conclusion as #92 (handle in a follow-on specification).",
          "createdAt": "2020-01-31T15:13:52Z",
          "updatedAt": "2020-01-31T15:13:52Z"
        }
      ]
    },
    {
      "number": 86,
      "id": "MDU6SXNzdWUzOTg2MDk1MzQ=",
      "title": "Add-in-Place / Garbage Collection",
      "url": "https://github.com/mlswg/mls-protocol/issues/86",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "bifurcation"
      ],
      "labels": [
        "performance"
      ],
      "body": "Currently, the tree only ever grows:\r\n\r\n* When you add someone, you have to add them at the right edge, even if there are blank leaves\r\n* When you remove someone, the tree never shrinks\r\n\r\nWe should enable reclaiming of blank leaves and automatically reduce the size of the tree to the minimum necessary size.",
      "createdAt": "2019-01-13T01:35:29Z",
      "updatedAt": "2019-12-17T10:40:25Z",
      "closedAt": "2019-03-06T08:44:27Z",
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "After discussion at 2019-01 interim: Agreement that this seems OK as long as we can verify that the tree invariant holds when you truncate the tree.",
          "createdAt": "2019-01-15T22:38:41Z",
          "updatedAt": "2019-01-15T22:38:41Z"
        }
      ]
    },
    {
      "number": 87,
      "id": "MDU6SXNzdWUzOTg2MTE1MzI=",
      "title": "Allow server to cache the roster / tree",
      "url": "https://github.com/mlswg/mls-protocol/issues/87",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "privacy",
        "performance",
        "? follow-up"
      ],
      "body": "Currently, clients are expected to cache the entire roster and tree (of size `n` and `2n-1`, respectively), and the `Welcome` message provides these to the new joiner by value.  In principle it's possible to create a scheme where:\r\n\r\n* The members of the group agree on a commitment to the roster / tree instead of the objects themselves\r\n* Each Handshake message includes the information necessary to update the commitment\r\n* ... and a proof of the signer's inclusion in the roster, relative to the current roster commitment\r\n\r\nFor example, if the roster were committed as a Merkle tree root, an Add message could come with (1) an inclusion proof for the signer's public key, relative to the prior tree root; and (2) a consistency proof between the prior tree root and the updated root.\r\n\r\nThis would open up a spectrum of options for how much state the clients have to cache (note that the client has to cache its direct path in any case, to be able to decrypt TreeKEM encryptions).  The current draft would be on one end, with clients storing everything.  The other end would have clients store nothing and handshake messages just carrying new entropy and updating commitments.\r\n\r\nAs an example of an intermediate state, if you assume that Updates are more common than Adds/Removes, you could require each client to cache its own copath.  Then Add/Remove/Update messages would have to provide enough information about the tree to allow the other clients to update their copaths (in addition to updating the commitments).\r\n",
      "createdAt": "2019-01-13T02:14:46Z",
      "updatedAt": "2019-12-17T10:40:04Z",
      "closedAt": "2019-10-30T21:51:37Z",
      "comments": []
    },
    {
      "number": 88,
      "id": "MDU6SXNzdWUzOTg2MTE4Mzc=",
      "title": "\"Pre-warm\" trees with some double-joined nodes",
      "url": "https://github.com/mlswg/mls-protocol/issues/88",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "raphaelrobert"
      ],
      "labels": [
        "security",
        "performance"
      ],
      "body": "In the current draft, creating a group is done with `n` Add messages, which just place the members of the group at the leaves of the tree.  This means that newly-created trees have some \"warm up\" time during which early operations are roughly linear size, gradually converging to log size.\r\n\r\nThis state of affairs is unavoidable if we are not going to have double joins.  However, it might be tolerable to have double joins, so long as (1) they only happen at group creation time and (2) they resolve relatively quickly.\r\n\r\nFor example, you might create a special `Init` message, distinct from Add, which initializes a tree with the members at the leaves, but also some intermediate nodes filled in by the creator (and thus double-joined).  These nodes would be overwritten as members update, but the double-joins would only be fully resolved once all members update (or `1/2^{k}` of the members if `k` lower layers are not double-joined).",
      "createdAt": "2019-01-13T02:20:33Z",
      "updatedAt": "2019-12-17T10:39:33Z",
      "closedAt": "2019-10-02T08:26:42Z",
      "comments": [
        {
          "author": "seanturner",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Closing until deployment shows we need this.",
          "createdAt": "2019-10-02T08:26:42Z",
          "updatedAt": "2019-10-02T08:26:42Z"
        }
      ]
    },
    {
      "number": 89,
      "id": "MDU6SXNzdWUzOTg2MTI1NjA=",
      "title": "Encryption of Welcome messages",
      "url": "https://github.com/mlswg/mls-protocol/issues/89",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "security",
        "privacy"
      ],
      "body": "This was resolved in #80, but recording it in this issue for posterity.  A Welcome message carries the `init_secret` value for the group, and so it needs to be encrypted for the new joiner.\r\n\r\nThe struct proposed in the revised draft wraps the information in the Welcome in an ECIES ciphertext, and adds enough information to enable the joiner to identify the private key it needs to decrypt the Welcome message.\r\n\r\n```\r\nstruct {\r\n  opaque group_id<0..255>;\r\n  uint32 epoch;\r\n  optional<Credential> roster<1..2^32-1>;\r\n  optional<PublicKey> tree<1..2^32-1>;\r\n  opaque transcript_hash<0..255>;\r\n  opaque init_secret<0..255>;\r\n} WelcomeInfo;\r\n\r\nstruct {\r\n  opaque user_init_key_id<0..255>;\r\n  CipherSuite cipher_suite;\r\n  ECIESCiphertext encrypted_welcome_info;\r\n} Welcome;\r\n```",
      "createdAt": "2019-01-13T02:34:51Z",
      "updatedAt": "2019-12-17T10:39:24Z",
      "closedAt": "2019-01-15T22:44:04Z",
      "comments": []
    },
    {
      "number": 90,
      "id": "MDU6SXNzdWUzOTg2MTI3NTU=",
      "title": "Simplify the key schedule",
      "url": "https://github.com/mlswg/mls-protocol/issues/90",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "bifurcation",
        "beurdouche"
      ],
      "labels": [
        "enhancement"
      ],
      "body": "Currently, the whole GroupState object is folded into the key schedule, via the `DeriveSecret` function.  Could this be simplified?  For example:\r\n\r\n* Hash the GroupState object once, and use it for all `DeriveSecret` calls, as opposed to passing it by value each time\r\n\r\n* Hash in the roster and tree as a commitment (cf #87) rather than by value\r\n\r\nOther suggestions welcome.",
      "createdAt": "2019-01-13T02:38:23Z",
      "updatedAt": "2019-12-17T10:42:51Z",
      "closedAt": "2019-05-01T01:14:03Z",
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "I think we can get away with using the transcript hash if we put a little more information in the transcript.  In particular, the Welcome message needs to be included to assure that the new joiner and the group have the same view of the group state bits in the Welcome message.",
          "createdAt": "2019-01-15T22:43:07Z",
          "updatedAt": "2019-01-15T22:43:07Z"
        }
      ]
    },
    {
      "number": 91,
      "id": "MDU6SXNzdWUzOTg2MTM2NTg=",
      "title": "User-Initiated Add",
      "url": "https://github.com/mlswg/mls-protocol/issues/91",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "enhancement",
        "work in progress"
      ],
      "body": "Currently, in order for a new member to join a group, an existing member needs to add them to the group.  Certain use cases work more naturally if a new joiner can initiate the add process.  I think that broadly speaking we want a process here where someone outside the group can (1) request to be added and (2) send to the group, but cannot receive from the group until added.\r\n\r\nSome things to consider here:\r\n\r\n* Anything that is revealed to a joiner that joins this way is effectively public.  Should they be able to see, e.g., the roster?\r\n\r\n* How should these interactions relate to the key schedule?  Assuming there's some `AddRequest` message, should it be included into the transcript at Add time?\r\n\r\n* What happens if there are multiple parallel requests?",
      "createdAt": "2019-01-13T02:56:32Z",
      "updatedAt": "2020-06-19T12:53:42Z",
      "closedAt": "2020-06-19T12:53:42Z",
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "At the 2019-01 interim, we discussed a \"reversed Add\" flow, where:\r\n\r\n* Group publishes an InitKey\r\n* The new joiner sends a UIK to the group and establishes a shared secret with the group\r\n* This initiates a period where the new joiner can send, but nobody in the group can\r\n* Before anyone in the group can send, they have to send a Welcome for the new joiner\r\n* ... which initiates an epoch where they are fully joined",
          "createdAt": "2019-01-15T22:48:10Z",
          "updatedAt": "2019-01-15T22:48:10Z"
        },
        {
          "author": "david6076",
          "authorAssociation": "NONE",
          "body": "In certain use cases, such as enterprise messaging there may/could/might be a problem if \"**Any** member of the group can download an ClientInitKey for a new client and broadcast an Add message\". An enterprise may wish to enforce access restrictions for certain information such as ClientInitKey. Just thinking about security related issues that may be most easily noticed by corp IT types.\r\n\r\nOn the other hand this may be best dealt with outside the protocol scope.\r\n",
          "createdAt": "2019-06-27T21:41:54Z",
          "updatedAt": "2019-06-27T21:41:54Z"
        },
        {
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "body": "@bifurcation I think this is fixed by #240 correct? A user can propose to Add herself.",
          "createdAt": "2019-11-14T17:41:49Z",
          "updatedAt": "2019-11-14T17:41:49Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Partly addressed by #240.  To complete the story, we need a \"send-to-group-from-outside\" mechanism.  Leaving this open until we have that.",
          "createdAt": "2019-11-14T18:25:49Z",
          "updatedAt": "2019-11-14T18:25:49Z"
        },
        {
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "body": "I don't think a \"send-to-group-from-outside\" mechanism will be possible, given that we try quite hard to prevent any key material from inside the group from ever being published.",
          "createdAt": "2020-05-30T03:54:57Z",
          "updatedAt": "2020-05-30T03:54:57Z"
        }
      ]
    },
    {
      "number": 92,
      "id": "MDU6SXNzdWUzOTg2MTM3NzI=",
      "title": "ACK / NACK",
      "url": "https://github.com/mlswg/mls-protocol/issues/92",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "enhancement"
      ],
      "body": "In early discussions around MLS, people expressed interest in specifying how to do ACKs / NACKs on messages.  Questions to address:\r\n\r\n* How are ACKs / NACKs encoded?\r\n* How are they cryptographically protected? (signed, encrypted, MAC'ed, etc.)\r\n* When should they be sent?\r\n* Do they apply to handshake messages?  application messages?  both?",
      "createdAt": "2019-01-13T02:58:54Z",
      "updatedAt": "2020-01-31T15:11:28Z",
      "closedAt": "2020-01-31T15:11:27Z",
      "comments": [
        {
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "body": "We should discuss that today",
          "createdAt": "2019-10-01T07:06:28Z",
          "updatedAt": "2019-10-01T07:06:28Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "This was discussed at the January 2020 interim.  The conclusion there was that error recovery is a sufficiently complex topic that it merits a separate specification, which may extend the protocol, e.g., to add an Ack message or a Resync proposal.",
          "createdAt": "2020-01-31T15:11:27Z",
          "updatedAt": "2020-01-31T15:11:27Z"
        }
      ]
    },
    {
      "number": 93,
      "id": "MDU6SXNzdWUzOTg2MTM5ODA=",
      "title": "State resync",
      "url": "https://github.com/mlswg/mls-protocol/issues/93",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "enhancement",
        "security",
        "work in progress"
      ],
      "body": "Sometimes a client falls out of sync with the rest of the group, and it is necessary to re-initialize it.  What protocol mechanisms are necessary to make this possible? \r\n\r\n* How do endpoints discover that they have lost sync?\r\n* How do they resync?\r\n* Who can provide resync data?  the server?  other clients?\r\n\r\nPerhaps it would be useful to look at the state of the art with regard to how desync occurs and how it repaired.",
      "createdAt": "2019-01-13T03:03:12Z",
      "updatedAt": "2020-01-31T15:14:24Z",
      "closedAt": "2020-01-31T15:14:23Z",
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "* Effectively Remove+Add, either in-group or server-initiated\r\n  * Without Proposals, would probably want a \"Re-add\" message\r\n  * With proposals, this can just comprise Remove + Add proposals\r\n* Might want to suppress UX in such cases, i.e., don't show \"X left.  X joined.\"\r\n* Desirable to provide some proof of prior membership in the group\r\n  * Unclear if there's a plausible story for how the proof would be stored\r\n ",
          "createdAt": "2019-10-02T11:28:18Z",
          "updatedAt": "2019-10-02T11:28:18Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "I think this issue falls under the same general conclusion as #92 (handle in a follow-on specification).",
          "createdAt": "2020-01-31T15:14:23Z",
          "updatedAt": "2020-01-31T15:14:23Z"
        }
      ]
    },
    {
      "number": 95,
      "id": "MDU6SXNzdWUzOTkwMzE3OTg=",
      "title": "Decouple curves from symmetric+hash identifiers",
      "url": "https://github.com/mlswg/mls-protocol/issues/95",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "beurdouche"
      ],
      "labels": [
        "editorial",
        "functionality"
      ],
      "body": "* Enable, e.g., P-256 with both AES-GCM and ChaChaPoly\r\n* Re-use code points from TLS",
      "createdAt": "2019-01-14T19:09:54Z",
      "updatedAt": "2019-12-17T10:39:09Z",
      "closedAt": "2019-11-14T17:17:23Z",
      "comments": [
        {
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "body": "We should discuss that today",
          "createdAt": "2019-10-01T07:07:08Z",
          "updatedAt": "2019-10-01T07:07:08Z"
        }
      ]
    },
    {
      "number": 96,
      "id": "MDU6SXNzdWUzOTkwMzMyOTY=",
      "title": "Clarify uniqueness constraints on UIK IDs",
      "url": "https://github.com/mlswg/mls-protocol/issues/96",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "beurdouche"
      ],
      "labels": [
        "security",
        "recommendation"
      ],
      "body": "Consumers should not assume that UIK IDs are unique across users.",
      "createdAt": "2019-01-14T19:14:03Z",
      "updatedAt": "2019-12-17T10:38:57Z",
      "closedAt": "2019-03-11T06:37:19Z",
      "comments": [
        {
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "body": "The current text says:\r\n```\r\nUserInitKeys also contain an identifier chosen by the client, which the client\r\nMUST assure uniquely identifies a given UserInitKey object among the\r\nset of UserInitKeys created by this client.\r\n```\r\n\r\nWould it be realistic to say that the Delivery Service MUST check when storing a key that the UIK identifier is not used by another key ? @bifurcation @raphaelrobert ",
          "createdAt": "2019-03-10T12:32:29Z",
          "updatedAt": "2019-03-10T12:33:36Z"
        },
        {
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "body": "I'd be fine with that requirement for the DS.",
          "createdAt": "2019-03-10T16:33:50Z",
          "updatedAt": "2019-03-10T16:33:50Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Given that arch PR and the fact that the doc already says \"the client MUST assure uniquely identifies a given UserInitKey object among the set of UserInitKeys created by this client\", I think we can call this fixed.",
          "createdAt": "2019-03-11T06:37:16Z",
          "updatedAt": "2019-03-11T06:37:16Z"
        }
      ]
    },
    {
      "number": 97,
      "id": "MDU6SXNzdWUzOTkwMzM1MTg=",
      "title": "CIK rotation",
      "url": "https://github.com/mlswg/mls-protocol/issues/97",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "beurdouche"
      ],
      "labels": [
        "enhancement"
      ],
      "body": "Security considerations should provide guidance about how often to rotate, last resort, etc.",
      "createdAt": "2019-01-14T19:14:41Z",
      "updatedAt": "2019-12-20T16:32:54Z",
      "closedAt": "2019-12-20T16:32:54Z",
      "comments": []
    },
    {
      "number": 98,
      "id": "MDU6SXNzdWUzOTkwMzM4MTQ=",
      "title": "Handshake message encryption",
      "url": "https://github.com/mlswg/mls-protocol/issues/98",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "security",
        "privacy"
      ],
      "body": "As proposed on the list, we should re-use the encrypted-message framing for encrypted handshake messages.  For better key separation, we might derive a separate set of keys for this purpose (the academics prefer this).\r\n\r\nIf we do key separation, we should have a separate sequence number space.  In any case, a type field will be needed to distinguish.",
      "createdAt": "2019-01-14T19:15:30Z",
      "updatedAt": "2019-12-17T10:38:41Z",
      "closedAt": "2019-05-02T17:46:12Z",
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Note that adding handshake encryption might make analysis significantly more complicated.",
          "createdAt": "2019-01-15T23:57:17Z",
          "updatedAt": "2019-01-15T23:57:17Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Technically, this will be done via the common framing layer, but we should have some discussion of how to apply it / what the trade-offs are.",
          "createdAt": "2019-03-20T15:47:33Z",
          "updatedAt": "2019-03-20T15:47:33Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed by #155 ",
          "createdAt": "2019-05-02T17:46:12Z",
          "updatedAt": "2019-05-02T17:46:12Z"
        }
      ]
    },
    {
      "number": 100,
      "id": "MDU6SXNzdWUzOTkxMTgzMzY=",
      "title": "Allow multiple Proposals and/or one Commit in an MLSPlaintext",
      "url": "https://github.com/mlswg/mls-protocol/issues/100",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "bifurcation"
      ],
      "labels": [
        "security",
        "performance",
        "functionality"
      ],
      "body": "This allows combo operations -- multiple adds, moves, resyncs -- without having to worry about getting interrupted mid-operation.",
      "createdAt": "2019-01-14T23:16:11Z",
      "updatedAt": "2019-12-17T10:38:05Z",
      "closedAt": "2019-11-14T18:24:44Z",
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "On discussion at the interim 2019-01: It may be better to do not just throw a blind combo layer in here, but rather to have more operation types.  That way, we can fully think through the implications of each one.",
          "createdAt": "2019-01-16T00:04:50Z",
          "updatedAt": "2019-01-16T00:04:50Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Deferred for further discussion on the mailing list.",
          "createdAt": "2019-01-16T00:05:05Z",
          "updatedAt": "2019-01-16T00:05:05Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Repurposing this issue for combo moves with regard to Proposals and Commits.  We should cover the following cases:\r\n\r\n* One or more Proposals with no Commit\r\n* A Commit with no Proposals\r\n* One or more Proposals bundled with a Commit\r\n\r\nIt seems like something like the following would be appropriate:\r\n\r\n```\r\nstruct{\r\n  Proposal proposals<0..2^16-1>;\r\n  optional<Commit> commit;\r\n} Handshake;\r\n```\r\n\r\n... together with a requirement that at least one of them be populated.",
          "createdAt": "2019-10-01T21:42:29Z",
          "updatedAt": "2019-10-01T21:42:29Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "At the interim:\r\n* Commit must cover all Proposals in the same message\r\n* As a result, if any of the Proposals are invalid, then the whole thing fails",
          "createdAt": "2019-10-02T08:31:22Z",
          "updatedAt": "2019-10-02T08:31:22Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed in #242 ",
          "createdAt": "2019-11-14T18:24:44Z",
          "updatedAt": "2019-11-14T18:24:44Z"
        }
      ]
    },
    {
      "number": 101,
      "id": "MDU6SXNzdWUzOTkxMTk2ODA=",
      "title": "Use common framing",
      "url": "https://github.com/mlswg/mls-protocol/issues/101",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "bifurcation"
      ],
      "labels": [
        "security",
        "performance",
        "functionality"
      ],
      "body": "We have several types of top-level objects right now:\r\n\r\n* UserInitKey messages\r\n* Welcome messages\r\n* Handshake messages\r\n* Application messages\r\n\r\nWe should have a common framing layer that describes the object type (and optionally provides encryption), to prevent confusion among these types.  This would be analogous to the [TLS record layer](https://tlswg.github.io/tls13-spec/draft-ietf-tls-tls13.html#rfc.section.5.1)",
      "createdAt": "2019-01-14T23:21:24Z",
      "updatedAt": "2019-12-17T10:37:53Z",
      "closedAt": "2019-05-02T17:46:04Z",
      "comments": [
        {
          "author": "katrielalex",
          "authorAssociation": "MEMBER",
          "body": "(cc @alexsherkin when they accept the invite :) )",
          "createdAt": "2019-01-16T00:07:25Z",
          "updatedAt": "2019-01-16T00:07:25Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Discussion with @beurdouche and @raphaelrobert \r\n* Some desire for privacy of header fields\r\n  * Encrypt using a group key?\r\n  * MAC (for low-entropy values like `sender`, `generation`)\r\n  * Not doing this for -04, but note an OPEN ISSUE to discuss in Prague\r\n* Likewise, concerns about using application keys for Handshake messages -> OPEN ISSUE\r\n* @beurdouche will try to mature #131 in the next few days, otherwise we can do #120 \r\n",
          "createdAt": "2019-02-28T14:55:38Z",
          "updatedAt": "2019-02-28T14:55:38Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed by #155 ",
          "createdAt": "2019-05-02T17:46:04Z",
          "updatedAt": "2019-05-02T17:46:04Z"
        }
      ]
    },
    {
      "number": 102,
      "id": "MDU6SXNzdWUzOTk0Mzg3NzI=",
      "title": "Replay protection",
      "url": "https://github.com/mlswg/mls-protocol/issues/102",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "beurdouche"
      ],
      "labels": [
        "security",
        "? follow-up"
      ],
      "body": "We should ensure that there is adequate anti-replay protection for both Handshake and Application messages.  (In particular, we should define what anti-replay issues are a concern.)  Could be related to #101 if we want to solve it at that framing layer.",
      "createdAt": "2019-01-15T16:52:28Z",
      "updatedAt": "2019-12-17T10:37:33Z",
      "closedAt": "2019-09-30T12:20:45Z",
      "comments": [
        {
          "author": "alexsherkin",
          "authorAssociation": "NONE",
          "body": "It looks like application key schedule on its own may not be enough to prevent replay attacks if out-of-order messages are supported (and it seems like they are supported according to section 9.2.1).\r\n\r\nLets say we are at epoch x, and the receiver derives application_secret_[sender]_[0] for epoch x. Then, the receiver receives message1 (generation = 1) first before message0. In order to decrypt message1, the receiver needs to advance the application secret forward once to application_secret_[sender]_[1] to get message1 nonce and AEAD secret. The receiver then happily processes message 1. However, the receiver cannot forget application_secret_[sender]_[0] at this time; otherwise it will never be able to decrypt message0 so it has to keep application_secret_[sender]_[0] around.\r\n\r\nIf the receiver receives message1 again, it can compute application_secret_[sender]_[1] from application_secret_[sender]_[0] and process the message. Hence, it seems that key schedule on its own will not prevent replay attacks. The receiver needs to remember that it has already processed message1.\r\n\r\nThe same problem may apply to receiving a message from epoch N+1 while not all messages from epoch N have been received (if such case is possible).\r\n\r\nReplay attack counter-measures may be implemented as part of key schedule logic or separately, but it looks like implementors need to pay attention to this.",
          "createdAt": "2019-01-18T19:31:44Z",
          "updatedAt": "2019-01-18T19:31:44Z"
        },
        {
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "body": "Obviously, if you keep a previous application secret, you are breaking FS. This is forbidden by the protocol. The protocol mandates: \"Receivers MUST delete an Application Secret once it has been used to derive the corresponding AEAD key and nonce as well as the next Application Secret. Receivers MAY keep the AEAD key and nonce around for some reasonable period.\"",
          "createdAt": "2019-01-18T19:57:43Z",
          "updatedAt": "2019-01-18T19:57:43Z"
        },
        {
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "body": "Cf. \"Updating the Application Secret\"",
          "createdAt": "2019-01-18T20:02:34Z",
          "updatedAt": "2019-01-18T20:02:34Z"
        },
        {
          "author": "alexsherkin",
          "authorAssociation": "NONE",
          "body": "Does it mean that receiving out-of-order messages is not possible? If I abandon application_secret_[sender][0] and advance to application_secret_[sender][2] after receiving message 1 before message 0, I will never be able to process message 0. Is this intended behavior or am I missing something?",
          "createdAt": "2019-01-18T20:36:37Z",
          "updatedAt": "2019-01-18T20:36:37Z"
        },
        {
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "body": "No, you can do out of order, but what you keep are the AEAD keys/nonces and not the Application Secrets. \r\n\r\nThe idea is the following:\r\n1 - Compute Application Secret[sender][0]\r\n2 - Derive AEAD Key[Sender][0] and AEAD Nonce[Sender][0] from Application Secret[sender][0]\r\n3 - Overwrite Application Secret[sender][0] with Application Secret[sender][1]\r\nBasically, you should see these 3 steps as a single operation\r\nNow, if you iterate over that you can get more AEAD Keys and nonces [0 ... N] to receive out of order.\r\nBecause of step 3 you have local Forward Secrecy. Note that you never store more than a single (the latest) Application Secret per sender and that you have the keys [0...N] to decrypt out of order.",
          "createdAt": "2019-01-18T20:53:41Z",
          "updatedAt": "2019-01-18T20:55:02Z"
        },
        {
          "author": "alexsherkin",
          "authorAssociation": "NONE",
          "body": "Makes sense. Thanks for explaining. I suspect receiving out of order messages from a different epoch works in a similar way. If I am at epoch 0, and I receive a message from epoch 2, I derive and keep application_secret for epoch 1 and roll the init_secret forward.\r\n\r\nFrom the implementation perspective, how do I know when I can safely discard an application secret for a particular epoch? Or how do I know that no more messages are coming for a particular sender/epoch?\r\n\r\nDo you think there is value in adding a paragraph clarifying how the key schedule ensures replay attack protection to the spec? I know these are probably all implementation questions, but I suspect these may be the questions the implementors may be asking.\r\n\r\n",
          "createdAt": "2019-01-20T16:33:47Z",
          "updatedAt": "2019-01-20T16:33:47Z"
        },
        {
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "body": "@alexsherkin \r\n\r\nI have some text stashed for when to discard the previous application secrets after there is a new epoch, so I will handle that. The idea is that you \"publish\" the number of application messages you sent in the previous epoch, but that is to be discussed...\r\n\r\nRegarding replay, if you asked, it means clarification might be helpful here, do you want to submit a PR and assign me for review ? Otherwise just tell me and I'll handle it... : )",
          "createdAt": "2019-01-22T22:09:21Z",
          "updatedAt": "2019-01-22T22:09:21Z"
        },
        {
          "author": "alexsherkin",
          "authorAssociation": "NONE",
          "body": "@beurdouche I think you should review the below and update the spec as you see fit : )\r\n\r\n-- I would update section 9.2.1 with something like:\r\n\r\nIf receiver's application secret is at generation N, and the receiver receives an out of order message with generation N+x (where x>0), the receiver MUST advance the application secret forward to application secret N+x+1 after processing the out of order message. For every message with generation between N and N+x-1 (messages that have not been received), the receiver SHOULD derive AEAD nonce and AEAD key and store them in order to be able to decrypt these messages later. Application secret MUST NOT be kept at generation N in order allow for decryption of out-of-order messages. Instead, stored AEAD key and nonce will allow for decryption of out-of-order messages when received later.\r\n\r\n\r\n-- We may also introduce a short new section \"Message Replay Protection\" with something like:\r\n\r\nApplication key schedule provides replay attack counter-measures. If a message is replayed, the receiver should not have the right AEAD key nor have the application secret that could be used for deriving the right AEAD key for the replayed message. Hence, replayed message will be rejected by the receiver. ",
          "createdAt": "2019-01-23T22:20:26Z",
          "updatedAt": "2019-01-23T22:20:26Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "I think this is adequately addressed by #146 and #155 ",
          "createdAt": "2019-09-30T12:18:58Z",
          "updatedAt": "2019-09-30T12:18:58Z"
        }
      ]
    },
    {
      "number": 103,
      "id": "MDU6SXNzdWUzOTk0Mzk5NDU=",
      "title": "Simplify nonce generation",
      "url": "https://github.com/mlswg/mls-protocol/issues/103",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "enhancement"
      ],
      "body": "Right now, nonces used to encrypt application messages are derived off the key schedule.  Since the keys are effectively single-use, this could probably be done more simply, e.g., by using the generation number as the nonce.",
      "createdAt": "2019-01-15T16:54:51Z",
      "updatedAt": "2019-12-17T10:36:37Z",
      "closedAt": "2019-01-16T00:20:06Z",
      "comments": [
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "The rationale for random nonces is a time/space tradeoff with mass surveillance on 128-bit keyspaces. See:\r\nhttps://tools.ietf.org/rfcmarkup?doc=8446#appendix-E.2\r\nand\r\nhttps://eprint.iacr.org/2016/564",
          "createdAt": "2019-01-16T00:20:02Z",
          "updatedAt": "2019-01-16T00:20:02Z"
        }
      ]
    },
    {
      "number": 104,
      "id": "MDU6SXNzdWUzOTk0NDE0MTc=",
      "title": "Server-initiated removal",
      "url": "https://github.com/mlswg/mls-protocol/issues/104",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "raphaelrobert"
      ],
      "labels": [
        "security",
        "functionality"
      ],
      "body": "Long-term inactive users undermine the FS and PCS properties of the protocol.  Obviously, users can remove each other if they notice that a participant is inactive.  We should consider whether we want to allow the server to do such a removal.",
      "createdAt": "2019-01-15T16:58:12Z",
      "updatedAt": "2019-12-17T10:35:48Z",
      "closedAt": "2019-11-14T17:16:10Z",
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Discussion at interim 2019-01: \r\n* Could do this as \"server-instructed\" vs. \"server done\"\r\n  * i.e., server instructs a client to do a remove\r\n  * But this causes some ambiguity w.r.t. the rest of the group\r\n* The only difference between Remove and a server-initiated variant would be signature\r\n* Other use cases: \r\n  * User deletes account\r\n  * User is no longer authorized to be in group\r\n* Application would need to set policy about whether / when server-initiated actions would be allowed\r\n",
          "createdAt": "2019-01-16T00:31:45Z",
          "updatedAt": "2019-01-16T00:31:45Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "I'm assigning this to draft-04 under the theory that the signature changes that will come about as a result of #101 will make it straightforward to have an additional key for the server that can be used to sign Adds / Removes.  If that doesn't turn out to be the case, this might get deferred.",
          "createdAt": "2019-02-26T19:38:36Z",
          "updatedAt": "2019-02-26T19:38:36Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "After discussion with @beurdouche and @raphaelrobert: \r\n* There will be a need to signal that a non-member key is being used, e.g., with some reserved `sender` values\r\n* Do the participants in the group need to agree the set of allowed non-member signers?  If some members accept a signer, others don't, then you can get partition\r\n* -04 will focus on Remove, not Add, and punt on the agreement question; we assume the application maintains consistency of the view of authorized signers.",
          "createdAt": "2019-02-28T14:23:20Z",
          "updatedAt": "2019-02-28T14:24:08Z"
        },
        {
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "body": "We should push some of this to the application layer in order to not introduce a new handshake message with problematic authenticity (agreement on the list of non-members who can sign handshake messages).\r\n\r\nThe server could publish an \"intent to remove\" that will be honored by the first client to come online.\r\nThe actual Remove HS message will be issued by a member of the group. It can additionally be attached to the server intent to remove, so that clients can convey more contextual information to users.\r\n\r\nExample: \r\n\r\n - Server issues the intent to remove Alice from the group.\r\n - Bob comes online first after that and send a regular Remove HS message to remove Alice and links it to the sever intent.\r\n - Other members of the group can now display \"Alice was removed\" instead of \"Bob removed Alice\" to the user.\r\n\r\nIn this example Bob is the first member to come online, but it could really be any other member.\r\n\r\nThis has the advantage that the protocol remains unaffected as such, while the desired behavior is still achieved.",
          "createdAt": "2019-03-11T16:43:30Z",
          "updatedAt": "2019-03-11T16:43:30Z"
        }
      ]
    },
    {
      "number": 105,
      "id": "MDU6SXNzdWUzOTk1NDg1NjY=",
      "title": "Version negotiation",
      "url": "https://github.com/mlswg/mls-protocol/issues/105",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "bifurcation"
      ],
      "labels": [
        "security",
        "functionality"
      ],
      "body": "We need some story for how to evolve versions over time.  How and where is version support indicated?  How can a group transition from one version to another?",
      "createdAt": "2019-01-15T21:43:13Z",
      "updatedAt": "2019-12-17T10:35:40Z",
      "closedAt": "2019-10-01T21:48:12Z",
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "It seems like the right answer here is roughly the same as for ciphersuites -- advertise support in UserInitKey, select in Welcome.",
          "createdAt": "2019-02-26T19:37:03Z",
          "updatedAt": "2019-02-26T19:37:03Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "For -04, this will be a preliminary effort.  @beurdouche points out that there are more subtle considerations here, e.g., what remains constant across versions.  But we'll go ahead and put something basic in -04, as a basis for discussion.",
          "createdAt": "2019-02-28T14:12:27Z",
          "updatedAt": "2019-02-28T14:12:27Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Moving to -05 to see if we need something more.",
          "createdAt": "2019-03-11T06:38:42Z",
          "updatedAt": "2019-03-11T06:38:42Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Per discussion at interim, this is adequately addressed by:\r\n\r\n* Stating a version in ClientInitKey (in current draft)\r\n* Providing a list of supported versions in CIK to prevent downgrade (#224)\r\n\r\nSo closing this in favor of #224 ",
          "createdAt": "2019-10-01T21:48:10Z",
          "updatedAt": "2019-10-01T21:48:10Z"
        }
      ]
    },
    {
      "number": 107,
      "id": "MDU6SXNzdWU0MDEwNDE5NzQ=",
      "title": "Application key schedule is busted",
      "url": "https://github.com/mlswg/mls-protocol/issues/107",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "beurdouche"
      ],
      "labels": [
        "bug"
      ],
      "body": "There are at least two bugs in the message protection section that make it unimplementable:\r\n\r\n1. It calls for `Derive-Secret(., \"app sender\", [sender])`, but the third argument to `Derive-Secret` as defined is a `GroupState`, not an octet string.\r\n\r\n2. It refers to a function `HKDF-Expand-Label`, which is defined in TLS, but not here.\r\n\r\nISTM the simplest way to fix these problems would to define `HKDF-Expand-Label` and use it (1) as the basis for `Derive-Secret`, (2) for deriving sender root secrets, and (3) for deriving keys and nonces.",
      "createdAt": "2019-01-19T22:37:48Z",
      "updatedAt": "2019-12-17T10:35:17Z",
      "closedAt": "2019-02-21T11:41:30Z",
      "comments": [
        {
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "body": "Fixed by #123 ",
          "createdAt": "2019-02-21T11:41:29Z",
          "updatedAt": "2019-02-21T11:41:29Z"
        }
      ]
    },
    {
      "number": 108,
      "id": "MDU6SXNzdWU0MDE5MjQ1ODk=",
      "title": "Some undefined terms and primitives",
      "url": "https://github.com/mlswg/mls-protocol/issues/108",
      "state": "CLOSED",
      "author": "rozbb",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "beurdouche"
      ],
      "labels": [
        "editorial"
      ],
      "body": "I think a bunch of these are probably relics of previous versions. For reference, the page numbers listed are from the PDF version of draft 3 of the protocol:\r\n\r\n- [x] 1 - p6: `GroupInit` is mentioned, but it is not defined anywhere in the specification. Perhaps `Init` is intended.\r\n\r\n- [x] 2 - p19: A `transcript` field is mentioned, but only `transcript_hash` is present. Also it's unclear which `Hash` function is supposed to be used here. It can't be ciphersuite-dependent, since it has to be the same for every Participant.\r\n\r\n- [x] 3 - p22: `update_secret` is used in a diagram, but never defined. I think this is important, and it's mentioned elsewhere.\r\n\r\n- [x] 4 - p24: `finished_mac` is mentioned, but never defined. Is it supposed to say `confirmation`?\r\n\r\n- [ ] 5 - p25: The underlying Hash that HMAC uses can't be defined by anyone's ciphersuite. This is group state, and everyone has to agree on this.\r\n\r\n- [x] 6 - p28: Mentioned \"update secret\" again without explanation.\r\n\r\n- [x] 7 - p29: \"identity tree\" is mentioned, but I can't tell what that's referring to. Also \"update secret\" is here.\r\n\r\n- [x] 8 - p35: `MLSPlaintext` is mentioned, but never defined. Perhaps `ApplicationPlaintext` is intended.",
      "createdAt": "2019-01-22T19:47:02Z",
      "updatedAt": "2019-03-01T09:34:09Z",
      "closedAt": "2019-03-01T09:34:08Z",
      "comments": [
        {
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "body": "Thanks a lot for the review, this is very useful.\nI have a pass planned for this week and will fix these issues :)\n",
          "createdAt": "2019-01-22T20:08:59Z",
          "updatedAt": "2019-01-22T20:08:59Z"
        },
        {
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "body": "@rozbb A PR #126 was opened with fixes for points 1, 2, 4, 7. Point 8 was already solved.\r\nAn issue has been opened #125 to solve points 3 and 6 related to the update secret definition.\r\nI tried to figure out your point 5 but I didn't understand it, can you give details ?",
          "createdAt": "2019-02-23T10:55:39Z",
          "updatedAt": "2019-02-23T10:55:39Z"
        },
        {
          "author": "rozbb",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Sorry for the delay. I think point 5 was a misunderstanding over when a common ciphersuite is established in the protocol. I'm still not 100% clear on it, but I think I'm just missing something simple. Consider it withdrawn.",
          "createdAt": "2019-02-28T22:41:12Z",
          "updatedAt": "2019-02-28T22:41:12Z"
        },
        {
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "body": "Ok, then these issues are fixed by #126 and #125. Thanks",
          "createdAt": "2019-03-01T09:34:08Z",
          "updatedAt": "2019-03-01T09:34:08Z"
        }
      ]
    },
    {
      "number": 110,
      "id": "MDU6SXNzdWU0MDE5NzE5MDA=",
      "title": "Syntax unification",
      "url": "https://github.com/mlswg/mls-protocol/issues/110",
      "state": "CLOSED",
      "author": "beurdouche",
      "authorAssociation": "MEMBER",
      "assignees": [
        "beurdouche"
      ],
      "labels": [
        "editorial"
      ],
      "body": "We inconsistently use the backtick, the underscore or nothing for messages fields or specific operations in the draft. This needs a fix, currently the opinion is to use the TLS style (aka remove everything)",
      "createdAt": "2019-01-22T21:57:05Z",
      "updatedAt": "2019-11-16T14:41:03Z",
      "closedAt": "2019-11-16T14:41:03Z",
      "comments": []
    },
    {
      "number": 112,
      "id": "MDU6SXNzdWU0MDE5Nzg4Nzk=",
      "title": "Discarding Application secrets from the previous Epoch",
      "url": "https://github.com/mlswg/mls-protocol/issues/112",
      "state": "CLOSED",
      "author": "beurdouche",
      "authorAssociation": "MEMBER",
      "assignees": [
        "beurdouche"
      ],
      "labels": [
        "security",
        "recommendation"
      ],
      "body": "In the current draft it is not known to the other group members when to discard the participant application secret from the previous epoch. My formal specification sends the 4 byte application message counter of the previous epoch within the first application message of each participant in the new epoch. Discuss and PR.",
      "createdAt": "2019-01-22T22:17:07Z",
      "updatedAt": "2019-12-17T10:35:05Z",
      "closedAt": "2019-05-17T14:27:58Z",
      "comments": [
        {
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "body": "This can be handled as part of #140 and #160",
          "createdAt": "2019-05-17T14:27:58Z",
          "updatedAt": "2019-05-17T14:27:58Z"
        }
      ]
    },
    {
      "number": 117,
      "id": "MDU6SXNzdWU0MDgyMjYxMjM=",
      "title": "Key and nonce should have separate lengths",
      "url": "https://github.com/mlswg/mls-protocol/issues/117",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "bug"
      ],
      "body": "This text is wrong:\r\n\r\n```\r\n   key = HKDF-Expand(Secret, ECIESLabel(\"key\"), Length)\r\n   nonce = HKDF-Expand(Secret, ECIESLabel(\"nonce\"), Length\r\n```",
      "createdAt": "2019-02-08T16:26:27Z",
      "updatedAt": "2019-12-17T10:34:44Z",
      "closedAt": "2019-02-21T11:42:59Z",
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "This could also be addressed by using draft-barnes-cfrg-hpke.",
          "createdAt": "2019-02-08T16:27:49Z",
          "updatedAt": "2019-02-08T16:27:49Z"
        },
        {
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "body": "This has been fixed by #116 ",
          "createdAt": "2019-02-21T11:42:59Z",
          "updatedAt": "2019-02-21T11:42:59Z"
        }
      ]
    },
    {
      "number": 118,
      "id": "MDU6SXNzdWU0MTAxODUyNzg=",
      "title": "Discuss DH cofactor issues and Update DH and Elliptic Curve parameters text.",
      "url": "https://github.com/mlswg/mls-protocol/issues/118",
      "state": "CLOSED",
      "author": "beurdouche",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "Sof\u00eda noted \"It is also unclear at some points the notation used for the Diffie-Hellman or\r\nElliptic Curve parameters. Related to this, is unsure if this protocol takes\r\ninto account the cofactor issues.\"\r\n",
      "createdAt": "2019-02-14T08:34:55Z",
      "updatedAt": "2020-06-19T12:53:42Z",
      "closedAt": "2020-06-19T12:53:42Z",
      "comments": [
        {
          "author": "rozbb",
          "authorAssociation": "CONTRIBUTOR",
          "body": "What precisely is unclear? X25519 specifies the scalar-clamping that's used to remove the 8-torsion part of the given curve point. And P-256 is a prime curve, so it has no cofactor.",
          "createdAt": "2019-02-14T17:05:58Z",
          "updatedAt": "2019-02-14T17:05:58Z"
        },
        {
          "author": "claucece",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Well, it only says:\r\n\r\n```\r\nGiven an octet string X, the private key produced by the Derive-Key-Pair operation is SHA-256(X).\r\n (Recall that any 32-octet string is a valid Curve25519 private key.) The corresponding public key is\r\n X25519(SHA-256(X), 9).\r\n\r\nImplementations SHOULD use the approach specified in {{RFC7748}} to calculate the Diffie-Hellman\r\n shared secret. \r\n```\r\n\r\nIt does not refer that you are referring to section 'The X25519 and X448 Functions' of the RFC (if so). And actually, I think it is referred to the subsection in that section where is says \"To implement the X25519(k, u) and X448(k, u)\". \r\n\r\nIt also says:\r\n\r\n```\r\nIf implementers use an alternative implementation of these elliptic curves, they SHOULD perform the\r\n additional checks specified in Section 7 of {{RFC7748}}\r\n```\r\n\r\nwhich does not recommend taking into account that \"For X25519, in order to decode 32 random bytes as an integer scalar, set the three least significant bits of the first byte and the most significant bit of the last to zero, set the second most significant bit of the last byte to 1 and, finally, decode as little-endian. \" (the clamping mechanism).\r\n\r\nIt is a little bit unclear from the text how the generation of the shared secret happens, as it does not point to an specific part of the RFC, nor specify if the encoding/decoding functions are needed.\r\n\r\nBut this is just my read ;)\r\n\r\n> And P-256 is a prime curve, so it has no cofactor.\r\n\r\nPrecisely. But this section is a little bit more defined. Compare:\r\n\r\n```\r\nP-256 ECDH calculations (including parameter and key generation as well as the shared secret\r\n calculation) are performed according to {{IEEE1363}} using the ECKAS-DH1 scheme with the identity\r\n map as key derivation function (KDF), so that the shared secret is the x-coordinate of the ECDH\r\n shared secret elliptic curve point represented as an octet string. Note that this octet string (Z in IEEE\r\n 1363 terminology) as output by FE2OSP, the Field Element to Octet String Conversion Primitive, has\r\n constant length for any given field; leading zeros found in this octet string MUST NOT be truncated.\r\n```\r\n\r\n\r\n:)\r\n",
          "createdAt": "2019-02-15T17:15:52Z",
          "updatedAt": "2019-02-15T17:16:36Z"
        },
        {
          "author": "claucece",
          "authorAssociation": "CONTRIBUTOR",
          "body": "And around unclear:\r\n\r\n- The definition of `Derive-Key-Pair` used to derive the private key, is defined as \"The ciphersuite must also specify an algorithm Derive-Key-Pair that maps octet strings with the same length as the output of the hash function to key pairs for the asymmetric encryption scheme.\". It is unclear how this algorithm looks in practice. It seems to imply that this function takes any amount of same length octet strings as input (generated as an output of a hash function) and map to create a private key and a public key somehow. \r\n\r\n- It says \"Given an octet string X, the private key produced by the Derive-Key-Pair operation is SHA-256(X). (Recall that any 32-octet string is a valid Curve25519 private key.) The corresponding public key is X25519(SHA-256(X), 9).\" If you don't read the RFC, it is unclear that the \"9 is the u-coordinate of the base point and is encoded as a byte with value 9, followed by 31 zero bytes\". It also does not specify if the private key should have been generated from randomness. \r\n\r\n- When saying \"Encryption keys are derived from shared secrets by taking the first 16 bytes of H(Z), where Z is the shared secret and H is SHA-256.\", it seems like 'H(input)' could be defined somewhere else previously. Maybe it should be in place to have a definition section for the different functions, like on the RFC7748 in \"3.  Notation\"?\r\n\r\n- When it says \"Generate an ephemeral DH key pair (x, x * G) in the DH group specified by the ciphersuite in use\", does this refer only to the usage of elliptic curves (as it generates the public key as 'x*G'? Maybe if it is DH, it should be noted as 'g^x'?\r\n\r\nThis is just some things that were unclear for me when reading :) Perhaps they are discussed somewhere else. It also depends on how self-contained that document wants to be. \r\n\r\nHope this helps :)",
          "createdAt": "2019-02-15T17:49:40Z",
          "updatedAt": "2019-02-15T17:53:31Z"
        },
        {
          "author": "rozbb",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Ah, ok. These seem like fair points. I had thought that X25519 specifies that clamping be done on every call to `X25519(k, u)`, but I see now that it's done once in the decoding step and then never again. Also that P-256 excerpt was very informative. Thanks!",
          "createdAt": "2019-02-15T17:51:33Z",
          "updatedAt": "2019-02-15T17:51:33Z"
        }
      ]
    },
    {
      "number": 119,
      "id": "MDU6SXNzdWU0MTA0Mjg5Mjk=",
      "title": "Handshake message parsing is ambiguous in type-safe implementations",
      "url": "https://github.com/mlswg/mls-protocol/issues/119",
      "state": "CLOSED",
      "author": "rozbb",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "invalid"
      ],
      "body": "At least 2 existing implementations of MLS have some sort of curve-specific DH public key type. This is to ensure type safety and reduce the likelihood of the programmer accidentally using one point value for a different curve. For me, this is\r\n```\r\nenum DhPoint {\r\n    X25519([u8; 32]),\r\n    P256([u8; 32]),\r\n}\r\n```\r\nThe issue I run into is that I cannot unambiguously deserialize `DHPublicKey`s into a `DHPoint`. Recall the definition `opaque DHPublicKey<1..2^16-1>`. The parse of an unmarked sequence of bytes is dependent on ambient state, namely the `CipherSuite` of the current session. Notably, the value of this `CipherSuite` is not repeated in any top-level messages. This means that a given `Handshake` message will have at least two correct interpretations unless context is specified. \r\n\r\nThis is not a massive issue, but one could imagine a case where a participant receives a message from another participant who somehow disagrees on the current `CipherSuite`. The receiver will parse all the messages correctly, check the signatures, and throw an invalid signature error. If we were to mark the type of the `DHPublicKey`, though, the receiver would parse the values and check that they agree with the current `CipherSuite`. This check will fail, and it will throw a decoherence error, which is more appropriate and informative.\r\n\r\n`DHPublicKey` is not the only data type for which this ambiguity occurs. I propose that we change at least some `opaque` datatypes to enums. Currently, the not-really-bytes opaque types are\r\n\r\n* `DHPublicKey`\r\n* `SignaturePublicKey`\r\n* `ECIES::ciphertext`\r\n* `UserInitKey::signature`\r\n* `Handshake::signature`\r\n* `ApplicationPlaintext::signature`\r\n* `Application::encrypted_content`\r\n\r\nMy own implementation makes distinctions between different signature types, ECDSA pubkey types, and ECDH pubkey types. Encrypted content is treated as a binary blob.",
      "createdAt": "2019-02-14T18:17:21Z",
      "updatedAt": "2019-12-17T10:34:35Z",
      "closedAt": "2019-02-26T19:16:17Z",
      "comments": [
        {
          "author": "burdges",
          "authorAssociation": "NONE",
          "body": "I'd kinda expect a trait instead of an enum for this in Rust, just because cipher suite agility creates many complexities.  If it's only a compile time choice, or protocol version number, then differentiating MACs and/or hashes might provide the desired protections.  Apologies if I've failed to understand all the goals here. ",
          "createdAt": "2019-02-20T06:48:41Z",
          "updatedAt": "2019-02-20T06:48:41Z"
        },
        {
          "author": "rozbb",
          "authorAssociation": "CONTRIBUTOR",
          "body": "No, this is a good point. I've chosen in my implementation to treat DH algorithms as trait implementations, and `DhPoint`s as data. So I would have something like `X25519.diffie_hellman(my_scalar, others_point)`. The reason I've chosen this representation for DH public keys is because these types cannot be known at compile time. If they could be, then I would probably use associated types for the aforementioned trait impls. So I have enums which I unwrap at runtime, and panic if there's a type error then. It's not pretty, but it'll hopefully prevent some bad things from happening.",
          "createdAt": "2019-02-20T07:04:36Z",
          "updatedAt": "2019-02-20T07:04:36Z"
        },
        {
          "author": "burdges",
          "authorAssociation": "NONE",
          "body": "Oh?  I'm curious why the types cannot be known?  Is it for linking with C or something?",
          "createdAt": "2019-02-20T09:26:31Z",
          "updatedAt": "2019-02-20T09:26:31Z"
        },
        {
          "author": "rozbb",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Well the types of, say, the DH implementor is not known. If DH operations are implemented as a trait `DiffieHellman`, then there are structs called `X25519` and `P256`. So if these are marked by bytes, say 0x00 and 0x01, respectively, then what is the return type of `deserialize_dh_from_byte(marker: u8) -> ???`.\r\nWell naturally it would be a `dyn DiffieHellman`. So say you do `let dh_impl = deserialize_dh_from_byte(b)`. Then what types does `dh_impl.multiply_basepoint(scalar: ???) -> ???` take and return? If each DH implementation has their own scalar type and point type, how can I know what to give this function?",
          "createdAt": "2019-02-20T17:10:06Z",
          "updatedAt": "2019-02-20T17:10:06Z"
        },
        {
          "author": "burdges",
          "authorAssociation": "NONE",
          "body": "I'd love it if Rust had type parameters for modules, but no such luck.  Instead, we often create parameters traits for the entire module or crate, commonly called `Trait` or `Params`.  It'd bloat the binary though if you need both X25519 and P256 in the same code, hence my C question.  Anyways not a big deal.  :)",
          "createdAt": "2019-02-20T17:37:30Z",
          "updatedAt": "2019-02-20T17:37:30Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "From a protocol design POV, there are basically two options here:\r\n\r\n1. Set the ciphersuite once, and force implementations to tell their deserializers what it is\r\n2. Set the ciphersuite on every object, and force implementations to verify that all the  ciphersuites are consistent\r\n\r\nIMO, option 1 is likely to be less error-prone, simply because it touches less code, and it is more likely to fail if you get it wrong.  It also doesn't seem *that* burdensome to implement.  Yes, you have to route the ciphersuite around to all the right places, but things like templates and generics can help a lot.",
          "createdAt": "2019-02-26T16:22:09Z",
          "updatedAt": "2019-02-26T16:22:09Z"
        },
        {
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "body": "I agree with Richard, the preferable way is usually to do 1 : ) It is more a implementation specific state machine enforcement issue than a protocol issue so I will close this, but feel free to discuss more in the Implementation issues if you feel like it is necessary.",
          "createdAt": "2019-02-26T19:16:17Z",
          "updatedAt": "2019-02-26T19:16:17Z"
        },
        {
          "author": "rozbb",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yeah, I tend to agree with this argument. I think I can find a way to pass state into my deserializer.",
          "createdAt": "2019-02-26T20:31:18Z",
          "updatedAt": "2019-02-26T20:31:18Z"
        }
      ]
    },
    {
      "number": 125,
      "id": "MDU6SXNzdWU0MTM2ODM0MTg=",
      "title": "Missing definition of update secret",
      "url": "https://github.com/mlswg/mls-protocol/issues/125",
      "state": "CLOSED",
      "author": "beurdouche",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "",
      "createdAt": "2019-02-23T10:51:12Z",
      "updatedAt": "2019-02-26T19:34:31Z",
      "closedAt": "2019-02-26T19:34:31Z",
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "@beurdouche could you elaborate on this?  It seems to me that the update secret is whatever the GroupOperation says it is.",
          "createdAt": "2019-02-26T16:15:21Z",
          "updatedAt": "2019-02-26T16:15:21Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing as a dup of #108 ",
          "createdAt": "2019-02-26T19:34:31Z",
          "updatedAt": "2019-02-26T19:34:31Z"
        }
      ]
    },
    {
      "number": 129,
      "id": "MDU6SXNzdWU0MTQzNDc0MDA=",
      "title": "Fix issues introduced in #114",
      "url": "https://github.com/mlswg/mls-protocol/issues/129",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "beurdouche"
      ],
      "labels": [
        "bug",
        "editorial"
      ],
      "body": "The PR from @kkohbrok introducing a KDF was merged before I had a chance to review it.  There are a number of problems with it:\r\n\r\n* Instead of calling for an abstract KDF, it should define one, as we have with the use of HKDF elsewhere\r\n* We can't just say `private_key = KDF(...)`, since KDFs produce octet strings, not private keys.  We need `Derive-Key-Pair()`, not just `Derive-Public-Key()`.\r\n* This doesn't match what I recall discussing on the list.  \r\n\r\nI think what you want is actually as follows:\r\n\r\n```\r\npath_secret[n+1]\r\n     ^\r\n     |\r\npath_secret[n] --> node_secret --> node_key_pair\r\n```\r\n\r\nOr in prose:\r\n\r\n```\r\nnode_secret = HKDF-Expand-Label(path_secret[n], \"node\", \"\", Hash.Length)\r\nnode_private, node_public = Derive-Key-Pair(node_secret)\r\npath_secret[n+1] = HKDF-Expand-Label(path_secret[n], \"path\", \"\", Hash.Length)\r\n```",
      "createdAt": "2019-02-25T22:56:32Z",
      "updatedAt": "2019-12-17T10:34:03Z",
      "closedAt": "2019-03-28T00:41:51Z",
      "comments": [
        {
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "That was exactly the question I was asking on the list, i.e., if we need an explicit \"derive-keypair\" function. The idea with deriving the private key directly was to avoid a redundant derive-key operation. I'm totally fine re-doing the PR to represent either approach.",
          "createdAt": "2019-02-26T08:00:14Z",
          "updatedAt": "2019-02-26T08:00:14Z"
        },
        {
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "body": "Merging that PR too quickly is on me.\r\nFor the parent derivation, we can just use what the formal model for TreeKEM does, which is roughly the `HKDF_Expand_Label` Richard points out. The part I don't like about this, is to define `Derive-Key-Pair` in the MLS specification as it depends on the HPKE internal algorithm.\r\n\r\nThe TreeKEM formal specification, it is done the following way (because we know that the HPKE interface we use can take random bytes as a secret key):\r\n```\r\n(** Key Derivation: compute a parent secret from the group secret *)\r\nval derive_parent_secret: alg:algorithm_hash -> context:bytes -> secret_s -> Tot secret_s\r\nlet derive_parent_secret alg context s =\r\n  Spec.HKDF.hkdf_expand_label alg s \"parent\" context size_secret\r\n\r\n(** Key Derivation: compute a KEM encryption key from the group secret *)\r\nval derive_encryption_secret: alg:algorithm_hash -> context:bytes -> secret_s -> Tot key_secret_s\r\nlet derive_encryption_secret alg context s =\r\n  Spec.HKDF.hkdf_expand_label alg s \"kem enc\" context size_key_secret\r\n```\r\n\r\nIn the MLS specification, I suggest we avoid defining anything new but point to the HPKE spec instead.\r\nAs it provides the KEM scheme, it should also provide ways to derive the `HPKEPrivateKey` from an octet string and the function that transform an `HPKEPrivateKey` to a `HPKEPublicKey`.\r\nI suggest we define, in the HPKE document, something like `HPKE_secret_to_public ()` that we already need anyway and eventually `HPKE_bytes_to_secret ()` that maps the random bytes to an `HPKEPrivateKey`. For X25519 we don't even need the second function but generically we probably need it.\r\nThat would lead to define the following in the MLS spec:\r\n```\r\n(** Key Derivation: compute a KEM encryption key from the group secret *)\r\nval mls_derive_encryption_secret: alg:algorithm_hash -> context:bytes -> secret_s -> Tot key_secret_s\r\nlet mls_derive_encryption_secret alg context s =\r\n  let output = Spec.HKDF.hkdf_expand_label alg s \"kem enc\" context size_key_secret in\r\n  Spec.HPKE.bytes_to_secret alg output\r\n```\r\n\r\n@bifurcation ?",
          "createdAt": "2019-02-26T08:50:04Z",
          "updatedAt": "2019-02-26T09:17:57Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "I don't think we can delegate this to HPKE.  HPKE doesn't have a need for anything like Derive-Key-Pair.  We do, so it's on us to define it.  The point @kkohbrok's raises about avoiding unnecessary operations is relevant here: If we're forking the hashes like this, then we can remove the hashing part from Derive-Key-Pair, so that it's really just a definition of how you convert from an octet string to a private key (and thus its public key).",
          "createdAt": "2019-02-26T16:10:36Z",
          "updatedAt": "2019-02-26T16:10:36Z"
        },
        {
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "body": "I disagree, it is not for MLS to define the `bytes_to_secret` and `secret_to_public` functions for all asymmetric schemes possibly used in HPKE. In MLS we should have to do only what TreeKEM does, aka, 2 KDFs, one outputing the parent's secret, one outputing the KEM encryption key, and that's it.\r\nI am willing to accept defining `Derive-Public-Key` here but this is already odd.",
          "createdAt": "2019-02-27T10:44:06Z",
          "updatedAt": "2019-02-27T10:44:06Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "If it's not our job, whose is it?  It's not HPKE's job, because they don't have a need to convert byte strings to private keys.  Some document needs to define this conversion in order for MLS to be implementable.",
          "createdAt": "2019-02-27T13:32:41Z",
          "updatedAt": "2019-02-27T13:32:41Z"
        },
        {
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "body": "I agree we are in trouble here :) But I still wish that if we can avoid it, we should.",
          "createdAt": "2019-02-27T13:34:05Z",
          "updatedAt": "2019-02-27T13:34:05Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "I agree that the KEM schemes themselves should define these things, like Curve25519 does.  But it's like two lines of text.  I'm not too bothered with it.",
          "createdAt": "2019-02-27T13:36:17Z",
          "updatedAt": "2019-02-27T13:36:17Z"
        },
        {
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think I'm a bit lost here. How do we go forward?\r\n\r\nRegarding the use of an abstract KDF: I was mostly just adapting the existing text, which used an abstract hash function if I recall correctly.  I didn't touch the texts that got more concrete because they seemed to be a little outdated anyway. That shouldn't be a problem though.",
          "createdAt": "2019-02-28T06:23:50Z",
          "updatedAt": "2019-02-28T06:23:50Z"
        },
        {
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "body": "@bifurcation Ok, looking at this now, I am not sure what we decided in the end.\r\nI would be ok to define `Derive-Key-Pair` as you said but as it is KEM specific so there is no good solution for P256 or for whatever PQ KEM that would have a specific way of generating keys from pseudo random bytes...",
          "createdAt": "2019-03-10T17:52:54Z",
          "updatedAt": "2019-03-10T17:52:54Z"
        },
        {
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "body": "@karthikbhargavan any suggestion here",
          "createdAt": "2019-03-10T17:54:44Z",
          "updatedAt": "2019-03-10T17:54:44Z"
        },
        {
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "body": "Fixed by #139 ",
          "createdAt": "2019-03-28T00:41:51Z",
          "updatedAt": "2019-03-28T00:41:51Z"
        }
      ]
    },
    {
      "number": 130,
      "id": "MDU6SXNzdWU0MTQ3MTI5MjM=",
      "title": "STROBE",
      "url": "https://github.com/mlswg/mls-protocol/issues/130",
      "state": "CLOSED",
      "author": "burdges",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "invalid"
      ],
      "body": "There is a nifty advantage of using Mike Hamburg's STROBE for symmetric cryptography:  \r\n \r\nApplications using WASM virtual machines should improve performance by using native code for cryptography.  STROBE works well for this because all actual processing is handled by *one* call that processes an arbitrary amount of data.  You always require multiple STROBE calls per operation in practice of course, but only O(1) cals.  If you wrapped say a ChaCha or Keccak permutation directly then you\u2019d have O(data_size) calls.  In short, STROBE simplifies the WASM call boundary dramatically without much performance penalty. \r\n\r\nIn MLS, you might favor adding ChaCha into your WASM call boundary anyways because STROBE lacks any round count configuration.  I wanted to mention this however since messengers do commonly get implemented in VMs. ",
      "createdAt": "2019-02-26T16:51:18Z",
      "updatedAt": "2019-12-17T10:33:00Z",
      "closedAt": "2019-07-08T14:12:55Z",
      "comments": [
        {
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "body": "Hi Jeff, I don't think this is much of an issue for our use cases, so I'll close the issue for now, but feel free to discuss this on the mailing list if you feel strongly about using STROBE as a base primitive ; )",
          "createdAt": "2019-07-08T14:12:55Z",
          "updatedAt": "2019-07-08T14:12:55Z"
        }
      ]
    },
    {
      "number": 137,
      "id": "MDU6SXNzdWU0MTkxNzk2NDY=",
      "title": "Rename UserInitKey to ClientInitKey",
      "url": "https://github.com/mlswg/mls-protocol/issues/137",
      "state": "CLOSED",
      "author": "beurdouche",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "terminology"
      ],
      "body": "These keys are Client one-time use keys, so \"UserInitKey\" seems like a strange name.",
      "createdAt": "2019-03-10T12:25:17Z",
      "updatedAt": "2019-05-24T14:04:36Z",
      "closedAt": "2019-05-24T14:04:36Z",
      "comments": [
        {
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "body": "I'm fine with ClientInitKey, as long as a client is not only a physical endpoint. Changes in the architecture doc should make this clear soon.",
          "createdAt": "2019-03-10T16:43:17Z",
          "updatedAt": "2019-03-10T16:43:17Z"
        }
      ]
    },
    {
      "number": 140,
      "id": "MDU6SXNzdWU0MjYwNDEzMDQ=",
      "title": "Provide signals to support better FS",
      "url": "https://github.com/mlswg/mls-protocol/issues/140",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "duplicate"
      ],
      "body": "If a group member can signal what its latest epoch is (e.g., by ACKing a handshake message), then other members know that they can safely delete any keys older than that epoch, at least for that sender.",
      "createdAt": "2019-03-27T15:51:03Z",
      "updatedAt": "2019-12-17T10:32:32Z",
      "closedAt": "2019-09-30T12:10:49Z",
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Duplicate of #160 ",
          "createdAt": "2019-09-30T12:10:49Z",
          "updatedAt": "2019-09-30T12:10:49Z"
        }
      ]
    },
    {
      "number": 142,
      "id": "MDU6SXNzdWU0MjYzNjUyMDk=",
      "title": "Prevent suppression of Handshake messages",
      "url": "https://github.com/mlswg/mls-protocol/issues/142",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "enhancement"
      ],
      "body": "In current proposals, it is possible for the delivery service to distinguish handshake and application messages.  This enables the DS to lock in a compromise by forbidding key updates while allowing application messaging to continue.  We should make it harder to distinguish handshake and application messages, e.g., by encrypting the content type.",
      "createdAt": "2019-03-28T08:41:51Z",
      "updatedAt": "2020-10-20T15:07:58Z",
      "closedAt": "2020-10-20T15:07:58Z",
      "comments": []
    },
    {
      "number": 144,
      "id": "MDU6SXNzdWU0MjkzNDI2ODM=",
      "title": "Application Secret deletion",
      "url": "https://github.com/mlswg/mls-protocol/issues/144",
      "state": "CLOSED",
      "author": "beurdouche",
      "authorAssociation": "MEMBER",
      "assignees": [
        "beurdouche"
      ],
      "labels": [
        "security"
      ],
      "body": "It has been pointed out that the text is not clear enough about the fact that once the Application secrets of the senders have been computed, the shared Application secret MUST be deleted. Make that clear.",
      "createdAt": "2019-04-04T15:25:49Z",
      "updatedAt": "2019-12-17T10:32:12Z",
      "closedAt": "2019-09-30T12:09:07Z",
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "This was addressed by Jo\u00ebl's PR that created ASTrees and a deletion schedule.",
          "createdAt": "2019-09-30T12:09:07Z",
          "updatedAt": "2019-09-30T12:09:07Z"
        }
      ]
    },
    {
      "number": 145,
      "id": "MDU6SXNzdWU0MjkzNDQ1OTM=",
      "title": "? Introduce the notion of \"virtual\" client.",
      "url": "https://github.com/mlswg/mls-protocol/issues/145",
      "state": "CLOSED",
      "author": "beurdouche",
      "authorAssociation": "MEMBER",
      "assignees": [
        "beurdouche"
      ],
      "labels": [
        "terminology"
      ],
      "body": "From @raphaelrobert ... This would be a useful terminology to describe a client which shares its cryptographic material across multiple device.\r\nTo be discussed ?",
      "createdAt": "2019-04-04T15:29:24Z",
      "updatedAt": "2019-12-17T10:31:40Z",
      "closedAt": "2019-07-08T14:04:38Z",
      "comments": [
        {
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "body": "Done in draft-06",
          "createdAt": "2019-07-08T14:04:38Z",
          "updatedAt": "2019-07-08T14:04:38Z"
        }
      ]
    },
    {
      "number": 150,
      "id": "MDU6SXNzdWU0MzUxODgzNDI=",
      "title": "Allow direct initialization",
      "url": "https://github.com/mlswg/mls-protocol/issues/150",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "security",
        "functionality"
      ],
      "body": "We have a long-standing OPEN ISSUE on creating a group with a single Init message instead of  N Add messages, which would change the work of initialization from O(N log N) to O(N).  I would propose roughly the following:\r\n\r\n```\r\nstruct {\r\n    Welcome creator_info<0..2^32-1>; // Welcome from one-member group to each joiner\r\n    UserInitKey members<0..2^32-1>; // Info to populate at the leaves\r\n    DirectPath creator_update; // Update from the creator to warm the tree\r\n} Init;\r\n```\r\n\r\nThen the processing would be:\r\n\r\n* Find the welcome that's for you\r\n* Initialize a one-member tree from the Welcome\r\n* Use the UserInitKeys to populate the leaves of the tree\r\n* Use the DirectPath to populate the creator's direct path (as in Update)",
      "createdAt": "2019-04-19T14:04:05Z",
      "updatedAt": "2019-12-17T10:31:28Z",
      "closedAt": "2019-07-08T13:58:59Z",
      "comments": [
        {
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "body": "Fixed by https://github.com/mlswg/mls-protocol/pull/171",
          "createdAt": "2019-07-08T13:58:59Z",
          "updatedAt": "2019-07-08T13:58:59Z"
        }
      ]
    },
    {
      "number": 154,
      "id": "MDU6SXNzdWU0Mzc2MTUyMzQ=",
      "title": "Weekly Digest (19 April, 2019 - 26 April, 2019)",
      "url": "https://github.com/mlswg/mls-protocol/issues/154",
      "state": "CLOSED",
      "author": "weekly-digest",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "weekly-digest"
      ],
      "body": "Here's the **Weekly Digest** for [*mlswg/mls-protocol*](https://github.com/mlswg/mls-protocol):\n\n - - - \n# ISSUES\nLast week 4 issues were created.\nOf these, 1 issues have been closed and 3 issues are still open.\n## OPEN ISSUES\n:green_heart: #153 [Common framing, consolidated](https://github.com/mlswg/mls-protocol/pull/153), by [bifurcation](https://github.com/bifurcation)\n:green_heart: #152 [Make epochs unpredictable](https://github.com/mlswg/mls-protocol/pull/152), by [bifurcation](https://github.com/bifurcation)\n:green_heart: #150 [Allow direct initialization](https://github.com/mlswg/mls-protocol/issues/150), by [bifurcation](https://github.com/bifurcation)\n## CLOSED ISSUES\n:heart: #151 [A couple of minor fixes](https://github.com/mlswg/mls-protocol/pull/151), by [bifurcation](https://github.com/bifurcation)\n## NOISY ISSUE\n:speaker: #152 [Make epochs unpredictable](https://github.com/mlswg/mls-protocol/pull/152), by [bifurcation](https://github.com/bifurcation)\nIt received 4 comments.\n\n - - - \n# PULL REQUESTS\nLast week, 9 pull requests were created, updated or merged.\n## UPDATED PULL REQUEST\nLast week, 8 pull requests were updated.\n:yellow_heart: #153 [Common framing, consolidated](https://github.com/mlswg/mls-protocol/pull/153), by [bifurcation](https://github.com/bifurcation)\n:yellow_heart: #152 [Make epochs unpredictable](https://github.com/mlswg/mls-protocol/pull/152), by [bifurcation](https://github.com/bifurcation)\n:yellow_heart: #148 [Added that users SHOULD verify pubkeys in an Update](https://github.com/mlswg/mls-protocol/pull/148), by [rozbb](https://github.com/rozbb)\n:yellow_heart: #147 [Added public_key_index to Add message](https://github.com/mlswg/mls-protocol/pull/147), by [rozbb](https://github.com/rozbb)\n:yellow_heart: #146 [Tree based app keyschedule](https://github.com/mlswg/mls-protocol/pull/146), by [psyoptix](https://github.com/psyoptix)\n:yellow_heart: #143 [Fixes to tree manipulation in Remove](https://github.com/mlswg/mls-protocol/pull/143), by [rozbb](https://github.com/rozbb)\n:yellow_heart: #134 [Tree Hash](https://github.com/mlswg/mls-protocol/pull/134), by [bifurcation](https://github.com/bifurcation)\n:yellow_heart: #131 [Common Framing](https://github.com/mlswg/mls-protocol/pull/131), by [beurdouche](https://github.com/beurdouche)\n## MERGED PULL REQUEST\nLast week, 1 pull request was merged.\n:purple_heart: #151 [A couple of minor fixes](https://github.com/mlswg/mls-protocol/pull/151), by [bifurcation](https://github.com/bifurcation)\n\n - - - \n# COMMITS\nLast week there were 4 commits.\n:hammer_and_wrench: [Merge pull request #151 from mlswg/minor-fixes  A couple of minor fixes](https://github.com/mlswg/mls-protocol/commit/24efba91dd3c679a27d9c96158707cfee3b09df3) by [bifurcation](https://github.com/bifurcation)\n:hammer_and_wrench: [Fix error noted by @rozbb](https://github.com/mlswg/mls-protocol/commit/b42e702fdfec54197159a27bd29f0bfa5c84a3da) by [bifurcation](https://github.com/bifurcation)\n:hammer_and_wrench: [Make welcome/add diagram clearer](https://github.com/mlswg/mls-protocol/commit/ee358ac6ac44c1e2fa65d6638b2d9473fc33da03) by [bifurcation](https://github.com/bifurcation)\n:hammer_and_wrench: [Open issue cleanup](https://github.com/mlswg/mls-protocol/commit/6d01e5cbe59abb49e0057582432bdd305bfad655) by [bifurcation](https://github.com/bifurcation)\n\n - - - \n# CONTRIBUTORS\nLast week there was 1 contributor.\n:bust_in_silhouette: [bifurcation](https://github.com/bifurcation)\n\n - - - \n# STARGAZERS\nLast week there was 1 stargazer.\n:star: [Mromson](https://github.com/Mromson)\nYou are the star! :star2:\n\n - - - \n# RELEASES\nLast week there were no releases.\n\n - - - \n\nThat's all for last week, please <kbd>:eyes: **Watch**</kbd> and <kbd>:star: **Star**</kbd> the repository [*mlswg/mls-protocol*](https://github.com/mlswg/mls-protocol) to receive next weekly updates. :smiley:\n\n*You can also [view all Weekly Digests by clicking here](https://github.com/mlswg/mls-protocol/issues?q=is:open+is:issue+label:weekly-digest).* \n\n> Your [**Weekly Digest**](https://github.com/apps/weekly-digest) bot. :calendar:\n",
      "createdAt": "2019-04-26T10:48:59Z",
      "updatedAt": "2019-04-26T10:52:03Z",
      "closedAt": "2019-04-26T10:52:03Z",
      "comments": []
    },
    {
      "number": 157,
      "id": "MDU6SXNzdWU0Mzk3MzU2NTc=",
      "title": "Resolve circular dependency between GroupOperation.confirmation and transcript_hash",
      "url": "https://github.com/mlswg/mls-protocol/issues/157",
      "state": "CLOSED",
      "author": "beurdouche",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "bug"
      ],
      "body": "```\r\nGroupOperation.confirmation =\r\n    HMAC(confirmation_key, GroupState.transcript\\_hash)\r\n```",
      "createdAt": "2019-05-02T18:51:28Z",
      "updatedAt": "2019-12-17T10:31:19Z",
      "closedAt": "2019-05-30T15:29:57Z",
      "comments": []
    },
    {
      "number": 158,
      "id": "MDU6SXNzdWU0NDI1OTc4ODk=",
      "title": "Issue in definition of MLSCiphertextContent",
      "url": "https://github.com/mlswg/mls-protocol/issues/158",
      "state": "CLOSED",
      "author": "beurdouche",
      "authorAssociation": "MEMBER",
      "assignees": [
        "beurdouche"
      ],
      "labels": [
        "editorial"
      ],
      "body": "The definition of `MLSCiphertextContent` is incorrect as it relies on `MLSInnerPlaintext.sig_len`. Should we make the `signature` opaque anyway ?",
      "createdAt": "2019-05-10T08:24:17Z",
      "updatedAt": "2019-12-17T10:31:11Z",
      "closedAt": "2019-05-17T09:48:11Z",
      "comments": []
    },
    {
      "number": 159,
      "id": "MDU6SXNzdWU0NDI5NjMyNzU=",
      "title": "Rename the GroupState structure as it is not a group state.",
      "url": "https://github.com/mlswg/mls-protocol/issues/159",
      "state": "CLOSED",
      "author": "beurdouche",
      "authorAssociation": "MEMBER",
      "assignees": [
        "beurdouche"
      ],
      "labels": [
        "terminology"
      ],
      "body": "We should change the name of this struct as it doesn't even contain the tree.",
      "createdAt": "2019-05-11T07:16:40Z",
      "updatedAt": "2019-12-17T10:30:58Z",
      "closedAt": "2019-05-24T14:10:34Z",
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed by #166 ",
          "createdAt": "2019-05-24T14:10:34Z",
          "updatedAt": "2019-05-24T14:10:34Z"
        }
      ]
    },
    {
      "number": 160,
      "id": "MDU6SXNzdWU0NDI5NjczNTc=",
      "title": "Advertize a global app generation for a sender",
      "url": "https://github.com/mlswg/mls-protocol/issues/160",
      "state": "CLOSED",
      "author": "beurdouche",
      "authorAssociation": "MEMBER",
      "assignees": [
        "beurdouche"
      ],
      "labels": [
        "enhancement",
        "security",
        "work in progress"
      ],
      "body": "We could use the sender_generation field of the MLS message to signal what was the global app generation of the sender.  Functionally, this allows receivers to know if they received all previous application messages from the sender. In the current design, if S sent M0, M1, M2 you can know if you missed M1 when receiving M2, but you cannot know if you missed M2. There are many ways of doing this: global sender counter, counter between two operations of the sender...",
      "createdAt": "2019-05-11T08:07:45Z",
      "updatedAt": "2020-10-20T15:07:58Z",
      "closedAt": "2020-10-20T15:07:58Z",
      "comments": [
        {
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "body": "We seemed in agreement at the interim because it prevents the application message suppression attacks",
          "createdAt": "2019-05-17T14:23:04Z",
          "updatedAt": "2019-05-17T14:23:04Z"
        }
      ]
    },
    {
      "number": 161,
      "id": "MDU6SXNzdWU0NDI5Njk0MTk=",
      "title": "? Include the node_hash in the RatchetNode struct",
      "url": "https://github.com/mlswg/mls-protocol/issues/161",
      "state": "CLOSED",
      "author": "beurdouche",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "security",
        "recommendation"
      ],
      "body": "",
      "createdAt": "2019-05-11T08:34:38Z",
      "updatedAt": "2019-12-17T10:30:46Z",
      "closedAt": "2019-05-24T14:10:02Z",
      "comments": [
        {
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "body": "@bifurcation I am not immediately clear if we need that or not. I think we do not have to send it in certain cases like update, but I think a receiver of an Add cannot recompute it, right ? We do send it in the formal spec...",
          "createdAt": "2019-05-17T14:44:37Z",
          "updatedAt": "2019-05-17T14:44:37Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "I don't think we need this.  Right now, we presume that each member caches the whole tree, which means that they can compute all the node hashes.  If we want to enable members to exist with log state, then we'll need to add a bunch of node hashes to the protocol messages.",
          "createdAt": "2019-05-24T14:10:02Z",
          "updatedAt": "2019-05-24T14:10:02Z"
        }
      ]
    },
    {
      "number": 162,
      "id": "MDU6SXNzdWU0NDUzMTU0NDE=",
      "title": "Reorder blanking and update in the Remove operation.",
      "url": "https://github.com/mlswg/mls-protocol/issues/162",
      "state": "CLOSED",
      "author": "beurdouche",
      "authorAssociation": "MEMBER",
      "assignees": [
        "beurdouche"
      ],
      "labels": [
        "performance"
      ],
      "body": "",
      "createdAt": "2019-05-17T08:02:38Z",
      "updatedAt": "2019-12-17T10:30:24Z",
      "closedAt": "2019-05-24T14:01:35Z",
      "comments": []
    },
    {
      "number": 168,
      "id": "MDU6SXNzdWU0NDU3MjcyNTY=",
      "title": "Clarify obligation of clients to Update",
      "url": "https://github.com/mlswg/mls-protocol/issues/168",
      "state": "CLOSED",
      "author": "beurdouche",
      "authorAssociation": "MEMBER",
      "assignees": [
        "beurdouche"
      ],
      "labels": [
        "editorial",
        "security",
        "recommendation"
      ],
      "body": "It has been noted that we don't discuss enough he influence of clients refusing to update in this document. The architecture document briefly explain why we minimally should evict clients that refuse to update to preserve FS or PCS. I think we actually enforce a MUST and provide a minimal recommendation. \r\n```\r\n### Membership and offline members\r\nBecause Forward Secrecy (FS) and Post-Compromise Security (PCS)\r\nrely on the deletion and replacement of keying material,\r\nany client which is persistently offline\r\nmay still be holding old keying material and thus be a threat\r\nto both FS and PCS if it is later compromised.\r\nMLS does not inherently defend against this problem, but\r\nMLS-using systems can enforce some mechanism for doing\r\nso. Typically this will consist of evicting clients which\r\nare idle for too long, thus containing the threat of\r\ncompromise. The precise details of such mechanisms are\r\na matter of local policy and beyond the scope of this document.\r\n```",
      "createdAt": "2019-05-18T15:37:32Z",
      "updatedAt": "2021-11-30T23:39:36Z",
      "closedAt": "2021-11-30T23:39:36Z",
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "The Security Considerations correctly notes that that you only get PCS when you update, which I think is sufficient for this document.  If we want to lay out operational recommendations for how Updates should be arranged in practice, that seems like a better topic for the architecture document, or for implementation considerations (cc @kkohbrok).",
          "createdAt": "2021-11-30T23:39:36Z",
          "updatedAt": "2021-11-30T23:39:36Z"
        }
      ]
    },
    {
      "number": 174,
      "id": "MDU6SXNzdWU0NDg1ODg4OTg=",
      "title": "Weekly Digest (19 May, 2019 - 26 May, 2019)",
      "url": "https://github.com/mlswg/mls-protocol/issues/174",
      "state": "CLOSED",
      "author": "weekly-digest",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "weekly-digest"
      ],
      "body": "Here's the **Weekly Digest** for [*mlswg/mls-protocol*](https://github.com/mlswg/mls-protocol):\n\n - - - \n# ISSUES\nLast week 5 issues were created.\nOf these, 1 issues have been closed and 4 issues are still open.\n## OPEN ISSUES\n:green_heart: #173 [Formatting: removed `\\_` where it was syntactically incorrect](https://github.com/mlswg/mls-protocol/pull/173), by [rozbb](https://github.com/rozbb)\n:green_heart: #172 [DirectPathNode contains encrypted node secrets, not path secrets](https://github.com/mlswg/mls-protocol/pull/172), by [rozbb](https://github.com/rozbb)\n:green_heart: #171 [Specify an Init message](https://github.com/mlswg/mls-protocol/pull/171), by [bifurcation](https://github.com/bifurcation)\n:green_heart: #170 [Confirmation and transcript improvements](https://github.com/mlswg/mls-protocol/pull/170), by [bifurcation](https://github.com/bifurcation)\n## CLOSED ISSUES\n:heart: #169 [Notion of virtual client when secrets are shared accross devices](https://github.com/mlswg/mls-protocol/pull/169), by [beurdouche](https://github.com/beurdouche)\n\n - - - \n# PULL REQUESTS\nLast week, 9 pull requests were created, updated or merged.\n## OPEN PULL REQUEST\nLast week, 3 pull requests were opened.\n:green_heart: #173 [Formatting: removed `\\_` where it was syntactically incorrect](https://github.com/mlswg/mls-protocol/pull/173), by [rozbb](https://github.com/rozbb)\n:green_heart: #172 [DirectPathNode contains encrypted node secrets, not path secrets](https://github.com/mlswg/mls-protocol/pull/172), by [rozbb](https://github.com/rozbb)\n:green_heart: #171 [Specify an Init message](https://github.com/mlswg/mls-protocol/pull/171), by [bifurcation](https://github.com/bifurcation)\n## UPDATED PULL REQUEST\nLast week, 1 pull request was updated.\n:yellow_heart: #170 [Confirmation and transcript improvements](https://github.com/mlswg/mls-protocol/pull/170), by [bifurcation](https://github.com/bifurcation)\n## MERGED PULL REQUEST\nLast week, 5 pull requests were merged.\n:purple_heart: #169 [Notion of virtual client when secrets are shared accross devices](https://github.com/mlswg/mls-protocol/pull/169), by [beurdouche](https://github.com/beurdouche)\n:purple_heart: #167 [Fix incorrect definition of update_secret](https://github.com/mlswg/mls-protocol/pull/167), by [beurdouche](https://github.com/beurdouche)\n:purple_heart: #166 [GroupState is not a group state, renaming to GroupContext](https://github.com/mlswg/mls-protocol/pull/166), by [beurdouche](https://github.com/beurdouche)\n:purple_heart: #164 [Rename UserInitKey to ClientInitKey](https://github.com/mlswg/mls-protocol/pull/164), by [beurdouche](https://github.com/beurdouche)\n:purple_heart: #163 [Reorder blanking and update in the Remove operation](https://github.com/mlswg/mls-protocol/pull/163), by [beurdouche](https://github.com/beurdouche)\n\n - - - \n# COMMITS\nLast week there were 8 commits.\n:hammer_and_wrench: [Merge pull request #164 from mlswg/beurdouche_clientinitkey  Rename UserInitKey to ClientInitKey](https://github.com/mlswg/mls-protocol/commit/0d849622508cebd6d9c769dd0388fa17d15fd083) by [bifurcation](https://github.com/bifurcation)\n:hammer_and_wrench: [Merge branch 'master' into beurdouche_clientinitkey](https://github.com/mlswg/mls-protocol/commit/72056b8116d31326a9f84855cde0ae08007715dd) by [bifurcation](https://github.com/bifurcation)\n:hammer_and_wrench: [Merge pull request #163 from mlswg/beurdouche_remove  Reorder blanking and update in the Remove operation](https://github.com/mlswg/mls-protocol/commit/46b8ece169e2bf0eb6771eac4396f144199032e4) by [bifurcation](https://github.com/bifurcation)\n:hammer_and_wrench: [Remove: truncate the tree on sending](https://github.com/mlswg/mls-protocol/commit/50bc327f2e5d65832713c93e0c2ab7588be0a4d1) by [beurdouche](https://github.com/beurdouche)\n:hammer_and_wrench: [Fix merge conflict with master](https://github.com/mlswg/mls-protocol/commit/b094afcfbe3cc1f7eb4dd8700933fc3d20b8a7e9) by [beurdouche](https://github.com/beurdouche)\n:hammer_and_wrench: [GroupState is not a group state, renaming to GroupContext (#166)  * GroupState is not a group state, renaming to GroupContext\r \r * GroupContext, update according to Richard's comment](https://github.com/mlswg/mls-protocol/commit/564ee2662e4eeac93a854edf3a6ab44eb46cb6d6) by [beurdouche](https://github.com/beurdouche)\n:hammer_and_wrench: [Merge pull request #169 from mlswg/beurdouche_145  Notion of virtual client when secrets are shared accross devices](https://github.com/mlswg/mls-protocol/commit/cefc48b64e3651fafeab56c6413fdd75bef4c4c5) by [bifurcation](https://github.com/bifurcation)\n:hammer_and_wrench: [Merge pull request #167 from mlswg/beurdouche_us  Fix incorrect definition of update_secret](https://github.com/mlswg/mls-protocol/commit/6e672188c590c2dbd34fd1369b3b6e1d6da8fda8) by [bifurcation](https://github.com/bifurcation)\n\n - - - \n# CONTRIBUTORS\nLast week there were 2 contributors.\n:bust_in_silhouette: [bifurcation](https://github.com/bifurcation)\n:bust_in_silhouette: [beurdouche](https://github.com/beurdouche)\n\n - - - \n# STARGAZERS\nLast week there was 1 stargazer.\n:star: [eknoes](https://github.com/eknoes)\nYou are the star! :star2:\n\n - - - \n# RELEASES\nLast week there were no releases.\n\n - - - \n\nThat's all for last week, please <kbd>:eyes: **Watch**</kbd> and <kbd>:star: **Star**</kbd> the repository [*mlswg/mls-protocol*](https://github.com/mlswg/mls-protocol) to receive next weekly updates. :smiley:\n\n*You can also [view all Weekly Digests by clicking here](https://github.com/mlswg/mls-protocol/issues?q=is:open+is:issue+label:weekly-digest).* \n\n> Your [**Weekly Digest**](https://github.com/apps/weekly-digest) bot. :calendar:\n",
      "createdAt": "2019-05-26T17:31:59Z",
      "updatedAt": "2019-06-04T11:30:42Z",
      "closedAt": "2019-06-04T11:30:42Z",
      "comments": []
    },
    {
      "number": 177,
      "id": "MDU6SXNzdWU0NTExNTgwMTc=",
      "title": "Weekly Digest (26 May, 2019 - 2 June, 2019)",
      "url": "https://github.com/mlswg/mls-protocol/issues/177",
      "state": "CLOSED",
      "author": "weekly-digest",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "weekly-digest"
      ],
      "body": "Here's the **Weekly Digest** for [*mlswg/mls-protocol*](https://github.com/mlswg/mls-protocol):\n\n - - - \n# ISSUES\nLast week 2 issues were created.\nOf these, 2 issues have been closed and 0 issues are still open.\n## CLOSED ISSUES\n:heart: #176 [Use correct field names](https://github.com/mlswg/mls-protocol/pull/176), by [bifurcation](https://github.com/bifurcation)\n:heart: #175 [Typo fix](https://github.com/mlswg/mls-protocol/pull/175), by [bifurcation](https://github.com/bifurcation)\n\n - - - \n# PULL REQUESTS\nLast week, 4 pull requests were created, updated or merged.\n## MERGED PULL REQUEST\nLast week, 4 pull requests were merged.\n:purple_heart: #176 [Use correct field names](https://github.com/mlswg/mls-protocol/pull/176), by [bifurcation](https://github.com/bifurcation)\n:purple_heart: #175 [Typo fix](https://github.com/mlswg/mls-protocol/pull/175), by [bifurcation](https://github.com/bifurcation)\n:purple_heart: #173 [Formatting: removed `\\_` where it was syntactically incorrect](https://github.com/mlswg/mls-protocol/pull/173), by [rozbb](https://github.com/rozbb)\n:purple_heart: #170 [Confirmation and transcript improvements](https://github.com/mlswg/mls-protocol/pull/170), by [bifurcation](https://github.com/bifurcation)\n\n - - - \n# COMMITS\nLast week there were 9 commits.\n:hammer_and_wrench: [Merge pull request #176 from mlswg/path-secret-typo  Use correct field names](https://github.com/mlswg/mls-protocol/commit/112b535e77f1122e434c2a49492393d15bf19aa8) by [bifurcation](https://github.com/bifurcation)\n:hammer_and_wrench: [Use correct field names](https://github.com/mlswg/mls-protocol/commit/facd7a383ec8952072d0ead3c30daae16824a4fe) by [bifurcation](https://github.com/bifurcation)\n:hammer_and_wrench: [Merge pull request #175 from mlswg/circular-confirmation  Typo fix](https://github.com/mlswg/mls-protocol/commit/b7498970e5dc1a8b4eb1a3db8db699e4dd1f5698) by [bifurcation](https://github.com/bifurcation)\n:hammer_and_wrench: [Merge pull request #173 from rozbb/backslash-underscore  Formatting: removed `\\_` where it was syntactically incorrect](https://github.com/mlswg/mls-protocol/commit/8c7cbca1e568b47394b1d89c73dbeaebe3f62afb) by [bifurcation](https://github.com/bifurcation)\n:hammer_and_wrench: [Merge branch 'master' into backslash-underscore](https://github.com/mlswg/mls-protocol/commit/c12be2c8a3e2fe913f4a0e81854308aa86298852) by [bifurcation](https://github.com/bifurcation)\n:hammer_and_wrench: [Typo fix](https://github.com/mlswg/mls-protocol/commit/779adb41d09c2fe99c55b61483bd3b26aa58d184) by [bifurcation](https://github.com/bifurcation)\n:hammer_and_wrench: [Merge pull request #170 from mlswg/circular-confirmation  Confirmation and transcript improvements](https://github.com/mlswg/mls-protocol/commit/7602f683a6e9ba79cdb732814314a259d8738cb2) by [bifurcation](https://github.com/bifurcation)\n:hammer_and_wrench: [Merge branch 'master' into circular-confirmation](https://github.com/mlswg/mls-protocol/commit/9132e357ce338c34d3fa95b93c1b5e5eb7598df4) by [bifurcation](https://github.com/bifurcation)\n:hammer_and_wrench: [Responses to comments from @raphaelrobert](https://github.com/mlswg/mls-protocol/commit/d30557726eacd6f748ef650e26e2dbfc20ff1b72) by [bifurcation](https://github.com/bifurcation)\n\n - - - \n# CONTRIBUTORS\nLast week there was 1 contributor.\n:bust_in_silhouette: [bifurcation](https://github.com/bifurcation)\n\n - - - \n# STARGAZERS\nLast week there were no stargazers.\n\n - - - \n# RELEASES\nLast week there were no releases.\n\n - - - \n\nThat's all for last week, please <kbd>:eyes: **Watch**</kbd> and <kbd>:star: **Star**</kbd> the repository [*mlswg/mls-protocol*](https://github.com/mlswg/mls-protocol) to receive next weekly updates. :smiley:\n\n*You can also [view all Weekly Digests by clicking here](https://github.com/mlswg/mls-protocol/issues?q=is:open+is:issue+label:weekly-digest).* \n\n> Your [**Weekly Digest**](https://github.com/apps/weekly-digest) bot. :calendar:\n",
      "createdAt": "2019-06-02T06:19:27Z",
      "updatedAt": "2019-06-04T11:30:42Z",
      "closedAt": "2019-06-04T11:30:42Z",
      "comments": []
    },
    {
      "number": 180,
      "id": "MDU6SXNzdWU0NTM4Njc0OTE=",
      "title": "Weekly Digest (2 June, 2019 - 9 June, 2019)",
      "url": "https://github.com/mlswg/mls-protocol/issues/180",
      "state": "CLOSED",
      "author": "weekly-digest",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "weekly-digest"
      ],
      "body": "Here's the **Weekly Digest** for [*mlswg/mls-protocol*](https://github.com/mlswg/mls-protocol):\n\n - - - \n# ISSUES\nLast week 2 issues were created.\nOf these, 1 issues have been closed and 1 issues are still open.\n## OPEN ISSUES\n:green_heart: #178 [Fix transcript so that new members get the right information](https://github.com/mlswg/mls-protocol/pull/178), by [bifurcation](https://github.com/bifurcation)\n## CLOSED ISSUES\n:heart: #179 [Add Beurdouche as a co-author](https://github.com/mlswg/mls-protocol/pull/179), by [bifurcation](https://github.com/bifurcation)\n## NOISY ISSUE\n:speaker: #179 [Add Beurdouche as a co-author](https://github.com/mlswg/mls-protocol/pull/179), by [bifurcation](https://github.com/bifurcation)\nIt received 1 comments.\n\n - - - \n# PULL REQUESTS\nLast week, 2 pull requests were created, updated or merged.\n## UPDATED PULL REQUEST\nLast week, 1 pull request was updated.\n:yellow_heart: #178 [Fix transcript so that new members get the right information](https://github.com/mlswg/mls-protocol/pull/178), by [bifurcation](https://github.com/bifurcation)\n## MERGED PULL REQUEST\nLast week, 1 pull request was merged.\n:purple_heart: #179 [Add Beurdouche as a co-author](https://github.com/mlswg/mls-protocol/pull/179), by [bifurcation](https://github.com/bifurcation)\n\n - - - \n# COMMITS\nLast week there were 2 commits.\n:hammer_and_wrench: [Merge pull request #179 from mlswg/add-beurdouche  Add Beurdouche as a co-author](https://github.com/mlswg/mls-protocol/commit/a3ac74a28e2417f9d08fe45375298db7bb7b3315) by [jmillican](https://github.com/jmillican)\n:hammer_and_wrench: [Add Beurdouche as a co-author](https://github.com/mlswg/mls-protocol/commit/af877ca3eb8c50a1bbfe6095756d7186aa5e221c) by [bifurcation](https://github.com/bifurcation)\n\n - - - \n# CONTRIBUTORS\nLast week there were 2 contributors.\n:bust_in_silhouette: [jmillican](https://github.com/jmillican)\n:bust_in_silhouette: [bifurcation](https://github.com/bifurcation)\n\n - - - \n# STARGAZERS\nLast week there were no stargazers.\n\n - - - \n# RELEASES\nLast week there were no releases.\n\n - - - \n\nThat's all for last week, please <kbd>:eyes: **Watch**</kbd> and <kbd>:star: **Star**</kbd> the repository [*mlswg/mls-protocol*](https://github.com/mlswg/mls-protocol) to receive next weekly updates. :smiley:\n\n*You can also [view all Weekly Digests by clicking here](https://github.com/mlswg/mls-protocol/issues?q=is:open+is:issue+label:weekly-digest).* \n\n> Your [**Weekly Digest**](https://github.com/apps/weekly-digest) bot. :calendar:\n",
      "createdAt": "2019-06-09T06:19:28Z",
      "updatedAt": "2019-06-23T08:38:49Z",
      "closedAt": "2019-06-23T08:38:49Z",
      "comments": []
    },
    {
      "number": 181,
      "id": "MDU6SXNzdWU0NTY2MDcxODM=",
      "title": "Weekly Digest (9 June, 2019 - 16 June, 2019)",
      "url": "https://github.com/mlswg/mls-protocol/issues/181",
      "state": "CLOSED",
      "author": "weekly-digest",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "weekly-digest"
      ],
      "body": "Here's the **Weekly Digest** for [*mlswg/mls-protocol*](https://github.com/mlswg/mls-protocol):\n\n - - - \n# ISSUES\nLast week, no issues were created.\n\n - - - \n# PULL REQUESTS\nLast week, no pull requests were created, updated or merged.\n\n - - - \n# COMMITS\nLast week there were no commits.\n\n - - - \n# CONTRIBUTORS\nLast week there were no contributors.\n\n - - - \n# STARGAZERS\nLast week there were 3 stagazers.\n:star: [ianopolous](https://github.com/ianopolous)\n:star: [yisiliu](https://github.com/yisiliu)\n:star: [hatgit](https://github.com/hatgit)\nYou all are the stars! :star2:\n\n - - - \n# RELEASES\nLast week there were no releases.\n\n - - - \n\nThat's all for last week, please <kbd>:eyes: **Watch**</kbd> and <kbd>:star: **Star**</kbd> the repository [*mlswg/mls-protocol*](https://github.com/mlswg/mls-protocol) to receive next weekly updates. :smiley:\n\n*You can also [view all Weekly Digests by clicking here](https://github.com/mlswg/mls-protocol/issues?q=is:open+is:issue+label:weekly-digest).* \n\n> Your [**Weekly Digest**](https://github.com/apps/weekly-digest) bot. :calendar:\n",
      "createdAt": "2019-06-16T06:19:27Z",
      "updatedAt": "2019-06-23T08:38:50Z",
      "closedAt": "2019-06-23T08:38:50Z",
      "comments": []
    },
    {
      "number": 182,
      "id": "MDU6SXNzdWU0NTk1NDEzMTE=",
      "title": "Weekly Digest (16 June, 2019 - 23 June, 2019)",
      "url": "https://github.com/mlswg/mls-protocol/issues/182",
      "state": "CLOSED",
      "author": "weekly-digest",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "weekly-digest"
      ],
      "body": "Here's the **Weekly Digest** for [*mlswg/mls-protocol*](https://github.com/mlswg/mls-protocol):\n\n - - - \n# ISSUES\nLast week, no issues were created.\n\n - - - \n# PULL REQUESTS\nLast week, no pull requests were created, updated or merged.\n\n - - - \n# COMMITS\nLast week there were no commits.\n\n - - - \n# CONTRIBUTORS\nLast week there were no contributors.\n\n - - - \n# STARGAZERS\nLast week there were 2 stagazers.\n:star: [defclass](https://github.com/defclass)\n:star: [capt8bit](https://github.com/capt8bit)\nYou all are the stars! :star2:\n\n - - - \n# RELEASES\nLast week there were no releases.\n\n - - - \n\nThat's all for last week, please <kbd>:eyes: **Watch**</kbd> and <kbd>:star: **Star**</kbd> the repository [*mlswg/mls-protocol*](https://github.com/mlswg/mls-protocol) to receive next weekly updates. :smiley:\n\n*You can also [view all Weekly Digests by clicking here](https://github.com/mlswg/mls-protocol/issues?q=is:open+is:issue+label:weekly-digest).* \n\n> Your [**Weekly Digest**](https://github.com/apps/weekly-digest) bot. :calendar:\n",
      "createdAt": "2019-06-23T06:19:27Z",
      "updatedAt": "2019-06-23T08:38:50Z",
      "closedAt": "2019-06-23T08:38:50Z",
      "comments": []
    },
    {
      "number": 185,
      "id": "MDU6SXNzdWU0NjQ5MTY3MjQ=",
      "title": "Weekly Digest (30 June, 2019 - 7 July, 2019)",
      "url": "https://github.com/mlswg/mls-protocol/issues/185",
      "state": "CLOSED",
      "author": "weekly-digest",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "weekly-digest"
      ],
      "body": "Here's the Weekly Digest for [mlswg/mls-protocol](https://github.com/mlswg/mls-protocol):\n# ISSUES \nThis week, 8 issues were created. Of these, 4 issues have been closed and 4 issues are still open. \n## OPEN ISSUES \n:green_heart: #171 [Specify an Init message](https://github.com/mlswg/mls-protocol/pull/171), by [bifurcation](https://github.com/bifurcation)\n:green_heart: #146 [Tree based app keyschedule](https://github.com/mlswg/mls-protocol/pull/146), by [psyoptix](https://github.com/psyoptix)\n:green_heart: #144 [Application Secret deletion](https://github.com/mlswg/mls-protocol/issues/144), by [beurdouche](https://github.com/beurdouche)\n:green_heart: #105 [Version negotiation](https://github.com/mlswg/mls-protocol/issues/105), by [bifurcation](https://github.com/bifurcation)\n## CLOSED ISSUES \n:heart: #184 [Clarify how HPKE ciphertexts are computed](https://github.com/mlswg/mls-protocol/pull/184), by [rozbb](https://github.com/rozbb)\n:heart: #183 [Multiple clarifications around Framing](https://github.com/mlswg/mls-protocol/pull/183), by [rozbb](https://github.com/rozbb)\n:heart: #152 [Make epochs unpredictable](https://github.com/mlswg/mls-protocol/pull/152), by [bifurcation](https://github.com/bifurcation)\n:heart: #113 [Algorithm agility and ciphersuites (Issue #95)](https://github.com/mlswg/mls-protocol/pull/113), by [beurdouche](https://github.com/beurdouche)\n## NOISY ISSUE \nThe issue most discussed this week has been:\n:speaker: #152 [Make epochs unpredictable](https://github.com/mlswg/mls-protocol/pull/152), by [bifurcation](https://github.com/bifurcation)\nIt received 9 comments.\n\n# PULL REQUESTS\nThis week, no pull requests has been proposed by the users. \n\n# CONTRIBUTORS \nThis week, 4 users have contributed to this repository. \nThey are [rozbb](https://github.com/rozbb), [bifurcation](https://github.com/bifurcation), [psyoptix](https://github.com/psyoptix), and [beurdouche](https://github.com/beurdouche).\n\n# STARGAZERS\nThis week, no user has starred this repository.\n\n# COMMITS\nThis week, there have been 4 commits in the repository.\nThese are: \n:hammer_and_wrench: [Merge pull request #183 from rozbb/mlsplaintext-signature\n\nMultiple clarifications around Framing](https://github.com/mlswg/mls-protocol/commit/74987e2b70e3bc5c2e02b0092d5bbb21cb7ae1eb) by [bifurcation](https://github.com/bifurcation)\n:hammer_and_wrench: [Merge pull request #184 from rozbb/hpke-encrypt\n\nClarify how HPKE ciphertexts are computed](https://github.com/mlswg/mls-protocol/commit/12b572eb379a571ff7830337201e3549f7912989) by [bifurcation](https://github.com/bifurcation)\n:hammer_and_wrench: [SetupBaseI returns eph_key, context](https://github.com/mlswg/mls-protocol/commit/f18d0d28f87af9998e74659172e4b658596e35ff) by [rozbb](https://github.com/rozbb)\n:hammer_and_wrench: [Turned em-dashes into `--` surrounded by single spaces](https://github.com/mlswg/mls-protocol/commit/edd48b4d01c2ca99c9f8cbc2c263699311ddb3f0) by [rozbb](https://github.com/rozbb)\n\n # RELEASES\nThis week, no releases were published.\n\nThat's all for this week, please watch :eyes: and star :star: [mlswg/mls-protocol](https://github.com/mlswg/mls-protocol) to receive next weekly updates. :smiley:",
      "createdAt": "2019-07-07T05:31:06Z",
      "updatedAt": "2019-07-08T13:58:17Z",
      "closedAt": "2019-07-08T13:58:17Z",
      "comments": []
    },
    {
      "number": 199,
      "id": "MDU6SXNzdWU0ODE5Nzk4NzA=",
      "title": "Weekly Digest (11 August, 2019 - 18 August, 2019)",
      "url": "https://github.com/mlswg/mls-protocol/issues/199",
      "state": "CLOSED",
      "author": "weekly-digest",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "weekly-digest"
      ],
      "body": "Here's the **Weekly Digest** for [*mlswg/mls-protocol*](https://github.com/mlswg/mls-protocol):\n\n - - - \n# ISSUES\nLast week 2 issues were created.\nOf these, 1 issues have been closed and 1 issues are still open.\n## OPEN ISSUES\n:green_heart: #198 [Initial design for the key schedule Exporter](https://github.com/mlswg/mls-protocol/pull/198), by [beurdouche](https://github.com/beurdouche)\n## CLOSED ISSUES\n:heart: #197 [Minor edit](https://github.com/mlswg/mls-protocol/pull/197), by [seanieb](https://github.com/seanieb)\n## LIKED ISSUE\n:+1: #198 [Initial design for the key schedule Exporter](https://github.com/mlswg/mls-protocol/pull/198), by [beurdouche](https://github.com/beurdouche)\nIt received :+1: x1, :smile: x0, :tada: x0 and :heart: x0.\n## NOISY ISSUE\n:speaker: #197 [Minor edit](https://github.com/mlswg/mls-protocol/pull/197), by [seanieb](https://github.com/seanieb)\nIt received 1 comments.\n\n - - - \n# PULL REQUESTS\nLast week, 3 pull requests were created, updated or merged.\n## OPEN PULL REQUEST\nLast week, 1 pull request was opened.\n:green_heart: #198 [Initial design for the key schedule Exporter](https://github.com/mlswg/mls-protocol/pull/198), by [beurdouche](https://github.com/beurdouche)\n## UPDATED PULL REQUEST\nLast week, 1 pull request was updated.\n:yellow_heart: #194 [Clarified and Changed WelcomeInfo Secrets](https://github.com/mlswg/mls-protocol/pull/194), by [rozbb](https://github.com/rozbb)\n## MERGED PULL REQUEST\nLast week, 1 pull request was merged.\n:purple_heart: #197 [Minor edit](https://github.com/mlswg/mls-protocol/pull/197), by [seanieb](https://github.com/seanieb)\n\n - - - \n# COMMITS\nLast week there were 2 commits.\n:hammer_and_wrench: [Merge pull request #197 from seanieb/patch-1  Minor edit](https://github.com/mlswg/mls-protocol/commit/483c2b2d87c4e2911a7428ea38d04bae938258dc) by [beurdouche](https://github.com/beurdouche)\n:hammer_and_wrench: [Minor edit   The operations in the lifecycle of a group has been reduced to three.](https://github.com/mlswg/mls-protocol/commit/9743c0e671eb1c18894703f18aff1e44d9ce5b94) by [seanieb](https://github.com/seanieb)\n\n - - - \n# CONTRIBUTORS\nLast week there were 2 contributors.\n:bust_in_silhouette: [beurdouche](https://github.com/beurdouche)\n:bust_in_silhouette: [seanieb](https://github.com/seanieb)\n\n - - - \n# STARGAZERS\nLast week there were 3 stagazers.\n:star: [Metalnem](https://github.com/Metalnem)\n:star: [ahmgeek](https://github.com/ahmgeek)\n:star: [dconnolly](https://github.com/dconnolly)\nYou all are the stars! :star2:\n\n - - - \n# RELEASES\nLast week there were no releases.\n\n - - - \n\nThat's all for last week, please <kbd>:eyes: **Watch**</kbd> and <kbd>:star: **Star**</kbd> the repository [*mlswg/mls-protocol*](https://github.com/mlswg/mls-protocol) to receive next weekly updates. :smiley:\n\n*You can also [view all Weekly Digests by clicking here](https://github.com/mlswg/mls-protocol/issues?q=is:open+is:issue+label:weekly-digest).* \n\n> Your [**Weekly Digest**](https://github.com/apps/weekly-digest) bot. :calendar:\n",
      "createdAt": "2019-08-18T10:48:56Z",
      "updatedAt": "2019-09-27T09:04:16Z",
      "closedAt": "2019-09-27T09:04:16Z",
      "comments": []
    },
    {
      "number": 202,
      "id": "MDU6SXNzdWU0ODQ5MTY5Mzg=",
      "title": "Weekly Digest (18 August, 2019 - 25 August, 2019)",
      "url": "https://github.com/mlswg/mls-protocol/issues/202",
      "state": "CLOSED",
      "author": "weekly-digest",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "weekly-digest"
      ],
      "body": "Here's the **Weekly Digest** for [*mlswg/mls-protocol*](https://github.com/mlswg/mls-protocol):\n\n - - - \n# ISSUES\nLast week 2 issues were created.\nOf these, 0 issues have been closed and 2 issues are still open.\n## OPEN ISSUES\n:green_heart: #201 [Define enum values for ProtocolVersion.](https://github.com/mlswg/mls-protocol/pull/201), by [Bren2010](https://github.com/Bren2010)\n:green_heart: #200 [Non-destructive add](https://github.com/mlswg/mls-protocol/pull/200), by [bifurcation](https://github.com/bifurcation)\n\n - - - \n# PULL REQUESTS\nLast week, 8 pull requests were created, updated or merged.\n## OPEN PULL REQUEST\nLast week, 1 pull request was opened.\n:green_heart: #201 [Define enum values for ProtocolVersion.](https://github.com/mlswg/mls-protocol/pull/201), by [Bren2010](https://github.com/Bren2010)\n## UPDATED PULL REQUEST\nLast week, 5 pull requests were updated.\n:yellow_heart: #200 [Non-destructive add](https://github.com/mlswg/mls-protocol/pull/200), by [bifurcation](https://github.com/bifurcation)\n:yellow_heart: #198 [Initial design for the key schedule Exporter](https://github.com/mlswg/mls-protocol/pull/198), by [beurdouche](https://github.com/beurdouche)\n:yellow_heart: #196 [Cleaned up beginning of Cryptographic Objects section](https://github.com/mlswg/mls-protocol/pull/196), by [rozbb](https://github.com/rozbb)\n:yellow_heart: #194 [Clarified and Changed WelcomeInfo Secrets](https://github.com/mlswg/mls-protocol/pull/194), by [rozbb](https://github.com/rozbb)\n:yellow_heart: #192 [Made it clear that Init messages MUST be sent unencrypted](https://github.com/mlswg/mls-protocol/pull/192), by [rozbb](https://github.com/rozbb)\n## MERGED PULL REQUEST\nLast week, 2 pull requests were merged.\n:purple_heart: #195 [Tightened up wording in AS tree deletion sched](https://github.com/mlswg/mls-protocol/pull/195), by [rozbb](https://github.com/rozbb)\n:purple_heart: #193 [Fix formatting issues.](https://github.com/mlswg/mls-protocol/pull/193), by [Bren2010](https://github.com/Bren2010)\n\n - - - \n# COMMITS\nLast week there were 2 commits.\n:hammer_and_wrench: [Merge pull request #195 from rozbb/astree-style-fixes  Tightened up wording in AS tree deletion sched](https://github.com/mlswg/mls-protocol/commit/4e60ddcd16df6ed524f64bf701fc4126594e4157) by [bifurcation](https://github.com/bifurcation)\n:hammer_and_wrench: [Merge pull request #193 from Bren2010/brendan/2019.7.0  Fix formatting issues.](https://github.com/mlswg/mls-protocol/commit/996280ee06a12ce7d51975bf929284cb59de7c3f) by [bifurcation](https://github.com/bifurcation)\n\n - - - \n# CONTRIBUTORS\nLast week there was 1 contributor.\n:bust_in_silhouette: [bifurcation](https://github.com/bifurcation)\n\n - - - \n# STARGAZERS\nLast week there was 1 stargazer.\n:star: [eau-u4f](https://github.com/eau-u4f)\nYou are the star! :star2:\n\n - - - \n# RELEASES\nLast week there were no releases.\n\n - - - \n\nThat's all for last week, please <kbd>:eyes: **Watch**</kbd> and <kbd>:star: **Star**</kbd> the repository [*mlswg/mls-protocol*](https://github.com/mlswg/mls-protocol) to receive next weekly updates. :smiley:\n\n*You can also [view all Weekly Digests by clicking here](https://github.com/mlswg/mls-protocol/issues?q=is:open+is:issue+label:weekly-digest).* \n\n> Your [**Weekly Digest**](https://github.com/apps/weekly-digest) bot. :calendar:\n",
      "createdAt": "2019-08-25T10:48:54Z",
      "updatedAt": "2019-09-27T09:04:16Z",
      "closedAt": "2019-09-27T09:04:16Z",
      "comments": []
    },
    {
      "number": 205,
      "id": "MDU6SXNzdWU0ODc4NzA1NDA=",
      "title": "Weekly Digest (25 August, 2019 - 1 September, 2019)",
      "url": "https://github.com/mlswg/mls-protocol/issues/205",
      "state": "CLOSED",
      "author": "weekly-digest",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "weekly-digest"
      ],
      "body": "Here's the **Weekly Digest** for [*mlswg/mls-protocol*](https://github.com/mlswg/mls-protocol):\n\n - - - \n# ISSUES\nLast week 2 issues were created.\nOf these, 0 issues have been closed and 2 issues are still open.\n## OPEN ISSUES\n:green_heart: #204 [Update ClientInitKey to contain only one ciphersuite.](https://github.com/mlswg/mls-protocol/pull/204), by [Bren2010](https://github.com/Bren2010)\n:green_heart: #203 [HPKECiphertext takes generic KEM output, not a public key.](https://github.com/mlswg/mls-protocol/pull/203), by [Bren2010](https://github.com/Bren2010)\n\n - - - \n# PULL REQUESTS\nLast week, 2 pull requests were created, updated or merged.\n## OPEN PULL REQUEST\nLast week, 2 pull requests were opened.\n:green_heart: #204 [Update ClientInitKey to contain only one ciphersuite.](https://github.com/mlswg/mls-protocol/pull/204), by [Bren2010](https://github.com/Bren2010)\n:green_heart: #203 [HPKECiphertext takes generic KEM output, not a public key.](https://github.com/mlswg/mls-protocol/pull/203), by [Bren2010](https://github.com/Bren2010)\n\n - - - \n# COMMITS\nLast week there were no commits.\n\n - - - \n# CONTRIBUTORS\nLast week there were no contributors.\n\n - - - \n# STARGAZERS\nLast week there were 2 stagazers.\n:star: [ericwestfall](https://github.com/ericwestfall)\n:star: [myfreeweb](https://github.com/myfreeweb)\nYou all are the stars! :star2:\n\n - - - \n# RELEASES\nLast week there were no releases.\n\n - - - \n\nThat's all for last week, please <kbd>:eyes: **Watch**</kbd> and <kbd>:star: **Star**</kbd> the repository [*mlswg/mls-protocol*](https://github.com/mlswg/mls-protocol) to receive next weekly updates. :smiley:\n\n*You can also [view all Weekly Digests by clicking here](https://github.com/mlswg/mls-protocol/issues?q=is:open+is:issue+label:weekly-digest).* \n\n> Your [**Weekly Digest**](https://github.com/apps/weekly-digest) bot. :calendar:\n",
      "createdAt": "2019-09-01T10:48:37Z",
      "updatedAt": "2019-09-27T09:04:17Z",
      "closedAt": "2019-09-27T09:04:17Z",
      "comments": []
    },
    {
      "number": 206,
      "id": "MDU6SXNzdWU0OTA3MzkzNDY=",
      "title": "Weekly Digest (1 September, 2019 - 8 September, 2019)",
      "url": "https://github.com/mlswg/mls-protocol/issues/206",
      "state": "CLOSED",
      "author": "weekly-digest",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "weekly-digest"
      ],
      "body": "Here's the **Weekly Digest** for [*mlswg/mls-protocol*](https://github.com/mlswg/mls-protocol):\n\n - - - \n# ISSUES\nLast week, no issues were created.\n\n - - - \n# PULL REQUESTS\nLast week, no pull requests were created, updated or merged.\n\n - - - \n# COMMITS\nLast week there were no commits.\n\n - - - \n# CONTRIBUTORS\nLast week there were no contributors.\n\n - - - \n# STARGAZERS\nLast week there were 3 stagazers.\n:star: [bernarden](https://github.com/bernarden)\n:star: [1993Dajana](https://github.com/1993Dajana)\n:star: [gonzalgu](https://github.com/gonzalgu)\nYou all are the stars! :star2:\n\n - - - \n# RELEASES\nLast week there were no releases.\n\n - - - \n\nThat's all for last week, please <kbd>:eyes: **Watch**</kbd> and <kbd>:star: **Star**</kbd> the repository [*mlswg/mls-protocol*](https://github.com/mlswg/mls-protocol) to receive next weekly updates. :smiley:\n\n*You can also [view all Weekly Digests by clicking here](https://github.com/mlswg/mls-protocol/issues?q=is:open+is:issue+label:weekly-digest).* \n\n> Your [**Weekly Digest**](https://github.com/apps/weekly-digest) bot. :calendar:\n",
      "createdAt": "2019-09-08T10:48:38Z",
      "updatedAt": "2019-09-27T09:04:17Z",
      "closedAt": "2019-09-27T09:04:17Z",
      "comments": []
    },
    {
      "number": 207,
      "id": "MDU6SXNzdWU0OTM3MjI3Mzk=",
      "title": "Weekly Digest (8 September, 2019 - 15 September, 2019)",
      "url": "https://github.com/mlswg/mls-protocol/issues/207",
      "state": "CLOSED",
      "author": "weekly-digest",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "weekly-digest"
      ],
      "body": "Here's the **Weekly Digest** for [*mlswg/mls-protocol*](https://github.com/mlswg/mls-protocol):\n\n - - - \n# ISSUES\nLast week, no issues were created.\n\n - - - \n# PULL REQUESTS\nLast week, 3 pull requests were created, updated or merged.\n## UPDATED PULL REQUEST\nLast week, 2 pull requests were updated.\n:yellow_heart: #204 [Update ClientInitKey to contain only one ciphersuite.](https://github.com/mlswg/mls-protocol/pull/204), by [Bren2010](https://github.com/Bren2010)\n:yellow_heart: #203 [HPKECiphertext takes generic KEM output, not a public key.](https://github.com/mlswg/mls-protocol/pull/203), by [Bren2010](https://github.com/Bren2010)\n## MERGED PULL REQUEST\nLast week, 1 pull request was merged.\n:purple_heart: #201 [Define enum values for ProtocolVersion.](https://github.com/mlswg/mls-protocol/pull/201), by [Bren2010](https://github.com/Bren2010)\n\n - - - \n# COMMITS\nLast week there was 1 commit.\n:hammer_and_wrench: [Merge pull request #201 from Bren2010/brendan/2019.8.0  Define enum values for ProtocolVersion.](https://github.com/mlswg/mls-protocol/commit/b8eed965739bae912b971e6156a377656f1884c0) by [bifurcation](https://github.com/bifurcation)\n\n - - - \n# CONTRIBUTORS\nLast week there was 1 contributor.\n:bust_in_silhouette: [bifurcation](https://github.com/bifurcation)\n\n - - - \n# STARGAZERS\nLast week there was 1 stargazer.\n:star: [rmdouglas](https://github.com/rmdouglas)\nYou are the star! :star2:\n\n - - - \n# RELEASES\nLast week there were no releases.\n\n - - - \n\nThat's all for last week, please <kbd>:eyes: **Watch**</kbd> and <kbd>:star: **Star**</kbd> the repository [*mlswg/mls-protocol*](https://github.com/mlswg/mls-protocol) to receive next weekly updates. :smiley:\n\n*You can also [view all Weekly Digests by clicking here](https://github.com/mlswg/mls-protocol/issues?q=is:open+is:issue+label:weekly-digest).* \n\n> Your [**Weekly Digest**](https://github.com/apps/weekly-digest) bot. :calendar:\n",
      "createdAt": "2019-09-15T10:48:42Z",
      "updatedAt": "2019-09-27T09:04:17Z",
      "closedAt": "2019-09-27T09:04:17Z",
      "comments": []
    },
    {
      "number": 211,
      "id": "MDU6SXNzdWU0OTY3NjI2MDA=",
      "title": "Weekly Digest (15 September, 2019 - 22 September, 2019)",
      "url": "https://github.com/mlswg/mls-protocol/issues/211",
      "state": "CLOSED",
      "author": "weekly-digest",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "weekly-digest"
      ],
      "body": "Here's the **Weekly Digest** for [*mlswg/mls-protocol*](https://github.com/mlswg/mls-protocol):\n\n - - - \n# ISSUES\nLast week 3 issues were created.\nOf these, 1 issues have been closed and 2 issues are still open.\n## OPEN ISSUES\n:green_heart: #209 [Proposals and Commits](https://github.com/mlswg/mls-protocol/pull/209), by [bifurcation](https://github.com/bifurcation)\n:green_heart: #208 [Add authenticated_data to the mls message.](https://github.com/mlswg/mls-protocol/pull/208), by [psla](https://github.com/psla)\n## CLOSED ISSUES\n:heart: #210 [Update changelog for recent PRs](https://github.com/mlswg/mls-protocol/pull/210), by [bifurcation](https://github.com/bifurcation)\n## NOISY ISSUE\n:speaker: #210 [Update changelog for recent PRs](https://github.com/mlswg/mls-protocol/pull/210), by [bifurcation](https://github.com/bifurcation)\nIt received 1 comments.\n\n - - - \n# PULL REQUESTS\nLast week, 6 pull requests were created, updated or merged.\n## OPEN PULL REQUEST\nLast week, 1 pull request was opened.\n:green_heart: #208 [Add authenticated_data to the mls message.](https://github.com/mlswg/mls-protocol/pull/208), by [psla](https://github.com/psla)\n## UPDATED PULL REQUEST\nLast week, 1 pull request was updated.\n:yellow_heart: #209 [Proposals and Commits](https://github.com/mlswg/mls-protocol/pull/209), by [bifurcation](https://github.com/bifurcation)\n## MERGED PULL REQUEST\nLast week, 4 pull requests were merged.\n:purple_heart: #210 [Update changelog for recent PRs](https://github.com/mlswg/mls-protocol/pull/210), by [bifurcation](https://github.com/bifurcation)\n:purple_heart: #204 [Update ClientInitKey to contain only one ciphersuite.](https://github.com/mlswg/mls-protocol/pull/204), by [Bren2010](https://github.com/Bren2010)\n:purple_heart: #203 [HPKECiphertext takes generic KEM output, not a public key.](https://github.com/mlswg/mls-protocol/pull/203), by [Bren2010](https://github.com/Bren2010)\n:purple_heart: #196 [Cleaned up beginning of Cryptographic Objects section](https://github.com/mlswg/mls-protocol/pull/196), by [rozbb](https://github.com/rozbb)\n\n - - - \n# COMMITS\nLast week there were 6 commits.\n:hammer_and_wrench: [Merge pull request #210 from mlswg/changelog-08  Update changelog for recent PRs](https://github.com/mlswg/mls-protocol/commit/46e586329b16d9703ec321a83f79c70d6ed72c17) by [bifurcation](https://github.com/bifurcation)\n:hammer_and_wrench: [Merge pull request #196 from rozbb/cleanup-crypto-objects  Cleaned up beginning of Cryptographic Objects section](https://github.com/mlswg/mls-protocol/commit/1a201118d76925dcc1e9b31138299798d71cc90f) by [bifurcation](https://github.com/bifurcation)\n:hammer_and_wrench: [Merge branch 'master' into cleanup-crypto-objects](https://github.com/mlswg/mls-protocol/commit/cf5b19766eaf75678010de52dac80b5d1ddcb0e8) by [bifurcation](https://github.com/bifurcation)\n:hammer_and_wrench: [Update changelog for recent PRs](https://github.com/mlswg/mls-protocol/commit/5d738bd4c395d1bf18597018d77dd06c50f381cb) by [bifurcation](https://github.com/bifurcation)\n:hammer_and_wrench: [Merge pull request #204 from Bren2010/brendan/2019.8.2  Update ClientInitKey to contain only one ciphersuite.](https://github.com/mlswg/mls-protocol/commit/f7142b7c206fca6217ac87aeae76c9ea2db67c06) by [bifurcation](https://github.com/bifurcation)\n:hammer_and_wrench: [Merge pull request #203 from Bren2010/brendan/2019.8.1  HPKECiphertext takes generic KEM output, not a public key.](https://github.com/mlswg/mls-protocol/commit/e3c6e466c17ea3ca41e2be3551ad432775b3b23e) by [bifurcation](https://github.com/bifurcation)\n\n - - - \n# CONTRIBUTORS\nLast week there was 1 contributor.\n:bust_in_silhouette: [bifurcation](https://github.com/bifurcation)\n\n - - - \n# STARGAZERS\nLast week there was 1 stargazer.\n:star: [psrihari007](https://github.com/psrihari007)\nYou are the star! :star2:\n\n - - - \n# RELEASES\nLast week there were no releases.\n\n - - - \n\nThat's all for last week, please <kbd>:eyes: **Watch**</kbd> and <kbd>:star: **Star**</kbd> the repository [*mlswg/mls-protocol*](https://github.com/mlswg/mls-protocol) to receive next weekly updates. :smiley:\n\n*You can also [view all Weekly Digests by clicking here](https://github.com/mlswg/mls-protocol/issues?q=is:open+is:issue+label:weekly-digest).* \n\n> Your [**Weekly Digest**](https://github.com/apps/weekly-digest) bot. :calendar:\n",
      "createdAt": "2019-09-22T10:48:39Z",
      "updatedAt": "2019-09-27T09:04:17Z",
      "closedAt": "2019-09-27T09:04:17Z",
      "comments": []
    },
    {
      "number": 212,
      "id": "MDU6SXNzdWU0OTk4NDU2OTU=",
      "title": "Weekly Digest (22 September, 2019 - 29 September, 2019)",
      "url": "https://github.com/mlswg/mls-protocol/issues/212",
      "state": "CLOSED",
      "author": "weekly-digest",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "weekly-digest"
      ],
      "body": "Here's the **Weekly Digest** for [*mlswg/mls-protocol*](https://github.com/mlswg/mls-protocol):\n\n - - - \n# ISSUES\nLast week, no issues were created.\n\n - - - \n# PULL REQUESTS\nLast week, 1 pull request was created, updated or merged.\n## UPDATED PULL REQUEST\nLast week, 1 pull request was updated.\n:yellow_heart: #209 [Proposals and Commits](https://github.com/mlswg/mls-protocol/pull/209), by [bifurcation](https://github.com/bifurcation)\n\n - - - \n# COMMITS\nLast week there were no commits.\n\n - - - \n# CONTRIBUTORS\nLast week there were no contributors.\n\n - - - \n# STARGAZERS\nLast week there were no stargazers.\n\n - - - \n# RELEASES\nLast week there were no releases.\n\n - - - \n\nThat's all for last week, please <kbd>:eyes: **Watch**</kbd> and <kbd>:star: **Star**</kbd> the repository [*mlswg/mls-protocol*](https://github.com/mlswg/mls-protocol) to receive next weekly updates. :smiley:\n\n*You can also [view all Weekly Digests by clicking here](https://github.com/mlswg/mls-protocol/issues?q=is:open+is:issue+label:weekly-digest).* \n\n> Your [**Weekly Digest**](https://github.com/apps/weekly-digest) bot. :calendar:\n",
      "createdAt": "2019-09-29T02:31:07Z",
      "updatedAt": "2019-10-01T11:06:55Z",
      "closedAt": "2019-10-01T11:06:55Z",
      "comments": []
    },
    {
      "number": 214,
      "id": "MDU6SXNzdWU1MDA1NTI2NzY=",
      "title": "Include message type in AAD when encrypting to public keys in leaves of ratchet tree",
      "url": "https://github.com/mlswg/mls-protocol/issues/214",
      "state": "CLOSED",
      "author": "Bren2010",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "Bren2010"
      ],
      "labels": [
        "security"
      ],
      "body": "The protocol currently uses the public keys in the leaves of the ratchet tree for two purposes: For encrypting path secrets, and for encrypting WelcomeInfo data. We should include the type of message we're sending in the HPKE AAD for that message.\r\n\r\nTaking messages meant for one purpose and using them for another might leak information about the plaintext because decryption will succeed but not subsequent processing. Ex: Putting a ciphertext containing a path secret in a Welcome message and observing error \"unknown group id: abcdef123...\" or similar",
      "createdAt": "2019-09-30T22:09:16Z",
      "updatedAt": "2019-12-17T10:30:12Z",
      "closedAt": "2019-11-14T17:18:25Z",
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Question: Should this be HPKE `info` or `aad`?",
          "createdAt": "2019-10-02T08:36:35Z",
          "updatedAt": "2019-10-02T08:36:35Z"
        }
      ]
    },
    {
      "number": 215,
      "id": "MDU6SXNzdWU1MDA1NTM5NDg=",
      "title": "Restrict life of ClientInitKey",
      "url": "https://github.com/mlswg/mls-protocol/issues/215",
      "state": "CLOSED",
      "author": "Bren2010",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "beurdouche"
      ],
      "labels": [
        "security"
      ],
      "body": "Generally, the protocol provides no way to prevent ClientInitKeys from being re-used.\r\n\r\nOne case where this matters: If a user's ClientInitKey is compromised, the DS can serve it to anybody that wants to communicate with the user and immediately decrypt the user's communication, for the rest of their identity key's life.\r\n\r\nWe could put an expiry on ClientInitKeys to limit their effective lifespan. Or something else?",
      "createdAt": "2019-09-30T22:12:44Z",
      "updatedAt": "2019-12-17T10:29:59Z",
      "closedAt": "2019-11-14T18:24:07Z",
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "As discussed in the interim meeting (and in #225), the general goal here is to limit inappropriate replay of CIKs by CIK servers.  This can be done either in the CIK itself or by expiring/revoking the credential used to sign the CIK.",
          "createdAt": "2019-10-01T21:38:24Z",
          "updatedAt": "2019-10-01T21:38:24Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed in #234 ",
          "createdAt": "2019-11-14T18:23:58Z",
          "updatedAt": "2019-11-14T18:23:58Z"
        }
      ]
    },
    {
      "number": 216,
      "id": "MDU6SXNzdWU1MDA1NTQ4ODg=",
      "title": "Address risk of re-using nonces after state loss",
      "url": "https://github.com/mlswg/mls-protocol/issues/216",
      "state": "CLOSED",
      "author": "Bren2010",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "bifurcation",
        "beurdouche"
      ],
      "labels": [
        "security",
        "work in progress"
      ],
      "body": "Nonces and keys are generated deterministically. If a client's state is rolled back to a previous version (because the process crashed, for instance), then the client is very likely to re-use the same key+nonce pair to encrypt a different application message. This breaks the confidentiality of the AEAD.\r\n\r\nConsider using explicit nonces (even small ones will do) or SIV-like constructions.",
      "createdAt": "2019-09-30T22:15:45Z",
      "updatedAt": "2020-02-17T17:57:43Z",
      "closedAt": "2020-02-17T17:57:43Z",
      "comments": [
        {
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "body": "Denis Jackson already discussed this, the WG, including I, was pretty conservative\nat the time but I am feeling more and more we should do it, indeed\u2026\n\nThere are other linked problems that I\u2019ll discuss today but in general, in case of recoverable\nstate loss I would strongly favor mandating an update which would definitely help with\nthe problem. Detecting such losses is probably not trivial though :) \n\nB.",
          "createdAt": "2019-10-01T06:49:04Z",
          "updatedAt": "2019-10-01T06:49:04Z"
        },
        {
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "body": "@bifurcation Notes for reference:The other solution we thought about was using the fresh explicit nonce as a re-randomizing solution for the deterministic handshake nonce.",
          "createdAt": "2019-11-16T14:45:58Z",
          "updatedAt": "2019-11-16T14:45:58Z"
        }
      ]
    },
    {
      "number": 217,
      "id": "MDU6SXNzdWU1MDA1NTY1MjU=",
      "title": "Signatures in MLSPlaintext should cover entire group context",
      "url": "https://github.com/mlswg/mls-protocol/issues/217",
      "state": "CLOSED",
      "author": "Bren2010",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "beurdouche"
      ],
      "labels": [
        "security"
      ],
      "body": "Signatures that go in the MLSPlaintext field right now only include the group ID and epoch. The group ID does help bind the message to a specific group, but group IDs are arbitrary and it seems multiple groups could have the same ID.\r\n\r\nWe should include the whole group context object in the data that's signed, to prevent messages from being copied from one conversation and pasted into another conversation with the same group ID.",
      "createdAt": "2019-09-30T22:20:31Z",
      "updatedAt": "2019-12-17T10:29:48Z",
      "closedAt": "2019-11-14T17:18:25Z",
      "comments": [
        {
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "body": "Yes, the lack of context has been pointed out by Karthik and I at the last interim.\nI said I would fix this but I didn\u2019t find time to write the PR yet, I\u2019ll try to do that today.\n\nThanks for the remainder...\n\n\n",
          "createdAt": "2019-10-01T06:43:14Z",
          "updatedAt": "2019-10-01T06:43:14Z"
        }
      ]
    },
    {
      "number": 222,
      "id": "MDU6SXNzdWU1MDA4MTM1Njc=",
      "title": "Performance measurements",
      "url": "https://github.com/mlswg/mls-protocol/issues/222",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "question",
        "performance"
      ],
      "body": "Some messaging providers can observe the sequence of adds and removes that happen in real groups.  From that, we can simulate MLS histories, under various assumptions about Update scheduling.  The data we would need to support this is effectively a list of (add/remove(id), timestamp) tuples for each group.\r\n\r\nAt the 2019-10 interim, @eomara  and @raphaelrobert agreed to provide some data of this character.",
      "createdAt": "2019-10-01T10:44:48Z",
      "updatedAt": "2020-06-19T12:55:34Z",
      "closedAt": "2020-06-19T12:55:34Z",
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Also @dwd offered to gather XMPP data",
          "createdAt": "2019-10-02T08:38:04Z",
          "updatedAt": "2019-10-02T08:38:04Z"
        }
      ]
    },
    {
      "number": 223,
      "id": "MDU6SXNzdWU1MDA4MjQ4NDM=",
      "title": "Welcome should not leak previous epoch encryption keys",
      "url": "https://github.com/mlswg/mls-protocol/issues/223",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "bifurcation",
        "beurdouche"
      ],
      "labels": [
        "security",
        "recommendation"
      ],
      "body": "Instead of initializing new members with information from the previous epoch and requiring them to process an Add, we should initialize new members directly with current epoch information.  This is covered in #209, but should be factored out.",
      "createdAt": "2019-10-01T11:08:36Z",
      "updatedAt": "2019-12-17T10:29:30Z",
      "closedAt": "2019-11-14T18:22:31Z",
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Dependent on: Some modeling to convince ourselves that removing `welcome_info_hash` isn't dangerous\r\n\r\nBlocks: #209 ",
          "createdAt": "2019-10-02T08:46:13Z",
          "updatedAt": "2019-10-02T08:46:13Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "I have made a Tamarin model of the 2- and 3-member cases of the proposal in #233, which shows that it provides certain authentication properties that one should expect of an AKE.  In particular, it provides the property that even if the adder is malicious, they cannot cause the new member and the existing members to come to differing views of the group without causing to group to decohere.  (Since the GroupContext is included in the key schedule, this might not be surprising.)\r\n\r\nTamarin model here:\r\n\r\nhttps://github.com/bifurcation/tamarin-ake/blob/master/mls-08-3way.spthy\r\n\r\nGiven this analysis, I'm comfortable making this change.  It's preliminary, but I think it's good enough to justify moving forward with this concept pending a more complete analysis.",
          "createdAt": "2019-10-09T21:08:00Z",
          "updatedAt": "2019-10-09T21:08:00Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed in #239 ",
          "createdAt": "2019-11-14T18:22:31Z",
          "updatedAt": "2019-11-14T18:22:31Z"
        }
      ]
    },
    {
      "number": 224,
      "id": "MDU6SXNzdWU1MDA5MDU4ODc=",
      "title": "Add extensions for ClientInitKeys",
      "url": "https://github.com/mlswg/mls-protocol/issues/224",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "functionality"
      ],
      "body": "To address the risk of version / ciphersuite downgrade by the CIK server, CIKs need to express the lists of versions and ciphersuites that a client supports.\r\n\r\n* Add a general extensions field to ClientInitKey, in the same form as TLS ClientHello/ServerHello\r\n* Define a `supported_versions` extension\r\n* Define a `supported_ciphersuites` extension\r\n* Require both extensions to be present\r\n\r\nThis allows the creator of a group to verify that CIKs it gets do not omit versions that the other client actually supports.  On Init, the participants of the group can examine the CIKs in the group to verify that the proper version / ciphersuite have been selected.",
      "createdAt": "2019-10-01T13:43:32Z",
      "updatedAt": "2019-12-17T10:28:47Z",
      "closedAt": "2019-11-14T17:58:54Z",
      "comments": []
    },
    {
      "number": 225,
      "id": "MDU6SXNzdWU1MDA5MDc3NzE=",
      "title": "Limit CIK servers' ability to replay",
      "url": "https://github.com/mlswg/mls-protocol/issues/225",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "security"
      ],
      "body": "There are a variety of risks that arise from CIK servers replaying old keys.  If a CIK server has compromised the private key corresponding to a CIK, then it can use that compromised key to join groups indefinitely.  If a client operates from supporting version 2 to supporting versions 2+3, then the CIK server can force the client to use version 2 by continuing to send the old CIK (cf. #224).\r\n\r\nThere are basically two ways to approach this:\r\n\r\n* Expiry / revocation of the CIK\r\n* Expiry / revocation of the credential used to sign the CIK",
      "createdAt": "2019-10-01T13:46:20Z",
      "updatedAt": "2019-12-17T10:28:31Z",
      "closedAt": "2019-10-01T21:38:31Z",
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Duplicate of #215 ",
          "createdAt": "2019-10-01T21:38:31Z",
          "updatedAt": "2019-10-01T21:38:31Z"
        }
      ]
    },
    {
      "number": 226,
      "id": "MDU6SXNzdWU1MDExNTgzODA=",
      "title": "Generalize ASTree to create multi-use per-user secrets",
      "url": "https://github.com/mlswg/mls-protocol/issues/226",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "wontfix",
        "security"
      ],
      "body": "At a minimum we need to make handshake key chains.  If we do Proposals (#209), then we will need to encrypt multiple handshake message per epoch, so we will need key chains instead of just a single handshake key.  Even if we don't do #209, this would improve symmetry / code reuse.\r\n\r\nSpecifically, we should repurpose the ASTree \"per-user secret tree\".  Instead of the leaves of the tree being the starting point for an application key chain, there would be used to derive the starting points for the application key chain, handshake key chain, and possibly exported per-user secrets.\r\n\r\n```\r\n...\r\n | \r\n +--(handshake)--> handshake_secret_[sender]_[0]\r\n | \r\n +--(application)--> application_secret_[sender]_[0]\r\n | \r\n +--(exporter+label)--> exported_secret_[sender]_[label]\r\n```",
      "createdAt": "2019-10-01T21:34:32Z",
      "updatedAt": "2019-12-17T10:28:11Z",
      "closedAt": "2019-11-14T18:22:06Z",
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "This ended up not being necessary.  For handshake messages, we don't need forward secrecy within an epoch, so the full AStree machinery isn't necessary.  Instead we use the simple TLS-like nonce updating described in #209 ",
          "createdAt": "2019-11-14T18:22:06Z",
          "updatedAt": "2019-11-14T18:22:06Z"
        }
      ]
    },
    {
      "number": 227,
      "id": "MDU6SXNzdWU1MDEzNjg0NTI=",
      "title": "Expose extended group attributes to new/existing members",
      "url": "https://github.com/mlswg/mls-protocol/issues/227",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "bifurcation",
        "beurdouche"
      ],
      "labels": [
        "enhancement",
        "security",
        "? follow-up"
      ],
      "body": "It could be useful for groups to agree on extended attributes (@psyoptix to provide examples), which are provided to new members and agreed by existing members.  Syntactically, this would mean:\r\n\r\n* An extensions field in the WelcomeInfo message\r\n* Including that field in the GroupContext so that it is confirmed that all members agree\r\n\r\nThat is, these attributes should follow the same general pattern as ciphersuites and versions, where the CIK advertises them (cf. #224) and the group picks and confirms.",
      "createdAt": "2019-10-02T09:09:31Z",
      "updatedAt": "2019-12-20T16:38:04Z",
      "closedAt": "2019-12-20T16:38:03Z",
      "comments": [
        {
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "body": "We now have CIK in the leaves #254, hence exposing not only the credential but also the extensions. We currently don't have mechanisms to extend group attribute within the protocol after initial \"agreement\" provided by accepting the message from the creator.",
          "createdAt": "2019-12-20T16:38:03Z",
          "updatedAt": "2019-12-20T16:38:03Z"
        }
      ]
    },
    {
      "number": 228,
      "id": "MDU6SXNzdWU1MDE0MjEyNzQ=",
      "title": "Re-randomize TreeKEM keys",
      "url": "https://github.com/mlswg/mls-protocol/issues/228",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "security",
        "performance"
      ],
      "body": "At the 2019-10 interim, @psyoptix described some work to re-randomize the tree as updates happen:\r\n\r\n* Distribute `(Enc(r), g^r)` in Update/Commit message\r\n* Transform the recipient public key as `x -> x+r, g^x -> g^{x+r}`\r\n\r\nBenefits are roughly some better FS properties, to be described in a forthcoming ePrint.\r\n\r\nCosts:\r\n* Additional public key in `DirectPath`\r\n* Restriction to curves with homomorphic multiplication (in particular, X25519->Ristretto)\r\n* Possibly harder modeling",
      "createdAt": "2019-10-02T11:04:23Z",
      "updatedAt": "2020-01-31T15:12:45Z",
      "closedAt": "2020-01-31T15:12:45Z",
      "comments": [
        {
          "author": "psyoptix",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Improvement to construction which allows using X25510/X448\r\n- Basic Idea: Use multiplicative \"updateable PKE\" instead of additive.\r\n\r\nWhen sending HPKE ciphertext for some message m to (pk, sk) in Update/Commit do:\r\n1) Sample re-randomizer r'. Compute re-randomizer scalar r = HKDF(r, pk, context...).\r\n2) Transform receiver's pk from g^x -> (g^x)^r = g^xr'=: pk'. Send  c <-- Enc(pk, r'|| m). Send (pk', c)\r\n3) Receiver use sk to decrypt c. gets m and r'. compute r. Update sk x to sk' := xr.\r\n\r\nSee \"UPKE for X25519/X448\" and draft-barnes-cfrg-mult-for-7748-00 RFC draft for how to implement \"*\" operation for updating sk --> sk' when using X25519/X448 curves.\r\n\r\n\r\n",
          "createdAt": "2020-01-11T15:00:58Z",
          "updatedAt": "2020-01-11T15:00:58Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "This was discussed at the January 2020 interim, with the conclusion that while this an interesting idea, it would be better handled as an extension.",
          "createdAt": "2020-01-31T15:12:45Z",
          "updatedAt": "2020-01-31T15:12:45Z"
        }
      ]
    },
    {
      "number": 231,
      "id": "MDU6SXNzdWU1MDMwNDI1Nzc=",
      "title": "Weekly Digest (29 September, 2019 - 6 October, 2019)",
      "url": "https://github.com/mlswg/mls-protocol/issues/231",
      "state": "CLOSED",
      "author": "weekly-digest",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "weekly-digest"
      ],
      "body": "Here's the **Weekly Digest** for [*mlswg/mls-protocol*](https://github.com/mlswg/mls-protocol):\n\n - - - \n# ISSUES\nLast week 18 issues were created.\nOf these, 3 issues have been closed and 15 issues are still open.\n## OPEN ISSUES\n:green_heart: #230 [Device loss and sig key compromise](https://github.com/mlswg/mls-protocol/pull/230), by [beurdouche](https://github.com/beurdouche)\n:green_heart: #228 [Re-randomize TreeKEM keys](https://github.com/mlswg/mls-protocol/issues/228), by [bifurcation](https://github.com/bifurcation)\n:green_heart: #227 [Expose extended group attributes to new/existing members](https://github.com/mlswg/mls-protocol/issues/227), by [bifurcation](https://github.com/bifurcation)\n:green_heart: #226 [Generalize ASTree to create multi-use per-user secrets](https://github.com/mlswg/mls-protocol/issues/226), by [bifurcation](https://github.com/bifurcation)\n:green_heart: #224 [Add extensions for ClientInitKeys](https://github.com/mlswg/mls-protocol/issues/224), by [bifurcation](https://github.com/bifurcation)\n:green_heart: #223 [Welcome should not leak previous epoch encryption keys](https://github.com/mlswg/mls-protocol/issues/223), by [bifurcation](https://github.com/bifurcation)\n:green_heart: #222 [Performance measurements](https://github.com/mlswg/mls-protocol/issues/222), by [bifurcation](https://github.com/bifurcation)\n:green_heart: #221 [Precisions on authentication and IdentityKeys](https://github.com/mlswg/mls-protocol/pull/221), by [beurdouche](https://github.com/beurdouche)\n:green_heart: #220 [More requirements regarding state loss](https://github.com/mlswg/mls-protocol/pull/220), by [beurdouche](https://github.com/beurdouche)\n:green_heart: #219 [Fix application message truncation attack](https://github.com/mlswg/mls-protocol/pull/219), by [beurdouche](https://github.com/beurdouche)\n:green_heart: #218 [Favor not reusing ClientInitKey reuse (SHOULD)](https://github.com/mlswg/mls-protocol/pull/218), by [beurdouche](https://github.com/beurdouche)\n:green_heart: #217 [Signatures in MLSPlaintext should cover entire group context](https://github.com/mlswg/mls-protocol/issues/217), by [Bren2010](https://github.com/Bren2010)\n:green_heart: #216 [Address risk of re-using nonces after state loss](https://github.com/mlswg/mls-protocol/issues/216), by [Bren2010](https://github.com/Bren2010)\n:green_heart: #215 [Restrict life of ClientInitKey](https://github.com/mlswg/mls-protocol/issues/215), by [Bren2010](https://github.com/Bren2010)\n:green_heart: #214 [Include message type in AAD when encrypting to public keys in leaves of ratchet tree](https://github.com/mlswg/mls-protocol/issues/214), by [Bren2010](https://github.com/Bren2010)\n## CLOSED ISSUES\n:heart: #229 [Correction of three minor typos](https://github.com/mlswg/mls-protocol/pull/229), by [pjunodsc](https://github.com/pjunodsc)\n:heart: #225 [Limit CIK servers' ability to replay](https://github.com/mlswg/mls-protocol/issues/225), by [bifurcation](https://github.com/bifurcation)\n:heart: #213 [Change ciphertext content to be standard TLS format.](https://github.com/mlswg/mls-protocol/pull/213), by [Bren2010](https://github.com/Bren2010)\n## NOISY ISSUE\n:speaker: #219 [Fix application message truncation attack](https://github.com/mlswg/mls-protocol/pull/219), by [beurdouche](https://github.com/beurdouche)\nIt received 5 comments.\n\n - - - \n# PULL REQUESTS\nLast week, 10 pull requests were created, updated or merged.\n## OPEN PULL REQUEST\nLast week, 1 pull request was opened.\n:green_heart: #230 [Device loss and sig key compromise](https://github.com/mlswg/mls-protocol/pull/230), by [beurdouche](https://github.com/beurdouche)\n## UPDATED PULL REQUEST\nLast week, 7 pull requests were updated.\n:yellow_heart: #221 [Precisions on authentication and IdentityKeys](https://github.com/mlswg/mls-protocol/pull/221), by [beurdouche](https://github.com/beurdouche)\n:yellow_heart: #220 [More requirements regarding state loss](https://github.com/mlswg/mls-protocol/pull/220), by [beurdouche](https://github.com/beurdouche)\n:yellow_heart: #219 [Fix application message truncation attack](https://github.com/mlswg/mls-protocol/pull/219), by [beurdouche](https://github.com/beurdouche)\n:yellow_heart: #218 [Favor not reusing ClientInitKey reuse (SHOULD)](https://github.com/mlswg/mls-protocol/pull/218), by [beurdouche](https://github.com/beurdouche)\n:yellow_heart: #209 [Proposals and Commits](https://github.com/mlswg/mls-protocol/pull/209), by [bifurcation](https://github.com/bifurcation)\n:yellow_heart: #208 [Add authenticated_data to the mls message.](https://github.com/mlswg/mls-protocol/pull/208), by [psla](https://github.com/psla)\n:yellow_heart: #200 [Non-destructive add](https://github.com/mlswg/mls-protocol/pull/200), by [bifurcation](https://github.com/bifurcation)\n## MERGED PULL REQUEST\nLast week, 2 pull requests were merged.\n:purple_heart: #229 [Correction of three minor typos](https://github.com/mlswg/mls-protocol/pull/229), by [pjunodsc](https://github.com/pjunodsc)\n:purple_heart: #213 [Change ciphertext content to be standard TLS format.](https://github.com/mlswg/mls-protocol/pull/213), by [Bren2010](https://github.com/Bren2010)\n\n - - - \n# COMMITS\nLast week there were 4 commits.\n:hammer_and_wrench: [Merge pull request #229 from pjunodsc/20191004_minor-typos  Correction of three minor typos](https://github.com/mlswg/mls-protocol/commit/d8672cf6e78d781a5ff6f9e238ee6b0db3b3f026) by [beurdouche](https://github.com/beurdouche)\n:hammer_and_wrench: [Corrected three minor typos](https://github.com/mlswg/mls-protocol/commit/328effac7452a831836ebe43391d3d2caa30cbf7) by [pjunodsc](https://github.com/pjunodsc)\n:hammer_and_wrench: [Merge pull request #213 from Bren2010/brendan/2019.9.0  Change ciphertext content to be standard TLS format.](https://github.com/mlswg/mls-protocol/commit/30c31565ce57843e10e36c69c8573da54d505a56) by [bifurcation](https://github.com/bifurcation)\n:hammer_and_wrench: [Change ciphertext content to be standard TLS format.](https://github.com/mlswg/mls-protocol/commit/1c3a2a6757ba447965ea90e2e1942d9e930d42fb) by [Bren2010](https://github.com/Bren2010)\n\n - - - \n# CONTRIBUTORS\nLast week there were 4 contributors.\n:bust_in_silhouette: [beurdouche](https://github.com/beurdouche)\n:bust_in_silhouette: [pjunodsc](https://github.com/pjunodsc)\n:bust_in_silhouette: [bifurcation](https://github.com/bifurcation)\n:bust_in_silhouette: [Bren2010](https://github.com/Bren2010)\n\n - - - \n# STARGAZERS\nLast week there were no stargazers.\n\n - - - \n# RELEASES\nLast week there were no releases.\n\n - - - \n\nThat's all for last week, please <kbd>:eyes: **Watch**</kbd> and <kbd>:star: **Star**</kbd> the repository [*mlswg/mls-protocol*](https://github.com/mlswg/mls-protocol) to receive next weekly updates. :smiley:\n\n*You can also [view all Weekly Digests by clicking here](https://github.com/mlswg/mls-protocol/issues?q=is:open+is:issue+label:weekly-digest).* \n\n> Your [**Weekly Digest**](https://github.com/apps/weekly-digest) bot. :calendar:\n",
      "createdAt": "2019-10-06T02:31:06Z",
      "updatedAt": "2019-10-07T17:29:23Z",
      "closedAt": "2019-10-07T17:29:23Z",
      "comments": []
    },
    {
      "number": 235,
      "id": "MDU6SXNzdWU1MDk1MzU2MzM=",
      "title": "Weekly Digest (13 October, 2019 - 20 October, 2019)",
      "url": "https://github.com/mlswg/mls-protocol/issues/235",
      "state": "CLOSED",
      "author": "weekly-digest",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "weekly-digest"
      ],
      "body": "Here's the **Weekly Digest** for [*mlswg/mls-protocol*](https://github.com/mlswg/mls-protocol):\n\n - - - \n# ISSUES\nLast week, no issues were created.\n\n - - - \n# PULL REQUESTS\nLast week, no pull requests were created, updated or merged.\n\n - - - \n# COMMITS\nLast week there were no commits.\n\n - - - \n# CONTRIBUTORS\nLast week there were no contributors.\n\n - - - \n# STARGAZERS\nLast week there were no stargazers.\n\n - - - \n# RELEASES\nLast week there were no releases.\n\n - - - \n\nThat's all for last week, please <kbd>:eyes: **Watch**</kbd> and <kbd>:star: **Star**</kbd> the repository [*mlswg/mls-protocol*](https://github.com/mlswg/mls-protocol) to receive next weekly updates. :smiley:\n\n*You can also [view all Weekly Digests by clicking here](https://github.com/mlswg/mls-protocol/issues?q=is:open+is:issue+label:weekly-digest).* \n\n> Your [**Weekly Digest**](https://github.com/apps/weekly-digest) bot. :calendar:\n",
      "createdAt": "2019-10-20T02:31:08Z",
      "updatedAt": "2019-10-20T13:48:13Z",
      "closedAt": "2019-10-20T13:48:13Z",
      "comments": []
    },
    {
      "number": 236,
      "id": "MDU6SXNzdWU1MTI5NDk5MDk=",
      "title": "Weekly Digest (20 October, 2019 - 27 October, 2019)",
      "url": "https://github.com/mlswg/mls-protocol/issues/236",
      "state": "CLOSED",
      "author": "weekly-digest",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "weekly-digest"
      ],
      "body": "Here's the **Weekly Digest** for [*mlswg/mls-protocol*](https://github.com/mlswg/mls-protocol):\n\n - - - \n# ISSUES\nLast week, no issues were created.\n\n - - - \n# PULL REQUESTS\nLast week, no pull requests were created, updated or merged.\n\n - - - \n# COMMITS\nLast week there were no commits.\n\n - - - \n# CONTRIBUTORS\nLast week there were no contributors.\n\n - - - \n# STARGAZERS\nLast week there were no stargazers.\n\n - - - \n# RELEASES\nLast week there were no releases.\n\n - - - \n\nThat's all for last week, please <kbd>:eyes: **Watch**</kbd> and <kbd>:star: **Star**</kbd> the repository [*mlswg/mls-protocol*](https://github.com/mlswg/mls-protocol) to receive next weekly updates. :smiley:\n\n*You can also [view all Weekly Digests by clicking here](https://github.com/mlswg/mls-protocol/issues?q=is:open+is:issue+label:weekly-digest).* \n\n> Your [**Weekly Digest**](https://github.com/apps/weekly-digest) bot. :calendar:\n",
      "createdAt": "2019-10-27T10:48:51Z",
      "updatedAt": "2019-10-27T15:58:18Z",
      "closedAt": "2019-10-27T15:58:18Z",
      "comments": []
    },
    {
      "number": 237,
      "id": "MDU6SXNzdWU1MTY4MTAzMTM=",
      "title": "Weekly Digest (27 October, 2019 - 3 November, 2019)",
      "url": "https://github.com/mlswg/mls-protocol/issues/237",
      "state": "CLOSED",
      "author": "weekly-digest",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "weekly-digest"
      ],
      "body": "Here's the **Weekly Digest** for [*mlswg/mls-protocol*](https://github.com/mlswg/mls-protocol):\n\n - - - \n# ISSUES\nLast week, no issues were created.\n\n - - - \n# PULL REQUESTS\nLast week, no pull requests were created, updated or merged.\n\n - - - \n# COMMITS\nLast week there were no commits.\n\n - - - \n# CONTRIBUTORS\nLast week there were no contributors.\n\n - - - \n# STARGAZERS\nLast week there was 1 stargazer.\n:star: [andytruong](https://github.com/andytruong)\nYou are the star! :star2:\n\n - - - \n# RELEASES\nLast week there were no releases.\n\n - - - \n\nThat's all for last week, please <kbd>:eyes: **Watch**</kbd> and <kbd>:star: **Star**</kbd> the repository [*mlswg/mls-protocol*](https://github.com/mlswg/mls-protocol) to receive next weekly updates. :smiley:\n\n*You can also [view all Weekly Digests by clicking here](https://github.com/mlswg/mls-protocol/issues?q=is:open+is:issue+label:weekly-digest).* \n\n> Your [**Weekly Digest**](https://github.com/apps/weekly-digest) bot. :calendar:\n",
      "createdAt": "2019-11-03T10:48:43Z",
      "updatedAt": "2019-11-03T11:09:56Z",
      "closedAt": "2019-11-03T11:09:56Z",
      "comments": []
    },
    {
      "number": 238,
      "id": "MDU6SXNzdWU1MjA1ODQ2MTE=",
      "title": "Weekly Digest (3 November, 2019 - 10 November, 2019)",
      "url": "https://github.com/mlswg/mls-protocol/issues/238",
      "state": "CLOSED",
      "author": "weekly-digest",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "weekly-digest"
      ],
      "body": "Here's the **Weekly Digest** for [*mlswg/mls-protocol*](https://github.com/mlswg/mls-protocol):\n\n - - - \n# ISSUES\nLast week, no issues were created.\n\n - - - \n# PULL REQUESTS\nLast week, 5 pull requests were created, updated or merged.\n## UPDATED PULL REQUEST\nLast week, 3 pull requests were updated.\n:yellow_heart: #218 [Favor not reusing ClientInitKey reuse (SHOULD)](https://github.com/mlswg/mls-protocol/pull/218), by [beurdouche](https://github.com/beurdouche)\n:yellow_heart: #209 [Proposals and Commits](https://github.com/mlswg/mls-protocol/pull/209), by [bifurcation](https://github.com/bifurcation)\n:yellow_heart: #200 [Non-destructive add](https://github.com/mlswg/mls-protocol/pull/200), by [bifurcation](https://github.com/bifurcation)\n## MERGED PULL REQUEST\nLast week, 2 pull requests were merged.\n:purple_heart: #230 [Device loss and sig key compromise](https://github.com/mlswg/mls-protocol/pull/230), by [beurdouche](https://github.com/beurdouche)\n:purple_heart: #221 [Precisions on authentication and IdentityKeys](https://github.com/mlswg/mls-protocol/pull/221), by [beurdouche](https://github.com/beurdouche)\n\n - - - \n# COMMITS\nLast week there were 2 commits.\n:hammer_and_wrench: [Merge pull request #221 from mlswg/beurdouche_auth_control  Precisions on authentication and IdentityKeys](https://github.com/mlswg/mls-protocol/commit/69739df60d07ee53c245ff9bbee7d391f1ce5b9d) by [bifurcation](https://github.com/bifurcation)\n:hammer_and_wrench: [Merge pull request #230 from mlswg/beurdouche_sig_pcs  Device loss and sig key compromise](https://github.com/mlswg/mls-protocol/commit/d4362b8075dd5e42e1a45c721874409a82a7438f) by [bifurcation](https://github.com/bifurcation)\n\n - - - \n# CONTRIBUTORS\nLast week there was 1 contributor.\n:bust_in_silhouette: [bifurcation](https://github.com/bifurcation)\n\n - - - \n# STARGAZERS\nLast week there were no stargazers.\n\n - - - \n# RELEASES\nLast week there were no releases.\n\n - - - \n\nThat's all for last week, please <kbd>:eyes: **Watch**</kbd> and <kbd>:star: **Star**</kbd> the repository [*mlswg/mls-protocol*](https://github.com/mlswg/mls-protocol) to receive next weekly updates. :smiley:\n\n*You can also [view all Weekly Digests by clicking here](https://github.com/mlswg/mls-protocol/issues?q=is:open+is:issue+label:weekly-digest).* \n\n> Your [**Weekly Digest**](https://github.com/apps/weekly-digest) bot. :calendar:\n",
      "createdAt": "2019-11-10T10:48:58Z",
      "updatedAt": "2019-11-10T12:35:46Z",
      "closedAt": "2019-11-10T12:35:46Z",
      "comments": []
    },
    {
      "number": 248,
      "id": "MDU6SXNzdWU1MjM5Njc5NjA=",
      "title": "Weekly Digest (10 November, 2019 - 17 November, 2019)",
      "url": "https://github.com/mlswg/mls-protocol/issues/248",
      "state": "CLOSED",
      "author": "weekly-digest",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "weekly-digest"
      ],
      "body": "Here's the **Weekly Digest** for [*mlswg/mls-protocol*](https://github.com/mlswg/mls-protocol):\n\n - - - \n# ISSUES\nLast week 9 issues were created.\nOf these, 6 issues have been closed and 3 issues are still open.\n## OPEN ISSUES\n:green_heart: #247 [Welcome confirmation and key derivation](https://github.com/mlswg/mls-protocol/pull/247), by [bifurcation](https://github.com/bifurcation)\n:green_heart: #246 [Bugfixes in ClientInitKey, Commit, and Welcome](https://github.com/mlswg/mls-protocol/pull/246), by [bifurcation](https://github.com/bifurcation)\n:green_heart: #245 [Unpredictable epochs](https://github.com/mlswg/mls-protocol/pull/245), by [bifurcation](https://github.com/bifurcation)\n## CLOSED ISSUES\n:heart: #244 [Some editorial fixes](https://github.com/mlswg/mls-protocol/pull/244), by [bifurcation](https://github.com/bifurcation)\n:heart: #243 [Add GroupContext to signatures and AAD](https://github.com/mlswg/mls-protocol/pull/243), by [bifurcation](https://github.com/bifurcation)\n:heart: #242 [Pack multiple Proposals and a Commit together](https://github.com/mlswg/mls-protocol/pull/242), by [bifurcation](https://github.com/bifurcation)\n:heart: #241 [IANA Considerations](https://github.com/mlswg/mls-protocol/pull/241), by [bifurcation](https://github.com/bifurcation)\n:heart: #240 [External proposals](https://github.com/mlswg/mls-protocol/pull/240), by [bifurcation](https://github.com/bifurcation)\n:heart: #239 [Welcome* == Init](https://github.com/mlswg/mls-protocol/pull/239), by [bifurcation](https://github.com/bifurcation)\n## NOISY ISSUE\n:speaker: #242 [Pack multiple Proposals and a Commit together](https://github.com/mlswg/mls-protocol/pull/242), by [bifurcation](https://github.com/bifurcation)\nIt received 2 comments.\n\n - - - \n# PULL REQUESTS\nLast week, 13 pull requests were created, updated or merged.\n## UPDATED PULL REQUEST\nLast week, 3 pull requests were updated.\n:yellow_heart: #247 [Welcome confirmation and key derivation](https://github.com/mlswg/mls-protocol/pull/247), by [bifurcation](https://github.com/bifurcation)\n:yellow_heart: #246 [Bugfixes in ClientInitKey, Commit, and Welcome](https://github.com/mlswg/mls-protocol/pull/246), by [bifurcation](https://github.com/bifurcation)\n:yellow_heart: #245 [Unpredictable epochs](https://github.com/mlswg/mls-protocol/pull/245), by [bifurcation](https://github.com/bifurcation)\n## MERGED PULL REQUEST\nLast week, 10 pull requests were merged.\n:purple_heart: #244 [Some editorial fixes](https://github.com/mlswg/mls-protocol/pull/244), by [bifurcation](https://github.com/bifurcation)\n:purple_heart: #243 [Add GroupContext to signatures and AAD](https://github.com/mlswg/mls-protocol/pull/243), by [bifurcation](https://github.com/bifurcation)\n:purple_heart: #242 [Pack multiple Proposals and a Commit together](https://github.com/mlswg/mls-protocol/pull/242), by [bifurcation](https://github.com/bifurcation)\n:purple_heart: #241 [IANA Considerations](https://github.com/mlswg/mls-protocol/pull/241), by [bifurcation](https://github.com/bifurcation)\n:purple_heart: #240 [External proposals](https://github.com/mlswg/mls-protocol/pull/240), by [bifurcation](https://github.com/bifurcation)\n:purple_heart: #239 [Welcome* == Init](https://github.com/mlswg/mls-protocol/pull/239), by [bifurcation](https://github.com/bifurcation)\n:purple_heart: #234 [Add downgrade protection to ClientInitKeys](https://github.com/mlswg/mls-protocol/pull/234), by [bifurcation](https://github.com/bifurcation)\n:purple_heart: #218 [Favor not reusing ClientInitKey reuse (SHOULD)](https://github.com/mlswg/mls-protocol/pull/218), by [beurdouche](https://github.com/beurdouche)\n:purple_heart: #209 [Proposals and Commits](https://github.com/mlswg/mls-protocol/pull/209), by [bifurcation](https://github.com/bifurcation)\n:purple_heart: #200 [Non-destructive add](https://github.com/mlswg/mls-protocol/pull/200), by [bifurcation](https://github.com/bifurcation)\n\n - - - \n# COMMITS\nLast week there were 38 commits.\n:hammer_and_wrench: [Merge pull request #244 from mlswg/editorial  Some editorial fixes](https://github.com/mlswg/mls-protocol/commit/09110a985ad173c546c37707e90614ae54f7468a) by [bifurcation](https://github.com/bifurcation)\n:hammer_and_wrench: [Some editorial fixes](https://github.com/mlswg/mls-protocol/commit/6961d3ec6915ecec9d7e8397cd6c4e7e7cb8d71a) by [bifurcation](https://github.com/bifurcation)\n:hammer_and_wrench: [Merge pull request #242 from mlswg/multi  Pack multiple Proposals and a Commit together](https://github.com/mlswg/mls-protocol/commit/b3f7fe7c836cfd951fc638966ebd95f478324f7d) by [bifurcation](https://github.com/bifurcation)\n:hammer_and_wrench: [Nits](https://github.com/mlswg/mls-protocol/commit/f8e5827a8d1c8a2b181cb8d6d9540fa4bc316f3c) by [bifurcation](https://github.com/bifurcation)\n:hammer_and_wrench: [Nits](https://github.com/mlswg/mls-protocol/commit/1418d678c94f1971e682068e4836ce6bf16f0e75) by [bifurcation](https://github.com/bifurcation)\n:hammer_and_wrench: [Comments from @beurdouche](https://github.com/mlswg/mls-protocol/commit/866829e6602b8a025dc32db27c9b43259be9b411) by [bifurcation](https://github.com/bifurcation)\n:hammer_and_wrench: [Merge branch 'master' into multi](https://github.com/mlswg/mls-protocol/commit/6fcb81c1960b5f1781392bef48764cb1932f73cb) by [bifurcation](https://github.com/bifurcation)\n:hammer_and_wrench: [Merge pull request #234 from mlswg/cik-extensions  Add downgrade protection to ClientInitKeys](https://github.com/mlswg/mls-protocol/commit/1ba65c11aee17962c22c85e1b2eb2250e3584a9c) by [bifurcation](https://github.com/bifurcation)\n:hammer_and_wrench: [Merge branch 'master' into cik-extensions](https://github.com/mlswg/mls-protocol/commit/5f9c2ff63e822ff7a51832778834be942e03f8b6) by [bifurcation](https://github.com/bifurcation)\n:hammer_and_wrench: [Merge pull request #239 from mlswg/welcome-equals-init  Welcome* == Init](https://github.com/mlswg/mls-protocol/commit/517c83b3b83ae73d5bd58cff763245c771567d2e) by [bifurcation](https://github.com/bifurcation)\n:hammer_and_wrench: [Merge branch 'master' into welcome-equals-init](https://github.com/mlswg/mls-protocol/commit/292a51be8f9ebcc921349f2a2fa469873bb29583) by [bifurcation](https://github.com/bifurcation)\n:hammer_and_wrench: [Comments from @beurdouche and a bugfix](https://github.com/mlswg/mls-protocol/commit/2f2f5d813037f7cf3c3d0d78612bc506f31eef5e) by [bifurcation](https://github.com/bifurcation)\n:hammer_and_wrench: [Merge pull request #218 from mlswg/beurdouche_noreuse  Favor not reusing ClientInitKey reuse (SHOULD)](https://github.com/mlswg/mls-protocol/commit/39006cae700c2acdd769046911b6983c7d566c66) by [bifurcation](https://github.com/bifurcation)\n:hammer_and_wrench: [Merge pull request #200 from mlswg/non-destructive-add  Non-destructive add](https://github.com/mlswg/mls-protocol/commit/d7ca4817c58cf48fd1ddc23dea5be4b5e89595fa) by [beurdouche](https://github.com/beurdouche)\n:hammer_and_wrench: [Merge pull request #243 from mlswg/inputs  Add GroupContext to signatures and AAD](https://github.com/mlswg/mls-protocol/commit/3bc25daa05026562a7221ca228498451ded9ceb4) by [beurdouche](https://github.com/beurdouche)\n:hammer_and_wrench: [Merge pull request #241 from mlswg/iana  IANA Considerations](https://github.com/mlswg/mls-protocol/commit/e03e5d74e59ba2aca912b6f454141a6d204bad3d) by [beurdouche](https://github.com/beurdouche)\n:hammer_and_wrench: [Merge pull request #240 from mlswg/external-proposals  External proposals](https://github.com/mlswg/mls-protocol/commit/2eb798398763655082d43c22fab5e52d563ecd4b) by [beurdouche](https://github.com/beurdouche)\n:hammer_and_wrench: [Merge branch 'master' into non-destructive-add](https://github.com/mlswg/mls-protocol/commit/064353ecff9d84b719a1333d53e785c2593642c5) by [bifurcation](https://github.com/bifurcation)\n:hammer_and_wrench: [Merge branch 'master' into welcome-equals-init](https://github.com/mlswg/mls-protocol/commit/93de1beb1ec07c6490e9e827fda46c5b05710fe7) by [bifurcation](https://github.com/bifurcation)\n:hammer_and_wrench: [Merge branch 'master' into external-proposals](https://github.com/mlswg/mls-protocol/commit/e543c19029d839ffe95e8ebd0a6c8597a0802290) by [bifurcation](https://github.com/bifurcation)\n:hammer_and_wrench: [Merge branch 'master' into iana](https://github.com/mlswg/mls-protocol/commit/96599f8b82016f8ffd43941cb4d810e3f5362df2) by [bifurcation](https://github.com/bifurcation)\n:hammer_and_wrench: [Merge branch 'master' into multi](https://github.com/mlswg/mls-protocol/commit/c9a09772ab5bd49fe12c180f89e876b8c1c64e1f) by [bifurcation](https://github.com/bifurcation)\n:hammer_and_wrench: [Merge branch 'master' into inputs](https://github.com/mlswg/mls-protocol/commit/34b3022a9ba40cb96114734915e7bb82af3c171c) by [bifurcation](https://github.com/bifurcation)\n:hammer_and_wrench: [Merge pull request #209 from mlswg/proposals  Proposals and Commits](https://github.com/mlswg/mls-protocol/commit/41a2389abf922fe0c3dbcc1ec67e2ddbd7416ec2) by [beurdouche](https://github.com/beurdouche)\n:hammer_and_wrench: [Comments from Karthik and Benjamin](https://github.com/mlswg/mls-protocol/commit/1af815682b86f1bb659302553b72c57517e6c48d) by [bifurcation](https://github.com/bifurcation)\n:hammer_and_wrench: [Add GroupContext to signatures and AAD](https://github.com/mlswg/mls-protocol/commit/33b260fdca7b46cdabf76b81370f8c75f56fbcc1) by [bifurcation](https://github.com/bifurcation)\n:hammer_and_wrench: [Changelog](https://github.com/mlswg/mls-protocol/commit/afc4965e76175fc3948466587719fbf805f5b184) by [bifurcation](https://github.com/bifurcation)\n:hammer_and_wrench: [Pack multiple Proposals and a Commit together](https://github.com/mlswg/mls-protocol/commit/c6d55441a77f6e44b645f4c9b8c514d28454b17a) by [bifurcation](https://github.com/bifurcation)\n:hammer_and_wrench: [Break into subsections](https://github.com/mlswg/mls-protocol/commit/4aad99c29a04eae55ab85b97b95eb26a89db3b94) by [bifurcation](https://github.com/bifurcation)\n:hammer_and_wrench: [Add expiration extension](https://github.com/mlswg/mls-protocol/commit/60f596f8a6db5aa6b1912a4eba405042db445031) by [bifurcation](https://github.com/bifurcation)\n:hammer_and_wrench: [Add downgrade protection recommendations](https://github.com/mlswg/mls-protocol/commit/235ff3d09ef3ce324d3e8a94c74209495e6c6986) by [bifurcation](https://github.com/bifurcation)\n:hammer_and_wrench: [Merge branch 'welcome-equals-init' into cik-extensions](https://github.com/mlswg/mls-protocol/commit/bdffffc72e1f1b472a6e5bc28b5775fbdb287a30) by [bifurcation](https://github.com/bifurcation)\n:hammer_and_wrench: [Merge branch 'proposals' into cik-extensions](https://github.com/mlswg/mls-protocol/commit/879528bf3890a0cc7b73318df7e18a35c9b4eb52) by [bifurcation](https://github.com/bifurcation)\n:hammer_and_wrench: [IANA considerations](https://github.com/mlswg/mls-protocol/commit/507744be08e202634311d8638b7437b230d0e703) by [bifurcation](https://github.com/bifurcation)\n:hammer_and_wrench: [User-initiated Add](https://github.com/mlswg/mls-protocol/commit/bd70d67c433529e072bdac480ff54a7f5057424d) by [bifurcation](https://github.com/bifurcation)\n:hammer_and_wrench: [External proposals](https://github.com/mlswg/mls-protocol/commit/5ff5e41e98a913f0ee01e6dfdc291f56bcd741c5) by [bifurcation](https://github.com/bifurcation)\n:hammer_and_wrench: [Collapse multiple Welcomes and make that Init](https://github.com/mlswg/mls-protocol/commit/5490d0ebfa1b41fff0ee54966ef375c37dadab68) by [bifurcation](https://github.com/bifurcation)\n:hammer_and_wrench: [Merge branch 'master' into proposals](https://github.com/mlswg/mls-protocol/commit/8f506ecac14c5f1bb413305901093202e94073fb) by [bifurcation](https://github.com/bifurcation)\n\n - - - \n# CONTRIBUTORS\nLast week there were 2 contributors.\n:bust_in_silhouette: [bifurcation](https://github.com/bifurcation)\n:bust_in_silhouette: [beurdouche](https://github.com/beurdouche)\n\n - - - \n# STARGAZERS\nLast week there was 1 stargazer.\n:star: [PaulLeCam](https://github.com/PaulLeCam)\nYou are the star! :star2:\n\n - - - \n# RELEASES\nLast week there were no releases.\n\n - - - \n\nThat's all for last week, please <kbd>:eyes: **Watch**</kbd> and <kbd>:star: **Star**</kbd> the repository [*mlswg/mls-protocol*](https://github.com/mlswg/mls-protocol) to receive next weekly updates. :smiley:\n\n*You can also [view all Weekly Digests by clicking here](https://github.com/mlswg/mls-protocol/issues?q=is:open+is:issue+label:weekly-digest).* \n\n> Your [**Weekly Digest**](https://github.com/apps/weekly-digest) bot. :calendar:\n",
      "createdAt": "2019-11-17T10:49:01Z",
      "updatedAt": "2019-11-17T18:53:17Z",
      "closedAt": "2019-11-17T18:53:17Z",
      "comments": []
    },
    {
      "number": 249,
      "id": "MDU6SXNzdWU1MjQ1NTE0NzI=",
      "title": "Discuss \"closing\" groups vs PCS",
      "url": "https://github.com/mlswg/mls-protocol/issues/249",
      "state": "CLOSED",
      "author": "beurdouche",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "security",
        "performance"
      ],
      "body": "Keeping cryptographic states for groups in which no members ever update is a problem because there is now a very large window of compromise for the session if it ever restarts updating. However, one could argue that recreating the group when the application needs it will reduce the PCS benefits we had from an ongoing session... Discuss.",
      "createdAt": "2019-11-18T18:51:16Z",
      "updatedAt": "2020-06-19T14:04:59Z",
      "closedAt": "2020-06-19T14:04:59Z",
      "comments": []
    },
    {
      "number": 250,
      "id": "MDU6SXNzdWU1MjQ1NTYxNDE=",
      "title": "Rename update_secret to commit_secret ?",
      "url": "https://github.com/mlswg/mls-protocol/issues/250",
      "state": "CLOSED",
      "author": "beurdouche",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "",
      "createdAt": "2019-11-18T19:00:52Z",
      "updatedAt": "2019-12-20T16:59:54Z",
      "closedAt": "2019-12-15T09:30:57Z",
      "comments": [
        {
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "body": "Fixed by #257",
          "createdAt": "2019-12-15T09:30:57Z",
          "updatedAt": "2019-12-15T09:30:57Z"
        }
      ]
    },
    {
      "number": 258,
      "id": "MDU6SXNzdWU1MjQ5MDQ3NjI=",
      "title": "Should direct paths include the root?",
      "url": "https://github.com/mlswg/mls-protocol/issues/258",
      "state": "CLOSED",
      "author": "kelrit",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "In the \"Ratchet Trees\" section it specifies that a direct path does not include the root. From an ad hoc discussion with @bifurcation in Singapore this may not be required. I at least don't see a reason for it - in  \"Synchronizing Views of the Tree\" it specifies to transmit information \"for each node in the direct path of the leaf, as well as the root\", and other mentions of direct paths seem to assume it includes the root.",
      "createdAt": "2019-11-19T10:08:32Z",
      "updatedAt": "2019-12-20T16:34:00Z",
      "closedAt": "2019-12-20T16:34:00Z",
      "comments": [
        {
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "body": "The path secret for the parent of the root in not included but the path secret at the level of the root has to be encrypted to the non-updated child subgroup. Can you point us to a place where you think the draft is incorrect ? If there is one we can fix it... : ) Thanks.",
          "createdAt": "2019-11-21T09:05:13Z",
          "updatedAt": "2019-11-21T09:05:13Z"
        },
        {
          "author": "kelrit",
          "authorAssociation": "CONTRIBUTOR",
          "body": "In particular the \"Ratchet Trees\" section that specifies that \"[t]he direct path of a root is the empty list\" looks incorrect. However the usage in the draft seems to imply it does include the root, or specifies \"intermediate nodes and the root\". It appears more natural to just include the root node (or I've seriously misunderstood something here).\r\n\r\nSemi-appendix: all mentions of \"Direct path\":\r\n\r\n**Synchronizing Views of the Tree** section:\r\n> When a client proposes a change to the tree (e.g., to add or remove a member), it transmits a handshake message containing a set of public values for intermediate nodes in the direct path of a leaf.\r\n\r\nThis message contains the public key for the root node as well.\r\n\r\n> To perform an update for a leaf, the sender broadcasts to the group the following information for each node in the direct path of the leaf, as well as the root\r\n\r\nUses direct path with the root.\r\n\r\n> Compute the updated path secrets.\r\n> - Identify a node in the direct path for which the local member is in the subtree of the non-updated child.\r\n\r\nThis node could be the root node.\r\n\r\n> Merge the updated path secrets into the tree.\r\n> - Replace the public keys for nodes on the direct path with the received public keys.\r\n\r\nThis could also be the root node.\r\n\r\n**Direct paths** section:\r\n\r\n> As described in {{ratchet-tree-updates}}, each MLS message needs to transmit node values along the direct path of a leaf. The path contains a public key for the leaf node, and a public key and encrypted secret value for intermediate nodes in the path. In both cases, the path is ordered from the leaf to the root; each node MUST be the parent of its predecessor.\r\n\r\nThis should also include the root node.\r\n\r\n**Group Creation** section:\r\n\r\n> The only choices the creator makes here are its own HPKE key and credential, the leaf secret from which the Commit is built, and the intermediate key pairs along the direct path to the root.\r\n\r\nThe creator also decides the root node key pair.\r\n\r\n> Process the path value to update the ratchet tree referenced by the provisional GroupContext and generate the update secret:\r\n> Update the ratchet tree by replacing nodes in the direct path of the sender with the corresponding nodes in the path (see {{direct-paths}}).\r\n\r\nThis replaces the root node secret as well.\r\n\r\n**Welcoming New Members** section:\r\n\r\n> In the same encrypted package, the committer transmits the path secret for the lowest node contained in the direct paths of both the committer and the new member. This allows the new member to compute private keys for nodes in its direct path that are being reset by the corresponding Commit.\r\n\r\n> Identify the lowest node at which the direct paths from index and signer_index overlap. Set private keys for that node and its parents up to the root of the tree, using the path_secret from the KeyPackage and following the algorithm in {{ratchet-tree-updates}} to move up the tree.\r\n\r\nThis node could be the root node.",
          "createdAt": "2019-11-21T10:15:07Z",
          "updatedAt": "2019-11-21T10:15:07Z"
        },
        {
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "body": "I believe this has been clarified as part as the redefinition of the DirectPath in the Leaf CIK PR",
          "createdAt": "2019-12-20T16:33:59Z",
          "updatedAt": "2019-12-20T16:33:59Z"
        }
      ]
    },
    {
      "number": 260,
      "id": "MDU6SXNzdWU1Mjc2ODAyMzI=",
      "title": "Weekly Digest (17 November, 2019 - 24 November, 2019)",
      "url": "https://github.com/mlswg/mls-protocol/issues/260",
      "state": "CLOSED",
      "author": "weekly-digest",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "weekly-digest"
      ],
      "body": "Here's the **Weekly Digest** for [*mlswg/mls-protocol*](https://github.com/mlswg/mls-protocol):\n\n - - - \n# ISSUES\nLast week 11 issues were created.\nOf these, 1 issues have been closed and 10 issues are still open.\n## OPEN ISSUES\n:green_heart: #258 [Should direct paths include the root?](https://github.com/mlswg/mls-protocol/issues/258), by [kelrit](https://github.com/kelrit)\n:green_heart: #257 [Make clear that Commits are responsible for FS and PCS](https://github.com/mlswg/mls-protocol/pull/257), by [beurdouche](https://github.com/beurdouche)\n:green_heart: #256 [Remove OPEN ISSUE: the entire group context is now in the signature](https://github.com/mlswg/mls-protocol/pull/256), by [beurdouche](https://github.com/beurdouche)\n:green_heart: #255 [Move epoch numbers to UInt64](https://github.com/mlswg/mls-protocol/pull/255), by [beurdouche](https://github.com/beurdouche)\n:green_heart: #254 [Initial work to use CIK in leaves](https://github.com/mlswg/mls-protocol/pull/254), by [beurdouche](https://github.com/beurdouche)\n:green_heart: #253 [Initial version of the Tree of Signature](https://github.com/mlswg/mls-protocol/pull/253), by [beurdouche](https://github.com/beurdouche)\n:green_heart: #252 [Bugfixes: fix a few typos in text and structs](https://github.com/mlswg/mls-protocol/pull/252), by [beurdouche](https://github.com/beurdouche)\n:green_heart: #251 [Initial proposal for PSK inputs](https://github.com/mlswg/mls-protocol/pull/251), by [beurdouche](https://github.com/beurdouche)\n:green_heart: #250 [Rename update_secret to commit_secret ?](https://github.com/mlswg/mls-protocol/issues/250), by [beurdouche](https://github.com/beurdouche)\n:green_heart: #249 [Discuss \"closing\" groups vs PCS](https://github.com/mlswg/mls-protocol/issues/249), by [beurdouche](https://github.com/beurdouche)\n## CLOSED ISSUES\n:heart: #259 [Remove blanking of nodes on Add, clarify language](https://github.com/mlswg/mls-protocol/pull/259), by [kelrit](https://github.com/kelrit)\n## NOISY ISSUE\n:speaker: #258 [Should direct paths include the root?](https://github.com/mlswg/mls-protocol/issues/258), by [kelrit](https://github.com/kelrit)\nIt received 2 comments.\n\n - - - \n# PULL REQUESTS\nLast week, 11 pull requests were created, updated or merged.\n## OPEN PULL REQUEST\nLast week, 6 pull requests were opened.\n:green_heart: #257 [Make clear that Commits are responsible for FS and PCS](https://github.com/mlswg/mls-protocol/pull/257), by [beurdouche](https://github.com/beurdouche)\n:green_heart: #256 [Remove OPEN ISSUE: the entire group context is now in the signature](https://github.com/mlswg/mls-protocol/pull/256), by [beurdouche](https://github.com/beurdouche)\n:green_heart: #255 [Move epoch numbers to UInt64](https://github.com/mlswg/mls-protocol/pull/255), by [beurdouche](https://github.com/beurdouche)\n:green_heart: #254 [Initial work to use CIK in leaves](https://github.com/mlswg/mls-protocol/pull/254), by [beurdouche](https://github.com/beurdouche)\n:green_heart: #253 [Initial version of the Tree of Signature](https://github.com/mlswg/mls-protocol/pull/253), by [beurdouche](https://github.com/beurdouche)\n:green_heart: #252 [Bugfixes: fix a few typos in text and structs](https://github.com/mlswg/mls-protocol/pull/252), by [beurdouche](https://github.com/beurdouche)\n## UPDATED PULL REQUEST\nLast week, 4 pull requests were updated.\n:yellow_heart: #251 [Initial proposal for PSK inputs](https://github.com/mlswg/mls-protocol/pull/251), by [beurdouche](https://github.com/beurdouche)\n:yellow_heart: #247 [Welcome confirmation and key derivation](https://github.com/mlswg/mls-protocol/pull/247), by [bifurcation](https://github.com/bifurcation)\n:yellow_heart: #219 [Fix application message truncation attack](https://github.com/mlswg/mls-protocol/pull/219), by [beurdouche](https://github.com/beurdouche)\n:yellow_heart: #198 [Initial design for the key schedule Exporter](https://github.com/mlswg/mls-protocol/pull/198), by [beurdouche](https://github.com/beurdouche)\n## MERGED PULL REQUEST\nLast week, 1 pull request was merged.\n:purple_heart: #259 [Remove blanking of nodes on Add, clarify language](https://github.com/mlswg/mls-protocol/pull/259), by [kelrit](https://github.com/kelrit)\n\n - - - \n# COMMITS\nLast week there were 2 commits.\n:hammer_and_wrench: [Merge pull request #259 from kelrit/master  Remove blanking of nodes on Add, clarify language](https://github.com/mlswg/mls-protocol/commit/bff920cf70b0de0ae5e2a71ae85ddf66615fe443) by [beurdouche](https://github.com/beurdouche)\n:hammer_and_wrench: [Remove blanking of nodes on Add, clarify language  - Blanking on add (I think) was obsoleted by unmerged leaves - Clarify/fix some language](https://github.com/mlswg/mls-protocol/commit/f9d003b76c69b80c429396ef90db54c847968300) by [kelrit](https://github.com/kelrit)\n\n - - - \n# CONTRIBUTORS\nLast week there were 2 contributors.\n:bust_in_silhouette: [beurdouche](https://github.com/beurdouche)\n:bust_in_silhouette: [kelrit](https://github.com/kelrit)\n\n - - - \n# STARGAZERS\nLast week there were 2 stagazers.\n:star: [Zottel](https://github.com/Zottel)\n:star: [zoresvit](https://github.com/zoresvit)\nYou all are the stars! :star2:\n\n - - - \n# RELEASES\nLast week there were no releases.\n\n - - - \n\nThat's all for last week, please <kbd>:eyes: **Watch**</kbd> and <kbd>:star: **Star**</kbd> the repository [*mlswg/mls-protocol*](https://github.com/mlswg/mls-protocol) to receive next weekly updates. :smiley:\n\n*You can also [view all Weekly Digests by clicking here](https://github.com/mlswg/mls-protocol/issues?q=is:open+is:issue+label:weekly-digest).* \n\n> Your [**Weekly Digest**](https://github.com/apps/weekly-digest) bot. :calendar:\n",
      "createdAt": "2019-11-24T10:48:42Z",
      "updatedAt": "2019-11-24T16:05:28Z",
      "closedAt": "2019-11-24T16:05:28Z",
      "comments": []
    },
    {
      "number": 261,
      "id": "MDU6SXNzdWU1MzA3MTE2ODY=",
      "title": "Weekly Digest (24 November, 2019 - 1 December, 2019)",
      "url": "https://github.com/mlswg/mls-protocol/issues/261",
      "state": "CLOSED",
      "author": "weekly-digest",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "weekly-digest"
      ],
      "body": "Here's the **Weekly Digest** for [*mlswg/mls-protocol*](https://github.com/mlswg/mls-protocol):\n\n - - - \n# ISSUES\nLast week, no issues were created.\n\n - - - \n# PULL REQUESTS\nLast week, 1 pull request was created, updated or merged.\n## UPDATED PULL REQUEST\nLast week, 1 pull request was updated.\n:yellow_heart: #255 [Move epoch numbers to UInt64](https://github.com/mlswg/mls-protocol/pull/255), by [beurdouche](https://github.com/beurdouche)\n\n - - - \n# COMMITS\nLast week there were no commits.\n\n - - - \n# CONTRIBUTORS\nLast week there were no contributors.\n\n - - - \n# STARGAZERS\nLast week there were no stargazers.\n\n - - - \n# RELEASES\nLast week there were no releases.\n\n - - - \n\nThat's all for last week, please <kbd>:eyes: **Watch**</kbd> and <kbd>:star: **Star**</kbd> the repository [*mlswg/mls-protocol*](https://github.com/mlswg/mls-protocol) to receive next weekly updates. :smiley:\n\n*You can also [view all Weekly Digests by clicking here](https://github.com/mlswg/mls-protocol/issues?q=is:open+is:issue+label:weekly-digest).* \n\n> Your [**Weekly Digest**](https://github.com/apps/weekly-digest) bot. :calendar:\n",
      "createdAt": "2019-12-01T10:49:08Z",
      "updatedAt": "2019-12-01T20:34:03Z",
      "closedAt": "2019-12-01T20:34:03Z",
      "comments": []
    },
    {
      "number": 262,
      "id": "MDU6SXNzdWU1MzQ1MjM2ODM=",
      "title": "Weekly Digest (1 December, 2019 - 8 December, 2019)",
      "url": "https://github.com/mlswg/mls-protocol/issues/262",
      "state": "CLOSED",
      "author": "weekly-digest",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "weekly-digest"
      ],
      "body": "Here's the **Weekly Digest** for [*mlswg/mls-protocol*](https://github.com/mlswg/mls-protocol):\n\n - - - \n# ISSUES\nLast week, no issues were created.\n\n - - - \n# PULL REQUESTS\nLast week, no pull requests were created, updated or merged.\n\n - - - \n# COMMITS\nLast week there were no commits.\n\n - - - \n# CONTRIBUTORS\nLast week there were no contributors.\n\n - - - \n# STARGAZERS\nLast week there were no stargazers.\n\n - - - \n# RELEASES\nLast week there were no releases.\n\n - - - \n\nThat's all for last week, please <kbd>:eyes: **Watch**</kbd> and <kbd>:star: **Star**</kbd> the repository [*mlswg/mls-protocol*](https://github.com/mlswg/mls-protocol) to receive next weekly updates. :smiley:\n\n*You can also [view all Weekly Digests by clicking here](https://github.com/mlswg/mls-protocol/issues?q=is:open+is:issue+label:weekly-digest).* \n\n> Your [**Weekly Digest**](https://github.com/apps/weekly-digest) bot. :calendar:\n",
      "createdAt": "2019-12-08T10:48:44Z",
      "updatedAt": "2019-12-08T10:52:57Z",
      "closedAt": "2019-12-08T10:52:57Z",
      "comments": []
    },
    {
      "number": 264,
      "id": "MDU6SXNzdWU1MzU5ODU3NTM=",
      "title": "Fix inconsistent definitions of Derive-Secret",
      "url": "https://github.com/mlswg/mls-protocol/issues/264",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "bifurcation",
        "beurdouche"
      ],
      "labels": [
        "bug",
        "security",
        "work in progress"
      ],
      "body": "On the one hand...\r\n```\r\nDerive-Secret(Secret, Label) =\r\n    HKDF-Expand-Label(Secret, Label, \"\", Hash.length)\r\n```\r\n\r\nOn the other hand...\r\n```\r\n...\r\n |\r\n +--> Derive-Secret(., \"sender data\", GroupContext_[n])\r\n |    = sender_data_secret\r\n```\r\n\r\nWe probably want Derive-Secret to have a third argument for the GroupContext, or define that Derive-Secret always takes the current group context.",
      "createdAt": "2019-12-10T20:48:55Z",
      "updatedAt": "2020-06-19T12:55:35Z",
      "closedAt": "2020-06-19T12:55:34Z",
      "comments": [
        {
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "body": "I would much prefer to go back to the TLS definition, we don't need the `GroupContext` thing at all, this is an implementation artifact...\r\n\r\nDefinition we use for TLS and the symbolic proof in the formal model:\r\n```\r\nDerive-Secret(Secret, Label, Messages) =\r\n            HKDF-Expand-Label(Secret, Label,\r\n                              Transcript-Hash(Messages), Hash.length)```",
          "createdAt": "2019-12-20T15:53:40Z",
          "updatedAt": "2019-12-20T15:55:10Z"
        },
        {
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "body": "Ps: because `Messages` is quite long in MLS, we directly pass `Transcript-Hash(Messages)` to `Derive-Secret` instead.",
          "createdAt": "2019-12-20T15:56:48Z",
          "updatedAt": "2019-12-20T15:56:48Z"
        }
      ]
    },
    {
      "number": 266,
      "id": "MDU6SXNzdWU1MzcwMjU5OTM=",
      "title": "Relax default policy of adding from left to right",
      "url": "https://github.com/mlswg/mls-protocol/issues/266",
      "state": "CLOSED",
      "author": "beurdouche",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "privacy",
        "performance"
      ],
      "body": "The current default strategy (add from left to right) doesn't allow for flexibility in forming optimized subgroups.\r\nIt also isn't super good for privacy: a newcomer should not be able to infer who is the creator of the group at epoch 0 from its position in the tree except when she is in the initial participants...",
      "createdAt": "2019-12-12T14:52:00Z",
      "updatedAt": "2020-07-27T19:09:37Z",
      "closedAt": "2020-07-27T19:09:37Z",
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Is it only the creator you're worried about?  If so, then we should be able to address that just by having the creator put themselves elsewhere in the tree.\r\n\r\nI'm also not convinced that this is an aspect of privacy that I really care about enough to design much mechanism around it.  It only applies at group creation time anyway, since after that, a new joiner doesn't know if member 0 is the creator or someone who was added after.",
          "createdAt": "2020-01-31T15:16:43Z",
          "updatedAt": "2020-01-31T15:16:43Z"
        }
      ]
    },
    {
      "number": 267,
      "id": "MDU6SXNzdWU1MzgwMzM1MDg=",
      "title": "Weekly Digest (8 December, 2019 - 15 December, 2019)",
      "url": "https://github.com/mlswg/mls-protocol/issues/267",
      "state": "CLOSED",
      "author": "weekly-digest",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "weekly-digest"
      ],
      "body": "Here's the **Weekly Digest** for [*mlswg/mls-protocol*](https://github.com/mlswg/mls-protocol):\n\n - - - \n# ISSUES\nLast week 4 issues were created.\nOf these, 0 issues have been closed and 4 issues are still open.\n## OPEN ISSUES\n:green_heart: #266 [Relax default policy of adding from left to right](https://github.com/mlswg/mls-protocol/issues/266), by [beurdouche](https://github.com/beurdouche)\n:green_heart: #265 [Align spec text with implementation](https://github.com/mlswg/mls-protocol/pull/265), by [bifurcation](https://github.com/bifurcation)\n:green_heart: #264 [Fix inconsistent definitions of Derive-Secret](https://github.com/mlswg/mls-protocol/issues/264), by [bifurcation](https://github.com/bifurcation)\n:green_heart: #263 [Change special values to structed types for external senders](https://github.com/mlswg/mls-protocol/pull/263), by [kelrit](https://github.com/kelrit)\n\n - - - \n# PULL REQUESTS\nLast week, 14 pull requests were created, updated or merged.\n## UPDATED PULL REQUEST\nLast week, 8 pull requests were updated.\n:yellow_heart: #265 [Align spec text with implementation](https://github.com/mlswg/mls-protocol/pull/265), by [bifurcation](https://github.com/bifurcation)\n:yellow_heart: #263 [Change special values to structed types for external senders](https://github.com/mlswg/mls-protocol/pull/263), by [kelrit](https://github.com/kelrit)\n:yellow_heart: #254 [Initial work to use CIK in leaves](https://github.com/mlswg/mls-protocol/pull/254), by [beurdouche](https://github.com/beurdouche)\n:yellow_heart: #253 [Initial version of the Tree of Signature](https://github.com/mlswg/mls-protocol/pull/253), by [beurdouche](https://github.com/beurdouche)\n:yellow_heart: #247 [Welcome confirmation and key derivation](https://github.com/mlswg/mls-protocol/pull/247), by [bifurcation](https://github.com/bifurcation)\n:yellow_heart: #246 [Bugfixes in ClientInitKey, Commit, and Welcome](https://github.com/mlswg/mls-protocol/pull/246), by [bifurcation](https://github.com/bifurcation)\n:yellow_heart: #245 [Unpredictable epochs](https://github.com/mlswg/mls-protocol/pull/245), by [bifurcation](https://github.com/bifurcation)\n:yellow_heart: #219 [Fix application message truncation attack](https://github.com/mlswg/mls-protocol/pull/219), by [beurdouche](https://github.com/beurdouche)\n## MERGED PULL REQUEST\nLast week, 6 pull requests were merged.\n:purple_heart: #257 [Make clear that Commits are responsible for FS and PCS](https://github.com/mlswg/mls-protocol/pull/257), by [beurdouche](https://github.com/beurdouche)\n:purple_heart: #256 [Remove OPEN ISSUE: the entire group context is now in the signature](https://github.com/mlswg/mls-protocol/pull/256), by [beurdouche](https://github.com/beurdouche)\n:purple_heart: #255 [Move epoch numbers to UInt64](https://github.com/mlswg/mls-protocol/pull/255), by [beurdouche](https://github.com/beurdouche)\n:purple_heart: #252 [Bugfixes: fix a few typos in text and structs](https://github.com/mlswg/mls-protocol/pull/252), by [beurdouche](https://github.com/beurdouche)\n:purple_heart: #251 [Initial proposal for PSK inputs](https://github.com/mlswg/mls-protocol/pull/251), by [beurdouche](https://github.com/beurdouche)\n:purple_heart: #198 [Initial design for the key schedule Exporter](https://github.com/mlswg/mls-protocol/pull/198), by [beurdouche](https://github.com/beurdouche)\n\n - - - \n# COMMITS\nLast week there were 10 commits.\n:hammer_and_wrench: [Merge pull request #198 from mlswg/beurdouche_exporter  Initial design for the key schedule Exporter](https://github.com/mlswg/mls-protocol/commit/d1c8986d3ef932ae4a7cc05b4172d2762428fcd0) by [bifurcation](https://github.com/bifurcation)\n:hammer_and_wrench: [Fix typo in the exporter section](https://github.com/mlswg/mls-protocol/commit/d7e67c208d70a846b3aa32bd70596bec3c990049) by [beurdouche](https://github.com/beurdouche)\n:hammer_and_wrench: [Merge branch 'master' into beurdouche_exporter](https://github.com/mlswg/mls-protocol/commit/7ed23e57901753871eacc9ad0d954dd136f4e529) by [beurdouche](https://github.com/beurdouche)\n:hammer_and_wrench: [Merge pull request #251 from mlswg/beurdouche_psk  Initial proposal for PSK inputs](https://github.com/mlswg/mls-protocol/commit/3eee58aa2ba2896a0f28fb9e1c6df16245b6fee7) by [bifurcation](https://github.com/bifurcation)\n:hammer_and_wrench: [Fix merging conflict with Master](https://github.com/mlswg/mls-protocol/commit/8fddd9af921b76f9b88bc41b9a65b4626c027b47) by [beurdouche](https://github.com/beurdouche)\n:hammer_and_wrench: [Insert on open issue for how to coordinate a PSK insertion](https://github.com/mlswg/mls-protocol/commit/517d461a3a1b5ef9bfbc19e1d7709bf9345d81c5) by [beurdouche](https://github.com/beurdouche)\n:hammer_and_wrench: [Merge pull request #252 from mlswg/beurdouche_bugfixes  Bugfixes: fix a few typos in text and structs](https://github.com/mlswg/mls-protocol/commit/c99d7c11318d78545a15973776b6bb1cf62833ea) by [raphaelrobert](https://github.com/raphaelrobert)\n:hammer_and_wrench: [Merge pull request #255 from mlswg/beurdouche_epoch  Move epoch numbers to UInt64](https://github.com/mlswg/mls-protocol/commit/6fc93429ad31553ca34f657f457da54272a962b0) by [raphaelrobert](https://github.com/raphaelrobert)\n:hammer_and_wrench: [Merge pull request #256 from mlswg/beurdouche_rem_openissue  Remove OPEN ISSUE: the entire group context is now in the signature](https://github.com/mlswg/mls-protocol/commit/c6bbdcd315d2201fb85681a3dc12d3d201135acf) by [bifurcation](https://github.com/bifurcation)\n:hammer_and_wrench: [Merge pull request #257 from mlswg/beurdouche_us_to_cs  Make clear that Commits are responsible for FS and PCS](https://github.com/mlswg/mls-protocol/commit/5140d9417f022f9313ac4ae4eb7355f18a12d517) by [bifurcation](https://github.com/bifurcation)\n\n - - - \n# CONTRIBUTORS\nLast week there were 3 contributors.\n:bust_in_silhouette: [bifurcation](https://github.com/bifurcation)\n:bust_in_silhouette: [beurdouche](https://github.com/beurdouche)\n:bust_in_silhouette: [raphaelrobert](https://github.com/raphaelrobert)\n\n - - - \n# STARGAZERS\nLast week there were no stargazers.\n\n - - - \n# RELEASES\nLast week there were no releases.\n\n - - - \n\nThat's all for last week, please <kbd>:eyes: **Watch**</kbd> and <kbd>:star: **Star**</kbd> the repository [*mlswg/mls-protocol*](https://github.com/mlswg/mls-protocol) to receive next weekly updates. :smiley:\n\n*You can also [view all Weekly Digests by clicking here](https://github.com/mlswg/mls-protocol/issues?q=is:open+is:issue+label:weekly-digest).* \n\n> Your [**Weekly Digest**](https://github.com/apps/weekly-digest) bot. :calendar:\n",
      "createdAt": "2019-12-15T10:48:39Z",
      "updatedAt": "2019-12-15T10:59:49Z",
      "closedAt": "2019-12-15T10:59:49Z",
      "comments": []
    },
    {
      "number": 268,
      "id": "MDU6SXNzdWU1Mzg5MTg5NDU=",
      "title": "Missing context in the PSK/Importer injection",
      "url": "https://github.com/mlswg/mls-protocol/issues/268",
      "state": "CLOSED",
      "author": "beurdouche",
      "authorAssociation": "MEMBER",
      "assignees": [
        "beurdouche"
      ],
      "labels": [
        "bug",
        "security"
      ],
      "body": "I forgot to push my last commit when merging #251 there should be a non-empty context for within the `Derive-Secret` just after the PSK.\r\n\r\nFix this when doing step 2 to keep close to the TLS importer...\r\n\r\n",
      "createdAt": "2019-12-17T08:42:05Z",
      "updatedAt": "2020-07-27T19:12:57Z",
      "closedAt": "2020-07-27T19:12:56Z",
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Think this is obsolete given recent revisions to Derive-Secret",
          "createdAt": "2020-07-27T19:12:56Z",
          "updatedAt": "2020-07-27T19:12:56Z"
        }
      ]
    },
    {
      "number": 269,
      "id": "MDU6SXNzdWU1Mzg5OTEwOTA=",
      "title": "Randomize values in the common framing header",
      "url": "https://github.com/mlswg/mls-protocol/issues/269",
      "state": "CLOSED",
      "author": "beurdouche",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "enhancement",
        "work in progress",
        "privacy"
      ],
      "body": "We can't really touch the ContentType because of the ordering constraints.\r\n\r\nWe could try to improve for the Epoch Number but loosing lexicographical ordering of the epoch numbers is a problem for transport loss + DS reordering.\r\n\r\nWe can definitely make sure that only group members can recognize the Group Identifier *across epochs* by generating the GID from the Key Schedule.\r\nWe also can do significantly better if we allow the DS to assist and modify the GID by deterministically blinding the GID with a pseudo random recipient ID. In that case seeing the GID after dispatching in the delivery queue will make it significantly more difficult to determine the group.\r\n\r\n\r\n\r\n",
      "createdAt": "2019-12-17T10:56:38Z",
      "updatedAt": "2020-10-19T14:31:06Z",
      "closedAt": "2020-10-19T14:31:06Z",
      "comments": [
        {
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "body": "See also: https://github.com/mlswg/mls-protocol/pull/245",
          "createdAt": "2019-12-17T10:58:24Z",
          "updatedAt": "2019-12-17T10:58:24Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "After WG discussion, we decided not to do this.  An implementation can provide this randomization if they like; all that is required is for clients to maintain a mapping between randomized IDs and groupID/epochID pairs.",
          "createdAt": "2020-10-19T14:31:06Z",
          "updatedAt": "2020-10-19T14:31:06Z"
        }
      ]
    },
    {
      "number": 270,
      "id": "MDU6SXNzdWU1Mzk1OTY0Mjg=",
      "title": "Expiration on \"last resort key\" must not be omitted",
      "url": "https://github.com/mlswg/mls-protocol/issues/270",
      "state": "CLOSED",
      "author": "beurdouche",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "security",
        "work in progress"
      ],
      "body": "Raphael and I noticed that the expiration can be omitted on a last resort key.\r\nDiscuss this as it doesn't seem to be a good idea, maybe a long expiration time is better...\r\nThis is also related to have the expiration extension mandatory or not.\r\n\r\nBecause we are planning signature key rotation in #254 we may not have to enforce an expiration of the last resort key, but it somehow feels dangerous.",
      "createdAt": "2019-12-18T10:36:44Z",
      "updatedAt": "2020-06-19T12:55:35Z",
      "closedAt": "2020-06-19T12:55:35Z",
      "comments": []
    },
    {
      "number": 271,
      "id": "MDU6SXNzdWU1Mzk1OTgyODU=",
      "title": "Create and send to sub-groups",
      "url": "https://github.com/mlswg/mls-protocol/issues/271",
      "state": "CLOSED",
      "author": "beurdouche",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "work in progress",
        "discussion",
        "functionality"
      ],
      "body": "An application with meta knowledge of subgroups could optimize the placement of members, discuss if we want to either create a new group from an existing subgroup or have a send to sub-group function.",
      "createdAt": "2019-12-18T10:40:01Z",
      "updatedAt": "2020-06-19T12:55:35Z",
      "closedAt": "2020-06-19T12:55:35Z",
      "comments": []
    },
    {
      "number": 272,
      "id": "MDU6SXNzdWU1Mzk3NDgwMTE=",
      "title": "Redundant information in MLSPlaintextCommitContent",
      "url": "https://github.com/mlswg/mls-protocol/issues/272",
      "state": "CLOSED",
      "author": "raphaelrobert",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "performance",
        "discussion"
      ],
      "body": "`MLSPlaintextCommitContent` contains all of the Proposals that were previously sent within the same epoch. This seems unnecessary, since all members should have them anyway. The list of `PorposalIDs` in the actual `Commit` message should be enough for members to parse and validate a `Commit` message.\r\n\r\nWe should discuss if we can de-duplicate this, since the list of Proposals might be quite long.",
      "createdAt": "2019-12-18T15:21:36Z",
      "updatedAt": "2020-06-02T17:02:47Z",
      "closedAt": "2020-06-02T17:02:46Z",
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "The current definition of `MLSPlaintextCommitContent` is as follows;\r\n\r\n```\r\nstruct {\r\n  opaque group_id<0..255>;\r\n  uint64 epoch;\r\n  Sender sender;\r\n  ContentType content_type = commit;\r\n  Commit commit;\r\n} MLSPlaintextCommitContent;\r\n```\r\n\r\nMaybe this issue is obsolete?",
          "createdAt": "2020-02-05T12:41:18Z",
          "updatedAt": "2020-02-05T12:41:18Z"
        },
        {
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "body": "Seems it is now obsolete indeed.",
          "createdAt": "2020-06-02T17:02:46Z",
          "updatedAt": "2020-06-02T17:02:46Z"
        }
      ]
    },
    {
      "number": 273,
      "id": "MDU6SXNzdWU1NDEwNjA5NDg=",
      "title": "Editorial: structure of the document",
      "url": "https://github.com/mlswg/mls-protocol/issues/273",
      "state": "CLOSED",
      "author": "beurdouche",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "editorial",
        "discussion"
      ],
      "body": "We relocated multiple pieces recently which causes the general structure of the document to feel a bit disordered, we need to do a minimal editorial restructure before releasing the next draft.\r\nChanging the depth of some sections might be enough...",
      "createdAt": "2019-12-20T15:48:48Z",
      "updatedAt": "2020-10-06T07:29:05Z",
      "closedAt": "2020-10-06T07:29:05Z",
      "comments": [
        {
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "body": "I am gonna close this in favor of the newer issue where we started a bit more discussion:\r\nhttps://github.com/mlswg/mls-protocol/issues/409",
          "createdAt": "2020-10-06T07:29:04Z",
          "updatedAt": "2020-10-06T07:29:04Z"
        }
      ]
    },
    {
      "number": 276,
      "id": "MDU6SXNzdWU1NDE0MzU1NjA=",
      "title": "Weekly Digest (15 December, 2019 - 22 December, 2019)",
      "url": "https://github.com/mlswg/mls-protocol/issues/276",
      "state": "CLOSED",
      "author": "weekly-digest",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "weekly-digest"
      ],
      "body": "Here's the **Weekly Digest** for [*mlswg/mls-protocol*](https://github.com/mlswg/mls-protocol):\n\n - - - \n# ISSUES\nLast week 8 issues were created.\nOf these, 0 issues have been closed and 8 issues are still open.\n## OPEN ISSUES\n:green_heart: #275 [Mandate expiration of ClientInitKeys and presence of some extensions](https://github.com/mlswg/mls-protocol/pull/275), by [beurdouche](https://github.com/beurdouche)\n:green_heart: #274 [Fix contexts and simplify key schedule](https://github.com/mlswg/mls-protocol/pull/274), by [beurdouche](https://github.com/beurdouche)\n:green_heart: #273 [Editorial: structure of the document](https://github.com/mlswg/mls-protocol/issues/273), by [beurdouche](https://github.com/beurdouche)\n:green_heart: #272 [Redundant information in MLSPlaintextCommitContent](https://github.com/mlswg/mls-protocol/issues/272), by [raphaelrobert](https://github.com/raphaelrobert)\n:green_heart: #271 [Create and send to sub-groups](https://github.com/mlswg/mls-protocol/issues/271), by [beurdouche](https://github.com/beurdouche)\n:green_heart: #270 [Expiration on \"last resort key\" must not be omitted](https://github.com/mlswg/mls-protocol/issues/270), by [beurdouche](https://github.com/beurdouche)\n:green_heart: #269 [Randomize values in the common framing header](https://github.com/mlswg/mls-protocol/issues/269), by [beurdouche](https://github.com/beurdouche)\n:green_heart: #268 [Missing context in the PSK/Importer injection](https://github.com/mlswg/mls-protocol/issues/268), by [beurdouche](https://github.com/beurdouche)\n## NOISY ISSUE\n:speaker: #269 [Randomize values in the common framing header](https://github.com/mlswg/mls-protocol/issues/269), by [beurdouche](https://github.com/beurdouche)\nIt received 1 comments.\n\n - - - \n# PULL REQUESTS\nLast week, 6 pull requests were created, updated or merged.\n## OPEN PULL REQUEST\nLast week, 1 pull request was opened.\n:green_heart: #275 [Mandate expiration of ClientInitKeys and presence of some extensions](https://github.com/mlswg/mls-protocol/pull/275), by [beurdouche](https://github.com/beurdouche)\n## UPDATED PULL REQUEST\nLast week, 3 pull requests were updated.\n:yellow_heart: #274 [Fix contexts and simplify key schedule](https://github.com/mlswg/mls-protocol/pull/274), by [beurdouche](https://github.com/beurdouche)\n:yellow_heart: #265 [Align spec text with implementation](https://github.com/mlswg/mls-protocol/pull/265), by [bifurcation](https://github.com/bifurcation)\n:yellow_heart: #219 [Fix application message truncation attack](https://github.com/mlswg/mls-protocol/pull/219), by [beurdouche](https://github.com/beurdouche)\n## MERGED PULL REQUEST\nLast week, 2 pull requests were merged.\n:purple_heart: #254 [Initial work to use CIK in leaves and CIK rotation](https://github.com/mlswg/mls-protocol/pull/254), by [beurdouche](https://github.com/beurdouche)\n:purple_heart: #253 [Initial version of the Tree of Signature](https://github.com/mlswg/mls-protocol/pull/253), by [beurdouche](https://github.com/beurdouche)\n\n - - - \n# COMMITS\nLast week there were 10 commits.\n:hammer_and_wrench: [Merge pull request #253 from mlswg/beurdouche_sigtree  Initial version of the Tree of Signature](https://github.com/mlswg/mls-protocol/commit/6555b94c457b22c3bf623c0f6ee29e6e14a1ca3f) by [raphaelrobert](https://github.com/raphaelrobert)\n:hammer_and_wrench: [Committer index in the ParentNodeHash](https://github.com/mlswg/mls-protocol/commit/9a1664a2f1575378df5860f3672c3463db39e3db) by [beurdouche](https://github.com/beurdouche)\n:hammer_and_wrench: [Fix GroupInfo terminology to tree_hash](https://github.com/mlswg/mls-protocol/commit/353fe3d064469fecc459748cc8586ba1832fbefc) by [beurdouche](https://github.com/beurdouche)\n:hammer_and_wrench: [SigTree follow-up: fix for server-assist when the tree is outsourced](https://github.com/mlswg/mls-protocol/commit/a670098a0e2223eaa049de5400f7c79969a47a4b) by [beurdouche](https://github.com/beurdouche)\n:hammer_and_wrench: [Update of the tree of signature section](https://github.com/mlswg/mls-protocol/commit/4ba6d55448df9818af39eaf8f9d014a574c59fb1) by [beurdouche](https://github.com/beurdouche)\n:hammer_and_wrench: [Initial definition of the Tree of Signatures](https://github.com/mlswg/mls-protocol/commit/d407030f79a658ac4f9f62211265748df0a0cfb3) by [beurdouche](https://github.com/beurdouche)\n:hammer_and_wrench: [Merge pull request #254 from mlswg/beurdouche_leafcik  Initial work to use CIK in leaves](https://github.com/mlswg/mls-protocol/commit/a72f07db7bfbbc1294754149cc9354b01322f846) by [raphaelrobert](https://github.com/raphaelrobert)\n:hammer_and_wrench: [Leaf CIK: review from Raphael](https://github.com/mlswg/mls-protocol/commit/02fefcc1fecfc0e834d2b4e4a4724a4763e97264) by [beurdouche](https://github.com/beurdouche)\n:hammer_and_wrench: [New strategy for Leaf CIK with Richard and Raphael](https://github.com/mlswg/mls-protocol/commit/7fbf94f376466332760d51126e51a928f169a02a) by [beurdouche](https://github.com/beurdouche)\n:hammer_and_wrench: [Fixes suggested by @Bren2010](https://github.com/mlswg/mls-protocol/commit/ccfb0d81a2eb9671c8c68288dbf169cb0bc3de5e) by [beurdouche](https://github.com/beurdouche)\n\n - - - \n# CONTRIBUTORS\nLast week there were 2 contributors.\n:bust_in_silhouette: [raphaelrobert](https://github.com/raphaelrobert)\n:bust_in_silhouette: [beurdouche](https://github.com/beurdouche)\n\n - - - \n# STARGAZERS\nLast week there was 1 stargazer.\n:star: [tuxcanfly](https://github.com/tuxcanfly)\nYou are the star! :star2:\n\n - - - \n# RELEASES\nLast week there were no releases.\n\n - - - \n\nThat's all for last week, please <kbd>:eyes: **Watch**</kbd> and <kbd>:star: **Star**</kbd> the repository [*mlswg/mls-protocol*](https://github.com/mlswg/mls-protocol) to receive next weekly updates. :smiley:\n\n*You can also [view all Weekly Digests by clicking here](https://github.com/mlswg/mls-protocol/issues?q=is:open+is:issue+label:weekly-digest).* \n\n> Your [**Weekly Digest**](https://github.com/apps/weekly-digest) bot. :calendar:\n",
      "createdAt": "2019-12-22T10:49:03Z",
      "updatedAt": "2019-12-22T13:42:25Z",
      "closedAt": "2019-12-22T13:42:25Z",
      "comments": []
    },
    {
      "number": 277,
      "id": "MDU6SXNzdWU1NDE0NDEyOTI=",
      "title": "Add/Welcome message should send the epoch secret and not init+commit secrets",
      "url": "https://github.com/mlswg/mls-protocol/issues/277",
      "state": "CLOSED",
      "author": "beurdouche",
      "authorAssociation": "MEMBER",
      "assignees": [
        "bifurcation",
        "beurdouche"
      ],
      "labels": [
        "bug",
        "security",
        "work in progress"
      ],
      "body": "Sending the `init_secret` and the `commit_secret` at once seem equivalent to sending the `epoch_secret` but I don't think it is actually the case since the message could be rejected by the DS, breaking the encryption key of that message would hence still have consequences even if the message is rejected.\r\n\r\nTechnically this is also breaking secrecy of the `init_secret` because the principals of the protocol which are associated to its secrecy are the members of the previous epoch, while the principals associated to the `epoch_secret` do contain the newcomer.\r\n\r\nI think we should update this mechanism to send the `epoch_secret` directly. DIscuss... ",
      "createdAt": "2019-12-22T11:52:37Z",
      "updatedAt": "2020-01-31T15:09:53Z",
      "closedAt": "2020-01-31T15:09:53Z",
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed in #247 ",
          "createdAt": "2020-01-31T15:09:53Z",
          "updatedAt": "2020-01-31T15:09:53Z"
        }
      ]
    },
    {
      "number": 280,
      "id": "MDU6SXNzdWU1NDMzNTU2NjA=",
      "title": "Weekly Digest (22 December, 2019 - 29 December, 2019)",
      "url": "https://github.com/mlswg/mls-protocol/issues/280",
      "state": "CLOSED",
      "author": "weekly-digest",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "weekly-digest"
      ],
      "body": "Here's the **Weekly Digest** for [*mlswg/mls-protocol*](https://github.com/mlswg/mls-protocol):\n\n - - - \n# ISSUES\nLast week 3 issues were created.\nOf these, 0 issues have been closed and 3 issues are still open.\n## OPEN ISSUES\n:green_heart: #279 [Bring back more ciphersuites](https://github.com/mlswg/mls-protocol/pull/279), by [raphaelrobert](https://github.com/raphaelrobert)\n:green_heart: #278 [Review of sections 1-6.](https://github.com/mlswg/mls-protocol/pull/278), by [Bren2010](https://github.com/Bren2010)\n:green_heart: #277 [Add/Welcome message should send the epoch secret and not init+commit secrets](https://github.com/mlswg/mls-protocol/issues/277), by [beurdouche](https://github.com/beurdouche)\n\n - - - \n# PULL REQUESTS\nLast week, 4 pull requests were created, updated or merged.\n## UPDATED PULL REQUEST\nLast week, 3 pull requests were updated.\n:yellow_heart: #279 [Bring back more ciphersuites](https://github.com/mlswg/mls-protocol/pull/279), by [raphaelrobert](https://github.com/raphaelrobert)\n:yellow_heart: #278 [Review of sections 1-6.](https://github.com/mlswg/mls-protocol/pull/278), by [Bren2010](https://github.com/Bren2010)\n:yellow_heart: #274 [Fix contexts and simplify key schedule](https://github.com/mlswg/mls-protocol/pull/274), by [beurdouche](https://github.com/beurdouche)\n## MERGED PULL REQUEST\nLast week, 1 pull request was merged.\n:purple_heart: #265 [Align spec text with implementation](https://github.com/mlswg/mls-protocol/pull/265), by [bifurcation](https://github.com/bifurcation)\n\n - - - \n# COMMITS\nLast week there was 1 commit.\n:hammer_and_wrench: [Merge pull request #265 from mlswg/impl  Align spec text with implementation](https://github.com/mlswg/mls-protocol/commit/9426b880dace5a105405196b347e7e493f3677ac) by [beurdouche](https://github.com/beurdouche)\n\n - - - \n# CONTRIBUTORS\nLast week there was 1 contributor.\n:bust_in_silhouette: [beurdouche](https://github.com/beurdouche)\n\n - - - \n# STARGAZERS\nLast week there were no stargazers.\n\n - - - \n# RELEASES\nLast week there were no releases.\n\n - - - \n\nThat's all for last week, please <kbd>:eyes: **Watch**</kbd> and <kbd>:star: **Star**</kbd> the repository [*mlswg/mls-protocol*](https://github.com/mlswg/mls-protocol) to receive next weekly updates. :smiley:\n\n*You can also [view all Weekly Digests by clicking here](https://github.com/mlswg/mls-protocol/issues?q=is:open+is:issue+label:weekly-digest).* \n\n> Your [**Weekly Digest**](https://github.com/apps/weekly-digest) bot. :calendar:\n",
      "createdAt": "2019-12-29T10:49:01Z",
      "updatedAt": "2019-12-29T14:46:37Z",
      "closedAt": "2019-12-29T14:46:37Z",
      "comments": []
    },
    {
      "number": 284,
      "id": "MDU6SXNzdWU1NDU0MDE1OTI=",
      "title": "Weekly Digest (29 December, 2019 - 5 January, 2020)",
      "url": "https://github.com/mlswg/mls-protocol/issues/284",
      "state": "CLOSED",
      "author": "weekly-digest",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "weekly-digest"
      ],
      "body": "Here's the **Weekly Digest** for [*mlswg/mls-protocol*](https://github.com/mlswg/mls-protocol):\n\n - - - \n# ISSUES\nLast week 3 issues were created.\nOf these, 0 issues have been closed and 3 issues are still open.\n## OPEN ISSUES\n:green_heart: #283 [Use the same ratchet for Handshake and Application keys](https://github.com/mlswg/mls-protocol/pull/283), by [bifurcation](https://github.com/bifurcation)\n:green_heart: #282 [Specify an Ack message](https://github.com/mlswg/mls-protocol/pull/282), by [bifurcation](https://github.com/bifurcation)\n:green_heart: #281 [Extend the epoch with a commit hash](https://github.com/mlswg/mls-protocol/pull/281), by [bifurcation](https://github.com/bifurcation)\n## NOISY ISSUE\n:speaker: #283 [Use the same ratchet for Handshake and Application keys](https://github.com/mlswg/mls-protocol/pull/283), by [bifurcation](https://github.com/bifurcation)\nIt received 1 comments.\n\n - - - \n# PULL REQUESTS\nLast week, 7 pull requests were created, updated or merged.\n## OPEN PULL REQUEST\nLast week, 2 pull requests were opened.\n:green_heart: #282 [Specify an Ack message](https://github.com/mlswg/mls-protocol/pull/282), by [bifurcation](https://github.com/bifurcation)\n:green_heart: #281 [Extend the epoch with a commit hash](https://github.com/mlswg/mls-protocol/pull/281), by [bifurcation](https://github.com/bifurcation)\n## UPDATED PULL REQUEST\nLast week, 4 pull requests were updated.\n:yellow_heart: #283 [Use the same ratchet for Handshake and Application keys](https://github.com/mlswg/mls-protocol/pull/283), by [bifurcation](https://github.com/bifurcation)\n:yellow_heart: #279 [Bring back more ciphersuites](https://github.com/mlswg/mls-protocol/pull/279), by [raphaelrobert](https://github.com/raphaelrobert)\n:yellow_heart: #278 [Review of sections 1-6.](https://github.com/mlswg/mls-protocol/pull/278), by [Bren2010](https://github.com/Bren2010)\n:yellow_heart: #275 [Mandate expiration of ClientInitKeys and presence of some extensions](https://github.com/mlswg/mls-protocol/pull/275), by [beurdouche](https://github.com/beurdouche)\n## MERGED PULL REQUEST\nLast week, 1 pull request was merged.\n:purple_heart: #263 [Change special values to structed types for external senders](https://github.com/mlswg/mls-protocol/pull/263), by [kelrit](https://github.com/kelrit)\n\n - - - \n# COMMITS\nLast week there were 3 commits.\n:hammer_and_wrench: [Merge pull request #263 from kelrit/master  Change special values to structed types for external senders](https://github.com/mlswg/mls-protocol/commit/02bf13ebad9a8efd675f6c30c3261dcf6191f179) by [bifurcation](https://github.com/bifurcation)\n:hammer_and_wrench: [Address comments from @bifurcation  Reword MLSCiphertext encryption section and mandate sender type for encrypting MLSPlaintext.](https://github.com/mlswg/mls-protocol/commit/d8bbe3d4e0692669d58a132ddab5d3d33d3d081b) by [kelrit](https://github.com/kelrit)\n:hammer_and_wrench: [Merge branch 'master' of https://github.com/mlswg/mls-protocol](https://github.com/mlswg/mls-protocol/commit/639577426f247a75d7fcc8292bf7bdd03271b8e6) by [kelrit](https://github.com/kelrit)\n\n - - - \n# CONTRIBUTORS\nLast week there were 2 contributors.\n:bust_in_silhouette: [bifurcation](https://github.com/bifurcation)\n:bust_in_silhouette: [kelrit](https://github.com/kelrit)\n\n - - - \n# STARGAZERS\nLast week there were 2 stagazers.\n:star: [jasikpark](https://github.com/jasikpark)\n:star: [iethree](https://github.com/iethree)\nYou all are the stars! :star2:\n\n - - - \n# RELEASES\nLast week there were no releases.\n\n - - - \n\nThat's all for last week, please <kbd>:eyes: **Watch**</kbd> and <kbd>:star: **Star**</kbd> the repository [*mlswg/mls-protocol*](https://github.com/mlswg/mls-protocol) to receive next weekly updates. :smiley:\n\n*You can also [view all Weekly Digests by clicking here](https://github.com/mlswg/mls-protocol/issues?q=is:open+is:issue+label:weekly-digest).* \n\n> Your [**Weekly Digest**](https://github.com/apps/weekly-digest) bot. :calendar:\n",
      "createdAt": "2020-01-05T10:49:03Z",
      "updatedAt": "2020-01-05T11:36:37Z",
      "closedAt": "2020-01-05T11:36:37Z",
      "comments": []
    },
    {
      "number": 289,
      "id": "MDU6SXNzdWU1NDg0ODA0MTg=",
      "title": "Make Editor's Copy and WG draft compare work properly",
      "url": "https://github.com/mlswg/mls-protocol/issues/289",
      "state": "CLOSED",
      "author": "seanturner",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "katrielalex"
      ],
      "labels": [
        "build"
      ],
      "body": "Please fix the link on the repo page to display diffs between the current editor's draft and the WG draft.  Now, it should PRs comparing back to the -00 version.",
      "createdAt": "2020-01-11T21:08:29Z",
      "updatedAt": "2020-06-19T12:55:36Z",
      "closedAt": "2020-06-19T12:55:36Z",
      "comments": [
        {
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "body": "@katrielalex Any change you could have a look at this when you have some time ? : )",
          "createdAt": "2020-01-15T10:56:51Z",
          "updatedAt": "2020-01-15T10:56:51Z"
        },
        {
          "author": "katrielalex",
          "authorAssociation": "MEMBER",
          "body": "Yeah, I'm gonna fix the CI and I can take a look at this as well. I tried to get it done before the interim but, well, excuses excuses",
          "createdAt": "2020-01-15T14:13:50Z",
          "updatedAt": "2020-01-15T14:13:50Z"
        },
        {
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "body": "Ahah... ;) No problem!!\nThanks !\n\n> On Jan 15, 2020, at 3:13 PM, Katriel Cohn-Gordon <notifications@github.com> wrote:\n> \n> \ufeff\n> Yeah, I'm gonna fix the CI and I can take a look at this as well. I tried to get it done before the interim but, well, excuses excuses\n> \n> \u2014\n> You are receiving this because you commented.\n> Reply to this email directly, view it on GitHub, or unsubscribe.\n",
          "createdAt": "2020-01-15T14:53:43Z",
          "updatedAt": "2020-01-15T14:53:43Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "@katrielalex -- last call on this, or i'm just going to close it",
          "createdAt": "2020-06-13T18:53:38Z",
          "updatedAt": "2020-06-13T18:53:38Z"
        },
        {
          "author": "katrielalex",
          "authorAssociation": "MEMBER",
          "body": "Sorry. As you will have guessed, this fell through the cracks. I'll try this week to fix it out and close it out if I don't get to it this weekend :/",
          "createdAt": "2020-06-15T13:19:22Z",
          "updatedAt": "2020-06-15T13:19:22Z"
        }
      ]
    },
    {
      "number": 290,
      "id": "MDU6SXNzdWU1NDg1NTI4NzI=",
      "title": "Weekly Digest (5 January, 2020 - 12 January, 2020)",
      "url": "https://github.com/mlswg/mls-protocol/issues/290",
      "state": "CLOSED",
      "author": "weekly-digest",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "weekly-digest"
      ],
      "body": "Here's the **Weekly Digest** for [*mlswg/mls-protocol*](https://github.com/mlswg/mls-protocol):\n\n - - - \n# ISSUES\nLast week 5 issues were created.\nOf these, 1 issues have been closed and 4 issues are still open.\n## OPEN ISSUES\n:green_heart: #289 [Make Editor's Copy and WG draft compare work properly](https://github.com/mlswg/mls-protocol/issues/289), by [seanturner](https://github.com/seanturner)\n:green_heart: #287 [Switch to signing strategy using one signature per leaf.](https://github.com/mlswg/mls-protocol/pull/287), by [Bren2010](https://github.com/Bren2010)\n:green_heart: #286 [Editorial: Unclear that Commits always include an Update/refreshes the CIK for the committer.](https://github.com/mlswg/mls-protocol/pull/286), by [Bren2010](https://github.com/Bren2010)\n:green_heart: #285 [Get rid of ignored proposals.](https://github.com/mlswg/mls-protocol/pull/285), by [Bren2010](https://github.com/Bren2010)\n## CLOSED ISSUES\n:heart: #288 [Typos](https://github.com/mlswg/mls-protocol/pull/288), by [raphaelrobert](https://github.com/raphaelrobert)\n## NOISY ISSUE\n:speaker: #285 [Get rid of ignored proposals.](https://github.com/mlswg/mls-protocol/pull/285), by [Bren2010](https://github.com/Bren2010)\nIt received 3 comments.\n\n - - - \n# PULL REQUESTS\nLast week, 8 pull requests were created, updated or merged.\n## UPDATED PULL REQUEST\nLast week, 7 pull requests were updated.\n:yellow_heart: #287 [Switch to signing strategy using one signature per leaf.](https://github.com/mlswg/mls-protocol/pull/287), by [Bren2010](https://github.com/Bren2010)\n:yellow_heart: #286 [Editorial: Unclear that Commits always include an Update/refreshes the CIK for the committer.](https://github.com/mlswg/mls-protocol/pull/286), by [Bren2010](https://github.com/Bren2010)\n:yellow_heart: #285 [Get rid of ignored proposals.](https://github.com/mlswg/mls-protocol/pull/285), by [Bren2010](https://github.com/Bren2010)\n:yellow_heart: #283 [Use the same ratchet for Handshake and Application keys](https://github.com/mlswg/mls-protocol/pull/283), by [bifurcation](https://github.com/bifurcation)\n:yellow_heart: #282 [Specify an Ack message](https://github.com/mlswg/mls-protocol/pull/282), by [bifurcation](https://github.com/bifurcation)\n:yellow_heart: #281 [Extend the epoch with a commit hash](https://github.com/mlswg/mls-protocol/pull/281), by [bifurcation](https://github.com/bifurcation)\n:yellow_heart: #278 [Review of sections 1-6.](https://github.com/mlswg/mls-protocol/pull/278), by [Bren2010](https://github.com/Bren2010)\n## MERGED PULL REQUEST\nLast week, 1 pull request was merged.\n:purple_heart: #288 [Typos](https://github.com/mlswg/mls-protocol/pull/288), by [raphaelrobert](https://github.com/raphaelrobert)\n\n - - - \n# COMMITS\nLast week there were 3 commits.\n:hammer_and_wrench: [Merge pull request #288 from mlswg/raphaelrobert-typos  Typos](https://github.com/mlswg/mls-protocol/commit/62bd560673d8e795e8b124e717d122e459e08611) by [bifurcation](https://github.com/bifurcation)\n:hammer_and_wrench: [Update draft-ietf-mls-protocol.md](https://github.com/mlswg/mls-protocol/commit/6b535809d07db778e7dfeb6ec8442f056abb3f07) by [raphaelrobert](https://github.com/raphaelrobert)\n:hammer_and_wrench: [Typos](https://github.com/mlswg/mls-protocol/commit/dbf8e1c753a2073c91494a23d05913f6e8043913) by [raphaelrobert](https://github.com/raphaelrobert)\n\n - - - \n# CONTRIBUTORS\nLast week there were 2 contributors.\n:bust_in_silhouette: [bifurcation](https://github.com/bifurcation)\n:bust_in_silhouette: [raphaelrobert](https://github.com/raphaelrobert)\n\n - - - \n# STARGAZERS\nLast week there were no stargazers.\n\n - - - \n# RELEASES\nLast week there were no releases.\n\n - - - \n\nThat's all for last week, please <kbd>:eyes: **Watch**</kbd> and <kbd>:star: **Star**</kbd> the repository [*mlswg/mls-protocol*](https://github.com/mlswg/mls-protocol) to receive next weekly updates. :smiley:\n\n*You can also [view all Weekly Digests by clicking here](https://github.com/mlswg/mls-protocol/issues?q=is:open+is:issue+label:weekly-digest).* \n\n> Your [**Weekly Digest**](https://github.com/apps/weekly-digest) bot. :calendar:\n",
      "createdAt": "2020-01-12T10:48:55Z",
      "updatedAt": "2020-01-12T13:23:58Z",
      "closedAt": "2020-01-12T13:23:58Z",
      "comments": []
    },
    {
      "number": 291,
      "id": "MDU6SXNzdWU1NDg2MTMyNzk=",
      "title": "Detection of tree forks by recipients via a commitment",
      "url": "https://github.com/mlswg/mls-protocol/issues/291",
      "state": "CLOSED",
      "author": "beurdouche",
      "authorAssociation": "MEMBER",
      "assignees": [
        "beurdouche"
      ],
      "labels": [
        "work in progress",
        "functionality"
      ],
      "body": "",
      "createdAt": "2020-01-12T19:12:01Z",
      "updatedAt": "2020-07-27T19:17:00Z",
      "closedAt": "2020-07-27T19:17:00Z",
      "comments": [
        {
          "author": "kelrit",
          "authorAssociation": "CONTRIBUTOR",
          "body": "There's a few implications of simply allowing forks:\r\n\r\n- FS issues - clients would need to use init_secret twice, which means keeping around init_secret for a potential fork, which breaks FS. One resolution here is to use something from the ASTree for init_secret (maybe the nth app secret, or a new ratchet derived from astree_node_[n]_secret).\r\n- Does detection yield any sort of meaningful resolution technique? Are we better off than we are now in terms of user experience? (What we have now, if the DS fails to order, is two (or N) groups of clients operating on different versions of the tree, which effectively partitions the group)\r\n\r\nI wrote about this here: https://mailarchive.ietf.org/arch/msg/mls/A4mVaXT-rqwZTNYXrC1TDb6XC_o suggesting merges as a resolution technique. The main downside is clients would need to keep around the list of proposals for a while.",
          "createdAt": "2020-01-14T22:57:55Z",
          "updatedAt": "2020-01-14T22:57:55Z"
        }
      ]
    },
    {
      "number": 293,
      "id": "MDU6SXNzdWU1NTczOTA3ODE=",
      "title": "How to derive group_info_key from the init_secret",
      "url": "https://github.com/mlswg/mls-protocol/issues/293",
      "state": "CLOSED",
      "author": "ericcornelissen",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "bug",
        "editorial",
        "security"
      ],
      "body": "In the [latest version of the draft in the section _Commit_](https://github.com/mlswg/mls-protocol/blob/13a4e3c8b0ee3e8b0145fb7c5bd8d6261f4b8520/draft-ietf-mls-protocol.md#commit) there is a sub-bullet for creating the GroupInfo object/Welcome message that says:\r\n\r\n> Encrypt the GroupInfo using the key and nonce derived from the `init_secret` for the current epoch (see {{welcoming-new-members}})\r\n\r\n\r\nThen, in [the section _Welcoming New Members_](https://github.com/mlswg/mls-protocol/blob/13a4e3c8b0ee3e8b0145fb7c5bd8d6261f4b8520/draft-ietf-mls-protocol.md#welcoming-new-members) it is stated that:\r\n\r\n> From the `init_secret` in the decrypted KeyPackage object, derive the `group_info_secret`, `group_info_key`, and `group_info_nonce`. Use the key and nonce to decrypt the `encrypted_group_info` field.\r\n\r\n\r\nHowever, from what I can tell, it is not explained anywhere how the _key and nonce_ should be derived from the `init_secret`. If it is somewhere, can someone point it out to me? If it is not in the RFC, should it be included?",
      "createdAt": "2020-01-30T10:12:10Z",
      "updatedAt": "2020-01-31T15:09:34Z",
      "closedAt": "2020-01-31T15:09:34Z",
      "comments": [
        {
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "body": "Thanks! There is indeed missing definitions in the document.\r\n\r\nOn a side note, I labelled this a security issue as I suspect there is a design issue to handle. The secrets derived from the init_secret are cryptographically associated to the previous group, not the current one, which breaks the secrecy invariant. I would much prefer to derive and encrypt under keys that are cryptographically associated to the new group and reveal those to the newcomer.",
          "createdAt": "2020-01-30T10:44:32Z",
          "updatedAt": "2020-01-30T10:44:32Z"
        },
        {
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "body": "Relates to #277",
          "createdAt": "2020-01-30T10:45:28Z",
          "updatedAt": "2020-01-30T10:45:28Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "I will make sure this gets covered in the revived #247 ",
          "createdAt": "2020-01-30T15:05:23Z",
          "updatedAt": "2020-01-30T15:05:23Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed in #247 ",
          "createdAt": "2020-01-31T15:09:34Z",
          "updatedAt": "2020-01-31T15:09:34Z"
        }
      ]
    },
    {
      "number": 297,
      "id": "MDU6SXNzdWU1NjAwOTU1Mzk=",
      "title": "Restart",
      "url": "https://github.com/mlswg/mls-protocol/issues/297",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "enhancement",
        "question",
        "security"
      ],
      "body": "Certain things about a group are fixed, for example, its ciphersuite and version of MLS, and with #296, its extensions.  It could be desirable to have the ability to change these parameters, e.g., to use a new ciphersuite when all members support it.\r\n\r\nDefining a way to change these values \"in place\" seems tricky, though.  Instead, we could define a \"restart\" mechanism that initializes a new group with the same membership and different parameters.  At one level this is trivially possible, just by creating a new group over the same members.  But it could be useful to explicitly hand-over from one to the other, so that clients understand that they are the same.  You could also tie them together cryptographically, e.g., by exporting a secret from the old group's key schedule, and importing it as a PSK into the new group.",
      "createdAt": "2020-02-05T02:05:25Z",
      "updatedAt": "2020-07-27T19:09:21Z",
      "closedAt": "2020-07-27T19:09:21Z",
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Replaced by #368 ",
          "createdAt": "2020-07-27T19:09:18Z",
          "updatedAt": "2020-07-27T19:09:18Z"
        }
      ]
    },
    {
      "number": 298,
      "id": "MDU6SXNzdWU1NjAxMDIyMzc=",
      "title": "Varints",
      "url": "https://github.com/mlswg/mls-protocol/issues/298",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "enhancement",
        "performance"
      ],
      "body": "As part of the cTLS work, we looked into the possibility of [using QUIC-style varints as vector lengths](https://github.com/ekr/draft-rescorla-tls-ctls/blob/specialization/draft-rescorla-tls-ctls.md#varints) in the TLS presentation syntax.   With the proper specification text, we could do the same in MLS, as well as using varints for in place of uint values like `epoch`, `sender_index`, and `generation`.\r\n\r\nUsing varints has a few benefits: \r\n\r\n* It avoids the need to specify vector lengths in the presentation syntax\r\n* It allows any field to go up to 2^64 (possibly not a benefit!)\r\n* It is more efficient at encoding values that are far below the maximum\r\n \r\nThe main drawback is that there's no support for varint vector lengths in existing code for encoding/decoding TLS syntax.\r\n\r\nThere's also a procedural question of where the varints mechanism should be defined.  Arguably MLS shouldn't be making its own extensions to the TLS syntax.  We've already sort of crossed that bridge, though, since we added optional<T>.",
      "createdAt": "2020-02-05T02:30:30Z",
      "updatedAt": "2020-06-19T12:55:36Z",
      "closedAt": "2020-06-19T12:55:36Z",
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Better link for [QUIC-style varints](https://tools.ietf.org/html/draft-ietf-quic-transport-22#section-16).  For whatever reason, the cTLS version only does 1/2/3-byte encodings, whereas the QUIC one does 1/2/4/8, which is better for our usage.",
          "createdAt": "2020-06-02T17:04:27Z",
          "updatedAt": "2020-06-02T17:04:27Z"
        },
        {
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "body": "Just repeating what I said during the call, but I think this is mixing layers of abstraction. The MLS spec uses the TLS presentation language to define structs, but we don't actually assume that the wire encoding of messages is TLS. Referencing this line from the architecture doc:\r\n\r\n```\r\nIn addition, it does not specify a complete wire encoding, but rather a \r\nset of abstract data structures which can then be mapped onto a variety \r\nof concrete encodings, such as TLS, CBOR, and JSON.\r\n```\r\n\r\nPeople said that we need to define the wire encoding to support interoperability (if we don't want interop, why are we writing a spec?). But I think in practice, different MLS implementations interoperating will be quite rare for a variety of reasons, mostly due to incompatible delivery and authentication services. The point of writing the spec, then, is to produce a well-reviewed protocol that people can implement confidently.\r\n\r\nLong story short, if you wanted varints you would use cTLS as the wire encoding, which doesn't require any changes to the spec.",
          "createdAt": "2020-06-02T18:35:41Z",
          "updatedAt": "2020-06-02T18:35:41Z"
        }
      ]
    },
    {
      "number": 299,
      "id": "MDU6SXNzdWU1NjAxMDQ0MjY=",
      "title": "Allow indirection of credentials",
      "url": "https://github.com/mlswg/mls-protocol/issues/299",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "enhancement",
        "performance"
      ],
      "body": "Credentials can be big, and they all go in the tree.  We should define a type of credential that is a secure indirection, something like:\r\n\r\n```\r\nenum {\r\n    ...\r\n    reference(xxx),\r\n    ...\r\n} CredentialType;\r\n\r\nstruct {\r\n    opaque hash<0..255>;\r\n    opaque uri<0..255>;\r\n} CredentialReference;\r\n```\r\n\r\nWith the provisos that: (1) the content reference by the URI MUST be a valid Credential struct, and MUST match the hash, and (2) it's up to the application to make sure that clients know how to deference the URIs.",
      "createdAt": "2020-02-05T02:39:00Z",
      "updatedAt": "2020-06-19T12:55:36Z",
      "closedAt": "2020-06-19T12:55:36Z",
      "comments": []
    },
    {
      "number": 300,
      "id": "MDU6SXNzdWU1NjAyNDU3Mjc=",
      "title": "Order in which proposals should be applied is a little bit vague",
      "url": "https://github.com/mlswg/mls-protocol/issues/300",
      "state": "CLOSED",
      "author": "ericcornelissen",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "The [Commit section](https://github.com/mlswg/mls-protocol/blob/d460925cac306275e529a6c657e74eed653cf11b/draft-ietf-mls-protocol.md#commit) writes:\r\n\r\n> Generate a provisional GroupContext object by applying the proposals referenced in the initial Commit object in the order provided, as described in {{proposals}}. [...]\r\n\r\nHowever, from this it is not immediately clear to me in which order the collections of proposals `updates`, `removes`, and `adds` are to be applied. I assume it should be in that order because it makes practical sense and because they're written in that order in the Commit struct.\r\n\r\nIf my guess is correct, perhaps it would be useful to make this explicit? E.g.:\r\n\r\n > Generate a provisional GroupContext object by applying the proposals referenced in the initial Commit object, as described in {{proposals}}. First the list of update proposals, then the list of remove proposals, and last the list of add proposals. [...]",
      "createdAt": "2020-02-05T09:32:29Z",
      "updatedAt": "2020-05-08T14:20:39Z",
      "closedAt": "2020-05-08T14:20:39Z",
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "@ericcornelissen - I agree with your interpretation here.  Could you make a PR with some proposed wording?",
          "createdAt": "2020-04-21T14:41:04Z",
          "updatedAt": "2020-04-21T14:41:04Z"
        },
        {
          "author": "ericcornelissen",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Apologies for closing/opening the issue. I will open a PR to update the wording.",
          "createdAt": "2020-05-07T17:37:42Z",
          "updatedAt": "2020-05-07T17:37:42Z"
        }
      ]
    },
    {
      "number": 301,
      "id": "MDU6SXNzdWU1NjA0MzM2NDI=",
      "title": "Targeted message",
      "url": "https://github.com/mlswg/mls-protocol/issues/301",
      "state": "CLOSED",
      "author": "raphaelrobert",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "privacy",
        "discussion",
        "functionality"
      ],
      "body": "It might be interesting to have a mechanism to send targeted messages within a group. The recipient could either be a leaf node or an intermediary node (in which case you send the message to a subgroup).\r\nThere certainly is a need for that kind of functionality in some messengers (think read receipts that shouldn't be broadcasted to the whole group, etc.).\r\nA starting point could be:\r\n - KEM to the public leaf key and combine that with something from the key schedule for the first message\r\n - hash ratchet forward for subsequent messages within the same epoch (FS)\r\n - include the new freshness in the forward ratcheting after an epoch an change (does that mean we inherit PCS guarantees?)\r\n\r\nJust a thought for now but worth pursuing IMHO.",
      "createdAt": "2020-02-05T15:07:37Z",
      "updatedAt": "2020-06-19T12:55:37Z",
      "closedAt": "2020-06-19T12:55:37Z",
      "comments": [
        {
          "author": "burdges",
          "authorAssociation": "NONE",
          "body": "In this vein, I think \"cryptographic introductions\" actually matter quite a lot, even when you make the participants start a seperate channel, so any authentication property you can extract here helps enormously.  I suppose TreeKEM lacks any semi-ephemeral public key for the parties lying around like in Axolotl or ART, right?",
          "createdAt": "2020-02-06T14:09:07Z",
          "updatedAt": "2020-02-06T14:09:07Z"
        },
        {
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "body": "The leaf nodes contain ClientInitKeys which allow you to authenticate members through the AS. So KEMing to a leaf node is authenticated and KEMing to intermediary nodes would be authenticated in the sense that only the leaves from the subtree would know the private key of the intermediary nodes. That notion of authentication seems less strong, but tree signatures should give some additional confidence.\r\n\r\n> I suppose TreeKEM lacks any semi-ephemeral public key for the parties lying around like in Axolotl or ART, right?\r\n\r\nDo you mean something like prekeys? MLS has ClientInitKeys for that.",
          "createdAt": "2020-02-07T09:33:28Z",
          "updatedAt": "2020-02-07T09:33:28Z"
        },
        {
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "body": "After some discussion with @beurdouche we realised this could be generalised to a more generic concept to send application messages.\r\n\r\nThe parameters would be:\r\n - Send from inside vs outside\r\n - Send to the whole vs send to subtree vs send to leaf node",
          "createdAt": "2020-02-07T09:36:24Z",
          "updatedAt": "2020-02-07T09:36:24Z"
        },
        {
          "author": "burdges",
          "authorAssociation": "NONE",
          "body": "> Do you mean something like prekeys? MLS has ClientInitKeys for that.\r\n\r\nNo.  I do not track this project closely enough but at first blush what you describe sounds fine.  In particular the ClientInitKeys comes bound into client's participation in the current session, not just from some untrusted external server somewhere. \r\n\r\nAxolotl has an ephemeral public key the client retains as part of the current session, which you can mutate for use in introductions.  I donno if you need to mutate ClientInitKeys for use here too.",
          "createdAt": "2020-02-07T10:25:12Z",
          "updatedAt": "2020-02-07T10:25:12Z"
        },
        {
          "author": "br-hale",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The coming PR for the key schedule change to allow ciphersuite upgrades also enables an option for group branching that may be a viable alternative for this. A group can use a PSK to upgrade, but it could also use it to re-initialize the group. In this vein, a PSK can be used to branch a group as well (enabling side conversations among nodes or subtrees that partially rely on the group state). \r\n\r\nThis is not quite the same, but would be an option using much of the current protocol infrastructure.\r\n\r\nNotably, such branching and side-messages that are linked to the group state do have potentially significant effects on PCS (by any of the ideas in this discussion and simply in general). While development of an option that could be enabled in the future would be good, the understanding of PCS security in various group structures is already tenuous at the moment. I would not recommend that we roll-out this as an option in the first protocol version. Cas, Konrad, and I started looking into PCS effects when side-chats among sub-trees were allowed (assuming the subtree is not treated as a separate group), and found the possible cross-effects of compromise between groups when this is enabled grew very quickly and unexpectedly.",
          "createdAt": "2020-03-29T23:01:12Z",
          "updatedAt": "2020-03-29T23:01:12Z"
        },
        {
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "body": "Branching is a cool thing as such, but I think it's orthogonal to the idea of targeted messages.\r\nThis stems from the real-world need to send certain messages only to one recipient, while the contextual scope of that message is still a certain group (as mentioned delivery and read receipts fall in that category).\r\nBy real-world I mean that messengers already have the need to do exactly that and right now they would have to resort to solving this on the application layer. It's not the end of the world, but one of the goals of MLS was to reduce the amount of low-level crypto operations messengers should solve on the application layer.\r\nThe risk of doing the wrong thing is higher if messengers solve this individually (because there is typically no scrutiny from academia at that level).",
          "createdAt": "2020-04-01T20:47:47Z",
          "updatedAt": "2020-04-01T20:47:47Z"
        },
        {
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@raphaelrobert in your first post you say that you might want to send a message to a sub-group. That would be where branching comes in, as it gives you a nice way to send messages to a sub-group and at the same time profit from all the security guarantees we got in the original group. I think sending to an intermediate note might be a bit unpractical, because the subgroup you want to send a message to might or might not be gathered under one such node. \r\n\r\nMaybe you can elaborate a bit more on the use-case?\r\n\r\n\"Targeted message\" seems to suggest that you might want to send a message to a _user_ rather than to a specific group member (where by user, I mean someone who might run multiple devices and thus be the entity behind more than one node in the group. Sorry if I got the official terminology wrong here). If that is the case, again, a proper sub-group might be the way to go. A quick-and-dirty way might be to just KEM to multiple leaf nodes, so that might also be an option (if there are not too many of them and targeted messages are an infrequent thing).",
          "createdAt": "2020-04-03T17:22:46Z",
          "updatedAt": "2020-04-03T17:22:46Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "I agree that there's some potential utility here, but it seems far enough afield of the main goal here (group AKE) that I would be inclined to not address it in the main specification.",
          "createdAt": "2020-04-21T14:44:10Z",
          "updatedAt": "2020-04-21T14:44:10Z"
        }
      ]
    },
    {
      "number": 302,
      "id": "MDU6SXNzdWU1NjExNzE5NTc=",
      "title": "Use masking instead of AES-GCM for sender data",
      "url": "https://github.com/mlswg/mls-protocol/issues/302",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "Bren2010"
      ],
      "labels": [
        "question",
        "security",
        "performance"
      ],
      "body": "Earlier, we had considered a \"masking\" approach for sender data, much like QUIC does for [encrypting packet sequence numbers](https://github.com/quicwg/base-drafts/blob/master/draft-ietf-quic-tls.md#header-protection-header-protect).  This approach would save 28 bytes of overhead (nonce + tag), but was abandoned because of uncertainty around the security of the masking approach.\r\n\r\nSince then, Bellare et al. published [\"Nonces are Noticed\"](https://eprint.iacr.org/2019/624.pdf), which includes what is effectively a proof of the security properties of the QUIC scheme.  The QUIC scheme is essentially scheme HN1 of the paper, the main difference being that QUIC encrypt not the nonce directly, but a packet number which is used to compute the nonce.  Our application would be similar, since we would encrypt metadata used to encrypt the key and the nonce.\r\n\r\nGiven this new analysis, is it time to bring back masking?",
      "createdAt": "2020-02-06T17:51:16Z",
      "updatedAt": "2020-09-10T15:01:09Z",
      "closedAt": "2020-09-10T15:01:09Z",
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed by #360 ",
          "createdAt": "2020-09-10T15:01:09Z",
          "updatedAt": "2020-09-10T15:01:09Z"
        }
      ]
    },
    {
      "number": 312,
      "id": "MDU6SXNzdWU1NzUxNDE1MjU=",
      "title": "Add IANA considerations for Extensions ",
      "url": "https://github.com/mlswg/mls-protocol/issues/312",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "bug"
      ],
      "body": "Now that we have a more robust extension mechanism, we need to have an IANA registry to manage extensions, including:\r\n\r\n* Registry structure\r\n* Registry policy and (probably) designated experts\r\n* Reserved vendor space",
      "createdAt": "2020-03-04T05:10:07Z",
      "updatedAt": "2020-07-14T17:25:16Z",
      "closedAt": "2020-07-14T17:25:16Z",
      "comments": []
    },
    {
      "number": 323,
      "id": "MDU6SXNzdWU1ODgwMDgxMTU=",
      "title": "Fix context for new-member-initiated Add",
      "url": "https://github.com/mlswg/mls-protocol/issues/323",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "bug"
      ],
      "body": "Right now, the signature on an MLSPlaintext includes the GroupContext for the group.  If we are going to allow Add proposals signed by the new member, then this will need to change, because the new member doesn't know the GroupContext.\r\n\r\nMy preference would be to simply remove the GroupContext from the plaintext.  The Group ID is already included, so copy/paste protection can be added that way.  The other elements of the GroupContext effectively overlap with the Epoch that is already signed.",
      "createdAt": "2020-03-25T21:40:54Z",
      "updatedAt": "2020-06-16T19:07:44Z",
      "closedAt": "2020-06-16T19:07:44Z",
      "comments": [
        {
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "body": "Haven't thought about this too deeply, but having the full GroupContext in MLSPlaintextTBS means that we know all the members agree on the state of the ratchet tree, the transcript, the extensions. Removing it means we would no longer have agreement on those, right?",
          "createdAt": "2020-03-27T20:59:36Z",
          "updatedAt": "2020-03-27T20:59:36Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "We won't have confirmation of agreement as a result of signature verification.  The question is whether that is necessary.   If the MLSPlaintext was decrypted from an MLSCiphertext, for example, then the successful decryption of the MLSCiphertext implies agreement on all those things.\r\n\r\nI suppose you could also switch the signature input based on SenderType, but that seems messier.",
          "createdAt": "2020-04-21T14:39:33Z",
          "updatedAt": "2020-04-21T14:39:33Z"
        },
        {
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "body": "I'm not so sure that decrypting an MLSCiphertext implies agreement, because the crypto is symmetric. A man-in-the-middle can re-encrypt but not re-sign.",
          "createdAt": "2020-04-21T17:54:34Z",
          "updatedAt": "2020-04-21T17:54:34Z"
        }
      ]
    },
    {
      "number": 324,
      "id": "MDU6SXNzdWU1ODg0NTUwMzI=",
      "title": "Use consistent arguments to Derive-Secret",
      "url": "https://github.com/mlswg/mls-protocol/issues/324",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "enhancement"
      ],
      "body": "The document is not consistent about how many arguments go into Derive-Secret:\r\n\r\n* The definition takes two labels, and some invocations provide two, e.g., MLS-Exporter\r\n* The derivations in the key schedule provide an extra argument\r\n\r\nI'm pretty sure the latter is wrong, and we should just delete the explicit context from the three-argument version.  At the same time, I'm wary that using the GroupContext in every invocation of HKDF-Expand-Label will get us into some unimplementable situations if we try to use HKDF-Expand-Label outside an established group.",
      "createdAt": "2020-03-26T14:16:40Z",
      "updatedAt": "2020-07-20T18:21:51Z",
      "closedAt": "2020-07-20T18:21:51Z",
      "comments": [
        {
          "author": "GaPhil",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I believe this duplicates #264?",
          "createdAt": "2020-03-31T07:38:40Z",
          "updatedAt": "2020-03-31T07:38:40Z"
        }
      ]
    },
    {
      "number": 325,
      "id": "MDU6SXNzdWU1ODg0ODgzMTI=",
      "title": "Simplify epoch secret derivation?",
      "url": "https://github.com/mlswg/mls-protocol/issues/325",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "question",
        "analysis"
      ],
      "body": "It doesn't seem like the `Derive-Secret` step between the `early_secret` and the `epoch_secret` is helping anything.  Could we remove it?\r\n\r\n```\r\n    PSK (or 0) -> HKDF-Extract = early_secret\r\n                     |\r\n                     V\r\ncommit_secret -> HKDF-Extract = epoch_secret\r\n```",
      "createdAt": "2020-03-26T15:01:29Z",
      "updatedAt": "2020-07-28T17:29:26Z",
      "closedAt": "2020-07-28T17:29:26Z",
      "comments": [
        {
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "body": "I think a number of people want to revisit the key schedule:\r\n\r\n - Britta/Konrad: want to make changes to the PSK part for version upgrades\r\n - Brendan: (I don't remember exactly)\r\n - Raphael: wants to harmonise how the GroupState is pulled in\r\n\r\nAt this point it would be good to collect all feedback first and do one big change instead of many small ones.",
          "createdAt": "2020-03-26T15:08:38Z",
          "updatedAt": "2020-03-26T15:08:38Z"
        },
        {
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "body": "+ Me: wants to use the transcript hash instead of the group state because the transcript hash contains strictly more.",
          "createdAt": "2020-03-26T16:18:05Z",
          "updatedAt": "2020-03-26T16:18:05Z"
        },
        {
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "body": "Not sure if this is everything, but I know I wanted to:\r\n1. Stop integrating the node id into every level of the application secret tree, to be more friendly to recursive implementations that don't store nodes in a linear array.\r\n2. Integrate context information at specific places, and then just use a hash directly (instead of HKDF) wherever possible. Hashes really do get quite expensive (~10 hashes = 1 ECDSA signature), and HKDF is two or three hashes.",
          "createdAt": "2020-03-27T20:52:06Z",
          "updatedAt": "2020-03-27T20:52:06Z"
        },
        {
          "author": "br-hale",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Konrad and I have a draft PR for a number of changes, mostly relating to version upgrades (with group branching support considered if we want that feature in the future). \r\n\r\nAdditional: derive authentication secret per-epoch separate from exporter key (i.e. secrets used in and for the protocol should be derived separately from secrets used beyond the protocol). \r\nTL:DR on IETF 104 presentation and other PCS work: authentication secrets can be used either for detection of an active MitM following signature key compromise or simply AS compromise, or in replacement of a TTP.",
          "createdAt": "2020-03-29T22:46:04Z",
          "updatedAt": "2020-03-29T22:46:04Z"
        },
        {
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "It seems to me that most of these changes to the key schedule are orthogonal, so maybe everyone should just make a PR for their preferred change?\r\n\r\nRegarding the changes proposed by @Bren2010, I think we should be careful such that we (1) still get the properties we need from the keys and (2) can prove that we actually do. I'm all for optimizing MLS for ease of implementation, but I think it at least warrants a discussion.\r\n\r\nMy take is that 1. does not impact key pseudorandomness but rather the collision resistance properties of that key (and the keys derived from it). From a proof-standpoint (using state-separating proofs ymmv with other techniques) we need that property at least when we next use the corresponding group key in an HKDF-extract function. If we include the transcript (which includes the groupstate) into the key at some point before, it should be doable as well. That being said, it would be *much* easier if we could make that argument \"up the tree\" as opposed to just in the end. So I think we have an \"ease-of-implementation\" vs. \"ease-of-proof\" trade-off here. My experience with a proof of the TLS key schedule we did recently is that this sort of step complicates the proof quite a bit (although that probably depends on your proof technique). I'd be interested what the other parties think that are doing (or are going to do) proofs.\r\n\r\nRegarding 2.: Are we not just using HKDF-expand in most cases? If the output of the hash function used to instantiate the hmac used in the HKDF is equal to the desired length of the key, there should only be one hash operation per call to HKDF-expand and it should not be much of a performance penalty if we include context at those points. Please correct me if I'm wrong.",
          "createdAt": "2020-03-31T11:15:55Z",
          "updatedAt": "2020-03-31T11:15:55Z"
        },
        {
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "body": "> My take is that 1. does not impact key pseudorandomness but rather the collision resistance properties of that key (and the keys derived from it).\r\n\r\nI don't understand the argument about collision resistance here. We're including explicit data in the call to HKDF-Expand (particularly, node id and generation) that's implicitly authenticated by the structure of HKDF-Expand calls used to build the tree. The tree's root is given by the key schedule, which is integrating all of the context you need.\r\n\r\nIf the hash function is weak, how would including more data in its input mitigate an attack?\r\n\r\n> Regarding 2.: Are we not just using HKDF-expand in most cases? If the output of the hash function used to instantiate the hmac used in the HKDF is equal to the desired length of the key, there should only be one hash operation per call to HKDF-expand and it should not be much of a performance penalty if we include context at those points. Please correct me if I'm wrong.\r\n\r\nThe HKDF-Expand is one HMAC call, and HMAC is two hashes. HMAC would be three hashes if the key were a different length.",
          "createdAt": "2020-03-31T23:47:14Z",
          "updatedAt": "2020-03-31T23:47:14Z"
        },
        {
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> We're including explicit data in the call to HKDF-Expand (particularly, node id and generation) that's implicitly authenticated by the structure of HKDF-Expand calls used to build the tree.\r\n\r\nMy impression was that you wanted to remove the node-id from the HKDF-expand call. Is that not the case?\r\n\r\nAgain, I'm not saying it's impossible to prove uniqueness of the resulting group key if we remove the node-id. I'm just saying it might make it _harder_ to prove (just as leaving them in might make it harder to implement).\r\n\r\n> If the hash function is weak, how would including more data in its input mitigate an attack?\r\n\r\nIt's not about the properties of the hash function. It's about ensuring that the output key is distinct from the keys derived in the other nodes. If we assume that the hash function is ideal with regard to collision resistance, the input uniquely determines the output. Thus, if we include the unique node id, we get a unique key, even if the rest of the input is potentially the same. This allows us to assume that the output key is unique, even if the adversary chooses the rest of the input.\r\n\r\n> The HKDF-Expand is one HMAC call, and HMAC is two hashes. HMAC would be three hashes if the key were a different length.\r\n\r\nAh, I was under the impression that HMAC was just one hash operation. In any case, I'm not an expert regarding properties of hash functions, but my understanding from [1] is that simple hashing is not advisable as a KDF, even if the input is already pseudorandom. Are there any further results on this? I'm happy to go to just a simple hash, but we need to be sure that we actually get good keys as a result.\r\n\r\n[1] Krawczyk, Cryptographic Extraction and Key Derivation:\r\nThe HKDF Scheme (https://eprint.iacr.org/2010/264)",
          "createdAt": "2020-04-01T05:35:56Z",
          "updatedAt": "2020-04-01T05:35:56Z"
        },
        {
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "body": "> My impression was that you wanted to remove the node-id from the HKDF-expand call. Is that not the case?\r\n\r\nYes, that's what I want to do. I want to remove `generation` now too, that I've thought of it.\r\n\r\n> It's not about the properties of the hash function. It's about ensuring that the output key is distinct from the keys derived in the other nodes.\r\n\r\nIf the output key for different nodes is the same, that clearly implies you've found a collision in the hash function, so the hash function is weak. That's because you *are* hashing different things at every point, in particular, `H(parent || \"left\")` and `H(parent || \"right\")`. Arguing \"if we assume the hash function is ideal\" doesn't make sense to me, because we know the hash function is not ideal.\r\n\r\n> Ah, I was under the impression that HMAC was just one hash operation. In any case, I'm not an expert regarding properties of hash functions, but my understanding from [1] is that simple hashing is not advisable as a KDF, even if the input is already pseudorandom.\r\n\r\nWe can generate the bulk of the tree with a hash, and still use HKDF for the chain at the leaves of the ASTree. But perhaps just one call to HKDF-Extract to generate both the key and nonce at once.",
          "createdAt": "2020-04-01T15:09:11Z",
          "updatedAt": "2020-04-01T15:09:11Z"
        },
        {
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> Yes, that's what I want to do. I want to remove generation now too, that I've thought of it.\r\n\r\nBut if we're not including that, then how is that \"implicitly authenticated by the structure of HKDF-Expand calls used to build the tree\" as you said in your earlier reply?\r\n\r\n> If the output key for different nodes is the same, that clearly implies you've found a collision in the hash function, so the hash function is weak. That's because you are hashing different things at every point, in particular, H(parent || \"left\") and H(parent || \"right\"). Arguing \"if we assume the hash function is ideal\" doesn't make sense to me, because we know the hash function is not ideal.\r\n\r\nI'm talking about arguments in the context of a proof, where the goal is to figure out if we get good keys in the end, under a set of assumptions. One of the assumptions is that we can replace the hash function we use by an ideal one, without an adversary \"noticing the difference\". It would make the proof easier if we can assume that the output of the key derivation step doesn't collide _even if_ the adversary can control the input key material. Then the inclusion of the node-specific label would give us that guarantee. We might be able to do the proof iteratively across the layers of the tree, but I'm not certain about that. That is why I wouldn't want to throw out that extra information in the key derivation step. I'm happy to explain our proof methodology in more detail to make clear what I'm worried about, but I'm not going to do that in a git issue.\r\n\r\n> We can generate the bulk of the tree with a hash, and still use HKDF for the chain at the leaves of the ASTree. But perhaps just one call to HKDF-Extract to generate both the key and nonce at once.\r\n\r\nI'm not sure that works, because for HKDF-Extract to give you a good (pseudorandom) key, you need the input to be pseudorandom. And I'm not sure there is solid basis to assume that the output of a hash function is indeed a pseudorandom string. If there was, I'd be happy to agree to just replace all HKDF-Expand calls with hash function calls.",
          "createdAt": "2020-04-01T15:37:56Z",
          "updatedAt": "2020-04-01T15:37:56Z"
        },
        {
          "author": "br-hale",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> Integrate context information at specific places, and then just use a hash directly (instead of HKDF) wherever possible....\r\n> We can generate the bulk of the tree with a hash, and still use HKDF for the chain at the leaves of the ASTree. \r\n\r\nA hash is definitely not enough for a key derivation. Just a quick look at the research should be enough to make that statement convincing. There is a reason why we use a KDF for key derivation to achieve sufficient pseudorandomness, and switching it out with a hash as a quick fix will be asking for problems down the line. If we use just a hash, then the output should NOT be called a secret or used as a key, as a general rule (exceptions depending on input). \r\n\r\nAs to removing context from the key derivation: I think that there is an underlying assumption being presented in the argument for removal that the remaining inputs are unique and tied sufficiently to individual nodes already. Hopefully this is the case, but there is no guarantee. Consequently the result of removing them is not simply that proofs may become more difficult, but that the ensuing reductions (for computational proofs) may become less tight. In (quite loose) terms, this means that there are more conditions on the contexts in which security is achieved, and increased possibilities for breaking it.",
          "createdAt": "2020-04-01T16:04:14Z",
          "updatedAt": "2020-04-01T16:04:14Z"
        },
        {
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "body": "> But if we're not including that, then how is that \"implicitly authenticated by the structure of HKDF-Expand calls used to build the tree\" as you said in your earlier reply?\r\n\r\nTake for example, the chain at each leaf of the ASTree. We include a `generation` counter in the input to each HKDF-Expand, but the generation counter is equal to how far you've walked in the hash chain. The generation counter = explicit authentication, how far you've walked in the chain = implicit authentication.\r\n\r\n> I'm talking about arguments in the context of a proof, where the goal is to figure out if we get good keys in the end, under a set of assumptions.\r\n\r\nPeople have been complaining about the difficulty of proving properties of the key schedule the whole time the wg has existed, trying to make it more expensive and materially less secure, to simplify proofs. In reality, it's one of the few \"obviously secure\" parts of the protocol and there are still vulnerabilities elsewhere. Proof efforts should be directed to parts of the protocol that are actually difficult for humans to reason about.\r\n\r\n> I'm not sure there is solid basis to assume that the output of a hash function is indeed a pseudorandom string. If there was, I'd be happy to agree to just replace all HKDF-Expand calls with hash function calls.\r\n\r\nI think it's very fair to assume that a secure hash function is a random oracle. HKDF is just the output of a hash. We would want to keep HKDF-Expand at the leaves for pragmatic reasons: infinite stream derivation (because key and nonce size are variable), and safely combining the label (\"key\", \"nonce\", \"secret\") with the IKM.\r\n\r\n---\r\n\r\nI believe Britta's comments are addressed above.",
          "createdAt": "2020-04-01T17:56:23Z",
          "updatedAt": "2020-04-01T17:56:23Z"
        },
        {
          "author": "br-hale",
          "authorAssociation": "CONTRIBUTOR",
          "body": ">People have been complaining about the difficulty of proving properties of the key schedule the whole time the wg has existed, trying to make it more expensive and materially less secure, to simplify proofs. In reality, it's one of the few \"obviously secure\" parts of the protocol and there are still vulnerabilities elsewhere. Proof efforts should be directed to parts of the protocol that are actually difficult for humans to reason about.\r\n\r\nI agree with the assessment that there are many potential vulnerabilities elsewhere that need focus. However, the above statement not only lacks core reasoning on the problem, but indicates misunderstanding of analysis methods and results. You are making an _ad hominem_ argument for ignoring what could have serious implications. See my comment above about tightness of security reductions, which you did not address. Tightness is not about ease of proof, it is about what claims can be proven. Your changes will likely have an effect on that. \r\n\r\n>I think it's very fair to assume that a secure hash function is a random oracle. HKDF is just the output of a hash. \r\n\r\nOK, but a decade of cryptographic research disagrees with that general statement. Making wide claims about what you _think_ should be _assumed_ does not progress the decision; it would be helpful if you founded your argument instead on the what the exact inputs are to the different hash uses (and there is a difference based on node height) and explain why you think there is sufficient randomness in the input to not use a KDF. \r\n\r\nNo one so far has said your suggestion is wrong, only that you have not put forth any supporting arguments, i.e. Konrad's comment:\r\n>And I'm not sure there is solid basis to assume that the output of a hash function is indeed a pseudorandom string. If there was, I'd be happy to agree to just replace all HKDF-Expand calls with hash function calls.\r\n\r\nIt is in everyone's interest to progress with decisions as scientifically as possible, with descriptive, shared reasoning behind changes - especially ones that have the potential to affect the randomness of keys - and without taking requests for justification personally. \r\n\r\nGiven the extended discussion on this issue, I suggest that it be moved to an interim meeting where it can be given appropriate attention. Engaging further in a git issue thread on the topic is unlikely to achieve satisfactory results, and it clearly warrants further attention.",
          "createdAt": "2020-04-01T18:38:47Z",
          "updatedAt": "2020-04-01T18:40:21Z"
        },
        {
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "body": "> You are making an ad hominem argument for ignoring what could have serious implications. See my comment above about tightness of security reductions, which you did not address. Tightness is not about ease of proof, it is about what claims can be proven. Your changes will likely have an effect on that.\r\n\r\nI'm saying we should de-prioritize provable security in the key schedule for three reasons:\r\n- It's easy to convince yourself of the key schedule's properties on-sight, both due to its simplicity and how much it has in common with other widely deployed cryptosystems.\r\n- Even if we optimize the key schedule for provable security, people have indicated that the proofs will still be very difficult and that they may not do them.\r\n- Existing system-level vulnerabilities are being (and have been) overlooked because of a hyper-focus on proving component-level properties.\r\n\r\nThis way, we can make the key schedule much faster and easier to implement.",
          "createdAt": "2020-04-01T19:55:44Z",
          "updatedAt": "2020-04-01T19:55:44Z"
        }
      ]
    },
    {
      "number": 326,
      "id": "MDU6SXNzdWU1ODg1MDg4MDQ=",
      "title": "Authenticate that added members know the PSK",
      "url": "https://github.com/mlswg/mls-protocol/issues/326",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "work in progress"
      ],
      "body": "The current PSK construct does not authenticate that a member added during the epoch knows the PSK.  This is because the PSK is used as an input to the epoch secret computation, and the new joiner is provided with the epoch secret directly.  I think that if we reverse the input of the commit secret and the PSK, and provide the intermediate product to the new joiner, we can achieve this property:\r\n\r\n```\r\n               init_secret_[n-1] (or 0)\r\n                     |\r\n                     V\r\n commit_secret -> HKDF-Extract = joiner_secret\r\n                     |\r\n                     V\r\n    PSK (or 0) -> HKDF-Extract = epoch_secret\r\n```\r\n\r\nIn other words, would provide the `joiner_secret` value to the new joiners in the GroupSecrets object, instead of the `epoch_secret`.",
      "createdAt": "2020-03-26T15:28:24Z",
      "updatedAt": "2020-07-28T17:29:26Z",
      "closedAt": "2020-07-28T17:29:26Z",
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "We might want to also provide an optional PSK ID in the GroupSecrets object.",
          "createdAt": "2020-03-26T15:29:24Z",
          "updatedAt": "2020-03-26T15:29:24Z"
        },
        {
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "body": "Konrad, Britta and I have been looking at this...\r\nNote that a PSK that is generated for a specific group should not be known by another group.",
          "createdAt": "2020-03-26T16:15:59Z",
          "updatedAt": "2020-03-26T16:15:59Z"
        },
        {
          "author": "br-hale",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Second that. \r\nAlso, the PSK ID should be linked to the epoch (or similarly identifiable) such that it is clear what current state is associated with the PSK being used (such as which members have access to the PSK in cases of reinitializing after breaks in group state, branching, etc.). ",
          "createdAt": "2020-03-29T22:28:48Z",
          "updatedAt": "2020-03-29T22:28:48Z"
        }
      ]
    },
    {
      "number": 328,
      "id": "MDU6SXNzdWU1ODk4NTU2MDM=",
      "title": "Use the same index for hashing parent and leaf nodes",
      "url": "https://github.com/mlswg/mls-protocol/issues/328",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "enhancement"
      ],
      "body": "Right now the LeafNodeHashInput struct uses the index of the node among the leaves, while the ParentNodeHashInput struct uses the index of the node among all nodes.  This means that, for example, the index value will be the same for the second leaf and its parent (`1` in both cases).\r\n\r\nWe should probably just use the node index in both cases.",
      "createdAt": "2020-03-29T18:40:44Z",
      "updatedAt": "2020-07-07T19:04:55Z",
      "closedAt": "2020-07-07T19:04:55Z",
      "comments": [
        {
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "body": "https://github.com/mlswg/mls-protocol/pull/320 is a better solution",
          "createdAt": "2020-03-29T19:05:04Z",
          "updatedAt": "2020-03-29T19:05:04Z"
        }
      ]
    },
    {
      "number": 340,
      "id": "MDU6SXNzdWU2MjE3NjE5NDc=",
      "title": "Clarify what it means to send a Commit with no Proposals",
      "url": "https://github.com/mlswg/mls-protocol/issues/340",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Right now, it is possible to send a Commit that covers no proposals.  This has the result that the leaf of the sender and its direct path are refreshed, but no other change to the tree is made.  (The epoch also advances, of course.)  This can be is a useful operation.  For example, an Add wipes out the new joiner's direct path, so having the new joiner send a Commit over no proposals would fill in that direct path and make subsequent operations more efficient.\r\n\r\nWe should clarify in some prose that (a) this is possible and (b) why it might be useful.",
      "createdAt": "2020-05-20T13:26:45Z",
      "updatedAt": "2020-07-24T21:11:12Z",
      "closedAt": "2020-07-24T21:11:11Z",
      "comments": []
    },
    {
      "number": 344,
      "id": "MDU6SXNzdWU2MjkyOTYzNTA=",
      "title": "Tree in GroupInfo not optional",
      "url": "https://github.com/mlswg/mls-protocol/issues/344",
      "state": "CLOSED",
      "author": "raphaelrobert",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "performance",
        "functionality"
      ],
      "body": "I remember we discussed this in the past, but I don't think we ever spec'ed this out fully:\r\n\r\nRight now the whole tree is part of `GroupInfo` (which in turn is part of `Welcome`). This can grow quite big in large groups (~17MB with 100k members with the MTI). The practical limitations are:\r\n\r\n - The TLS representation of the tree is hard to parse efficiently (no skipping and no a priori information of how many nodes are in the tree)\r\n - Out-of-band transmission (like server assist) is not possible\r\n - Large messages like that are hard to handle on mobile devices, when they have to be downloaded in the background\r\n\r\nWe should introduce an indirection, like a commit hash of the tree.",
      "createdAt": "2020-06-02T15:26:56Z",
      "updatedAt": "2020-07-24T21:14:45Z",
      "closedAt": "2020-07-24T21:14:45Z",
      "comments": []
    },
    {
      "number": 346,
      "id": "MDU6SXNzdWU2MzY0MzAxNzQ=",
      "title": "Ratcheting of External PSKs",
      "url": "https://github.com/mlswg/mls-protocol/issues/346",
      "state": "CLOSED",
      "author": "br-hale",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "This issue is to start a discussion thread on the suggestion made by Chris Wood under PR #336. The suggestion is not directly related to #336, so is listed here for discussion (some discussion already appears there):\r\n\r\n`chris-wood:\r\nAre \"external\" PSKs fixed? Would it make sense for them to also include an epoch, to allow applications to roll them forward for some FS?`\r\n\r\nCurrent considerations: \r\n1) Is this a use case worth addressing for MLS (i.e. taking in an external PSK and then maintaining it in sync to protocol ratcheting)?\r\n2) If so, is it sufficiently critical to be part of the protocol, or sufficiently peripheral to be discussed in the architecture?",
      "createdAt": "2020-06-10T17:38:06Z",
      "updatedAt": "2020-06-19T12:55:37Z",
      "closedAt": "2020-06-19T12:55:37Z",
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "I don't think this is really an issue we need to address here.  We already allow a different PSK to be injected at every epoch change.  How exactly the app chooses which PSK to inject at which time is their business, not ours.",
          "createdAt": "2020-06-13T19:04:45Z",
          "updatedAt": "2020-06-13T19:04:45Z"
        }
      ]
    },
    {
      "number": 351,
      "id": "MDU6SXNzdWU2Mzk5NTM4NDM=",
      "title": "Use HPKE KDF for the MLS key schedule",
      "url": "https://github.com/mlswg/mls-protocol/issues/351",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Our HPKE dependency provides a perfectly usable KDF.  We should just use that instead of nailing a dependency to HKDF.  This will mainly be a matter of changing `HKDF-Extract` and `HKDF-Expand` calls to the corresponding calls on the HPKE KDF.",
      "createdAt": "2020-06-16T20:32:22Z",
      "updatedAt": "2020-07-24T19:49:13Z",
      "closedAt": "2020-07-24T19:49:13Z",
      "comments": []
    },
    {
      "number": 365,
      "id": "MDU6SXNzdWU2NjU0MTk4Njc=",
      "title": "Update security considerations",
      "url": "https://github.com/mlswg/mls-protocol/issues/365",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "The not-protocol parts of the document, including security considerations and some of the operational considerations, are mostly untouched since the beginning of this work.  As we get the protocol firmed up, we should revisit these parts to make sure they're up to date and give an accurate reflection of the concerns around the protocol.",
      "createdAt": "2020-07-24T21:10:56Z",
      "updatedAt": "2021-11-30T23:37:59Z",
      "closedAt": "2021-11-30T23:37:59Z",
      "comments": [
        {
          "author": "ericcornelissen",
          "authorAssociation": "CONTRIBUTOR",
          "body": "One particular thing related to this that I noticed is that in the [Confidentiality of the Group Secrets section](https://github.com/mlswg/mls-protocol/blob/c3db39266505e9d202158d642d65918d35870e77/draft-ietf-mls-protocol.md#confidentiality-of-the-group-secrets) the first sentence:\r\n\r\n> Group secrets are derived from (i) previous group secrets, and (ii) the root key of a ratcheting tree. [...]\r\n\r\nis outdated as (ii) can now also be an all-zero vector, namely if `path` is not required and not set (as introduced in  #331 if I'm not mistaken).",
          "createdAt": "2020-08-04T11:57:03Z",
          "updatedAt": "2020-08-04T11:57:03Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "I did a review of the Security Considerations and didn't see anything that needs fixing before WGLC.  The point that @ericcornelissen raises appears to have been fixed in some other PR.",
          "createdAt": "2021-11-30T23:37:59Z",
          "updatedAt": "2021-11-30T23:37:59Z"
        }
      ]
    },
    {
      "number": 366,
      "id": "MDU6SXNzdWU2NjU0NDEzNTk=",
      "title": "Add extensions to the Commit message",
      "url": "https://github.com/mlswg/mls-protocol/issues/366",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "[This issue is part of a feature breakdown based on #336]\r\n\r\nApplications might want to signal to group members  processing a commit that they should take certain actions in addition to ratcheting the group forward.  The most obvious example is folding in a PSK for the epoch, but you can also imagine addressing things like transcript consistency or updatable PKE through this channel.\r\n\r\nThis should be straightforward syntactically, but will also require updating the extensibility section to make clear that Commit extensions can also in principle affect the GroupContext extensions.  In other words:\r\n\r\n* Each group member associates a list of extensions with the group, which are confirmed via the GroupContext\r\n* New joiners get configured with these via extensions in the GroupInfo\r\n* Existing members can find out about changes to the group's extensions via extensions in the Commit",
      "createdAt": "2020-07-24T22:03:25Z",
      "updatedAt": "2020-08-25T18:15:15Z",
      "closedAt": "2020-08-25T18:15:15Z",
      "comments": [
        {
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think making commit messages extensible is a great idea. However, I'd like to understand better what we want to use the extensions first. \r\n\r\n> Applications might want to signal to group members processing a commit that they should take certain actions in addition to ratcheting the group forward.\r\n\r\nI thought that was what Proposals are for. I think for mechanisms that are part of the base protocol spec, there is no reason not to extend the list of proposals.\r\n\r\nRegarding the nature of extensions: Do I understand correctly, that an extension is a property of the group first and foremost? And extensions in the commit are meant to alert other group members to changes in those properties? Or are extensions in the commit messages a mechanism to allow for the inclusion of additional data in the commits? Or both? I feel like the meaning of the word \"extension\" is a little stretched here.\r\n\r\nSince we're discussing this also in the context of PSK injections: Do you think PSK injections should be something that can be switched on and off for any given group? If so, why? I would consider it part of the base protocol and do not see what benefits we get from disallowing it in a group.",
          "createdAt": "2020-08-03T08:54:42Z",
          "updatedAt": "2020-08-03T08:54:42Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "It's a fair point, that we have basically two extension points here -- proposal types and extensions.  I think the theory I had in mind was something like:\r\n\r\n1. Proposals describe modifications you make to the tree before you use it for TreeKEM (to get the path) (if you do)\r\n2. The DirectPath describes the outcome of TreeKEM.Encap\r\n3. Extensions tell you anything else you need to do\r\n\r\nIf that philosophy makes sense, I can update the PR to make that clearer.\r\n\r\nNote that proposal extensibility is currently broken because we don't actually have a way for the Commit to include any Proposals with new proposal types.  I've filed #383 for that.",
          "createdAt": "2020-08-03T21:30:05Z",
          "updatedAt": "2020-08-03T21:30:05Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "On the nature of extensions: My thinking here is that an \"extension\" is purely syntactic; its semantics are defined entirely by its ExtensionType.  One thing that extensions do (in the context of GroupContext) is express what attributes/parameters the group has agreed to.  But they can also do other things.",
          "createdAt": "2020-08-03T21:33:43Z",
          "updatedAt": "2020-08-03T21:33:43Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "On PSK injections: My thinking here is that PSKs are a per-epoch decision, in that you can inject a different set of PSKs at each epoch.  Since the Commit is the thing that starts a new epoch, it signals what PSKs to use for that epoch.  A few illustrative cases:\r\n\r\n- A \"meeting password\" might get injected on every commit\r\n- ... or you might only inject it in commits where you have an Add, to verify that the new guy has it\r\n- In a scenario where you have some OOB PSK distribution (say to add more PQ safety), you would inject a PSK every epoch, but a different one in each epoch\r\n- When re-starting a group or branching a subgroup, you would incorporate the resumption secret from the previous group, but then might not need a PSK ever again.",
          "createdAt": "2020-08-03T21:44:57Z",
          "updatedAt": "2020-08-03T21:44:57Z"
        },
        {
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I see, thanks for the clarification. My understanding of extensions was that their advantage is that they're dynamic and can be defined and used after MLS is defined, i.e. to keep the standard extensible. I know that in the TLS context, extensions are used for all sorts of basic protocol behaviour, but my understanding was that was more something that has evolved over time rather than it being \"by-design\".\r\n\r\nIs there any reason for Proposals to be limited to TreeKEM operations (other than that being their historic purpose)? Because otherwise it seems a little odd to me not to use them for core MLS operations such as PSK injection.",
          "createdAt": "2020-08-04T07:31:57Z",
          "updatedAt": "2020-08-04T07:31:57Z"
        },
        {
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Otherwise, I agree with your take on PSK injections. They should definitely be part of the commit and it should be possible to inject them ad-hoc. Although for the re-starting or branching use-case, I think they should be part of the Welcome message, but I think we're having that discussion on the mailing list already.",
          "createdAt": "2020-08-04T07:36:02Z",
          "updatedAt": "2020-08-04T07:36:02Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "This was discussed at the interim on 2020-08-25.  The feeling of the group was that Proposals should be a sufficient extension mechanism for Commits, so we don't need this if we fix #383.  And since #389 is about to do that, closing this issue.",
          "createdAt": "2020-08-25T18:15:15Z",
          "updatedAt": "2020-08-25T18:15:15Z"
        }
      ]
    },
    {
      "number": 367,
      "id": "MDU6SXNzdWU2NjU0NDg1ODE=",
      "title": "Negotiate PSKs",
      "url": "https://github.com/mlswg/mls-protocol/issues/367",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "kkohbrok"
      ],
      "labels": [
        "enhancement",
        "security",
        "work in progress"
      ],
      "body": "[This issue is part of a feature breakdown based on #336]\r\n\r\nThere are a few subissues here:\r\n\r\n# 1. Signaling which PSK(s) to add to the key schedule\r\n\r\nWhen a PSK is to be added to the key schedule in an epoch, the sender of the Commit needs to signal this to existing members in a Commit, and to any new members in the GroupInfo.  In both cases, there should be an extension to signal this.  This would work like the [TLS ServerHello PSK extension](https://tools.ietf.org/html/rfc8446#section-4.2.11), which simply indicates which PSK is being used.  In the MLS case, we would probably include the full ID instead of just an index, since there's not a clear list like in TLS.  And just like the server's ability to complete the TLS handshake proves that it has the PSK, the confirmation value in MLS would validate the same.\r\n\r\n```\r\nstruct {\r\n    opaque identity<1..2^16-1>;\r\n} PreSharedKeyExtension;\r\n```\r\n\r\n# 2. Signaling which PSKs are available\r\n\r\nIt might also be useful for clients to advertise in a KeyPackage extension what PSKs they have available.  This would be analogous to the ClientHello PSK extension, which includes a binding value to prove that the client has the PSK.  If we define such an extension, we will need to decide (a) whether we need such a binding and (b) what parts of the KeyPackage should be covered by the binding MAC.\r\n\r\nUnlike TLS, however, the set of available PSKs might change over the lifetime of the group.  Since the KeyPackages in the leaves of the tree can be modified, in principle, clients could signal the availability of new PSKs by updating, and you would get a clear assurance that everyone has the key before you try to use it.  But this seems pretty complex, and for not much benefit if the application can coordinate which PSKs are available.\r\n\r\n# 3. Structuring PSK input / multiple PSKs\r\n\r\nIt may be desirable for the input to the key schedule not to be a PSK directly, but some derived value that adds some context to the PSK.  This is the approach taken in the [TLS external PSK draft](https://tools.ietf.org/html/draft-ietf-tls-external-psk-importer-05) and in #336.  We might also want to support the application of multiple PSKs in a single epoch.\r\n\r\nFor the former need, we would need to define what context is added, how it is signaled in the relevant extensions, and how it is combined with the PSK itself to derive the ultimate PSK.  For the latter need, we need a way to signal multiple PSKs and their order, and an algorithm for combining them all into one value to be added to the key schedule.  (The schemes in both #336 and #337 are relevant here.)\r\n",
      "createdAt": "2020-07-24T22:24:00Z",
      "updatedAt": "2020-10-19T14:27:48Z",
      "closedAt": "2020-10-19T14:27:47Z",
      "comments": [
        {
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Except for the advertisement of PSKs in KeyPackages, we already covered all of this in #336. In particular, it is important to distinguish PSKs by type (internal/external, which type of internal) by having an extra layer of derivations before injecting the PSK into the key schedule. Again, this is already present in #336.\r\n\r\nPR #376 re-implements #336 partially, but instead of having additional types of proposals, it instead has a dedicated preSharedKey extension that can come with a commit. Why an extension instead of a proposal? I would think that PSKs are part of MLS' core functionality, for example to securely create subgroups or to restart groups with different parameters.\r\n\r\nHaving PSKs in KeyPackages might be a good idea, but as you already hint at, I don't think it's a good idea to use it as a necessary way of signalling the availability for all PSKs. With group restarting and branching, we use PSKs much more dynamically than in TLS. For example, when creating a sub-group, the creator already knows that the relevant PSKs are available to all members due to their membership in the original group.\r\n\r\nDo you want me to isolate the parts of #336 relevant for this particular issue and create a separate PR? If we still want an extension instead of a dedicated proposal, we should probably merge #369 first and then do the PR against the result.",
          "createdAt": "2020-07-29T07:35:37Z",
          "updatedAt": "2020-07-29T07:35:37Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed by #336 ",
          "createdAt": "2020-10-19T14:27:47Z",
          "updatedAt": "2020-10-19T14:27:47Z"
        }
      ]
    },
    {
      "number": 368,
      "id": "MDU6SXNzdWU2NjU0NTIxOTA=",
      "title": "Proof of prior membership in the group / Resumption",
      "url": "https://github.com/mlswg/mls-protocol/issues/368",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "kkohbrok"
      ],
      "labels": [
        "enhancement",
        "security",
        "work in progress"
      ],
      "body": "[This issue is part of a feature breakdown based on #336]\r\n\r\nThere are two cases where the members of a group might want to authenticate that the other members of the group were present at another point in history:\r\n\r\n1. A user who has lost state re-joining the group\r\n2. Re-initializing the group with different parameters\r\n3. Initializing a subgroup from a master group\r\n\r\nIn the former case, the group would want to authenticate that the user re-joining is the same user who was present at some past point in the history of the group.  In the latter two cases, the members of the new, re-initialized group would be authenticating that everyone in the new group was also in the old group.\r\n\r\nThese use cases are similar to resumption in TLS, where a PSK is derived from the key schedule and used as for authentication in a different session.  A similar approach seems sensible here, roughly:\r\n\r\n1. At each epoch of the group derive a PSK and PSK ID to be used \r\n2. Use the general PSK signaling mechanism (#367) to signal that a prior epoch's PSK should be used\r\n\r\nThis approach is also a good indication that the PSK mechanism in #367 should allow for PSKs to have specified types.  In TLS, there has been some confusion about how applications can distinguish external PSKs from resumption PSKs.  If we have an explicit type here, we won't end up with that confusion.",
      "createdAt": "2020-07-24T22:34:54Z",
      "updatedAt": "2020-10-19T14:28:05Z",
      "closedAt": "2020-10-19T14:28:05Z",
      "comments": [
        {
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "As noted in my comment on #367, this is all detailed and implemented in PR #336.\r\n\r\nWe created #336 based on the use cases you identified and reached the same conclusions. Getting the PSK derivations and their inclusion in the key schedule right is a little tricky. How should we proceed? It probably makes sense to agree on something to merge for #367 and then create a separate PR for this issue with whatever is left of the original #336 PR.",
          "createdAt": "2020-07-29T07:47:55Z",
          "updatedAt": "2020-07-29T07:47:55Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Yeah, the idea of this sequence of issues (#366, #367, #368, #374) was to pull apart the multiple features being addressed in #336.\r\n\r\nAs you can see with #369 and #376, I've begun posting PRs to address these smaller issues, drawing on the work done in #336 and adding details / refinements that were missing.  Would it be a sensible split to cover #366 and #367 with those, and update #336 to cover #368 and #374?",
          "createdAt": "2020-07-29T14:02:06Z",
          "updatedAt": "2020-07-29T14:02:06Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed by #336 ",
          "createdAt": "2020-10-19T14:28:02Z",
          "updatedAt": "2020-10-19T14:28:02Z"
        }
      ]
    },
    {
      "number": 373,
      "id": "MDU6SXNzdWU2NjU5NTgyMzQ=",
      "title": "Address DoS by malicious insiders",
      "url": "https://github.com/mlswg/mls-protocol/issues/373",
      "state": "CLOSED",
      "author": "tomtau",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "enhancement",
        "editorial",
        "discussion"
      ],
      "body": "https://github.com/mlswg/mls-protocol/issues/21\r\n\r\nIn the current protocol draft:\r\n```\r\n<!-- OPEN ISSUE: It is not possible for the recipient of a handshake\r\nmessage to verify that ratchet tree information in the message is\r\naccurate, because each node can only compute the secret and private\r\nkey for nodes in its direct path.  This creates the possibility\r\nthat a malicious participant could cause a denial of service by sending a\r\nhandshake message with invalid values for public keys in the ratchet\r\ntree. -->\r\n```\r\n\r\nUnless I overlooked it, the current draft seems to be also missing a \"simple\" DoS case where a handshake message could omit / malform some `DirectPathNode` (e.g. by having an empty ciphertext or invalid kem_output) -- this should be easily detectable (either by members themselves or if handshake messages are transmitted as MLSPlaintext, the delivery service could reject that).\r\n\r\nFor that originally discussed case, I guess the sketched out solution with a \"Nack\" message containing a DLEQ proof could work. Besides the drawbacks described there, one will also need to extend HPKE definitions to allow for this \"directly decrypt from the revealed shared secret\" use case. ",
      "createdAt": "2020-07-27T04:04:21Z",
      "updatedAt": "2020-10-20T15:17:11Z",
      "closedAt": "2020-10-20T15:17:11Z",
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "You're correct that there is a simpler DoS case where the sender could simply send a malformed `DirectPathNode`.  It shares with the DoS described that it is only detectable by affected nodes.   And I think that those two together cover the DoS possibilities, since it covers the two things that can be chosen in Commit.\r\n\r\nAs far as Nack/DLEQ -- I'm not sure what you have in mind there.  It seems like you would want zero-knowledge proofs for two relationships between HPKE ciphertexts: (1) that two ciphertexts are encryptions of the same value under two different public keys, and (2) that a parent ciphertext is an encryption of the parent node secret, and the child ciphertext is an encryption of the child node secret.  It's not clear that there are solutions for either of these.\r\n\r\nWhat we can do though, is make sure that the Security Considerations cover these risks.  I would propose focusing on documenting the risk rather than fixing it.\r\n",
          "createdAt": "2020-07-28T18:10:12Z",
          "updatedAt": "2020-07-28T18:10:12Z"
        },
        {
          "author": "tomtau",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> It shares with the DoS described that it is only detectable by affected nodes.\r\n\r\nFor that simpler case, it can be detected by other nodes by doing extra checks (e.g. checking all `DirectPathNode` cipher text lengths or public key formats match what one would expect in a particular ciphersuite).\r\n\r\n> As far as Nack/DLEQ -- I'm not sure what you have in mind there.\r\n\r\nI was referring to the final comments here: https://github.com/mlswg/mls-protocol/issues/21#issuecomment-455392023\r\nSo, the goal won't be to prevent malicious insiders, but allow affected nodes to report that they couldn't process Commit by revealing the corresponding ephemeral key. With HPKE / current draft, it may be:\r\n- for malformed path secrets, affected nodes reveal `dh` + `DLEQ(dh:kem_output :: node_public_key:G)`\r\n- others check DLEQ; then using `dh` compute `zz` for `SetupBaseR` and can go ahead to check the path secrets (either the ciphertext is malformed or the public keys derived from secrets don't match the received public keys in Commit)",
          "createdAt": "2020-07-29T01:58:01Z",
          "updatedAt": "2020-07-29T01:58:01Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Discussed on virtual interim 2020-10-20: Closing pending a more detailed proposal.",
          "createdAt": "2020-10-20T15:17:11Z",
          "updatedAt": "2020-10-20T15:17:11Z"
        }
      ]
    },
    {
      "number": 374,
      "id": "MDU6SXNzdWU2NjY2MjY5OTM=",
      "title": "Derive an \"authentication secret\"",
      "url": "https://github.com/mlswg/mls-protocol/issues/374",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "functionality"
      ],
      "body": "[This issue is part of a feature breakdown based on #336]\r\n\r\nAs noted in #336, it can be useful for members of the group to have a value they can compare to verify that they have the same view of the state of the group, similar to \"short authentication strings\" in [ZRTP](https://tools.ietf.org/html/rfc6189#section-7) or [TLS](https://tools.ietf.org/id/draft-miers-tls-sas-00.html) or \"safety numbers\" in [Signal](https://support.signal.org/hc/en-us/articles/360007060632-What-is-a-safety-number-and-why-do-I-see-that-it-changed-) and related protocols.\r\n\r\nIn MLS, values derived from the epoch secret via Derive-Secret can be used as confirmations of the relevant state, including the roster, the contents of the tree, and the transcript.  So at a cryptographic level, this should only require deriving an additional secret from the key schedule (as in #336).  We should expand on the text in #336 for how this secret is used and what authentication guarantees it provides.",
      "createdAt": "2020-07-27T22:36:40Z",
      "updatedAt": "2020-10-19T14:26:54Z",
      "closedAt": "2020-10-19T14:26:54Z",
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed by #336 and #419 ",
          "createdAt": "2020-10-19T14:26:54Z",
          "updatedAt": "2020-10-19T14:26:54Z"
        }
      ]
    },
    {
      "number": 383,
      "id": "MDU6SXNzdWU2NzIzNTE3MzA=",
      "title": "Enable Commit to cover new proposal types",
      "url": "https://github.com/mlswg/mls-protocol/issues/383",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "In principle, the set of ProposalType values is extensible.  But with the current Commit syntax, there is no way for a Commit to reference a Proposal with a type other than Add/Update/Remove.  We could enable this by adding a field to the commit that would carry such references:\r\n\r\n```\r\nstruct {\r\n    ProposalID updates<0..2^32-1>;\r\n    ProposalID removes<0..2^32-1>;\r\n    ProposalID adds<0..2^32-1>;\r\n    ProposalID others<0..2^32-1>;    // <------\r\n\r\n    optional<DirectPath> path;\r\n} Commit;\r\n```\r\n\r\nHowever, if other proposal types had sequencing requirements, they would not get the benefit of explicit, separate grouping and ordering as is done for the current proposal types.\r\n\r\nIf we don't extend the Commit in this way, we should add some explanatory text to clarify that new proposal types require an extension that changes the format of the Commit message.",
      "createdAt": "2020-08-03T21:24:38Z",
      "updatedAt": "2020-08-25T19:50:20Z",
      "closedAt": "2020-08-25T19:50:20Z",
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Personally, I lean toward the \"do nothing\" option here.  If we take the view that proposals should describe modifications to the tree (other actions being signaled in [Commit extensions](https://github.com/mlswg/mls-protocol/issues/366)), then Add, Update, and Remove are pretty much the available atomic operations.  You could envision some minor variations (an Add with a specified location, say) or compositions (Resync = Remove+Add), but nothing is coming to my mind that would be important enough to merit the extra complexity.",
          "createdAt": "2020-08-03T21:28:30Z",
          "updatedAt": "2020-08-03T21:28:30Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed by #389 ",
          "createdAt": "2020-08-25T19:50:20Z",
          "updatedAt": "2020-08-25T19:50:20Z"
        }
      ]
    },
    {
      "number": 386,
      "id": "MDU6SXNzdWU2NzYxNzQ2OTk=",
      "title": "Remove remaning raw Hash or add hash function to ciphersuite",
      "url": "https://github.com/mlswg/mls-protocol/issues/386",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "In #364, we changed from using HKDF to using the KDF from HPKE, which I thought removed the need for the ciphersuite to specify a hash function. As a result, ciphersuites no longer needed to specify a hash.\r\n\r\nHowever, the transcript computations still have a raw `Hash()` invocation, not a KDF invocation.  So we need to either:\r\n\r\n1. Change the transcript hash computations to use the KDF, or\r\n2. Clarify that ciphersuites still specify a hash function (as before)",
      "createdAt": "2020-08-10T14:21:13Z",
      "updatedAt": "2020-08-11T19:18:11Z",
      "closedAt": "2020-08-11T19:18:11Z",
      "comments": [
        {
          "author": "ericcornelissen",
          "authorAssociation": "CONTRIBUTOR",
          "body": "What about the `Hash()` call in the [Exporters section](https://github.com/mlswg/mls-protocol/blob/d1d5f56a5d83781042d19c830497ab5aa104907f/draft-ietf-mls-protocol.md#exporters) and the \"hashes\" for [Tree Hashes](https://github.com/mlswg/mls-protocol/blob/d1d5f56a5d83781042d19c830497ab5aa104907f/draft-ietf-mls-protocol.md#tree-hashes)?",
          "createdAt": "2020-08-11T13:10:29Z",
          "updatedAt": "2020-08-11T13:10:29Z"
        }
      ]
    },
    {
      "number": 390,
      "id": "MDU6SXNzdWU2Nzc0NTI2NTM=",
      "title": "impossible to verify the group creation process for the joiner without knowing the random init_secret that the group creator used",
      "url": "https://github.com/mlswg/mls-protocol/issues/390",
      "state": "CLOSED",
      "author": "tomtau",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "https://github.com/mlswg/mls-protocol/pull/385#issuecomment-671949236",
      "createdAt": "2020-08-12T07:09:17Z",
      "updatedAt": "2020-08-18T14:50:20Z",
      "closedAt": "2020-08-18T14:50:20Z",
      "comments": []
    },
    {
      "number": 392,
      "id": "MDU6SXNzdWU2NzkxMTczNjM=",
      "title": "Is the path secret used as PRK when doing Kdf.Expand?",
      "url": "https://github.com/mlswg/mls-protocol/issues/392",
      "state": "CLOSED",
      "author": "yihuang",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "When evolving the ratchet tree, we'll do:\r\n```\r\npath_secret[n] = ExpandWithLabel(path_secret[n-1],\r\n                                   \"path\", \"\", KEM.Nsk)\r\n```\r\nDoes the `path_secret[n-1]` used as the `PRK` directly?\r\n```\r\n   HKDF-Expand(PRK, info, L) -> OKM\r\n```\r\nIf that's the case, does that mean ` KEM.Nsk` should be `>= Kdf.Nh`?\r\n\r\nOr should we do an extract before the expand?",
      "createdAt": "2020-08-14T12:14:46Z",
      "updatedAt": "2020-09-03T00:30:22Z",
      "closedAt": "2020-09-03T00:30:22Z",
      "comments": [
        {
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "body": "Yes, `path_secret[n-1]` is used as the PRK directly. Why does `Kdf.Nh` matter?",
          "createdAt": "2020-08-18T16:11:36Z",
          "updatedAt": "2020-08-18T16:11:36Z"
        },
        {
          "author": "yihuang",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Because in https://tools.ietf.org/html/rfc5869, there's:\r\n```\r\n   HKDF-Expand(PRK, info, L) -> OKM\r\n...\r\n   Inputs:\r\n      PRK      a pseudorandom key of at least HashLen octets\r\n               (usually, the output from the extract step)\r\n```\r\n\r\nAnd length of `path_secret` is `KEM.Nsk`, so `KEM.Nsk >= Kdf.Nh`? unless we do an extract before expand?",
          "createdAt": "2020-08-18T16:52:27Z",
          "updatedAt": "2020-08-18T16:52:27Z"
        },
        {
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "body": "I believe the PRK is just used as an HMAC key in HKDF, so I don't think that's a hard requirement",
          "createdAt": "2020-08-18T17:43:38Z",
          "updatedAt": "2020-08-18T17:43:38Z"
        },
        {
          "author": "yihuang",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> I believe the PRK is just used as an HMAC key in HKDF, so I don't think that's a hard requirement\r\n\r\nI'm not sure how hard the requirement is, the RFC didn't say it's a `SHOULD`, and [implementation added check on this](https://github.com/RustCrypto/KDFs/blob/master/hkdf/src/hkdf.rs#L128), so it'll cause confusion, or even panic program.",
          "createdAt": "2020-08-19T03:35:48Z",
          "updatedAt": "2020-08-19T03:37:18Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "@yihuang I think you're right here.  We should probably change `KEM.Nsk` to `KDF.Nh`.",
          "createdAt": "2020-08-25T18:13:18Z",
          "updatedAt": "2020-08-25T18:13:18Z"
        }
      ]
    },
    {
      "number": 405,
      "id": "MDU6SXNzdWU3MDU1NDMyMDc=",
      "title": "Mandatory Extensions vs. Fields",
      "url": "https://github.com/mlswg/mls-protocol/issues/405",
      "state": "CLOSED",
      "author": "kkohbrok",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Why are extensions that MUST be present in an instance of a struct (e.g. `capabilities` and `lifetime` in a `KeyPackage`) not just fields in that struct?\r\n\r\nShouldn't `extensions` be used for custom extensions or maybe optional parts of the struct? (Although those should probably be `optional` fields, I would think.)",
      "createdAt": "2020-09-21T12:16:00Z",
      "updatedAt": "2020-09-28T13:31:10Z",
      "closedAt": "2020-09-28T13:31:09Z",
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "I don't have a strong feeling on this.  The best argument that comes to my mind is that it makes changes in the future a bit easier, since adding/removing extensions is a bit easier than changing the base struct.  The [TLS 1.3 ClientHello](https://tools.ietf.org/html/rfc8446#section-4.1.2), for example, has fields like `legacy_version` that have been deprecated because they found a better way to do things like version negotiation.  \r\n\r\n@Bren2010 @raphaelrobert maybe you guys have opinions?",
          "createdAt": "2020-09-22T17:43:39Z",
          "updatedAt": "2020-09-22T17:43:39Z"
        },
        {
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "body": "I believe this has been brought up before, but you said you wanted them to be extensions because it forces people to actually implement the extensibility logic. I would like them to be fields but that was a good enough argument that I left it alone",
          "createdAt": "2020-09-22T20:40:27Z",
          "updatedAt": "2020-09-22T20:40:27Z"
        },
        {
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thanks for elaborating on this. I also prefer fields, but given those arguments, I'm happy to have them as extensions as well.",
          "createdAt": "2020-09-23T06:02:30Z",
          "updatedAt": "2020-09-23T06:02:30Z"
        }
      ]
    },
    {
      "number": 409,
      "id": "MDU6SXNzdWU3MTQ3MjAxMTY=",
      "title": "Draft structure/Editorial Changes",
      "url": "https://github.com/mlswg/mls-protocol/issues/409",
      "state": "CLOSED",
      "author": "franziskuskiefer",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "This issue accompanies the e-mail [1] pointing out editorial issues with the draft and suggesting improvements.\r\n\r\nTL;DR: I don't think the draft currently is what is needed to implement MLS. It needs an editorial overhaul with a better structure.\r\n\r\n[1] https://mailarchive.ietf.org/arch/msg/mls/ZOy80Yp5bRhoM8fsQMGVwmFFEzY/",
      "createdAt": "2020-10-05T10:31:58Z",
      "updatedAt": "2022-02-01T15:14:03Z",
      "closedAt": "2022-02-01T15:14:03Z",
      "comments": [
        {
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "body": "If we want an implementation document, which is a legitimate ask, we should write an implementation document.",
          "createdAt": "2020-10-05T11:14:19Z",
          "updatedAt": "2020-10-05T11:14:19Z"
        },
        {
          "author": "franziskuskiefer",
          "authorAssociation": "CONTRIBUTOR",
          "body": "What's the purpose of the document if not for implementation?\r\nIn order for this draft to become an RFC it needs implementations. I don't see a way this will happen with the draft as is.",
          "createdAt": "2020-10-05T11:31:04Z",
          "updatedAt": "2020-10-05T11:31:04Z"
        },
        {
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "body": "Specifying a functional behavior and providing a guide for implementation are two very different things.\r\n\r\nRe: what you suggested in your email: Internal representations of the tree, the way you number the indices, how you implement them or the fact that you store some hashes in the nodes are completely irrelevant to this document.\r\nAlso, there is nothing formal about this appendix. \r\n\r\nOn the other hand the information you need from this document is how to perform **computations** : things such as providing the arguments to the node_encap/node_decap functions which are required to generate a correct payload and a standard way to serialize abstract structures... etc.",
          "createdAt": "2020-10-05T12:10:26Z",
          "updatedAt": "2020-10-05T12:10:26Z"
        },
        {
          "author": "franziskuskiefer",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> Specifying a functional behavior and providing a guide for implementation are two very different things.\r\n\r\nRight, the document is doing neither right now.",
          "createdAt": "2020-10-05T12:58:11Z",
          "updatedAt": "2020-10-05T12:58:11Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "We have two separable issues here: We need better explanation of the overall structure of the protocol (as in Franziskus' email), and we could rearrange the text to be clearer.\r\n\r\nFor the first, I have filed #520.  That provides a pretty complete overview of the protocol, covering all of the syntax and high-level operations.\r\n\r\nFor the second, we should do a second PR after the other outstanding PRs have landed.  Looking at the table of contents, I would propose we refactor in the following way:\r\n\r\n* For top-level sections: \r\n    * Move `# Ratchet Trees` to after `# Cryptographic Objects` and `# Key Packages`\r\n* For subsections:\r\n    * Move the tree-relevant subsections of `# Key Packages` into `# Ratchet Trees` \u2014 including `## Parent Hash`, `## Tree Hashes`, and `## Update Paths`\r\n    * Split `## Group State` into two:\r\n        * Put the GroupContext definition part in a new subsection `## Group Context` under `# Cryptographic Objects` \r\n        * Put the transcript updating part in a new subsection `## Updating the Transcript` under `# Key Schedule` ",
          "createdAt": "2021-12-01T17:13:38Z",
          "updatedAt": "2021-12-01T17:13:38Z"
        },
        {
          "author": "rohan-wire",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I have an alternative organization of the first sections:\r\n* Add the one sentence definition of `node` before the last paragraph of `##Tree Computation Terminology`\r\n* Swap `##Ratchet Tree Nodes` and `##Views of a Ratchet Tree`\r\n\r\nThis seems to all flow nicely with very few forward references.\r\n\r\nA more radical rewrite might \r\n* Move `#Group Evolution` forward before `#Cryptographic Objects`\r\nbut I don't think that is necessary.\r\n\r\nI do like Richard's proposal to split `## Group State`\r\n\r\n",
          "createdAt": "2022-01-27T18:45:49Z",
          "updatedAt": "2022-01-27T18:45:49Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "I'm considering this fixed after the series of reorg PRs that @rohan-wire @Bren2010 and I just finished.  \r\n\r\n#565 #566 #567 #568 #569 #570 #571 \r\n",
          "createdAt": "2022-02-01T15:14:03Z",
          "updatedAt": "2022-02-01T15:14:03Z"
        }
      ]
    },
    {
      "number": 410,
      "id": "MDU6SXNzdWU3MTQ3NjEwMzM=",
      "title": "Welcome message delivery",
      "url": "https://github.com/mlswg/mls-protocol/issues/410",
      "state": "CLOSED",
      "author": "franziskuskiefer",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "It is currently unclear how welcome messages are supposed to be delivered. They should be sent to the clients directly without sending them to the group. But welcome messages as described in `11.2.1. Welcoming New Members` have no information about recipients. Neither are they framed in a way that would allow delivery.\r\nEither the `Welcome` message should get a recipient field, or it should get framed as an `MLSPlaintext` and sent to the group instead.",
      "createdAt": "2020-10-05T11:34:47Z",
      "updatedAt": "2021-08-19T23:26:04Z",
      "closedAt": "2021-08-19T23:26:04Z",
      "comments": [
        {
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "body": "The encoded `Welcome` struct is what's sent to the new user. The exact method of delivery is up to the application, but you have the user's identity in their credential which should be enough",
          "createdAt": "2020-10-05T20:56:31Z",
          "updatedAt": "2020-10-05T20:56:31Z"
        },
        {
          "author": "franziskuskiefer",
          "authorAssociation": "CONTRIBUTOR",
          "body": "If message delivery and franking is something that's supposed to be left to the implementation, it should be removed for `MLSPlaintext` and `MLSCiphertext` as well. In fact description of the delivery service should be dropped all together from the architecture doc as well then.\r\nBut I don't think that's what you want. What's currently missing is a way to deliver `Welcome` messages only. All other messages are fine as far as I can see.\r\nSo if message delivery is something that should be described, as it is for all other messages, it should be done for `Welcome` messages as well.",
          "createdAt": "2020-10-06T06:45:39Z",
          "updatedAt": "2020-10-06T06:45:39Z"
        },
        {
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "body": "What you mean when you say there's no way to deliver Welcome messages? You just send the encoded struct to the new user.",
          "createdAt": "2020-10-06T15:04:10Z",
          "updatedAt": "2020-10-06T15:04:10Z"
        },
        {
          "author": "franziskuskiefer",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> You just send the encoded struct to the new user.\r\n\r\nHow is the new user identified and how is the message supposed to get there? There's no real definition of users.",
          "createdAt": "2020-10-07T07:11:58Z",
          "updatedAt": "2020-10-07T07:11:58Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "You're correct that the Welcome message only needs to be sent to the new members, though of course there's no security impact if it is also broadcast to the group.\r\n\r\nI would argue that this is a problem for the DS to solve, for example by having the Welcome sender specify the routing identifiers for the recipients of the Welcome.  There's no need for these identifiers to be at all tied to the rest of the protocol, so there's no need for them to go in MLS; they can just be part of whatever framing is used to send MLS messages.\r\n\r\nAll that said, this could be a good topic for an issue on the architecture doc.  Basically, we want the DS to provide the following services:\r\n\r\n1. Routing of KeyPackages from (potential) joiners to group members who might add them\r\n2. Unicast/multicast routing of Welcome back to joiner(s)\r\n3. Multicast routing of Proposals/Commits to the group\r\n",
          "createdAt": "2020-10-07T12:38:23Z",
          "updatedAt": "2020-10-07T12:38:23Z"
        },
        {
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "body": "> How is the new user identified and how is the message supposed to get there? There's no real definition of users.\r\n\r\nWe have the new member's KeyPackage which contains a Credential which contains their identity.",
          "createdAt": "2020-10-07T15:17:42Z",
          "updatedAt": "2020-10-07T15:17:42Z"
        }
      ]
    },
    {
      "number": 411,
      "id": "MDU6SXNzdWU3MTYwODc0ODk=",
      "title": "Track Expected Types of Deployments",
      "url": "https://github.com/mlswg/mls-protocol/issues/411",
      "state": "CLOSED",
      "author": "Bren2010",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This ticket is meant to collect all of the use-cases and types of deployments that we support, or types of deployments that we've chosen not to support. In the future, I'd like us to take some time to make a sorta taxonomy of deployments -- think through the architecture / protocol decisions you need to achieve each use-case, and the security properties you get.\r\n\r\nI'll start with a few:\r\n\r\n- **Centralized Deployment:** Optimally simple client-side implementation.\r\n  - Authentication Service: Endpoint run by service provider. Either trusted to act correctly or built with transparency technology.\r\n  - Delivery Service: Endpoint run by service provider. Ensures a linear ordering of Commits.\r\n  - Proposals and Commits are left as plaintext.\r\n  - *Properties:*\r\n    - The DS knows of all groups and which members are in each group, as well as the value of the group's ratchet tree.\r\n    - Since the DS ensures a linear ordering of Commits, members can process Commits in the naive way.\r\n    - The DS must process messages and maintain a copy of the ratchet tree.\r\n    - New members can get a copy of a group's ratchet tree from the DS, meaning Welcome messages can be smaller.\r\n    - Members are aware of all the other members in each group.\r\n- **Broadcast Channel Deployment:** Server-side implementation that doesn't require strong coordination.\r\n  - Authentication Service: Endpoint run by service provider. Either trusted to act correctly or built with transparency technology.\r\n  - Delivery Service: Broadcast channel that sends new messages to all group members indiscriminately, combined with a separate mechanism for KeyPackage distribution.\r\n  - Proposals and Commits are encrypted.\r\n  - *Properties:*\r\n    - The DS can infer which groups exist and which members are in each group, but this isn't required for it to operate. It does not know the ratchet tree.\r\n    - Members must use a consensus protocol to decide on which Commit to accept if multiple are sent at once. This may imply forking or reverting to a previous state.\r\n    - Since the ratchet tree isn't stored centrally, Welcome messages must be larger to accommodate the serialized tree.\r\n    - Members are aware of all the other members in each group.\r\n- **Anonymous Deployment:** Attempts to hide the membership of each group but does not attempt to hide the number of groups / number of members in each group.\r\n  - Authentication Service: Endpoint run by service provider. Either trusted to act correctly or built with transparency technology. Must be accessed anonymously.\r\n  - Delivery Service: Oblivious to *both* who writes a message to a given group, and who read that message. An onion network could be used, as long as a new circuit is created for each message. Ensures a linear ordering of Commits.\r\n  - Proposals and Commits are encrypted. No additional framing is used beyond what the onion network dictates.\r\n  - *Properties:*\r\n    - The DS knows of all groups and how many members are in each group. It does not know the ratchet tree or the identities of group members.\r\n    - Since the DS ensures a linear ordering of Commits, members can process Commits in the naive way.\r\n    - Since the ratchet tree isn't stored centrally, Welcome messages must be larger to accommodate the serialized tree.\r\n    - Members are aware of all the other members in each group.\r\n\r\nSome that I need to think more about:\r\n\r\n- **Hidden-Membership Deployment:** Allows groups where group members are unable to determine the identity of other members. All communication is either from/to the group creator.\r\n- **Deniable Deployment:** Avoids signing messages sent to a group with a binding private key.\r\n- **Federated Deployment:** Allows the users of multiple cooperating AS and DS providers to inter-communicate.\r\n",
      "createdAt": "2020-10-06T23:29:26Z",
      "updatedAt": "2020-10-19T14:31:44Z",
      "closedAt": "2020-10-19T14:31:44Z",
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "This seems worth thinking about, but more in the context of the architecture document than the protocol.",
          "createdAt": "2020-10-07T12:39:12Z",
          "updatedAt": "2020-10-07T12:39:12Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing this as a protocol issue, feel free to re-file on the architecture.",
          "createdAt": "2020-10-19T14:31:44Z",
          "updatedAt": "2020-10-19T14:31:44Z"
        }
      ]
    },
    {
      "number": 418,
      "id": "MDU6SXNzdWU3MTkyNzgzNDM=",
      "title": "Reuse guard mechanism is described in wrong section",
      "url": "https://github.com/mlswg/mls-protocol/issues/418",
      "state": "CLOSED",
      "author": "raphaelrobert",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "It is in \"Content Encryption\" but should be in \"Sender Data Encryption\".",
      "createdAt": "2020-10-12T10:48:38Z",
      "updatedAt": "2020-10-16T14:04:59Z",
      "closedAt": "2020-10-16T14:04:59Z",
      "comments": []
    },
    {
      "number": 426,
      "id": "MDU6SXNzdWU3MjUyNTc1NzE=",
      "title": "Adopt TLS-Style Key Schedule",
      "url": "https://github.com/mlswg/mls-protocol/issues/426",
      "state": "CLOSED",
      "author": "kkohbrok",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Extracting from the `GroupContext_[n]` doesn't really make sense from a provable security standpoint. Instead, we should go with the TLS approach and use the `GroupContext_[n]` as context in a `KDF.Derive` step. This could be an extra step before we derive the individual keys off the key schedule or we include it in each individual derivation operation.",
      "createdAt": "2020-10-20T06:44:12Z",
      "updatedAt": "2020-10-20T15:41:44Z",
      "closedAt": "2020-10-20T15:41:44Z",
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Discussed on virtual interim:\r\n\r\n```\r\nBEFORE:\r\n                   Derive-Secret(., \"epoch\") = ExpandWithLabel(Secret, \"epoch\", \"\", KDF.Nh)\r\n                         |\r\n                         V\r\n GroupContext_[n] -> KDF.Extract = epoch_secret\r\n                         |\r\n                         +--> Derive-Secret(., <label>)\r\n                         |    = <secret>\r\n\r\nAFTER:\r\n                   ExpandWithLabel(., \"epoch\", GroupContext_[n], KDF.Nh)\r\n                         |\r\n                         V\r\n                    epoch_secret\r\n                         |\r\n                         +--> Derive-Secret(., <label>)\r\n                         |    = <secret>\r\n```",
          "createdAt": "2020-10-20T15:15:51Z",
          "updatedAt": "2020-10-20T15:15:51Z"
        },
        {
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Solved by merging #427 . Closing.",
          "createdAt": "2020-10-20T15:41:44Z",
          "updatedAt": "2020-10-20T15:41:44Z"
        }
      ]
    },
    {
      "number": 432,
      "id": "MDU6SXNzdWU3Mjc5ODI3OTU=",
      "title": "Ensure no ambiguity between leaf and node indices",
      "url": "https://github.com/mlswg/mls-protocol/issues/432",
      "state": "CLOSED",
      "author": "kkohbrok",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "We currently distinguish between leaf indices and node indices, where node indices are a straight-forward index in the array representing a ratcheting tree and leaf indices index what (I think) used be called the roster, an array just containing the members. However, the roster was removed and instead, we always use the ratcheting tree array when referring to both nodes and leaves. As a result, whenever we use a leaf index, we have to translate it to a node index when actually indexing the array. I don't see a reason for this added complexity and propose only use node indices.\r\n\r\nThis was already discussed a bit in #431 , where @bifurcation pointed out that leaf indices make sure that a Remove only ever references a leaf. I think having a little check here that the index actually refers to a leaf is preferable over having to translate back and forth in many other places. Note, that we have to check anyway if the index in Remove is within the bounds of the tree, regardless of it being a leaf or a node index.\r\n\r\nI'm happy to provide a PR if this is something we want to do.",
      "createdAt": "2020-10-23T07:25:18Z",
      "updatedAt": "2021-10-11T19:11:21Z",
      "closedAt": "2021-10-11T19:11:21Z",
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "When I mentioned Remove in the context of #431, that was only an initial example.  Here's a more fulsome list of where leaf indices are used:\r\n\r\n* `Remove.removed`\r\n* `ParentNode.unmerged_leaves`\r\n* `MLSPlaintext.Sender.sender`\r\n* `GroupInfo.signer_index`\r\n\r\nAll of those are cases where a node index would be nonsensical.  So while even with a leaf index, you still have to bounds-check, you're basically asking for us to allow more nonsensical cases to be expressible in the syntax.\r\n\r\nAs far as comprehensibility / implementability: The difference between node indices and leaf indices is clearly laid out in the [tree terminology section](https://github.com/mlswg/mls-protocol/blob/master/draft-ietf-mls-protocol.md#tree-computation-terminology), and AFAICT, all of the references to indices are clear about which one they refer to.  \r\n\r\nThis distinction is a good one for implementors to have in mind, and not just to simplify parsing / input validation on messages as above.  There are lots of internal methods that only make sense to refer to leaves as well.  For example, a TreeKEM implementation internal to an MLS implementation will need to know the index of the caller of `TreeKEM.encap()` so that it can make the right UpdatePath.  Here again, providing a node index is nonsensical.  So implementations will likely end up needing to differentiate leaves from nodes *anyway*.\r\n\r\nNet of all that, I propose closing this with no action.\r\n",
          "createdAt": "2020-10-23T17:49:15Z",
          "updatedAt": "2020-10-23T17:49:15Z"
        },
        {
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Fair enough. Closing this, then.",
          "createdAt": "2020-10-25T06:49:23Z",
          "updatedAt": "2020-10-25T06:49:23Z"
        },
        {
          "author": "franziskuskiefer",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I suggest to re-open this in order to remove the concept of lead indices from the spec.\r\nWe'll do so in OpenMLS in https://github.com/openmls/openmls/issues/356 because it's a footgun causing a ton of issues.\r\n\r\nIf you really want to keep the concept in the spec, it must be made clear when a leaf index and when a node index is used. Taking the text for remove proposals for example.\r\n\r\n> A Remove proposal requests that the client at a specified index in the tree be removed from the group.\r\n\r\nThis sounds like the index is a node index.\r\n\r\n> Replace the leaf node at position removed with a blank node\r\n\r\nThis sounds like it could be a leaf index.\r\n\r\nBut it's not defined either way.\r\n\r\nSo your claim @bifurcation that \"all of the references to indices are clear about which one they refer to.\" is not true.\r\n\r\n> This distinction is a good one for implementors to have in mind\r\n\r\nI totally agree with this. But the current concept introduces more issues than it actually solves. So this definitely needs work, either by removing the concept (which I'd prefer) or actually making clear which index is used.\r\nIn my opinion the tree should only be indexed by one type of indices to reduce ambiguity and the potential for bugs. This way we can reduce the places of conversion while still making it clear to implementors that there is a distinction between the two.",
          "createdAt": "2021-04-12T07:53:33Z",
          "updatedAt": "2021-04-12T07:53:33Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "I'm happy to clean up references, but I would like to avoid explicitly allowing invalid requests.  You shouldn't be able to ask to remove node 5, or say you signed with node 7.  You risk bugs either way; in the \"all indices are node indices\" case you just have to catch them at runtime, as opposed to using the right type at build time.  So I continue to believe this is better handled with type systems.\r\n\r\nNonetheless, I'll do a review and try to clean up any ambiguous cases.",
          "createdAt": "2021-08-10T23:54:20Z",
          "updatedAt": "2021-08-10T23:54:20Z"
        }
      ]
    },
    {
      "number": 440,
      "id": "MDU6SXNzdWU3NDU4MzgxNjg=",
      "title": "Fix the protocol overview section",
      "url": "https://github.com/mlswg/mls-protocol/issues/440",
      "state": "CLOSED",
      "author": "raphaelrobert",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "Currently section \"4. Protocol Overview\" states:\r\n\r\n`Upon receiving the Welcome message and the corresponding Commit, the new member will be able to read and send new messages to the group`\r\n\r\nI think this is a legacy from before the propose/commit scheme and got carried over. New members no longer need the Commit.\r\nThe subsequent diagram also needs to be adapted.",
      "createdAt": "2020-11-18T17:03:31Z",
      "updatedAt": "2021-03-04T21:33:44Z",
      "closedAt": "2021-03-04T21:33:44Z",
      "comments": []
    },
    {
      "number": 443,
      "id": "MDU6SXNzdWU3NDgzNDU4NDc=",
      "title": "External commit for resync used with PSK",
      "url": "https://github.com/mlswg/mls-protocol/issues/443",
      "state": "CLOSED",
      "author": "br-hale",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "A good point was raised by Jonathon Hoyland during the MLS IETF 109 meeting regarding possible concerns in using external commits for resync, particularly in the case of Alice adding/removing herself. Richard noted that this is a feature in the case that Alice is no longer synchronized with the group and therefore can use an external commit to add herself back in, removing the previous version.\r\n \r\nAs opposed to any newcomer joining with an external commit, the case of Alice re-joining presents a potential security issue. Namely, as currently specified (in my reading of the draft), an existing group member, Bob, has no means to distinguish between the following cases:\r\n\r\n1) Alice needs to resync and therefore performs an external commit and removes her prior version.\r\n2) Alice\u2019s signature keys are compromised (it is not necessary for the adversary to compromise any group state). The adversary performs an external commit in Alice\u2019s name, and then removes her prior version and impersonates her to the group.\r\n \r\nOne might hope that Alice notices that she is removed and communicates this to the group members OOB, but it is also possible that that she assumes some other reason for the removal, is offline, or simply is not active enough to take action for a fairly long compromise window. Even if she tries to use an external commit to get back into the group and then removes the adversary-as-Alice, there is no means for other group members distinguish the real Alice from the adversary-as-Alice and the process could be circular (until new valid identity keys are issued).\r\n \r\nWhile a newcomer is a fresh source to be trusted or not, Alice has been \u201chealing\u201d along with the group and the above option (2) allows the adversary to bypass all of that.\r\n \r\nThe source of the problem is that when Alice re-syncs, she is not providing any validation of being the same/previous identity, so it is easy for other group members to accept that nothing more than a resync has taken place. Thus, a fairly straightforward solution is to require PSK use in cases where an external commit is used for resync. By enabling a PSK derived from a previous epoch during which Alice was part of the group to be injected with the external commit, Alice provides some proof of prior group membership and we avoid the total reset.\r\n\r\nThis is not quite PCS in that the attacker is active following compromise, but it is a linked case. As such it is important that a conscious decision is made regarding this (either as a slight change before the feature-freeze in line with the other changes that the editors have proposed, or as a working group decision to close the issue as out-of-scope).",
      "createdAt": "2020-11-22T20:44:14Z",
      "updatedAt": "2021-10-11T19:25:36Z",
      "closedAt": "2021-10-11T19:25:36Z",
      "comments": [
        {
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "body": "Just to think this with what has been discussed on the mailing list: #439 will give members a way to do the distinction mentioned above.",
          "createdAt": "2021-03-02T15:16:07Z",
          "updatedAt": "2021-03-02T15:16:07Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "@raphaelrobert - I don't think that's actually the case; it would only allow the members a way to recognize that Alice is replacing herself.\r\n\r\nI think the right answer here is what Britta suggests, plus a little: We should enumerate a few specific constraints on the proposals that can be carried inline in an external Commit:\r\n* There MUST be an Add proposal for the signer\r\n* There MUST be an ExternalInit proposal\r\n* There MUST NOT be any Update proposals\r\n* If a Remove proposal is present, then:\r\n    * The identity of the removed node MUST be the same as the identity in the Add KeyPackage\r\n    * There MUST be a PSK proposal of type `ReInit`, referencing an earlier epoch of this group\r\n  \r\nIn other words, you can commit things that existing members sent (by reference), but the joiner-initiated proposals must only (a) add the joiner, and (b) optionally remove the old instance of the joiner, with the PSK assurance @br-hale suggests.",
          "createdAt": "2021-08-11T00:17:48Z",
          "updatedAt": "2021-08-11T00:18:49Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Coming back to this after a few weeks, I'm actually not sure this is a problem worth solving.  The attack scenario (2) exists whether or not a member can resync without proving prior membership.  As long as (a) the group allows external Commits, and (b) the group does not require a new appearance of an existing identity to present a PSK from an earlier epoch, then the attacker can still do the attack by first joining, and then removing the old Alice.  The only difference in the case where the external commit also does the resync is that the two happen together.\r\n\r\nIt also doesn't seem unreasonable to regard the ability to resync from loss of all state except the signature key as a feature, not a bug.  Of course, that position would entail accepting that compromise of signature keys would be sufficient to impersonate the user, but that doesn't seem all that surprising, at least to me.\r\n\r\nSo this seems like a question of group policy to me.  Either the group requires ReInit PSKs on resync (and you can't recover from all-but-signature-key state loss), or it doesn't (and signature keys are the last resort).\r\n\r\nThis can be documented in the Security Considerations, in a new PR.  As far as #481, I think it's probably still worth adding the precision, but I would change the PSK part to MAY if not remove it entirely.",
          "createdAt": "2021-09-30T21:51:43Z",
          "updatedAt": "2021-09-30T21:51:43Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "There is also a practical issue with using PSKs to prove past membership, in that if there have been joins since Alice lost state, the new joiners won't have the PSK.  This is of course a general issue with the proof-of-past-membership PSK, but it is particularly salient here.",
          "createdAt": "2021-10-01T14:03:38Z",
          "updatedAt": "2021-10-01T14:03:38Z"
        }
      ]
    },
    {
      "number": 447,
      "id": "MDU6SXNzdWU3NjUyMzMyNzg=",
      "title": "Motivate Ratchet Trees",
      "url": "https://github.com/mlswg/mls-protocol/issues/447",
      "state": "CLOSED",
      "author": "yaronf",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "The top of Sec. 5 has exactly one sentence before diving into tree terminology. Please explain at a high level what is the motivation for this structure and maybe how it fits into the rest of the protocol.",
      "createdAt": "2020-12-13T09:57:39Z",
      "updatedAt": "2021-12-01T18:22:26Z",
      "closedAt": "2021-12-01T18:22:26Z",
      "comments": [
        {
          "author": "psyoptix",
          "authorAssociation": "CONTRIBUTOR",
          "body": "My 2 cents: Abstractly, a distributed cryptographic state (like the ratchet tree) consists of a set of secrets. Each user j knows some subset S(j) of those secrets. More generally a set of users U collectively knows secrets S(U). To get Post Compromise Security for the distributed state we need a way for each user j to re-sample all secrets in S(j) and distribute such that the following is true. Suppose an adversary knows secrets S(U) in the old crypto state for some set of users U. Then in the new state, after witnessing the distribution phase on the wire, the adversary only knows the secrets in S(U\\\\{i}).\r\n\r\nFor example:\r\n - Suppose I steal your secrets (i.e. you are user j and now i know S(j)). Now you re-sample & distribute. As a result I now know S(\\emptyset) = nothing at all. The session is secure again. \r\n - Suppose I steal the keys of users 2, 4 and 7. So i know S({2,4,7}). Then after 7 re-samples & distributes I only know S({2,4}). Once 2 and 4 also re-sample and distribute I know nothing and the session is secure again.\r\n\r\nIn a nutshell, the ratchet tree in MLS gives us a way to efficiently do this re-sampling & distribution for commit_secrets repeatedly, non-interactively and *efficiently*. That is by sending out a single, reasonably small packet. \r\n\r\nOf course, as the ratchet tree adds more secrets to MLS distributed state we then have to be able to re-sample & distribute those as well which the ratchet tree lets us do. But at the end of the day, its all about distributing new commit_secrets.",
          "createdAt": "2021-10-28T15:34:47Z",
          "updatedAt": "2021-10-28T18:33:51Z"
        },
        {
          "author": "yaronf",
          "authorAssociation": "NONE",
          "body": "LGTM. Thanks!",
          "createdAt": "2021-10-28T17:22:49Z",
          "updatedAt": "2021-10-28T17:22:49Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "@yaronf - I put my own spin on this in #513.  Let me know if that looks good to you!",
          "createdAt": "2021-11-19T22:07:16Z",
          "updatedAt": "2021-11-19T22:07:16Z"
        },
        {
          "author": "yaronf",
          "authorAssociation": "NONE",
          "body": "@bifurcation Absolutely. Thank you!",
          "createdAt": "2021-11-20T13:38:06Z",
          "updatedAt": "2021-11-20T13:38:06Z"
        }
      ]
    },
    {
      "number": 448,
      "id": "MDU6SXNzdWU3NjU1NTMwMDU=",
      "title": "Pin HPKE version",
      "url": "https://github.com/mlswg/mls-protocol/issues/448",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "editorial",
        "interoperability"
      ],
      "body": "@bifurcation points out that the HPKE version is not pinned. This is probably needed for interop. Version -07 should come sometime this week, so that seems like a perfectly fine version to use. I can send a PR when that version is cut.",
      "createdAt": "2020-12-13T17:35:39Z",
      "updatedAt": "2020-12-21T21:59:59Z",
      "closedAt": "2020-12-21T21:59:59Z",
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed by #449 ",
          "createdAt": "2020-12-21T21:59:59Z",
          "updatedAt": "2020-12-21T21:59:59Z"
        }
      ]
    },
    {
      "number": 457,
      "id": "MDU6SXNzdWU4MTczNzYxMjM=",
      "title": "Clarify ParentHash verification",
      "url": "https://github.com/mlswg/mls-protocol/issues/457",
      "state": "CLOSED",
      "author": "franziskuskiefer",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "The [parent hash verification](https://github.com/mlswg/mls-protocol/blob/master/draft-ietf-mls-protocol.md#verifying-parent-hashes) is currently not very well described. Depending on the reading it might also be wrong.\r\nIn particular, the condition `If R is a leaf node, the check fails`, if implemented as described makes it so that valid parent hashes are rejected. Take for example a simple tree with two leafs where the right leaf (node 2) sends a commit. In this case the other leaf will reject the parent hash because it fails when going down to the right leaf.\r\n\r\nThis might be a wrong interpretation of the described verification procedure but then the description needs updating.\r\nI suggest to add a more formal description of the parent hash generation and verification (e.g. pseudocode) to reduce ambiguity.",
      "createdAt": "2021-02-26T13:54:51Z",
      "updatedAt": "2021-08-11T07:54:44Z",
      "closedAt": "2021-08-11T07:54:44Z",
      "comments": [
        {
          "author": "psyoptix",
          "authorAssociation": "CONTRIBUTOR",
          "body": " I think that condition should read \"If R is a blank leaf node, the check fails\".",
          "createdAt": "2021-03-05T10:40:31Z",
          "updatedAt": "2021-03-05T10:40:31Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Agree with @psyoptix here; the [relevant code in MLSpp](https://github.com/cisco/mlspp/blob/main/src/treekem.cpp#L468) matches this interpretation.  So I think we just need to adjust that text.",
          "createdAt": "2021-08-11T00:00:12Z",
          "updatedAt": "2021-08-11T00:00:12Z"
        },
        {
          "author": "franziskuskiefer",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I agree, this was fixed in #460 ",
          "createdAt": "2021-08-11T07:54:44Z",
          "updatedAt": "2021-08-11T07:54:44Z"
        }
      ]
    },
    {
      "number": 459,
      "id": "MDU6SXNzdWU4MjI5MjY5NDI=",
      "title": "Trim tree after removal",
      "url": "https://github.com/mlswg/mls-protocol/issues/459",
      "state": "CLOSED",
      "author": "raphaelrobert",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Over time we lost the rule that the ratchet tree should also be trimmed after members have been removed (where it really makes sense), not only when members are added.",
      "createdAt": "2021-03-05T09:50:05Z",
      "updatedAt": "2021-08-10T23:48:02Z",
      "closedAt": "2021-08-10T23:48:02Z",
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "@suhasHere posted #461 to address this issue",
          "createdAt": "2021-03-08T00:04:59Z",
          "updatedAt": "2021-03-08T00:04:59Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed in #461  - https://github.com/mlswg/mls-protocol/blob/main/draft-ietf-mls-protocol.md#remove",
          "createdAt": "2021-08-10T23:48:02Z",
          "updatedAt": "2021-08-10T23:48:02Z"
        }
      ]
    },
    {
      "number": 468,
      "id": "MDU6SXNzdWU4NzAwOTI3ODM=",
      "title": "Clarify relationship between Ratchet Tree Evolution, Group Creation, and Key Schedule",
      "url": "https://github.com/mlswg/mls-protocol/issues/468",
      "state": "CLOSED",
      "author": "knightcode",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "The terminology used in these sections is different, so that it's unclear if they're descriptions of the same operation with different levels of detail or entirely different operations performed at different times. I come in having read most of the original white paper, so that my intuition is that it's one operation performed against data stored in the tree structure. As such, I'm unclear how the `init_secret`->`epoch_secret` relates to the `leaf_secret` via the \"number of secrets [that] are derived from the epoch secret for different purposes\".\r\n\r\nAlso, The Group Creation section makes no reference to any of these secrets by name. I would kind of expect something called, `init_secret`, to be involved during group creation, but it doesn't seem like that's necessary. \r\n\r\nis `authenticated_data` defined anywhere? Is it application level data to be included as desired?",
      "createdAt": "2021-04-28T15:44:52Z",
      "updatedAt": "2021-12-01T18:22:26Z",
      "closedAt": "2021-12-01T18:22:26Z",
      "comments": [
        {
          "author": "knightcode",
          "authorAssociation": "NONE",
          "body": "Can you add the definition of `commit_secret` definition to [Ratchet Tree Evolution](https://github.com/mlswg/mls-protocol/blob/main/draft-ietf-mls-protocol.md#ratchet-tree-evolution)?",
          "createdAt": "2021-06-04T19:02:31Z",
          "updatedAt": "2021-06-04T19:02:31Z"
        },
        {
          "author": "knightcode",
          "authorAssociation": "NONE",
          "body": "In [Encryption Keys](https://github.com/mlswg/mls-protocol/blob/main/draft-ietf-mls-protocol.md#encryption-keys),\r\nin the diagram copied below, the label, \"secret\", is passed to DeriveTreeSecret(), where in the preceding section, it was either \"application\" or \"handshake\". This is intentional?\r\n\r\n```\r\nratchet_secret_[N]_[j]\r\n      |\r\n      +--> DeriveTreeSecret(., \"nonce\", N, j, AEAD.Nn)\r\n      |    = ratchet_nonce_[N]_[j]\r\n      |\r\n      +--> DeriveTreeSecret(., \"key\", N, j, AEAD.Nk)\r\n      |    = ratchet_key_[N]_[j]\r\n      |\r\n      V\r\nDeriveTreeSecret(., \"secret\", N, j, KDF.Nh)\r\n= ratchet_secret_[N]_[j+1]\r\n```",
          "createdAt": "2021-06-07T23:12:37Z",
          "updatedAt": "2021-06-07T23:12:37Z"
        },
        {
          "author": "knightcode",
          "authorAssociation": "NONE",
          "body": "Could you specifically call out where the authentication tag created by AES-256-GCM is stored? Some implementations will need to find it and pass it in as a param to `open()`.",
          "createdAt": "2021-06-08T21:57:34Z",
          "updatedAt": "2021-06-08T21:57:34Z"
        },
        {
          "author": "knightcode",
          "authorAssociation": "NONE",
          "body": "The group creation and external init parts of the doc each have discussions in two parts. It'd be easier to follow if they were consolidated. I would suggest moving the group creation section up to the other relevant parts and maybe introduce the other concepts in the context of group creation... that's how implementations would start.",
          "createdAt": "2021-06-23T14:03:13Z",
          "updatedAt": "2021-06-23T14:03:13Z"
        },
        {
          "author": "knightcode",
          "authorAssociation": "NONE",
          "body": "I'm not sure why there needs to be two ratchets per leaf node. It seems like they never get ratcheted at the same time, and they both get reset during the same event(s).",
          "createdAt": "2021-06-23T14:04:36Z",
          "updatedAt": "2021-06-23T14:04:36Z"
        },
        {
          "author": "knightcode",
          "authorAssociation": "NONE",
          "body": "It was easier for me to understand the `resolution`  concept as just a kind of depth first search through the sibling's tree, favoring the left child, for a public or private key. If building an update path follows the addition of empty nodes, then for each step up the tree, the sibling's tree is not going to have filled any new key pairs yet, so that conducting a search at that moment is only going to resolve a public key from the previous epoch. ",
          "createdAt": "2021-06-23T15:13:30Z",
          "updatedAt": "2021-06-23T15:13:30Z"
        },
        {
          "author": "knightcode",
          "authorAssociation": "NONE",
          "body": "What does this mean? Is part of the sentence missing?\r\n\r\n```\r\nTruncate the tree by reducing the size of tree until the rightmost non-blank leaf node\r\n```\r\n ",
          "createdAt": "2021-06-24T22:13:44Z",
          "updatedAt": "2021-06-24T22:13:44Z"
        },
        {
          "author": "knightcode",
          "authorAssociation": "NONE",
          "body": "Leaving it to applications to determine how many resumption secrets to maintain creates a problem with ExternalInit's. The external init is predicated entirely on public group state, so that the new member(s) will not have any resumption secrets from prior epochs as determined by the application. If one of those resumption secrets is employed, the group fractures.\r\n\r\nMoreover, I'm not seeing how one resumption_secret alone is enough for a recovery operation... if that's one of its intended uses, which seems to be implied. There's not much to go on in the doc, but it seems to suggest the resumption secret is included in the key derivation schedule as a PSK. But the schedule also requires an init_secret and a commit_secret as inputs, which a recovering node cannot rely on to be in sync with the group.",
          "createdAt": "2021-06-30T14:20:25Z",
          "updatedAt": "2021-06-30T14:20:25Z"
        },
        {
          "author": "knightcode",
          "authorAssociation": "NONE",
          "body": "For members, A, C, and D of a 4 member group, where A performed the additions of B,C, and D and then broadcast a Welcome message to all the others, their respective trees would look like the following after each adds their own private keys locally:\r\n```\r\n         p[3]                  p[3]                   p[3]\r\n        /     \\              /      \\               /     \\\r\n     p[1]       _          p[1]       _          p[1]       _\r\n     /  \\      / \\         /  \\      / \\         /  \\      / \\\r\n    p[A] B    C   D       A    B  p[C]  D       A    B    C p[D]\r\n```\r\n`p[x]` denotes that a public/private key pair resides at node x\r\n\r\nIf node performs an another tree update, e.g. adds another member, when computing the updatePath for node 3, it must select a public key from the subtree rooted at node 5 (the underscore). No key pair has been computed for node 5 yet, so that it would select the public key for node C and proceed. This, however, prevents node D from decrypting the path_secret for node 3 because D does not know the private key for C. If A is to encrypt the path_secret multiple times---each with a different key---what's the protocol? How many copies are enough? Does the number of copies have to grow with the size of the tree?",
          "createdAt": "2021-06-30T16:33:24Z",
          "updatedAt": "2021-06-30T16:33:24Z"
        },
        {
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Hi @knightcode,\r\n\r\nthanks for raising all these issues. There's an effort under way to give the draft an overhaul from an editorial standpoint. That should help with some of the issues around definitions and structuring/sequence of sections.\r\n\r\nRegarding `DeriveTreeSecret`: `DeriveTreeSecret` is just a function that's used in multiple places and the label changes depending on what kind of secret we're deriving.\r\n\r\nRegarding storage of authentication tags: I'm not sure what you mean by \"store\" here? This sounds like an implementation specific question that the draft won't be able to answer.\r\n\r\nRegarding two ratchets per leaf node: I assume you mean that from a leaf secret we derive a node secret and a path secret. This is to ensure that keys are cryptographically separate, such that they can be used by different cryptographic primitives. Cryptographic assumptions on primitives such as KDFs, authenticated encryption, etc usually assume that the key is only used with that primitive. As a consequence, proving the security of the protocol would likely require non-standard assumptions if one were _not_ to separate keys properly.\r\n\r\nRegarding truncation: The sentence is meant to express that, starting from the rightmost leaf, leaves are removed until the first non-blank leaf is reached.\r\n\r\nRegarding resumptions and ExternalInits: Good catch! That should be added to the section on ExternalInit.\r\n\r\nRecovery through resumption secrets: When creating a group, it can be linked to an existing group through the use of resumption secrets. Linking a new group to an existing group means that the creator follows the normal group creation process, i.e. creating a group and adding other members, sending Welcome messages, etc. However, when adding the new members, the group creator also injects a PSK derived from the resumption secret (from the existing group) into the key schedule. Thus, as per the \"normal\" group creation process, no other shared secrets are needed, excpet the PSK derived from the resumption secret for the step where the members are added.\r\n\r\nRegarding you most recent example: If I understand the scenario correctly, I believe you are not computing the resolution properly. The node sending the update would encrypt the path secret of node 3 to the resolution of the blank node. The resolution of a blank node is computed by taking the resolution of its two children, which in this case are both C _and_ D.\r\n\r\nI hope that answered some of your questions. If you have questions regarding the draft in general, the mailing list `mls@ietf.org` is usually a better place to get answers. Also, if you're working on an implementation, there's a Wire group for discussions regarding implementation issues and interop between the individual implementations. See [here](https://github.com/mlswg/mls-implementations) for the links. We're always happy to see new implementations!\r\n",
          "createdAt": "2021-07-01T06:53:36Z",
          "updatedAt": "2021-07-01T06:53:36Z"
        },
        {
          "author": "knightcode",
          "authorAssociation": "NONE",
          "body": "By \"two ratchets\", I was referring to the secrets derived at the leaves of the secret tree... i.e. the final values computed by `DeriveTreeSecret`. There's one using a label of \"application\" and one using a label of \"handshake\". The former is ratcheted for application messages, and the latter for handshake messages. In the diagram I referenced above, the label switches to \"secret\"... probably from an earlier iteration of the doc. In any case, I don't see a reason to have two secrets here. It's more to maintain for little benefit.\r\n\r\nSimply shifting leaves and then truncating the right side of the tree is sufficient to properly remove any arbitrary leaf from the tree? I guess maybe that works with the resolution computation you described, but that could like unmerge half the leaves between the departing index and the end.\r\n\r\nFor the AES-256-GCM authentication tag, for the `crypto` library in Node.js, the tag is retrieved with a separate call after the cipher is finalized (`cipher.getAuthTag()`), so that the ciphertext and the tag are two pieces of information that need to get formatted into a packet and transmitted. I understand that this is just one algorithm and others may only have the ciphertext. But for the ciphersuites that employ AES-256-GCM, two implementations might format the packets differently and be inoperable with each other. ..or there's already an agreed upon formatting that I don't know about. Moreover, the length of the tag is a configurable param for the algorithm, which should be specified somewhere.\r\n\r\nI get it now that recovery is just group creation using the same group ID with a resumption secret thrown in. I kind of like it being an External Init with the resumption secret thrown in. One message instead of N messages.\r\n\r\nMailing lists are terrible at organizing information (not that I'm doing any better putting all my topics in one Issue).",
          "createdAt": "2021-07-02T15:49:49Z",
          "updatedAt": "2021-07-02T15:49:49Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Hi @knightcode , finally getting around to addressing these comments.  Sorry it took a bit!\r\n\r\nNotes from a first read-through (before looking at the exchange with @kkohbrok):\r\n\r\n* Terminology between Ratchet Tree Evolution, Group Creation, Key Schedule - I\r\n  think this has been sorted out by some more recent changes.\r\n* Definition of `commit_secret` - This doesn't go in {{ratchet-tree-evolution}},\r\n  it is defined in the commit generation / handling sections\r\n* \"secret\" / \"handshake\" / \"application\" - Yes, this is intentional.  The first\r\n  derivation splits the application and handshake key chains, then both evolve\r\n  via \"secret\" derivation\r\n* GCM authentication tag - We assume the RFC 5116 AEAD interface, which has a\r\n  unitary ciphertext, not a separate ciphertext+tag.  Added a note to clarify.\r\n* Group creation and external init parts each have discussions in two parts -\r\n  Not immediately clear how to address this; will consider in a broader review.\r\n* Two ratchets per leaf node - Assuming you're talking about the `path_secret`\r\n  vs. `node_secret` distinction, this is to assure that each secret is only used\r\n  with one algortihm.  I have added a note to clarify.\r\n* Easier to understand resolution as depth-first search - Added this to the\r\n  description of resolution.\r\n* \"Truncate the tree...\" - Yep, missing part of the sentence. Reworded.\r\n* Resumption secret & ExternalInit - There's no connection between ExternalInit\r\n  and resumption secrets (just `external_pub`), and in any case, the only epoch\r\n  for which an ExternalInit can be constructed is the current one.  Otherwise,\r\n  you're forking history.  You're correct that the resumption secret is not\r\n  sufficient to join a group, and it's not meant to be.  It is only proof of\r\n  prior involvement with the group.\r\n* For members A, C, D, ... - Your representation of the secret knowledge here\r\n  isn't quite right.  C and D wouldn't know p[1], since it's not on their direct\r\n  path.  In your hypothetical, if A or B did an operation, they would encrypt to\r\n  the *resolution* of node 5, that is to both C and D.  This diagram seems\r\n  useful for building intuition, though, so I've added something like it to the\r\n  ratchet tree section.\r\n\r\n========\r\n\r\nNotes on responses to @kkohbrok:\r\n\r\n* The separate application and handshake ratchet to ensure that application and\r\n  handshake messages don't fate-share -- if the application keys are\r\n  compromised, that doesn't compromise the handshake keys.  While this might not\r\n  matter much in practice, I believe it helps with the security analysis.\r\n* Truncation is not how members are removed from the tree.  That's done by\r\n  blanking a member's leaf and parents.  Truncation is just garbage collection.\r\n  If you have a 1000-member group where leaf 1 is blank (starting at zero), and\r\n  the member at leaf 2 removes members at leaves 3-1000, then you'll end up with\r\n  a tree with three leaves (member A, blank, member B), and truncation will\r\n  clear out the now-blank leaves 3-1000 and all their parents.\r\n* Yeah, there's unfortunate divergence in AES-GCM interfaces.  The good news is\r\n  that even if an implementation produces a different layout, as long as you can\r\n  find the tag, you can rearrange things to match the desired layout here\r\n  (ciphertext || tag).\r\n",
          "createdAt": "2021-11-19T22:06:45Z",
          "updatedAt": "2021-11-19T22:06:45Z"
        }
      ]
    },
    {
      "number": 470,
      "id": "MDU6SXNzdWU4ODk4OTE4NjY=",
      "title": "group_context is passed into HPKE's aad instead of info",
      "url": "https://github.com/mlswg/mls-protocol/issues/470",
      "state": "CLOSED",
      "author": "kkohbrok",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "This came up during a discussion with @raphaelrobert and @franziskuskiefer on an issue discovered by Th\u00e9ophile (https://github.com/openmls/openmls/pull/404).\r\n\r\nI don't think this is a security issue necessarily, as both sender and receiver must agree on the group_context to successfully decrypt. However, I believe it's cleaner to have `group_context` go into the HPKE key derivation rather than the AEAD's aad.",
      "createdAt": "2021-05-12T09:45:27Z",
      "updatedAt": "2021-10-04T17:38:24Z",
      "closedAt": "2021-10-04T17:38:24Z",
      "comments": []
    },
    {
      "number": 472,
      "id": "MDU6SXNzdWU4OTU1MzM3NDE=",
      "title": "Make extensions more powerful",
      "url": "https://github.com/mlswg/mls-protocol/issues/472",
      "state": "CLOSED",
      "author": "kkohbrok",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Extensions can currently be set when creating the group, after which they are fixed for the rest of the group's lifetime. Being able to change extensions dynamically, e.g. via a dedicated proposal would make extensions a much more powerful mechanism.\r\n\r\nFor example, there's currently no way to use MLS to make the group agree on arbitrary data/context. Sure, one could create a custom extension, which makes each client include a specific bit of data into the context. However, for that to work, one would have to change the implementation to include that mechanism for that specific bit of data. On the other hand, if one could change extensions on the fly, e.g. via a proposal, one could, for example, store group metadata (or hashes thereof) in an extension and thus achieve agreement, but also change that data from one epoch to the next.\r\n\r\nOf course, it should always be ensured that every type of extension used is supported by every group member.\r\n\r\nOne could also generalize such a proposal to be a GroupConfig proposal, which allows change of Version number or Ciphersuite as well...",
      "createdAt": "2021-05-19T14:41:51Z",
      "updatedAt": "2021-05-20T13:04:20Z",
      "closedAt": "2021-05-20T13:04:20Z",
      "comments": [
        {
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Closing in favor of #473.",
          "createdAt": "2021-05-20T13:04:20Z",
          "updatedAt": "2021-05-20T13:04:20Z"
        }
      ]
    },
    {
      "number": 473,
      "id": "MDU6SXNzdWU4OTY4MDI1MDg=",
      "title": "Extensions",
      "url": "https://github.com/mlswg/mls-protocol/issues/473",
      "state": "CLOSED",
      "author": "raphaelrobert",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "After a thorough review of the current MLS extension system, there are a few questions and we also have a few suggestions for changes.\r\n\r\n#### How we interpret the spec currently:\r\n - The total set of extensions is fixed and cannot be changed during the lifetime of a group.\r\n - The set of extensions that is associated with a group is decided by the group creator.\r\n - All extension types from the set have to be supported by all clients and must therefore be advertised in their capabilities extension.\r\n - The implementation needs to validate the support in 4 instances: When creating a new group, when joining a group, when creating an add proposal, when parsing someone else's add proposal as part of a Commit.\r\n - Key package extensions are simple and well-understood, in that they never leave the KeyPackage and there is group consensus through the tree hash.\r\n - The other kind of extension seems to be called a Group Info Extension (GIE).\r\n - GIEs can come in two flavours: a) they must be included in the group context, b) they must not be included in the group context.\r\n - The ratchet tree extensions is an example of type b).\r\n - GIEs of type a) are essentially just passed from the Adder to the New Joiner, using Welcome messages as an E2EE pipe.\r\n\r\n#### Open questions:\r\n - The spec does not explicitly introduce the notion of a GIE, it is only mentioned in 16.2. Should the spec be more explicit here?\r\n - Should the flavour of a GIE (as described above) be reflected in the `Extension` struct in the spec? E.g. a message type that indicates whether a GIE should be included in the GroupContext (see proposal below).\r\n - Can the content of a GIE be dynamic (i.e. it can change during the lifetime of a group)? The ratchet tree extension seems to validate that assumption, it is a bit unclear if this is true for all kinds of GIE. We should be more explicit in the spec.\r\n - If the content of GIEs is indeed dynamic, should those GIEs always be excluded from the GroupContext? Or optionally? If they are to be included in the GroupContext, how do clients agree on the changes? (See proposal below)\r\n\r\nWe need more guidance regarding extensions in order to keep implementations aligned and capable of interop.\r\n\r\n#### Concrete proposed improvements:\r\n\r\nA first suggestion would be to allow for the creation of extensions that have dynamic content. This would allow them to use MLS to agree on arbitrary data.\r\n\r\nThe requirement would be to make GIEs with dynamic content more robust by introducing a new proposal type to update the content of extensions:\r\n\r\n```c\r\nstruct {\r\n  Extension extension;\r\n} ExtensionUpdate;\r\n```\r\n\r\n\r\nAnother improvement to the current extension system would be to be more clear about the kinds of extensions by introducing a dedicated `MessageType` field for every extension:\r\n\r\n```c\r\nenum {\r\n    reserved(0),\r\n    KeyPackage(1),\r\n    GroupContext(2), // GIEs that are to be included in the group context\r\n    GroupInfo(3), // GIEs that should not be included in the group context, like the ratchet tree extension\r\n    (255)\r\n} MessageType;\r\n\r\nstruct {\r\n    ExtensionId extension_id;\r\n    MessageType message_type;\r\n    opaque extension_data<0..2^16-1>;\r\n} Extension;\r\n```\r\n\r\nThis would allow generic `GroupInfo` extensions, which in turn allow committers of Add proposals to communicate arbitrary data to new group members in a robust fashion.",
      "createdAt": "2021-05-20T13:02:49Z",
      "updatedAt": "2021-10-04T19:47:55Z",
      "closedAt": "2021-10-04T19:47:55Z",
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks for the analysis here.  To your point about \u201cdynamic GIEs\u201d \u2014 My initial concept here was that the GIEs included in the GroupContext would be fixed for all time.  The ratchet tree extension would not be included in the GroupContext; as you say, it just uses the Welcome for E2E tunneling.\r\n\r\nBoiling this down a bit, it seems like there are a few problems to solve here:\r\n\r\n* Clarifying which extensions in the GroupInfo go into the GroupContext and which are just used for tunneling E2E\r\n* Allowing for updates to the group\u2019s extensions\r\n\r\nFor the former, there's a pretty simple solution available: Just have separate fields in the GroupContext for permanent and ephemeral extensions.\r\n\r\n```\r\nstruct {\r\n  // ...\r\n  Extension group_context_extensions<0..2^32-1>;\r\n  Extension other_extensions<0..2^32-1>;\r\n  // ...\r\n} GroupInfo;\r\n```\r\n\r\nThe joiner processing would then place the `group_context_extensions` into the MLS state / GroupContext, and use/discard the `other_extensions`.  We could also then update the IANA considerations to reflect these additional categories for where an extension can appear.\r\n\r\nFor the latter problem, I think your ExtensionUpdate is about the right approach.  It might be simpler just to have the update proposal provide wholesale replacement to the extensions, so that we don't have to design a merge algorithm.  I'm not totally sure this is worth doing right now, since it seems easy to do as an extension.  But especially if we keep it simple, I'm not strongly opposed.",
          "createdAt": "2021-08-11T00:35:46Z",
          "updatedAt": "2021-08-11T00:35:46Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "@kkohbrok @raphaelrobert and I discussed real-time, propose to do the following:\r\n\r\n1. Split out the GroupContext extensions as above\r\n2. Define a new proposal type to update the group's extensions:\r\n\r\n```\r\nstruct {\r\n    Extension new_extensions<0..2^32-1>;\r\n} ExtensionUpdate;\r\n\r\n// Processing:\r\n// group_context.extensions = ext_update.new_extensions;\r\n```",
          "createdAt": "2021-08-12T17:17:58Z",
          "updatedAt": "2021-08-12T17:17:58Z"
        }
      ]
    },
    {
      "number": 482,
      "id": "MDU6SXNzdWU5NzUxMjI3NzI=",
      "title": "Review advisory sections",
      "url": "https://github.com/mlswg/mls-protocol/issues/482",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "The \"Sequencing of State Changes\" and \"Application Messages\" sections date to very early in the document's life, and probably need some updates to reflect current thinking.",
      "createdAt": "2021-08-19T23:17:45Z",
      "updatedAt": "2021-11-30T23:28:29Z",
      "closedAt": "2021-11-30T23:28:29Z",
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing for now, might reopen based on WGLC review.",
          "createdAt": "2021-11-30T23:28:29Z",
          "updatedAt": "2021-11-30T23:28:29Z"
        }
      ]
    },
    {
      "number": 485,
      "id": "I_kwDOBoyH6c48gSlC",
      "title": "Mandatory extension types?",
      "url": "https://github.com/mlswg/mls-protocol/issues/485",
      "state": "CLOSED",
      "author": "rohan-wire",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Many protocols which have an extensibility mechanism have a way to indicate that understanding an extension is mandatory for certain behaviors. For MLS, this would mean having a way to require a member understand an MLS extension before it can join a group. The three extension types defined currently are: \r\n MLS ciphersuites, \r\n MLS extension types, and \r\n MLS credential types. \r\n\r\nOne logical way to add mandatory extensions would be to pick one of these types (the MLS extensions type) and use the high order bit or a specific range to indicate that a member must understand and implement the extension to join a group which uses that extension. The IANA values could be changed as follows:\r\n\r\nValues from 0x8000-0xffff indicate understanding the extension is required\r\n0x7f00 - 0x7fff  Reserved for Private Use (not required)\r\n0xff00 - 0xfff   Reserved for Private Use (required)\r\n\r\nIf a required ciphersuite or credential becomes necessary, a new extension type could be created to add an extension in the KeyPackage or GroupInfo which would be required and would indicate support for the mandatory ciphersuites or credentials.\r\n\r\nIn order to prevent some other entity from adding an MLS client that does not support a mandatory extension, we already have the KeyPackage Client Capabilities, which lists which extensions are supported by the client. \r\n\r\n",
      "createdAt": "2021-10-04T12:09:23Z",
      "updatedAt": "2021-10-05T07:52:19Z",
      "closedAt": "2021-10-05T07:52:18Z",
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Note that though this might seem \"now or never\", I don't think it really\nis.  Consider TLS by way of analogy -- it has no mechanism for specifying\nthat extensions are required.  But if a server gets a ClientHello that is\nmissing some extension that it requires, it can just abort the handshake.\nLikewise in MLS, the member adding a new joiner to the group can examine\nthat joiner's KeyPackage to see if they support the extensions needed for\nthe group.\n\nSo I think you could implement this as a non-mandatory GroupContext\nextension, which would state the extensions required by the group so that\nall members apply the same requirements for new joiners.\n\n--Richard\n\n\nOn Mon, Oct 4, 2021 at 8:09 AM rohan-wire ***@***.***> wrote:\n\n> Many protocols which have an extensibility mechanism have a way to\n> indicate that understanding an extension is mandatory for certain\n> behaviors. For MLS, this would mean having a way to require a member\n> understand an MLS extension before it can join a group. The three extension\n> types defined currently are:\n> MLS ciphersuites,\n> MLS extension types, and\n> MLS credential types.\n>\n> One logical way to add mandatory extensions would be to pick one of these\n> types (the MLS extensions type) and use the high order bit or a specific\n> range to indicate that a member must understand and implement the extension\n> to join a group which uses that extension. The IANA values could be changed\n> as follows:\n>\n> Values from 0x8000-0xffff indicate understanding the extension is required\n> 0x7f00 - 0x7fff Reserved for Private Use (not required)\n> 0xff00 - 0xfff Reserved for Private Use (required)\n>\n> If a required ciphersuite or credential becomes necessary, a new extension\n> type could be created to add an extension in the KeyPackage or GroupInfo\n> which would be required and would indicate support for the mandatory\n> ciphersuites or credentials.\n>\n> In order to prevent some other entity from adding an MLS client that does\n> not support a mandatory extension, we already have the KeyPackage Client\n> Capabilities, which lists which extensions are supported by the client.\n>\n> \u2014\n> You are receiving this because you are subscribed to this thread.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/mlswg/mls-protocol/issues/485>, or unsubscribe\n> <https://github.com/notifications/unsubscribe-auth/AAASOTL4OCSPWHLYHISRUM3UFGKP5ANCNFSM5FJGPVUQ>\n> .\n> Triage notifications on the go with GitHub Mobile for iOS\n> <https://apps.apple.com/app/apple-store/id1477376905?ct=notification-email&mt=8&pt=524675>\n> or Android\n> <https://play.google.com/store/apps/details?id=com.github.android&referrer=utm_campaign%3Dnotification-email%26utm_medium%3Demail%26utm_source%3Dgithub>.\n>\n>\n",
          "createdAt": "2021-10-04T13:58:07Z",
          "updatedAt": "2021-10-04T13:58:07Z"
        },
        {
          "author": "rohan-wire",
          "authorAssociation": "CONTRIBUTOR",
          "body": "While you can implement this \"out-of-band\", that makes it implicit rather than explicit behavior.",
          "createdAt": "2021-10-04T14:41:57Z",
          "updatedAt": "2021-10-04T14:41:57Z"
        },
        {
          "author": "seanturner",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Discussed at 20211004 interim, liked this functionality. But, instead of IANA registry use field (or extension) in group context to indicate which extensions are required.\r\n\r\n@rohan-wire to generate PR.",
          "createdAt": "2021-10-04T15:56:18Z",
          "updatedAt": "2021-10-04T15:56:18Z"
        },
        {
          "author": "rohan-wire",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Discussed with @bifurcation and incorporated this functionality into PR #489  ",
          "createdAt": "2021-10-05T07:52:18Z",
          "updatedAt": "2021-10-05T07:52:18Z"
        }
      ]
    },
    {
      "number": 486,
      "id": "I_kwDOBoyH6c48g8Pb",
      "title": "Use `(identity, endpoint_id)` tuple instead of leaf indices in Message structs",
      "url": "https://github.com/mlswg/mls-protocol/issues/486",
      "state": "CLOSED",
      "author": "kkohbrok",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "As suggested in [here](https://github.com/mlswg/mls-protocol/pull/476#issuecomment-919746483), once #476 is merged, we can use `(identity, endpoint_id)` to uniquely address group members instead of leaf indices.\r\n\r\nThis slightly bloats messages, but it also helps abstract away the binary tree representation a little more.",
      "createdAt": "2021-10-04T14:39:53Z",
      "updatedAt": "2021-10-11T19:21:47Z",
      "closedAt": "2021-10-11T19:21:47Z",
      "comments": []
    },
    {
      "number": 493,
      "id": "I_kwDOBoyH6c48qOKi",
      "title": "Key schedule text - figure mismatch",
      "url": "https://github.com/mlswg/mls-protocol/issues/493",
      "state": "CLOSED",
      "author": "kkohbrok",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "I believe there's a small mismatch between the text and the Key Schedule figure. The text says [here](https://github.com/mlswg/mls-protocol/blob/b7a741e3d2b48252d3f005274d93d2e4212bcf12/draft-ietf-mls-protocol.md#L2648) that if there are no PSK proposals, the `psk_secret` should be a zero-length string, while the Key Schedule figure seems to indicate that it's a string of zeros of length `KDF.n`.",
      "createdAt": "2021-10-06T07:42:07Z",
      "updatedAt": "2021-10-11T19:28:25Z",
      "closedAt": "2021-10-11T19:28:25Z",
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed in #490 ",
          "createdAt": "2021-10-11T19:28:25Z",
          "updatedAt": "2021-10-11T19:28:25Z"
        }
      ]
    },
    {
      "number": 498,
      "id": "I_kwDOBoyH6c49dYEO",
      "title": "`Ciphersuite` should be part of `PublicGroupStateTbs`",
      "url": "https://github.com/mlswg/mls-protocol/issues/498",
      "state": "CLOSED",
      "author": "kkohbrok",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Am I missing something here, or should the ciphersuite really be part of the `PublicGroupStateTbs`? It's part of the `PublicGroupState`, but the way it is right now it doesn't get signed.",
      "createdAt": "2021-10-20T08:14:29Z",
      "updatedAt": "2021-11-19T20:22:47Z",
      "closedAt": "2021-11-19T20:22:47Z",
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Yes, this looks like a copy/paste error.  ",
          "createdAt": "2021-10-20T13:53:27Z",
          "updatedAt": "2021-10-20T13:53:27Z"
        }
      ]
    },
    {
      "number": 499,
      "id": "I_kwDOBoyH6c49eRaO",
      "title": "`typed` struct definition",
      "url": "https://github.com/mlswg/mls-protocol/issues/499",
      "state": "CLOSED",
      "author": "kkohbrok",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "In many places, we use a `typed` pattern of struct, where we have a type uint, followed by a `select` statement decides the type of the following field based on the preceding type uint. For example the `Credential` struct:\r\n```\r\nstruct {\r\n    CredentialType credential_type;\r\n    select (Credential.credential_type) {\r\n        case basic:\r\n            BasicCredential;\r\n\r\n        case x509:\r\n            Certificate chain<1..2^32-1>;\r\n    };\r\n} Credential;\r\n```\r\nOther examples are `Content`/`ContentType`, `PSKType` in `PreSharedKey`, `Sender`/`SenderType` and `Proposal`/`ProposalType`.\r\n\r\nIn the context of [an attempt at creating a macro for this pattern](https://github.com/RustCrypto/formats/pull/125), @franziskuskiefer suggested that we actually define a generic struct for this similar to the `optional<T>` pattern.\r\n```\r\nstruct {\r\n    T type;\r\n    select(typed<T>.type) {\r\n        T.variant1: \r\n            Variant1 \r\n    }\r\n} typed<T>\r\n```\r\nIt would translate, for example, as follows for `typed<CredentialType>` (although we could then probably rename the enum from `CredentialType` to `Credential`:\r\n```\r\nstruct {\r\n    CredentialType credential_type;\r\n    select typed<CredentialType>.type {\r\n        CredentialType.basic: \r\n            Basic\r\n        ...\r\n    }\r\n} typed<CredentialType>\r\n```\r\nIt doesn't quite match up to what's currently in the spec (`Basic` instead of `BasicCredential`), but this rather naive approach is meant more as a basis for discussion than as a complete proposal. Let me know what you think!",
      "createdAt": "2021-10-20T12:22:51Z",
      "updatedAt": "2021-11-30T23:12:19Z",
      "closedAt": "2021-11-30T23:12:19Z",
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "On the one hand, there is merit to this idea in principle.  For example, we have implemented things like [Credential](https://github.com/cisco/mlspp/blob/main/include/mls/credential.h#L106) and [Proposal](https://github.com/cisco/mlspp/blob/main/include/mls/messages.h#L363) in MLSpp as \"tagged variants\" that [automatically serialize/deserialize in the required form](https://github.com/cisco/mlspp/blob/main/lib/tls_syntax/include/tls/tls_syntax.h#L408).\r\n\r\nOn the other hand, I'm not sure how much there is to be gained from it in the spec.  After all, the \"type + `select`\" framework already captures the intended semantic here, as long as it's used properly.  And as you can see in the MLSpp code, it's kind of messy even when you have language support for variants -- behold the [TEMPLATE MAGIC!](https://github.com/cisco/mlspp/blob/main/lib/tls_syntax/include/tls/tls_syntax.h#L430) to iterate through variant case and match them with their tags.\r\n\r\nIt seems like the best we could do here is provide some syntax that would codify this particular usage of the `select` mechanism, and maybe let you combine it with the enum definition.\r\n\r\n```\r\nstruct {\r\n    WireFormat wire_format;\r\n    opaque group_id<0..255>;\r\n    uint64 epoch;\r\n    Sender sender;\r\n    opaque authenticated_data<0..2^32-1>;\r\n\r\n    variant (ContentType) {\r\n        case application:\r\n          opaque application_data<0..2^32-1>;\r\n\r\n        case proposal:\r\n          Proposal proposal;\r\n\r\n        case commit:\r\n          Commit commit;\r\n \r\n        ...(255)\r\n    }\r\n\r\n    opaque signature<0..2^16-1>;\r\n    optional<MAC> confirmation_tag;\r\n    optional<MAC> membership_tag;\r\n} MLSPlaintext;\r\n```\r\n\r\nNet/net, though, this seems like a lot of invention for not a lot of benefit.",
          "createdAt": "2021-10-20T18:57:39Z",
          "updatedAt": "2021-10-20T18:57:39Z"
        },
        {
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "We're already somewhat formally extending the TLS serialization format with the `option` type, so why not continue with this. I think it would be useful in the spec. It would be useful for implementers to have a guideline for their template magic. But it might also benefit others in the same way that we are benefiting from the TLS spec.",
          "createdAt": "2021-10-21T11:12:56Z",
          "updatedAt": "2021-10-21T11:12:56Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "I'm not worried about perturbing the TLS serialization format.  I just don't think there's much savings to be had, given that you need to specify the mapping of enum values to types anyway.  ISTM the `variant` syntax I proposed above is about as compact/elegant as you could make it, so I would propose we either do that or just close this issue with no action.",
          "createdAt": "2021-11-19T20:48:42Z",
          "updatedAt": "2021-11-19T20:48:42Z"
        },
        {
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Sounds good to me. An alternative would be to put this in the implementation-considerations doc. It currently doesn't have any content, so this might be a good first contribution.",
          "createdAt": "2021-11-23T14:02:14Z",
          "updatedAt": "2021-11-23T14:02:14Z"
        },
        {
          "author": "franziskuskiefer",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I suggest to move this to the implementation-considerations doc.",
          "createdAt": "2021-11-24T07:53:13Z",
          "updatedAt": "2021-11-24T07:53:13Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "OK, sounds like we have consensus to move to implementation considerations, so I'm closing this.  \r\n\r\n@kkohbrok \u2014 It might be good to start up a repo for that document, so that we don't lose things like this.  The other topic that comes to mind is the array-based tree representation (cf. #507).",
          "createdAt": "2021-11-30T23:12:19Z",
          "updatedAt": "2021-11-30T23:12:19Z"
        }
      ]
    },
    {
      "number": 500,
      "id": "I_kwDOBoyH6c49eoQ2",
      "title": "Update HPKE requirement to latest",
      "url": "https://github.com/mlswg/mls-protocol/issues/500",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "MLS draft-12 still references draft-08 of HPKE, which is now on draft-12.  We should update to the final version of HPKE before finalizing MLS.",
      "createdAt": "2021-10-20T13:51:51Z",
      "updatedAt": "2021-11-30T22:51:50Z",
      "closedAt": "2021-11-30T22:51:50Z",
      "comments": []
    },
    {
      "number": 502,
      "id": "I_kwDOBoyH6c4-Rwzj",
      "title": "Consolidate resumption PSK definitions",
      "url": "https://github.com/mlswg/mls-protocol/issues/502",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Right now, we treat the re-init and branch PSK cases as distinct cases, as opposed to just having a general \"export PSK from one group+epoch, insert it into another\" function.  What I would call a \"resumption PSK\", following TLS.   Even though we have the distinction, the content of the PSK itself is the same: (group ID, epoch, resumption secret).  So the only difference is that the PreSharedKeyID has a bit that signals the intent of injecting this resumption PSK.\r\n\r\nDo we really need that bit?  If there's not a compelling need, it would streamline the API and allow for more flexibility if we just had the notion of a resumption PSK.",
      "createdAt": "2021-11-04T14:47:01Z",
      "updatedAt": "2022-01-19T17:12:59Z",
      "closedAt": "2022-01-19T17:12:59Z",
      "comments": [
        {
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Key separation by domain is usually a good idea. If we derive a key, the purpose should be \"baked in\", i.e. included in the derivation to avoid potential collision across protocol functionalities/domains. I'm not sure I understand how that makes the API more complex. If it's really bad, we should consider the trade-off, but if it's not too much trouble, I'd prefer we keep the key separation. Can you elaborate a bit on the API complexity?",
          "createdAt": "2021-11-15T08:28:22Z",
          "updatedAt": "2021-11-15T08:28:22Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "I'm mostly concerned about being too specific in the \"purpose\" definitions, and thus making applications make a choice that doesn't really make sense.  For example, take the obvious case of TLS-like resumption, where I take a key from the last epoch of a prior instance of the group and use it as input to a new appearance of the group.  Is that a re-init?  There wasn't necessarily a ReInit proposal.  Is it a branch?  \"Branch\" isn't even defined in the spec.  Better to just talk about \"resumption\" as the general act of exporting a secret from one group and inserting it into another.",
          "createdAt": "2021-11-15T16:24:44Z",
          "updatedAt": "2021-11-15T16:24:44Z"
        },
        {
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The scenarios you describe seem to indicate problems in the spec that don't have anything to do with the derivation of the resumption secret. If you want to enable re-init secrets without a proposal, that's fine and we can define in the spec which key to use for that purpose (probably the re-init key). Similarly, if branch isn't well defined in  the spec, we should probably define it better. In the end, for everything else that you want to do that's not (properly) defined in the spec, you can just use an exporter secret. I don't see that weakening the domain separation of the re-init and branch key derivation is the right way to solve these problems. Is the code complexity that bad?",
          "createdAt": "2021-11-16T13:54:15Z",
          "updatedAt": "2021-11-16T13:54:15Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "We could go off and try to define all the possible uses of a resumption PSK, but (a) that's a lot more work, (b) it seems unlikely to succeed, (c) even if you do succeed, you'll end up with a more complicated API for applications (bc N names for the same technical act) and (d) it's not clear to me what the benefit is.\r\n\r\nWhen you talk about domain separation here, what is the failure case that this prevents? ",
          "createdAt": "2021-11-16T15:20:46Z",
          "updatedAt": "2021-11-16T15:20:46Z"
        },
        {
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "What we're trying to prevent is that participants end up with the same keys after executing a different part/functionality of the protocol. If party A thinks, they are doing a branch, while party B thinks they're doing a Re-Init and they end up with the same key, then that's bad. If an implementer wants to do proprietary things, i.e. things that are not described in the spec, they have to use an exporter key and make sure their keys are properly separated.",
          "createdAt": "2021-12-01T06:56:36Z",
          "updatedAt": "2021-12-01T06:56:36Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "It depends on what you mean by a \"different functionality of the protocol\".  The only difference between the branch and reinit cases is that in the reinit case, you quit using the old group.  You could also imagine injecting a resumption PSK into an independent group with its own history, whose membership overlaps with the group from which the PSK was drawn.  Is the functionality \"linking one group/epoch to a prior group/epoch\" or is it \"reinit / branch / ...\"?  The former seems more at the right level of granularity to me, and leads to the approach here and in #518.\r\n\r\nIf you're really hard over here, how about a compromise: Unify the syntax, but add a `usage` distinguisher alongside the group ID and epoch, which has specified values for the branch and reinit cases, and which the application MAY set for other cases.\r\n\r\n```\r\nenum {\r\n  unspecified(0),\r\n  branch(1),\r\n  reinit(2),\r\n  (255)\r\n} PSKUsage;\r\n\r\n// ...\r\n\r\n    case resumption:\r\n      PSKUsage usage;\r\n      opaque psk_group_id<0..255>;\r\n      uint64 psk_epoch;\r\n```",
          "createdAt": "2021-12-01T13:43:20Z",
          "updatedAt": "2021-12-01T13:43:20Z"
        },
        {
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I see where you're coming from and if you're convinced it is the more useful approach, we can make the trade-off and go with #518 (although we might as well rename the key from \"resumption\" to something like \"group-link\" or something). \r\n\r\nHowever, I do want to note that we have a trade-off here. Previously, designating a PSK \"branch\" or \"re-init\" signaled intent on the side of the sender and arriving at the same PSK meant agreement on said intent. For example, using a re-init key would imply that the new group is meant to replace the old group. As far as I understand that is no longer the case with #518.",
          "createdAt": "2021-12-01T14:13:05Z",
          "updatedAt": "2021-12-01T14:13:05Z"
        },
        {
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "body": "I understand the concern from a cryptographic standpoint, it's nice to have a type that indicates that the group should be shut down.\r\nFrom an engineering perspective, this all feels pretty vague. It's not clear at all how exactly a group will be shut down and a new one will be created, the protocol doesn't give any specific guidance. I don't think this is a huge concern, as long as we don't paint ourselves in a corner when we want to upgrade groups to newer MLS versions in the future.",
          "createdAt": "2021-12-01T15:02:06Z",
          "updatedAt": "2021-12-01T15:02:06Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Even if we want to have everyone agree that the group should be shut down, the ReInit proposal provides that.  Committing the ReInit puts it in the transcript, which means everyone agrees on it.  So everyone who exports a PSK from that epoch should know it's a \"dead epoch\".  In fact, the `branch` vs. `reinit` distinction seems duplicative here, since you shouldn't be able to get a `reinit` PSK from a \"live\" epoch or a `branch` PSK from a dead one.  `branch` iff live; `reinit` iff dead.\r\n\r\nNow, there may be other sub-cases within live or dead; as noted, not all resumption PSK cases map clearly to `branch` or `reinit`.  But it seems premature to put in stub functionality without some taxonomy and requirements.\r\n\r\nI would propose we do #518 for now, and if there turns out to be a need to be PSK use cases that really need segregating, it should be straightforward extension to add another PSKType.",
          "createdAt": "2021-12-06T18:47:09Z",
          "updatedAt": "2021-12-06T18:47:09Z"
        },
        {
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Fair enough. I see that the trade-off is probably ok. I'd be ok with merging #518.\r\n\r\nThe proposal should indeed ensure that the streams don't get crossed, so that all that remains would be ease of provability at that point. I still feel uncomfortable about not properly separating keys, though.\r\n\r\nRegarding the last two arguments:\r\n- the \"for now\" solution is a bit moot, since with the WGLC at hand, it's almost certainly not going to change until then\r\n- the extension argument goes the other way as well, as you could just as easily have an extension that implements #518 and gets rid of the need for the distinction between resumption PSKs. If anything, we should opt to be conservative in the spec and allow users to loosen the key separation via an extension at their own risk.",
          "createdAt": "2021-12-07T07:23:01Z",
          "updatedAt": "2021-12-07T07:23:01Z"
        },
        {
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> I understand the concern from a cryptographic standpoint, it's nice to have a type that indicates that the group should be shut down. From an engineering perspective, this all feels pretty vague. It's not clear at all how exactly a group will be shut down and a new one will be created, the protocol doesn't give any specific guidance. I don't think this is a huge concern, as long as we don't paint ourselves in a corner when we want to upgrade groups to newer MLS versions in the future.\r\n\r\nI understand that it's unclear how the linking of groups is going to take place in a practical setting, but I don't see that that's an argument to weaken the cryptographic basis of the mechanism. If we don't figure out how to do it in practice, then that's fine, as we can just ignore that part of the protocol. If we do, however, we will want to get proper security guarantees whenever we link two groups in this way.\r\n\r\nAgain, I think #518 is ok. But it's because we probably get good enough guarentees and not because the whole mechanism is a secondary concern due to there being unsolved higher level engineering challenges.",
          "createdAt": "2021-12-07T07:34:22Z",
          "updatedAt": "2021-12-07T07:34:22Z"
        },
        {
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "body": "I have recently implemented some of this to get a better feel for it. While we already knew the \"reinit\" case was quite underspecified, I now also realized that there might be another issue with it: A member can shut down a group before a new one is created and there is no way to force the creation of the new group within the protocol. I think it would be safer to first create a new group (with whatever new parameters) and to tear down the old one in that process. Since this is too complex for the protocol it should be solved at the application layer. In other words, I think #518 is indeed fine.",
          "createdAt": "2021-12-09T23:00:03Z",
          "updatedAt": "2021-12-09T23:00:03Z"
        },
        {
          "author": "br-hale",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Commenting on #518 here, to keep discussion from splitting to the PR.\r\n\r\nThere are a few issues here that could use clarify, and some confusion in the interpretation of the proposals.\r\n\r\nFirst - as @kkohbrok pointed out, if anything is unclear/underspecified, then that should be clarified and cleaned up vs. removal as the default. From the confusion above, it is clear that some pieces are not sufficiently specified.\r\n\r\nSecond - There is a core distinction between how PSKs are used in MLS vs. TLS that we need to be careful of. In TLS, these are used strictly for the same _two_ members communicating again after a finished session. It is not used again within the same session nor outside of the protocol (exporter keys are for that). Namely, the uses are:\r\n\r\n1. Group-internal use (resumption by an identical member set of the two parties)\r\n \r\nIn MLS, these assumptions change by the very fact that the group may have more than 2 members. For the protocol-external case we have exporter keys as well. For PSK use, we have the following:\r\n\r\n1. Group-internal use (resumption by an identical member set)\r\n2. Subgroup-internal use (resumption by a proper subset of members)\r\n3. Session-internal use (since continuous KE implies that keying material may be injected)\r\n\r\nWhile the session-internal use is not the focus of this discussion, it has been previously (i.e. proving knowledge of prior group state). This contrasts against TLS were the handshake takes place only once\r\n\r\nPoint 2 is notable in that it is impossible for a proper subset of TLS session members to use session information in a separate session (i.e. that would imply only one communication party with no partner). In MLS, this is possible, and we need to be careful about mis-aligning TLS for precedent. To avoid potential forks, etc., and clarity of key source, any group-subset PSK use really ought to be denoted (currently a 'branch'). @kkohbrok is correct that there could be subtle attacks on this if key use is not properly separated.\r\n\r\n\r\nIn addition to the above there seems to be confusion on what resumption is linked to (this is consequently something that needs more clarity in the spec.). To be precise in alignment of terms, using a PSK in TLS for communication in a new session is aligned to using a PSK in MLS for a new group, i.e. it being a continuous session. Thus we need to align discussion here between \"alive\" and \"dead\" sessions in TLS to \"alive\" and \"dead\" groups in MLS - not epochs. We can get a reinit PSK from a live group, i.e. if a member wants to force a restart for any reason and instantiates a new group with the reinit secret. This signals to all members joining that group that the prior group should be terminated and not considered secure/alive after the point of reinit use. It is an edge case, but possible. Similarly and more commonly, we could get a branch PSK from a dead group, i.e. if a new (sub-)group wants members to prove knowledge from some prior connection. Thus it follows that we can branch from both \"alive\" and \"dead\" groups. This may be helpful in terms of authentication.\r\n\r\nI am favorable to @bifurcation 's PSKUsage suggestion, i.e. that if there are other desired uses apart from the above cases the application can provide for those. The \"bleeding\" of key separation across different uses is something that is concerning, and should involve closer scrutiny before inclusion in the specification. If anything, more separation is safer at this stage, vs consolidation.\r\n\r\n\r\n\r\n\r\n\r\n\r\n",
          "createdAt": "2021-12-10T22:25:27Z",
          "updatedAt": "2021-12-10T22:25:27Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "@br-hale Good point about the differences from the two-party case.  I think your taxonomy is not quite complete, though. You could also imagine cases where the epoch into which the resumption PSK is injected has members that were not in the group in the epoch in which it was extracted (and these members were provided the PSK some other way).  For instance, in the session-internal case where there have been some Adds in the meantime.\r\n\r\nTo try to factor this a little differently, it seems like you have at least three independent columns in the truth table here comparing the extraction epoch to the injection epoch:\r\n\r\n* Same group or different group (\"group\" is the term that matches TLS \"session\"; linear sequence of epochs)\r\n* Some members have been removed\r\n* Some members have been added\r\n\r\nSo you have at least 8 cases to cover to start with assuming you care about both of those axes (same/different group and membership).\r\n\r\nIt's not clear to me why those are the two axes that one cares about.  On the one hand, why is it not important to distinguish ciphersuite changes as well, or changes in extensions?  On the other hand, why do we need to agree on membership changes here, given that the key schedule already confirms that we agree on the membership?  Basically, I don't understand (a) what cases need to be distinguished, (b) why do these cases need to be distinguished, and (c) why the required separation properties aren't provided by some other mechanism already.\r\n\r\nI would also note that you don't get the benefits of key separation unless the recipients know how to verify that the usage is right for the injection context. (Otherwise, a malicious PSK sender can send the wrong value.)  For the same/different group, that's easy enough to do based on key schedule continuity.  But membership is problematic.  For example, if you're changing the ciphersuite between extraction and injection, then all of the KeyPackages and Credentials will be different -- what do you compare to verify equality?\r\n\r\nI can update #518 to add PSKUsage, but the cases we put there need to at least be enforceable, and ideally fit into some principled taxonomy (even if all the cases in the taxonomy aren't enforceable).",
          "createdAt": "2021-12-14T15:38:07Z",
          "updatedAt": "2021-12-14T15:38:07Z"
        },
        {
          "author": "br-hale",
          "authorAssociation": "CONTRIBUTOR",
          "body": "For the record, distinguishing on ciphersuite changes was brought up earlier in the WG - I am in the support if bringing it back on the discussion table is an option...\r\nSeparately though, for most other changes during the lifespan of a group, proposals basically perform a similar action for distinguishing between keys and separating changes from epoch to epoch. The difference with the PSK is there is no \"one way\" to interpret a PSK's use (as compared to e.g. a ciphersuite change). This also means that it can be more challenging to provably separate out misuse. \r\n[BTW: I am assuming in this discussion you mean ciphersuite change in the context of the listed components, since reinit is actually used for ciphersuite key changes per line 1598.]\r\n\r\nYou are quite correct that there is a group-external use, i.e. the \"different group\" case. However, anything outside of the group/session is an external/exporter key use. Namely, the MLS protocol spec is about a single session and anything that is used in other groups/sessions is an external key (similar to TLS export from session). The distinction between PSK usage and external/exporter keys (whether the latter is used for another application or injected into a different group entirely) is that PSK use is within the analysis bounds of the given session. To this point, there is a gray area on item 2 (subgroup-internal use / resumption by a proper subset of members). This is probably the only one I could see an argument for also pushing as an exporter key use. \r\n\r\nThe issue of some members added between PSK usage is really reducible to two cases: a) a member was already in the set and the PSK use appears as item 1 or 3 (group-internal use or session-internal use) or b) a member was added and the PSK offers no security beyond that of an exporter key inject. The potential value proposition is for existing members, there is no loss for a new member, and the it is better to offer the value as possible than to deny it based on the weakest link.\r\n\r\nThe issue of some members being removed between PSK usage is similarly reducible. If the ejected member does not have the current group state then knowing a PSK should not provide value. It is similar to knowing an exporter key but having no place to export it into. The goal of PSK usage is to strengthen an existent system vs. being the sole point of security for that. If our KDF is done correctly, then combing current group state and the PSK will not be problematic (former unknown but latter known to the ejected member).\r\n\r\n",
          "createdAt": "2021-12-15T02:46:00Z",
          "updatedAt": "2021-12-15T02:46:00Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "So @kkohbrok and I had some offline discussion about this, and it led me to the conclusion that what I'm really grumpy about is a need for more clarity in the branch and reinit definitions.  We don't need a full taxonomy of uses if (a) we can say \"use this PSK usage for this specific protocol feature\", and (b) we have some escape hatch that allows for usages of resumption PSKs outside those specific protocol features.\r\n\r\nI have filed #525 reflecting this theory.  Hopefully folks find it more agreeable.",
          "createdAt": "2021-12-15T15:45:41Z",
          "updatedAt": "2021-12-15T15:45:41Z"
        },
        {
          "author": "br-hale",
          "authorAssociation": "CONTRIBUTOR",
          "body": "That seems like a well-reasoned solution. ",
          "createdAt": "2021-12-17T06:15:35Z",
          "updatedAt": "2021-12-17T06:15:35Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed with #518  and #525 ",
          "createdAt": "2022-01-19T17:12:58Z",
          "updatedAt": "2022-01-19T17:12:58Z"
        }
      ]
    },
    {
      "number": 503,
      "id": "I_kwDOBoyH6c4-p7DW",
      "title": "Ciphersuite Addition",
      "url": "https://github.com/mlswg/mls-protocol/issues/503",
      "state": "CLOSED",
      "author": "br-hale",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "I suggest that we consider including a ciphersuite that enables AES256 GCM with SHA384 and that for signatures ECDSA with P-384 (and SHA-384) is also permitted. The NSA restricts commercial applications to certain algorithms for applications that are used in or in coordination with the U.S. federal government and, from a general availability perspective, adding this could expand protocol use potential. ",
      "createdAt": "2021-11-11T16:54:53Z",
      "updatedAt": "2021-12-01T18:22:10Z",
      "closedAt": "2021-12-01T18:22:10Z",
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "I presume you're thinking of [Suite B](https://apps.nsa.gov/iaarchive/programs/iad-initiatives/cnsa-suite.cfm) here?  I realize that the table specifies P-384 and SHA-384; is it your understanding that it forbids using bigger curves/hashes?",
          "createdAt": "2021-11-16T22:48:20Z",
          "updatedAt": "2021-11-16T22:48:20Z"
        },
        {
          "author": "br-hale",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Both Suite B and alignment to the [Commercial Capability Packages](https://www.nsa.gov/Resources/Commercial-Solutions-for-Classified-Program/Capability-Packages/#data-at-rest). The other options currently in the spec, size accounted for, do not align to requirements.",
          "createdAt": "2021-11-17T22:27:12Z",
          "updatedAt": "2021-11-17T22:27:12Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "You didn't answer my question about forbidding the use of bigger curves/hashes.  Would the cases you're interested in be covered by the AES-256 / SHA-512 / P-521 suite?",
          "createdAt": "2021-11-19T20:34:27Z",
          "updatedAt": "2021-11-19T20:34:27Z"
        }
      ]
    },
    {
      "number": 504,
      "id": "I_kwDOBoyH6c4-tHWM",
      "title": "KeyPackage ID vs KeyPackage Identifier",
      "url": "https://github.com/mlswg/mls-protocol/issues/504",
      "state": "CLOSED",
      "author": "franziskuskiefer",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "There's a KeyPackageID ( 7.1. Key Package IDs ) and a KeyPackage Identifiers ( 7.4. KeyPackage Identifiers ) right now.\r\nThis is pretty confusing and probably not necessary. \r\n\r\nAs far as I can tell the only difference is that the KeyPackageID has to be unique within a group. If we add this restriction to the KeyPacakge Identifier, for example by adding the key package hash, we could get rid of the KeyPackageID and the confusion.",
      "createdAt": "2021-11-12T14:19:50Z",
      "updatedAt": "2021-12-01T18:21:19Z",
      "closedAt": "2021-12-01T18:21:19Z",
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "IMO there is a useful distinction here.  The KeyPackage identifier extension is application provided, and can contain something more / differently useful than just a hash.\r\n\r\nIn #510 I renamed KeyPackageID to KeyPackageRef, which should help?",
          "createdAt": "2021-11-16T22:46:16Z",
          "updatedAt": "2021-11-16T22:46:16Z"
        },
        {
          "author": "franziskuskiefer",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Fair enough. The `KeyPackageRef` description is certainly better than the `KeyPackageID` and avoids confusion.",
          "createdAt": "2021-11-17T07:58:51Z",
          "updatedAt": "2021-11-17T07:58:51Z"
        }
      ]
    },
    {
      "number": 505,
      "id": "I_kwDOBoyH6c4-ukfi",
      "title": "Add is unnecessary in external Commit",
      "url": "https://github.com/mlswg/mls-protocol/issues/505",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "When a new joiner sends an external Commit, within the current structure, they have to generate and send **two** KeyPackages:  First in an Add proposal, and second in `Commit.path.leaf_key_package`.  Obviously, this is wasteful, since the second immediately overwrites the first.  It also complicates receiver processing, since the receiver has to find where the appropriate Add happened so that it knows the sender's index in the new tree, so that it knows how to apply the update path in the Commit.\r\n\r\nWe should remove the requirement for an Add commit in an external Commit, and instead assign the new member the leftmost free slot after all proposals have been applied, then apply the commit from there.",
      "createdAt": "2021-11-12T20:45:00Z",
      "updatedAt": "2021-12-01T18:21:52Z",
      "closedAt": "2021-12-01T18:21:52Z",
      "comments": [
        {
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "body": "I agree that the key package in the Add proposal is redundant.\r\nI'm not so sure it will simplify implementations so much, because key packages from the update path of a Commit are usually treated like Update proposals (e.g. the constraint that the identity must be the same between the old and new credential).\r\nTl;DR: I agree with the change, but I want to raise awareness about issues this introduces.",
          "createdAt": "2021-11-20T11:46:02Z",
          "updatedAt": "2021-11-20T11:46:02Z"
        }
      ]
    },
    {
      "number": 506,
      "id": "I_kwDOBoyH6c4-u3z_",
      "title": "Use smaller, fixed-size hash-based identifiers",
      "url": "https://github.com/mlswg/mls-protocol/issues/506",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Right now, we use hash-based identifiers to reference KeyPackages (e.g., in KeyPackageID) and Proposals (ProposalOrRef).  To avoid truncating hashes, we use full-sized hashes, which are (a) much larger than necessary and (b) vary in size depend on the ciphersuite.\r\n\r\nWe should consider moving toward hash-identifiers that are of a fixed size just long enough to make collisions negligible (say 128 bits, like a UUID).  A rough proposal:\r\n\r\n```\r\nopaque HashIdentifier[16];\r\n\r\nMakeHash(value) = KDF.expand(KDF.extract(\"\", value), \"MLS 1.0 id\", 16)\r\n```",
      "createdAt": "2021-11-12T23:22:06Z",
      "updatedAt": "2021-12-01T18:21:19Z",
      "closedAt": "2021-12-01T18:21:19Z",
      "comments": []
    },
    {
      "number": 516,
      "id": "I_kwDOBoyH6c4_YcyV",
      "title": "Discard pending Update proposals for the sender if a `path` is included",
      "url": "https://github.com/mlswg/mls-protocol/issues/516",
      "state": "CLOSED",
      "author": "kkohbrok",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Any Update proposal for the sender is redundant if the Commit includes a `path`.",
      "createdAt": "2021-11-25T09:59:49Z",
      "updatedAt": "2021-12-01T18:13:54Z",
      "closedAt": "2021-12-01T18:13:54Z",
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "This is true, but they're also harmless, since the information in the `path` will overwrite all of their effects.\r\n\r\nNote that:\r\n* A requirement to this effect would only be binding on a committer.  The receiver of a Commit MUST process all of the referenced proposals, as prescribed in the Commit.\r\n* A `path` is required if a Commit covers Updates or Removes; if a Commit covers a self-Update, then it must have a `path`.   So there's no reasn to condition on \"if a `path` is included\".\r\n\r\nThis seems fine for some advisory text, but not an absolute prohibition.",
          "createdAt": "2021-11-30T23:26:54Z",
          "updatedAt": "2021-11-30T23:26:54Z"
        },
        {
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The way I read Section 11.2 is that the receiver should verify that the committer has followed the rules, e.g. that the commit contains all valid proposals, etc., even if that is not explicit in the list of things the receiver of a commit should do. So any requirement on the committer would also affect the receiver. So if we mandate that a committer can't include self-updates if the path is populated, then it would be implicit that the receiver checks that the committer actually followed the rules when processing a commit.\r\n\r\nI'm not sure I understand your second point. My reasoning would be that if a committer wants to do an update, they would just include a path rather than an update proposal, which is redundant anyway.",
          "createdAt": "2021-12-01T06:47:57Z",
          "updatedAt": "2021-12-01T06:47:57Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Sorry @kkohbrok, I missed that there was still conversation going on here before merging #517.\r\n\r\nOn the latter point: All I'm saying is that there is no case where there is both (a) a self-update and (b) no `path`.  So you're always in the bad scenario :)\r\n\r\nIn our Wire chat, you made a good point that repeated proposals for the same leaf are invalid, and self-Updates are effectively repeats of the `path`.  Reopening, will  file a fresh PR to adjust the text.",
          "createdAt": "2021-12-01T14:58:19Z",
          "updatedAt": "2021-12-01T14:58:19Z"
        }
      ]
    },
    {
      "number": 528,
      "id": "I_kwDOBoyH6c5Ajrn9",
      "title": "Include `context` in `MLSPlaintextTBS` for sender_type `NewMember`",
      "url": "https://github.com/mlswg/mls-protocol/issues/528",
      "state": "CLOSED",
      "author": "kkohbrok",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "From what I can see, there is no reason not to sign the context in the case of an external init. I'm not sure why it got taken out, but while implementing external inits, verification went through even when including the context.",
      "createdAt": "2021-12-17T10:11:11Z",
      "updatedAt": "2022-01-26T14:49:24Z",
      "closedAt": "2022-01-26T14:49:24Z",
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "As I commented in #526, it's not even clear that we need this context any more for members any more, given `membership_tag` for MLSPlaintext and the AEAD of MLSCiphertext.  So I would propose we just remove the context added to MLSPlaintextTBS altogether.\r\n\r\n@beurdouche IIRC you were the one that proposed adding the context.  WDYT?",
          "createdAt": "2022-01-06T21:43:04Z",
          "updatedAt": "2022-01-06T21:43:04Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "This was fixed in #526 ",
          "createdAt": "2022-01-26T14:49:24Z",
          "updatedAt": "2022-01-26T14:49:24Z"
        }
      ]
    },
    {
      "number": 530,
      "id": "I_kwDOBoyH6c5Aj4q4",
      "title": "Require uniqueness of RatchetTreeExtensions in GroupInfo",
      "url": "https://github.com/mlswg/mls-protocol/issues/530",
      "state": "CLOSED",
      "author": "kkohbrok",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "A GroupInfo (or a PublicGroupState) should only ever contain one RatchetTreeExtension. Either that or it should be specified what happens if there is more than one.",
      "createdAt": "2021-12-17T11:09:22Z",
      "updatedAt": "2022-01-19T17:06:28Z",
      "closedAt": "2022-01-19T17:06:28Z",
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Seems like we should be able to make a general proclamation that extension IDs MUST be unique in a given vector of extensions, whether that's GroupContext, KeyPackage, GroupInfo, GroupContextExtensions, etc.",
          "createdAt": "2022-01-06T21:34:29Z",
          "updatedAt": "2022-01-06T21:34:29Z"
        },
        {
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Sounds good to me. I'll draft a PR.",
          "createdAt": "2022-01-10T06:59:49Z",
          "updatedAt": "2022-01-10T06:59:49Z"
        }
      ]
    },
    {
      "number": 531,
      "id": "I_kwDOBoyH6c5Ak7dL",
      "title": "MLS version is used inconsistently in strings",
      "url": "https://github.com/mlswg/mls-protocol/issues/531",
      "state": "CLOSED",
      "author": "raphaelrobert",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Both \"mls10\" and \"MLS 1.0\" are used. I'd go for \"mls10\" everywhere.",
      "createdAt": "2021-12-17T16:26:39Z",
      "updatedAt": "2022-01-26T13:16:32Z",
      "closedAt": "2022-01-26T13:16:32Z",
      "comments": []
    },
    {
      "number": 534,
      "id": "I_kwDOBoyH6c5BSz6T",
      "title": "Improve padding description ",
      "url": "https://github.com/mlswg/mls-protocol/issues/534",
      "state": "CLOSED",
      "author": "tomleavy",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "In section 14.1 Message Encryption and Decryption there is a paragraph describing the reasons why you would want to use padding, and part of that mentions the following\r\n\r\nAs the padding mechanism is used to improve protection against traffic analysis, removal of the padding SHOULD be implemented in a \"constant-time\" manner at the MLS layer and above layers to prevent timing side-channels that would provide attackers with information on the size of the plaintext. The padding length length_of_padding can be chosen at the time of the message encryption by the sender.\r\n\r\nThis seems out of date given that padding is a separate field that doesn't need to be explicitly stripped off at decrypt time and there is no other mention of `length_of_padding` in the document.",
      "createdAt": "2022-01-06T15:53:58Z",
      "updatedAt": "2022-01-19T17:06:03Z",
      "closedAt": "2022-01-19T17:06:03Z",
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "That seems right.  We used to have a more clever, more economical padding scheme mirroring what TLS does.  But that got rationalized a while ago.  These are probably dangling references.  Want to send a PR?",
          "createdAt": "2022-01-06T21:44:20Z",
          "updatedAt": "2022-01-06T21:44:20Z"
        },
        {
          "author": "tomleavy",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Sounds good, pushed PR https://github.com/mlswg/mls-protocol/pull/536",
          "createdAt": "2022-01-10T16:36:10Z",
          "updatedAt": "2022-01-10T16:36:10Z"
        }
      ]
    },
    {
      "number": 537,
      "id": "I_kwDOBoyH6c5BdADG",
      "title": "Clarity around extensions and `RequiredCapabilities`",
      "url": "https://github.com/mlswg/mls-protocol/issues/537",
      "state": "CLOSED",
      "author": "tomleavy",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "The description of `RequiredCapabilities` is clear that proposals defined in the RFC are not to be included because they are considered standard, however there is no such clarification around extensions. \r\n\r\nIn general, extension requirements are not all that clear because in several places (such as Lifetime) it is mentioned that an extension must be included, however they are all listed as recommended rather than required in the table. It also raises a question in that if an extension is required to be implemented as part of the specification, and required in every KeyPackage, should it just be a field rather than an extension?",
      "createdAt": "2022-01-10T16:45:24Z",
      "updatedAt": "2022-01-27T22:26:35Z",
      "closedAt": "2022-01-27T22:26:35Z",
      "comments": [
        {
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> The description of `RequiredCapabilities` is clear that proposals defined in the RFC are not to be included because they are considered standard, however there is no such clarification around extensions.\r\n\r\nEven that is not quite clear to me. At least to me it doesn't follow from Section 10.1.\r\n\r\n> In general, extension requirements are not all that clear because in several places (such as Lifetime) it is mentioned that an extension must be included, however they are all listed as recommended rather than required in the table. It also raises a question in that if an extension is required to be implemented as part of the specification, and required in every KeyPackage, should it just be a field rather than an extension?\r\n\r\nThe last one at least, I can shed some light on, as we had this discussion before and I was arguing the same thing. From what I remember, the argument was the keeping it an extension rather than a field would force implementers to implement the Extension mechanism. I don't have a super strong opinion here, but I seem to remember that that's what it boiled down to.\r\n\r\nI generally agree, though, that some things around RequiredCapabilities (RC) and Capabilities in general is unclear. I discussed this with @raphaelrobert and here are some examples/questions that came up:\r\n\r\n* If a group doesn't have an RC extension, can we assume that all extensions/proposals in the spec are supported by everyone, or do we have to check all KeyPackages?\r\n* Do we want all extensions/proposals in the spec to be MTI and thus implicitly supported by everyone? It might be useful to distinguish between basic (MTI) ones like Add, Remove, etc. and consider some optional such as ExternalInit or AppAck.\r\n* Relatedly, should the `Capabilities` extension in the KeyPackage list all the Spec proposals/extensions, too? Are they invalid if they do or if they don't? \r\n* We might want to discuss the difference between RC and a potential group policy. The way I understand it, RC is not meant to be an allow list or a block list, but instead should specify a minimum requirement for all clients in the group. A question here would be: If it's not in the RC, but everyone's capabilities support it, can I use/send it?",
          "createdAt": "2022-01-19T16:53:06Z",
          "updatedAt": "2022-01-19T16:53:06Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Reacting to Konrad's points here:\r\n\r\n* It seems like to to be sure, you always need to check.  RC just helps ensure that the check will produce the right answer.\r\n* I would propose the answer to this be \"Yes, the proposals/extensions in the spec are MTI\"\r\n* If the answer to the prior question is as I propose, then you don't need to list spec proposals/extensions in Capabilities\r\n* The difference between RC and checking everyone supports it is whether we expect it to be supported in the future.  For Proposals, that might not matter; for GroupContext extensions, it matters more.\r\n\r\nIt also seems like there's a fair argument that RequiredCapabilities should just be removed from the spec and replaced by some application-layer coordinated policy.  I would be OK with that.\r\n\r\nTo @tomleavy's point about mandatory extensions -- I would probably be OK with converting mandatory extensions to fields, especially with the better division of labor proposed in #539.  ",
          "createdAt": "2022-01-20T13:27:52Z",
          "updatedAt": "2022-01-20T13:27:52Z"
        },
        {
          "author": "tomleavy",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I kind of like the idea of RequiredCapabilities because it enforces the proper checks lower down. Application layer would need to proxy packets via a middleware type of layer which could potentially be messy. \n\n",
          "createdAt": "2022-01-20T13:56:52Z",
          "updatedAt": "2022-01-20T13:56:52Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Discussion on working call:\r\n\r\n* Agreement to not list in-spec capabilities in RC/Capabilities, so all those things are MTI",
          "createdAt": "2022-01-27T15:52:34Z",
          "updatedAt": "2022-01-27T15:52:34Z"
        }
      ]
    },
    {
      "number": 538,
      "id": "I_kwDOBoyH6c5BdDmk",
      "title": "KeyPackage lifetime handling",
      "url": "https://github.com/mlswg/mls-protocol/issues/538",
      "state": "CLOSED",
      "author": "tomleavy",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "The RFC currently says the following:\r\n\r\nA client MUST NOT use the data in a KeyPackage for any processing before the not_before date, or after the not_after date.\r\n\r\nClarification would be helpful here because this could be interpreted in different ways and I imagine this would be a point of contention when trying to gain compatibility between implementations. \r\n\r\nExamples: \r\n\r\n* A key package expires after it has been placed into a leaf\r\n* A key package has an expiration in 1 month, a commit is made which places it into a leaf, and a member of the group receives that commit 1 month later due to them being offline",
      "createdAt": "2022-01-10T16:55:49Z",
      "updatedAt": "2022-01-27T16:15:53Z",
      "closedAt": "2022-01-27T16:15:53Z",
      "comments": [
        {
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Good point and good examples as well. Unfortunately, we're using KeyPackages and the key material in it in two roles: a) as pre-published key material that can be used by others to add new members to a group and b) as as the key material representing a member in a group. I always thought of key package expiration as relevant for role a), where when adding a member, their key material has to be reasonably fresh, since for pre-published keys, the lifetime limit is the only way a client can know that they have achieved PCS at some point (without trusting the server and assuming there is no trusted and reliable revocation mechanism). For role b) it's more of a tracker of when a given party has last made an update.\r\n\r\nI would imagine example 1 is more of a policy question. If a key package expires while it's already in a group (role b), the policy could be to remove that member (and maybe even to prohibit any group activity until this was done) or to not accept any messages from that member other than an update, etc.\r\n\r\nDue to asynchronicity, I don't think we will be able to reliably solve example 2. We could have the committer (and maybe even the DS) add a time-stamp, so the receiver can more easily distinguish between themselves receiving an old commit and the committer trying to do something fishy, but there we're also relying on clocks \ud83e\udd37\ud83c\udffb.\r\n\r\nDepending on what we want for the spec, it might be worth to have different structs for the two roles. That would also enable us to get slightly better FS guarantees as suggested by @psyoptix a while ago by using different key pairs for group participation and Welcome encryption.",
          "createdAt": "2022-01-11T07:17:16Z",
          "updatedAt": "2022-01-11T07:17:16Z"
        },
        {
          "author": "tomleavy",
          "authorAssociation": "CONTRIBUTOR",
          "body": "That makes sense to me @kkohbrok , I touched on this a little bit in #537 in that it `ParentHash` ext seems like it deserves to be a field rather than an extension. If we made that change you have a scenario where `KeyPackage` always does not have a `ParentHash` ext when used to add someone, and it always has a `ParentHash` ext when it is situated in a tree, so different types make sense.\r\n\r\nI would say though we would have to be careful to not break `ParentHash` functionality or signatures since I believe there is a step when you join a group where you verify all the key package signatures in the tree",
          "createdAt": "2022-01-12T15:39:01Z",
          "updatedAt": "2022-01-12T15:39:01Z"
        },
        {
          "author": "tomleavy",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@kkohbrok the one concern I had about not checking the lifetime upon receiving an add was just that I have no way to verify the sender of the add actually did a reasonable check. I don't see a way to resolve this problem though tbh",
          "createdAt": "2022-01-12T15:53:47Z",
          "updatedAt": "2022-01-12T15:53:47Z"
        },
        {
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> @kkohbrok the one concern I had about not checking the lifetime upon receiving an add was just that I have no way to verify the sender of the add actually did a reasonable check. I don't see a way to resolve this problem though tbh\r\n\r\nYes, that one's tricky and I don't think there's a way to solve it properly. However, if you mandate by policy that the sender includes a time stamp (e.g. via a `time_of_add` extension or something similar) and you don't assume the sender is actively malicious or their clock is totally out-of-whack, then you can compare that with the expiration date of the KeyPackage included in the Add to get some idea of whether the KeyPackage was valid when the commit was done. This reminds me that committers should probably check all Add proposals for expired KeyPackages, since the proposal could have been sent well in advance of the actual commit. In any case, it would probably make sense to cover this explicitly either in the spec or in the architecture doc.",
          "createdAt": "2022-01-13T07:05:09Z",
          "updatedAt": "2022-01-13T07:05:09Z"
        },
        {
          "author": "tomleavy",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Closing in favor of #539 . The separation there will make it obvious when Lifetime matters",
          "createdAt": "2022-01-27T16:15:53Z",
          "updatedAt": "2022-01-27T16:15:53Z"
        }
      ]
    },
    {
      "number": 539,
      "id": "I_kwDOBoyH6c5BlRUu",
      "title": "Separation between pre-published key packages and leaf node content",
      "url": "https://github.com/mlswg/mls-protocol/issues/539",
      "state": "CLOSED",
      "author": "TWal",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "`KeyPackage`s currently have two usages in the spec:\r\n1. Pre-published key packages that you can download and put in a leaf when adding a new member\r\n2. leaf node content that you update when doing a full `Commit`\r\n\r\nCurrently, things have been designed to use only one structure for both uses, leading to some weirdness such as:\r\n- `version` and `cipher_suite` are useful in the usage 1, but are parameters of the group in usage 2.\r\n- `hpke_init_key` is a good name in usage 1, but would better be named `hpke_key` in usage 2.\r\n- some data is important in usage 2 and have no meaning in usage 1, hence they were designed as \"mandatory-when-updating extensions\" (such as `ParentHash`, and we were also discussing about adding the `group_id` in #527 to help prevent cross-group attacks)\r\n\r\nHow about using different structures for these?\r\n\r\n    // Essentially identical to KeyPackage\r\n    struct {\r\n        ProtocolVersion version;\r\n        CipherSuite cipher_suite;\r\n        HPKEPublicKey hpke_init_key;\r\n        opaque endpoint_id<0..255>;\r\n        Credential credential;\r\n        Extension extensions<8..2^32-1>;\r\n        opaque signature<0..2^16-1>;\r\n    } PrePublishedKeyPackage;\r\n    \r\n    struct {\r\n        HPKEPublicKey hpke_key;\r\n        opaque endpoint_id<0..255>;\r\n        Credential credential;\r\n        opaque parent_hash<0..255>;\r\n        opaque group_id<0..255>;\r\n        Extension extensions<8..2^32-1>;\r\n        opaque signature<0..2^16-1>;\r\n    } LeafNodeContent;\r\n    \r\n    enum {\r\n        reserved(0),\r\n        pre_published_key_package(1),\r\n        leaf_node_content(2),\r\n        (255)\r\n    } LeafNodeType;\r\n    \r\n    struct LeafNode {\r\n        // This is not included in the signature, but with the \"unambiguous signature\" PR that's not a problem\r\n        LeafNodeType type;\r\n        select(LeafNode.type) {\r\n            case pre_published_key_package:\r\n                PrePublishedKeyPackage data;\r\n            case leaf_node_content:\r\n                LeafNodeContent data;\r\n        }\r\n    }\r\n\r\nWhat would you think about refactoring `KeyPackage` like this?",
      "createdAt": "2022-01-12T12:34:44Z",
      "updatedAt": "2022-02-13T15:49:31Z",
      "closedAt": "2022-02-13T15:49:31Z",
      "comments": [
        {
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "If we're doing this, I'd suggest including a dedicated public key to encrypt Welcome messages to for the `PrePublishedKeyPackage`. @psyoptix suggested this at some point. It gives us better FS guarantees, because the receiver of the `Welcome` can delete the corresponding private key immediately after decryption, while they might have to keep the other key around for a bit until they can actually issue an update.\r\n\r\nThis might also help clarify #538.",
          "createdAt": "2022-01-12T13:00:19Z",
          "updatedAt": "2022-01-12T13:01:00Z"
        },
        {
          "author": "tomleavy",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Ties into #537 as well because `ParentHash` is an example of an extension that is required and should be a field instead",
          "createdAt": "2022-01-12T15:41:00Z",
          "updatedAt": "2022-01-12T15:41:00Z"
        },
        {
          "author": "tomleavy",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@TWal one concern I have is how is that `signature` field in `LeafNodeContent` created? ",
          "createdAt": "2022-01-12T15:44:35Z",
          "updatedAt": "2022-01-12T15:44:35Z"
        },
        {
          "author": "TWal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "When sending a full `Commit`, the participant includes a new `LeafNodeContent` in the `UpdatePath` (it replaces the `leaf_key_package` field).\r\nIt computes the signature with `SignWithLabel(signature_key, \"LeafNodeContent\", LeafNodeContentTBS)` where:\r\n- `LeafNodeContentTBS` corresponds to all the fields of `LeafNodeContent` except `signature` (the usual thing)\r\n- `SignWithLabel` comes from #526 ",
          "createdAt": "2022-01-12T15:51:48Z",
          "updatedAt": "2022-01-12T15:51:48Z"
        },
        {
          "author": "tomleavy",
          "authorAssociation": "CONTRIBUTOR",
          "body": "What about the scenario where Alice pulls down Bob's key package to add him to the group? In that case Alice can't do the conversion between formats on Bob's behalf. ",
          "createdAt": "2022-01-13T01:31:15Z",
          "updatedAt": "2022-01-13T01:31:36Z"
        },
        {
          "author": "TWal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Alice don't have to do the conversion, this is why `LeafNode` either contain a `PrePublishedLeafPackage` (when adding someone to the group) or a `LeafNodeContent` (when updating your own key package).",
          "createdAt": "2022-01-13T09:09:09Z",
          "updatedAt": "2022-01-13T09:09:09Z"
        },
        {
          "author": "tomleavy",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Ah somehow I missed that part in your original post. Makes sense",
          "createdAt": "2022-01-13T13:40:34Z",
          "updatedAt": "2022-01-13T13:40:34Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "I like this general direction.  It solves a few things.\r\n\r\nInstead of having leaf nodes contain either a prepublished thing or a normal leaf node, how about having the prepublished thing wrap the leaf node thing?  As a bonus, we get separation between the key pair used for Welcome encryption and the key pair that goes in the leaf for TreeKEM.\r\n\r\n```\r\nstruct {\r\n    HPKEPublicKey hpke_key; // used for TreeKEM\r\n    opaque endpoint_id<0..255>;\r\n    Credential credential;\r\n    opaque parent_hash<0..255>; // empty when prepublished\r\n    Extension extensions<8..2^32-1>; // MUST have capabilities\r\n    opaque signature<0..2^16-1>;\r\n} LeafNodeContent;\r\n\r\n// Adds the things that aren't in the leaf node and wraps in another signature\r\nstruct {\r\n    ProtocolVersion version;\r\n    CipherSuite cipher_suite;\r\n    HPKEPublicKey init_key; // used for Welcome\r\n    LeafNodeContent leaf_node;\r\n    Extension extensions<8..2^32-1>; // MUST have lifetime\r\n    opaque signature<0..2^16-1>;\r\n} KeyPackage; // no need for \"PrePublished\"\r\n```\r\n\r\nThen when Alice adds Bob, she extracts his LeafNodeContent and sends that in the Add.  That doesn't let the other members of the group verify that Alice did the right thing w.r.t. expiry, but I'm not heartbroken about that.\r\n\r\nWe might also be able to remove the extensions field from the outer (KeyPackage) wrapping if we turn the `lifetime` extension into KeyPackage field.  I expect we probably need leaf extensions, but would be open to making `capabilities` into a field.",
          "createdAt": "2022-01-19T17:37:45Z",
          "updatedAt": "2022-01-19T17:37:45Z"
        },
        {
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Why not keep sending the KeyPackage in the Add? That wouldn't cost much and would allow everyone to validate the lifetime. Note, that the lifetime is crucial in achieving PCS for pre-published key material. If I compromise Bob and get hold of the private key material of a bunch of his KeyPackages, I can add \"Bob\" to any group I want as long as the Credential inside the LeafNodeContent remains valid and Bob doesn't revoke the LeafNodeContent somehow.\r\n\r\nAlso, we'll have to do this if we want to enable any member to send the Welcome message as you proposed here: https://github.com/mlswg/mls-protocol/pull/525#discussion_r788056226.",
          "createdAt": "2022-01-20T08:09:10Z",
          "updatedAt": "2022-01-20T08:09:10Z"
        },
        {
          "author": "TWal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I agree that including `LeafNodeContent` inside `KeyPackage` is quite clean, but something is bothering me with this approach: I'd like that the `group_id` is signed by the participant occupying that leaf, to protect against cross-group attacks.\r\n\r\nIn the first message of this issue I did this by including `group_id` in `LeafNodeContent`, but in fact we don't need to store it in the leaf, we just need to include it in the `LeafNodeContentTBS`.\r\n\r\nIn any case, if we want to include `group_id` in the signature, we need a way to differentiate between leaves that triggered a commit and the ones that are \"fresh\". And for that I think using a tagged-union struct is the cleanest way to do it.\r\n",
          "createdAt": "2022-01-20T12:53:24Z",
          "updatedAt": "2022-01-20T12:53:24Z"
        },
        {
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "It always feels a bit lazy to use an extension (and implementations have to be careful to check for their presence), but we could use a `GroupId` extension in the same way that we use a `ParentHash` extension. You will find both of them only on LeafContents that were updated at least once.\r\n\r\nAnother result of including GroupId in the KeyPackage is that the signature will explicitly sign the `GroupId` and I'm not sure if that doesn't completely destroy any deniability guarantees we can still get from MLS.",
          "createdAt": "2022-01-20T13:09:17Z",
          "updatedAt": "2022-01-20T13:09:17Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "I don't think there's really a good way to get the `group_id` into the leaf.  Because of prepublication, it would have to be optional, but in order to prevent attacks, you need rules to decide whether it's required in a given situation.  It seems like the best you can do is basically TOFU:\r\n\r\n* When you first get the tree, you can't validate whether the group_id should be in a given leaf or not\r\n* Once you're a member, you require that group_id is sent in Update and UpdatePath.leaf_key_package\r\n\r\nI could live with a solution of that character, but given it's a bit complex, might prefer to leave it out unless we get a useful property from it.\r\n\r\n@kkohbrok - Re: Sending KeyPackage in Add - Yep, that makes sense.  So you would send KeyPackage in Add, and LeafNode in Update.",
          "createdAt": "2022-01-20T13:42:07Z",
          "updatedAt": "2022-01-20T13:42:07Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "I tried to worked through what would be necessary to implement this.  It looks like it would require some fairly invasive changes to be made to rationalize the document's structure before making this change.  But those changes should probably be made anyway.  Proposal:\r\n\r\nPreparatory PR: Rationalize layout\r\n* Move \"Cryptograhic Objects\" to before \"Ratchet Trees\"\r\n* Update \"Ratchet Tree Nodes\" to define ParentNode and LeafNode structs, with LeafNode initially just equal to KeyPackage\r\n* Move subsections of \"Key Packages\" to under \"Ratchet Trees\"\r\n  * Parent Hash\r\n  * Tree Hashes\r\n  * Update Paths\r\n* Move Group State to its own top-level section\r\n\r\nMain PR:\r\n* Change LeafNode to have the required content:\r\n  * HPKE key for TreeKEM\r\n  * Credential\r\n  * Parent hash\r\n  * Capabilities\r\n  * Extensions\r\n  * Signature\r\n* Change KeyPackage to refer to LeafNode for internals, plus:\r\n  * HPKE key for Welcome\r\n  * Lifetime\r\n  * Extensions\r\n  * Signature\r\n* Add continues to send KeyPackage\r\n* Update and Commit send LeafNode instead of KeyPackage\r\n* Remove and Sender refer to LeafNodeRef instead of KeyPackageRef\r\n\r\nWe should probably do the preparatory PR regardless of this issue.",
          "createdAt": "2022-01-26T15:18:19Z",
          "updatedAt": "2022-01-26T15:18:53Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Discussion on working call:\r\n\r\n* General agreement on the approach\r\n* Should sign group_id when possible\r\n   * Include in TBS if we at least have a flag for pre-published / in-group\r\n   * Or we can store it\r\n   * Or we could have independent structs for pre-published / in-group leaves\r\n* Do we need extensions at both levels?\r\n   * Capabilities / lifetime should probably be promoted to fields",
          "createdAt": "2022-01-27T16:14:46Z",
          "updatedAt": "2022-01-27T16:14:46Z"
        }
      ]
    },
    {
      "number": 540,
      "id": "I_kwDOBoyH6c5BqThG",
      "title": "Proposals by reference in external commit",
      "url": "https://github.com/mlswg/mls-protocol/issues/540",
      "state": "CLOSED",
      "author": "kkohbrok",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "The spec currently doesn't distinguish much between an external and a member commit w.r.t. how proposals by reference are handled. In theory, the server could keep track of proposals and send the external committer all proposals that were sent up until the time they want to commit externally. However, there are a few difficulties in committing proposals by reference in an external commit.\r\n\r\n* Membership tags: The external committer doesn't have the ability to verify membership tags on proposals. This is probably not a show-stopper, as proposals still need to be signed by a group member, but if nothing else, this should be noted in the spec.\r\n* Leaf positioning: The spec was changed such that the committer is added into the tree without an Add proposal being present. If there are other Add (and Remove) proposals present, it is unclear in what order they should be processed. Should the committer be added when the path is processed? Or should it still be processed as if it were an Add?\r\n\r\nThere are probably other things that can go wrong when committing referenced proposals externally, but those are the first that come to mind.\r\n\r\nThe simplest solution would be to simply ignore proposals by reference, although this would break the current principle that a commit must always include all valid proposals that were sent during the epoch. The consequence would be that Parties that sent proposals will have to re-send them if the epoch is ended by an external commit. It should be noted, that a Preconfigured sender will have no way to detect if their proposal was committed or not.",
      "createdAt": "2022-01-13T11:55:41Z",
      "updatedAt": "2022-01-28T18:38:48Z",
      "closedAt": "2022-01-28T18:38:48Z",
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "I'm not sure your worries here are very real:\r\n\r\n* Membership tags: I don't think the membership tag issue matters, because the existing members will reject the proposal (and thus the commit) if the membership tag is invalid; at worst the joiner gets themselves wedged into a group by themselves.  And as you say, they're signed, and they keys can be tied back to the tree hash in the GroupInfo.\r\n* Leaf positioning: We need to clear this up regardless of proposals-by-reference.  It seems like basically having a synthetic Add at the beginning or end of the proposal list would work fine.\r\n* Preconfigured proposer: This is a problem only when Commits are encrypted, so it's not a problem in the external commit case (since an external Commit cannot be encrypted).\r\n\r\nNonetheless, the point that an external joiner can't fully verify a Proposal seems to argue pretty strongly for forbidding proposals by reference.  I don't think this even violates the semantic of \"include all valid proposals received in the epoch\", since (1) that requirement is receiver oriented (it's not enough for the proposals to have been sent) and (2) the external joiner can't tell if the proposals or valid.\r\n\r\nOverall, I would lean slightly toward removing proposals by reference.  And if we do that, it might even make sense to just define an ExternalCommit message that packages together the few things that are still allowed.",
          "createdAt": "2022-01-19T17:50:27Z",
          "updatedAt": "2022-01-19T17:50:27Z"
        },
        {
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'm not sure I understand how the receiver-orientation of the \"all valid proposals must be included\" rule matters to its application to this case. If we remove the requirement for external commits to include proposals by reference and don't soften that rule to exclude external commits, receivers will consider all external commits invalid in the presence of valid pending proposals by reference.\r\n\r\nIn any case, I'm also in favor of keeping it simple and restrict the External Commit to a few, well defined components that do not include any proposals by reference.",
          "createdAt": "2022-01-20T07:57:36Z",
          "updatedAt": "2022-01-20T07:57:36Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Discussion on working call:\r\n\r\n* \"No proposals by reference\" kind of follows from \"all _valid_ proposals\", since the joiner can't necessarily determine that proposals are valid\r\n* Maybe allow attempts?  Might not get feedback to retry, though.  Whole point of external commit is to allow async.\r\n* Agreement to prohibit proposals by reference in external Commit",
          "createdAt": "2022-01-27T15:49:10Z",
          "updatedAt": "2022-01-27T15:49:10Z"
        }
      ]
    },
    {
      "number": 542,
      "id": "I_kwDOBoyH6c5B_UHj",
      "title": "Conflicting proposal / commit behavior",
      "url": "https://github.com/mlswg/mls-protocol/issues/542",
      "state": "CLOSED",
      "author": "tomleavy",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "There are several rules in terms of selecting proposals and issuing commits against them. I have distilled the existing wording in the document into the following rules\r\n\r\n1. If there are multiple updates for the same leaf, cherry pick one.\r\n2. If there is a remove and an update/add for the same key package, always choose remove\r\n3. If there are multiple group context extension updates, cherry pick one\r\n4. The sender of a commit MUST use all valid proposals it has received \r\n5. In the event that a valid proposal is omitted from the next Commit, the sender of the proposal SHOULD retransmit it in the new epoch\r\n\r\nIt seems that rule 4 and rule 5 conflict with each other in that one is suggesting that all proposals must be consumed or there should be a hard error, and the other assumes it is possible for a commit to purposefully leave out a proposal and it can optionally be retransmitted.\r\n\r\nI have been trying to write code that reasonably handles the cherry picking logic around multiple proposals referencing the same key package or multiple changes to group context while also enforcing the \"must use all valid proposals received\" rule, and it does introduce some complexity that maybe would be avoided by just eliminating that rule?\r\n",
      "createdAt": "2022-01-18T16:30:42Z",
      "updatedAt": "2022-01-27T19:07:23Z",
      "closedAt": "2022-01-27T19:07:23Z",
      "comments": [
        {
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Good point. One situation where rule 5 would make sense is if we prohibit proposals by reference in external commits to solve the problems outlined in #540. Rule 5 would otherwise make sense in situations, where there's no agreement on whether a proposal is valid. One case where this is necessarily the case is the following: A remove proposal was sent, but the client that is to be removed is the committer in this epoch. The client can't commit their own removal, but the proposal is still technically valid from the proposer's point of view. \r\n\r\nThere might be other situations, for example, where the application imposes some sort of policy that different clients interpret differently. This should be the application's problem, though.",
          "createdAt": "2022-01-19T07:46:14Z",
          "updatedAt": "2022-01-19T07:46:14Z"
        },
        {
          "author": "tomleavy",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think what I'm trying to boil this down to is, should my implementation throw an error if all proposals are not consumed by the process of applying the commit I just received? I'm still thinking enforcing that would be too difficult to apply everywhere. ",
          "createdAt": "2022-01-19T19:49:16Z",
          "updatedAt": "2022-01-20T03:02:09Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "@tomleavy I don't think you can be that strict, just because of the sender/receiver asymmetry.  Just because you received a Proposal doesn't mean that the committer did.  I would view the rules in the doc as local guidance for the committer in constructing a Commit.  Given that they don't reflect externally-visible behavior, they should probably be downgraded to SHOULD.",
          "createdAt": "2022-01-20T13:11:05Z",
          "updatedAt": "2022-01-20T13:11:05Z"
        },
        {
          "author": "tomleavy",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@bifurcation that makes sense to me, I'll put up a PR to change to SHOULD",
          "createdAt": "2022-01-20T13:50:57Z",
          "updatedAt": "2022-01-20T13:50:57Z"
        }
      ]
    },
    {
      "number": 557,
      "id": "I_kwDOBoyH6c5CigqQ",
      "title": "Relationship and definition of Key Schedule and Secret Tree?",
      "url": "https://github.com/mlswg/mls-protocol/issues/557",
      "state": "CLOSED",
      "author": "rohan-wire",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "In the Protocol Overview, Figure 1 shows a ratchet tree, commit_secret, epoch_secret, encryption_secret, and a secret tree, while the text discusses the epoch_secret and encryption_secret.\r\n\r\nThen the next section, Cryptographic State and Evolution states that \"There are two types of cryptographic state at the core of MLS:\" a key schedule, and a ratchet tree. The Secret Tree isn't mentioned there.\r\n\r\nThen we have a Key Schedule section which then includes a Secret Tree sub-section.\r\n\r\nReaders are left wondering what the relationship is between the the Key Schedule and Secret Tree.",
      "createdAt": "2022-01-27T15:06:09Z",
      "updatedAt": "2022-01-27T22:52:02Z",
      "closedAt": "2022-01-27T22:52:02Z",
      "comments": []
    },
    {
      "number": 558,
      "id": "I_kwDOBoyH6c5CipEB",
      "title": "Remove `endpoint_id`",
      "url": "https://github.com/mlswg/mls-protocol/issues/558",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "We added `endpoint_id` to have a way to reference a member that is stable over the member's lifetime in the group.  However, `endpoint_id` is never used in the protocol; the main need for such references is to give applications a way to tell an MLS stack what to do, e.g., which member to remove.\r\n\r\n`endpoint_id` isn't really required for this purpose, either:\r\n\r\n* Leaf indices have the same stability as `endpoint_id` (since members don't change leaves), and no need for explicit checks on uniqueness.\r\n* Applications can add their own unique identifiers in KeyPackage extensions\r\n* Applications often want to refer to _non-unique_ identifiers, e.g., asking to remove all devices belonging to an email address\r\n\r\nSo it seems like at this point, `endpoint_id` can safely be removed.",
      "createdAt": "2022-01-27T15:24:10Z",
      "updatedAt": "2022-02-03T15:23:37Z",
      "closedAt": "2022-02-03T15:23:37Z",
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "@Bren2010 @br-hale @kkohbrok - tagging you all here since I seem to recall you had opinions on this topic.",
          "createdAt": "2022-01-27T19:31:55Z",
          "updatedAt": "2022-01-27T19:31:55Z"
        },
        {
          "author": "br-hale",
          "authorAssociation": "CONTRIBUTOR",
          "body": "With the changes in enforcing consistent verification methods and the fact that a prior key signs off on any new signature key, I think we have a fairly consistent chain for the identity and the endpoint_id can probably be removed. Leaving it in may strengthen security in some way, but I do not immediately see an issue.",
          "createdAt": "2022-01-28T04:34:45Z",
          "updatedAt": "2022-01-28T04:34:45Z"
        },
        {
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "What @br-hale said. I left a comment in #509 regarding the details on the check, but otherwise, I think we're ok to remove `endpoing_id`. As you pointed out earlier @bifurcation, if an application decides it's necessary, they can always add it via an extension.",
          "createdAt": "2022-01-28T09:45:54Z",
          "updatedAt": "2022-01-28T09:45:54Z"
        }
      ]
    },
    {
      "number": 559,
      "id": "I_kwDOBoyH6c5Cjsun",
      "title": "Remove redundant nodes from the tree",
      "url": "https://github.com/mlswg/mls-protocol/issues/559",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Right now, the UpdatePath generation and processing algorithms populate \"redundant\" parent nodes in the tree, in the sense that they have only one child node.  These redundant nodes are harmless except that they make tree truncation less effective.  We should update the UpdatePath algorithms so that they do not add redundant nodes to the tree.",
      "createdAt": "2022-01-27T19:24:35Z",
      "updatedAt": "2022-02-18T19:44:00Z",
      "closedAt": "2022-02-18T19:44:00Z",
      "comments": [
        {
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "body": "I think the definition of redundant is slightly different than what you propose. Redundant nodes are nodes with a resolution of only one leaf node, where all parent nodes are filtered out of the resolution. I think in the very early days we called that a \"shadow\".\r\n\r\nWith the definition you propose, I think it would become impossible to do the first-ever full commit in an otherwise empty tree.",
          "createdAt": "2022-01-31T12:25:22Z",
          "updatedAt": "2022-01-31T12:25:22Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed by #587 ",
          "createdAt": "2022-02-18T19:42:41Z",
          "updatedAt": "2022-02-18T19:42:41Z"
        }
      ]
    },
    {
      "number": 574,
      "id": "I_kwDOBoyH6c5C5CEX",
      "title": "Consistency between \"optional that MUST contain a value when \u2026\" and selects",
      "url": "https://github.com/mlswg/mls-protocol/issues/574",
      "state": "CLOSED",
      "author": "TWal",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "In the draft, we often need some value to be present in a structure under certain conditions.\r\n\r\nSometimes, it is done using an `optional<\u2026>`, and the prose says that it MUST contain a value under these conditions, e.g. for:\r\n- `confirmation_tag`\r\n- `membership_tag`\r\n\r\nSometimes, it is done using a `select`, e.g. for:\r\n- `GroupContext` in `MLSPlaintextTBS`\r\n\r\nIt looks like we need to make a choice here.",
      "createdAt": "2022-02-02T18:17:33Z",
      "updatedAt": "2022-02-15T11:37:59Z",
      "closedAt": "2022-02-15T11:37:59Z",
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "It seems like the `select` pattern only works when you have an indicator to use as selector, as opposed to some broader context.  For `confirmation_tag` and `membership_tag`, you might be able to use `sender.type`, but it seems a bit messy. ",
          "createdAt": "2022-02-02T23:20:44Z",
          "updatedAt": "2022-02-02T23:20:44Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Discussion on virtual interim:\r\n\r\n* @TWal  elaborates:\r\n    * For `confirmation_tag` could select on `content_type`\r\n    * For `membership_tag` could select on `sender.type`\r\n* @bifurcation agrees that failing on parsing is a pretty compelling rationale for these cases ",
          "createdAt": "2022-02-03T15:56:58Z",
          "updatedAt": "2022-02-03T15:56:58Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "I just looked at implementing this on top of #523, and it actually looked a little non-trivial.  If we use `select` in MLSMessageAuth, then we'll need to know the `content_type` from elsewhere when parsing the MLSMessageAuth.  \r\n\r\n```\r\nstruct {\r\n    // SignWithLabel(., \"MLSMessageContentTBS\", MLSMessageContentTBS)\r\n    opaque signature<0..2^16-1>;\r\n\r\n    select (content_type) { // <---- where does this come from?\r\n        case application: struct{};\r\n        case proposal: struct{};\r\n\r\n        // MAC(confirmation_key, GroupContext.confirmed_transcript_hash)\r\n        case commit: MAC confirmation_tag;\r\n    }\r\n} MLSMessageAuth;\r\n```\r\n\r\nThat might not be terrible to implement, but it does mean that MLSMessageAuth is no longer independently parseable.\r\n\r\nNo similar concerns about `membership_tag` -- that's within MLSPlaintext, so you can refer to `content.sender.sender_type`.\r\n\r\n```\r\nstruct {\r\n    MLSMessageContent content;\r\n    MLSMessageAuth auth;\r\n\r\n    select (content.sender.sender_type) {\r\n        case preconfigured: struct{};\r\n        case new_member: struct{};\r\n\r\n        // MAC(membership_key, MLSMessageContentTBM)\r\n        case member: MAC membership_tag;\r\n    }\r\n} MLSPlaintext;\r\n```",
          "createdAt": "2022-02-07T21:17:52Z",
          "updatedAt": "2022-02-07T21:17:52Z"
        },
        {
          "author": "TWal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "You are right\u2026 We maybe we could template `MLSMessageAuth` on the ContentType?\r\n\r\nSomething like\r\n```\r\ntemplate <ContentType content_type>\r\nstruct {\r\n    // SignWithLabel(., \"MLSMessageContentTBS\", MLSMessageContentTBS)\r\n    opaque signature<0..2^16-1>;\r\n\r\n    select (content_type) {\r\n        case application: struct{};\r\n        case proposal: struct{};\r\n\r\n        // MAC(confirmation_key, GroupContext.confirmed_transcript_hash)\r\n        case commit: MAC confirmation_tag;\r\n    }\r\n} MLSMessageAuth;\r\n```\r\n\r\nand\r\n\r\n```\r\nstruct {\r\n    MLSMessageContent content;\r\n    MLSMessageAuth<content.content_type> auth;\r\n\r\n    select (content.sender.sender_type) {\r\n        case preconfigured: struct{};\r\n        case new_member: struct{};\r\n\r\n        // MAC(membership_key, MLSMessageContentTBM)\r\n        case member: MAC membership_tag;\r\n    }\r\n} MLSPlaintext;\r\n```\r\n\r\nBut that might look a bit convoluted\u2026",
          "createdAt": "2022-02-07T22:26:53Z",
          "updatedAt": "2022-02-07T22:26:53Z"
        },
        {
          "author": "TWal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Note that a structure with a similar problem already exists: `MLSCiphertextContent`.\r\n\r\nWith the same style, we could have:\r\n```\r\nstruct {\r\n    // SignWithLabel(., \"MLSMessageContentTBS\", MLSMessageContentTBS)\r\n    opaque signature<0..2^16-1>;\r\n\r\n    select (MLSMessageContent.content_type) {\r\n        case application: struct{};\r\n        case proposal: struct{};\r\n\r\n        // MAC(confirmation_key, GroupContext.confirmed_transcript_hash)\r\n        case commit: MAC confirmation_tag;\r\n    }\r\n} MLSMessageAuth;\r\n```",
          "createdAt": "2022-02-07T22:34:45Z",
          "updatedAt": "2022-02-07T22:34:45Z"
        },
        {
          "author": "TWal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Note that independently of #523 we also have a similar problem for `MLSPlaintextCommitAuthData`.",
          "createdAt": "2022-02-08T15:18:54Z",
          "updatedAt": "2022-02-08T15:18:54Z"
        },
        {
          "author": "TWal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Fixed in #523 ",
          "createdAt": "2022-02-15T11:37:59Z",
          "updatedAt": "2022-02-15T11:37:59Z"
        }
      ]
    },
    {
      "number": 576,
      "id": "I_kwDOBoyH6c5C81BF",
      "title": "Make credential succession checking the AS's job",
      "url": "https://github.com/mlswg/mls-protocol/issues/576",
      "state": "CLOSED",
      "author": "kkohbrok",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Right now it says in the Update proposal section: \"Verify that the set of identities attested by the credential is acceptable to the application for the participant being updated.\"\r\n\r\nFirstly, I think this is a matter of authentication and thus the AS' job and secondly, it's a validation step that should probably go into the `KeyPackage Validation` section.",
      "createdAt": "2022-02-03T15:42:57Z",
      "updatedAt": "2022-02-13T14:39:07Z",
      "closedAt": "2022-02-13T14:39:07Z",
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Discussion on virtual interim:\r\n\r\n* Depends on what the boundary of the AS is:\r\n    * Checking credential is valid\r\n    * Also checking (credential -> credential) transitions\r\n* Moving this check to KP validation section would make it clearer\r\n* @kkohbrok to make a PR ",
          "createdAt": "2022-02-03T16:10:51Z",
          "updatedAt": "2022-02-03T16:10:51Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed by #584 ",
          "createdAt": "2022-02-13T14:38:56Z",
          "updatedAt": "2022-02-13T14:38:56Z"
        }
      ]
    },
    {
      "number": 577,
      "id": "I_kwDOBoyH6c5C82g0",
      "title": "Add message/mls MIME Type",
      "url": "https://github.com/mlswg/mls-protocol/issues/577",
      "state": "CLOSED",
      "author": "rohan-wire",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "When MLS messages are transmitted over a protocol which supports Content-Type / MIME Type negotiation, signal that the message is an MLS message.\r\n\r\nBecause MLS messages are really a bag of formats today we should have a MIME type parameter which specifies the specific format included.\r\n\r\nmessage/mls;format={application|handshake|welcome|keypackage|groupcontext}",
      "createdAt": "2022-02-03T15:48:23Z",
      "updatedAt": "2022-02-13T14:38:07Z",
      "closedAt": "2022-02-13T14:38:07Z",
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "This seems like a fine idea to me.  Could go as a section in the protocol spec, or as a separate (small) spec.",
          "createdAt": "2022-02-03T16:02:23Z",
          "updatedAt": "2022-02-03T16:02:23Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Discussion on virtual interim:\r\n\r\n* Section or separate doc?\r\n* How do we handle versioning?\r\n    * Internal to the protocol (field in MLSMessage?)\r\n    * Field in the MIME type\r\n    * Different MIME type per version",
          "createdAt": "2022-02-03T16:05:15Z",
          "updatedAt": "2022-02-03T16:05:15Z"
        },
        {
          "author": "rohan-wire",
          "authorAssociation": "CONTRIBUTOR",
          "body": "- I would prefer a short section in the protocol document.\r\n- I think Internal to the protocol is cleanest. \r\n- Likewise the format parameter becomes unnecessary if we add Welcome, PublicGroupState, and KeyPackage to wire_format (see issue #574 )",
          "createdAt": "2022-02-03T23:46:55Z",
          "updatedAt": "2022-02-03T23:46:55Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "@rohan-wire send a PR?",
          "createdAt": "2022-02-07T20:33:51Z",
          "updatedAt": "2022-02-07T20:33:51Z"
        },
        {
          "author": "seanturner",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Asking for friend: would we want to define (or use) a structured syntax suffix ala [RFC 6839](https://datatracker.ietf.org/doc/html/rfc6839)?",
          "createdAt": "2022-02-07T20:49:07Z",
          "updatedAt": "2022-02-07T20:49:07Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "@seanturner If you mean for multiple formats, no, we have only one encoding.  If someone wants to re-encode the protocol as XML or whatever, a MIME type will be the least of their troubles.\r\n\r\n",
          "createdAt": "2022-02-13T14:37:42Z",
          "updatedAt": "2022-02-13T14:37:42Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed in #581 ",
          "createdAt": "2022-02-13T14:37:54Z",
          "updatedAt": "2022-02-13T14:37:54Z"
        }
      ]
    },
    {
      "number": 578,
      "id": "I_kwDOBoyH6c5DBcq6",
      "title": "Uniqueness of PSK proposals within a commit",
      "url": "https://github.com/mlswg/mls-protocol/issues/578",
      "state": "CLOSED",
      "author": "tomleavy",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Should multiple PSK proposals within a commit be able to reference the same `PreSharedKeyID `? I feel like this should be covered in the same way we state multiple removals for the same `KeyPackageRef` should result in the committer choosing one. Wasn't sure if this was an oversight or on purpose. \r\n\r\nI can submit a PR to clarify if this is something that should be addressed",
      "createdAt": "2022-02-04T17:40:35Z",
      "updatedAt": "2022-02-10T19:12:46Z",
      "closedAt": "2022-02-10T19:12:46Z",
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "I agree, duplicates are an error.  Committer MUST NOT include duplicates; receiver MUST reject Commit with duplicates.\r\n\r\n@tomleavy  - Please send a PR!",
          "createdAt": "2022-02-07T20:39:17Z",
          "updatedAt": "2022-02-07T20:39:17Z"
        }
      ]
    },
    {
      "number": 588,
      "id": "I_kwDOBoyH6c5DV5QB",
      "title": "external_key_id seems to have a double usage",
      "url": "https://github.com/mlswg/mls-protocol/issues/588",
      "state": "CLOSED",
      "author": "raphaelrobert",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "`external_key_id` is used both for:\r\n - pre-configured senders (aka senders that are explicitly not part of any group)\r\n - a `KeyPackage` extension (aka something used only by members of groups)\r\n \r\nI think this should be disambiguated.",
      "createdAt": "2022-02-10T10:43:54Z",
      "updatedAt": "2022-02-18T19:53:04Z",
      "closedAt": "2022-02-18T19:53:04Z",
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Now that we have KeyPackage / LeafNode separation, it seems like you could use the same extension in both places.  For example, specify an `external_key_id` in your KeyPackage before joining, then when you update after joining, add the group-internal one to your LeafNode.",
          "createdAt": "2022-02-15T22:53:24Z",
          "updatedAt": "2022-02-15T22:53:24Z"
        },
        {
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "body": "I think that they are still fundamentally different concepts and it's just a name collision introduced by mistake. Pre-configured senders are there to allow for entities like servers to make proposals for a group. There is no overlap between these entities and (future) group members. We should just rename one of the instances.",
          "createdAt": "2022-02-16T11:25:22Z",
          "updatedAt": "2022-02-16T11:25:22Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Discussion:\r\n\r\n* TODO(@bifurcation) `Sender.external_key_id -> Sender.id` or something like that",
          "createdAt": "2022-02-17T16:36:31Z",
          "updatedAt": "2022-02-17T16:36:31Z"
        }
      ]
    },
    {
      "number": 589,
      "id": "I_kwDOBoyH6c5DYCpB",
      "title": "Replace labeled signing with signing wire format?",
      "url": "https://github.com/mlswg/mls-protocol/issues/589",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "With #523, we now have a wire format for each signed thing.  Could we just use this instead of a string label to distinguish signatures?",
      "createdAt": "2022-02-10T16:02:27Z",
      "updatedAt": "2022-02-18T21:11:24Z",
      "closedAt": "2022-02-18T21:11:24Z",
      "comments": [
        {
          "author": "TWal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Something I like about string-based signature labels instead of binary ones, is that if you stare at the hexdump of the signed data there is absolutely no ambiguity about what is signed, because the first bytes are e.g. \"MLS 1.0 KeyPackageTBS\".\r\nIn the binary-based signature labels, the argument is that the first two bytes are e.g. \"0105\" and it's much more cryptic in my eyes.",
          "createdAt": "2022-02-11T14:47:57Z",
          "updatedAt": "2022-02-11T14:47:57Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Unless we convert the whole protocol to JSON, you're going to have to deal with binary stuff :)",
          "createdAt": "2022-02-11T15:10:06Z",
          "updatedAt": "2022-02-11T15:10:06Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Discussion on virtual interim:\r\n\r\n* What's important is to have a \"magic string\" that distinguishes this protocol from other protocols\r\n* Need to distinguish between\r\n    1. Different structures within MLS\r\n    2. Different versions of MLS\r\n    3. MLS vs. everything else\r\n* E.g., \"MLS 1.0 KeyPackageTBS\" ~> protocol / version /  type\r\n* In addition to already having it, having the protocol distinguisher in ASCII gives greater confidence\r\n    * \"Intra-protocol\" identifiers can be small\r\n    * \"Inter-protocol\" identifiers need to be larger to reduce collision probability\r\n    * Consider introducing some standard prefix to \"MLS\"\r\n* If we're going to have both ASCII distinguisher and `wire_format`, spec needs to enforce equivalence\r\n    * Could also omit wire_format from signature and rely on ASCII distinguisher alone\r\n    * TODO(@TWal) Check that this is clear in the spec, see if wire format should be omitted",
          "createdAt": "2022-02-17T16:33:18Z",
          "updatedAt": "2022-02-17T16:33:18Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "When we discussed this on the virtual interim, I forgot about #590, which provides a protocol-internal version.  That gives us small distinguisher for the version, so we're down to the inter-protocol distinguisher.\r\n",
          "createdAt": "2022-02-18T21:11:24Z",
          "updatedAt": "2022-02-18T21:11:24Z"
        }
      ]
    },
    {
      "number": 590,
      "id": "I_kwDOBoyH6c5DYEA3",
      "title": "Add version to MLSMessage",
      "url": "https://github.com/mlswg/mls-protocol/issues/590",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "To enable version agility, we need MLSMessages to indicate what version they are intended for.  Since version is included in signature labels, we need to deconflict these two indicators.",
      "createdAt": "2022-02-10T16:05:41Z",
      "updatedAt": "2022-03-06T16:35:55Z",
      "closedAt": "2022-03-06T16:35:55Z",
      "comments": []
    },
    {
      "number": 591,
      "id": "I_kwDOBoyH6c5DZxEJ",
      "title": "Reinit logic clarification",
      "url": "https://github.com/mlswg/mls-protocol/issues/591",
      "state": "CLOSED",
      "author": "tomleavy",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "The goal of the reinit proposal is to trigger a tear down / restart of a group with the same members but different parameters such as a version upgrade, or a cipher suite change.\r\n \r\n1. Changing version - version is a field within key package, and this locks a key package to a specific version, even if capabilities allow for multiple versions. Should that field be removed, and instead you just look at capabilities? It seems that this would change with #575 since leaf nodes will not be pinned to a specific version, just a cipher suite. After 575 gets merged one could upgrade versions using a new tree that copies the current non-empty leaves so long as each leaf has the upgraded version in their capabilities set. That specific tree building process is not mentioned, it is just sort of assumed in context.\r\n \r\n2. Changing cipher suite - In the case you want to change cipher suite, complexity somewhat increases. You will need to create a new tree by grabbing new key packages for each participant, and because the cipher suite has changed, all of the credentials have also changed. It is mentioned that \"A group may be reinitialized by creating a new group with the same membership and different parameters\", but this does not have a statement that has a SHOULD or MUST associated with it. For example, in my 5000 member group 1 member does not support the cipher suite that we are migrating away from. As the committer, I'm assuming that I should keep everyone in the group as best effort, but have the option to filter out problematic members that are blocking a migration due to them being offline for long periods of time or having outdated software. Due to the credential change, enforcing a MUST might be difficult since equality between two x509 credentials is not straight forward for example.\r\n \r\nTo summarize, I propose some changes\r\n \r\n1. Remove version from key package, and rely on capabilities instead, this may now be irrelevant due to #575, but the version and capabilities.versions values seem duplicative\r\n \r\n2. Add some language in reinitialization that clarifies the flow for upgrading just version vs changing cipher suite, where changing cipher suite explicitly requires you acquire new key packages for each member.\r\n \r\n3. Clarify that a person issuing the welcome based on a reinit proposal SHOULD include all existing members",
      "createdAt": "2022-02-10T19:59:42Z",
      "updatedAt": "2022-02-18T19:20:11Z",
      "closedAt": "2022-02-18T19:20:11Z",
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "1. IMO those fields have quite separate purposes.  Keep in mind that a different version could have a different KeyPackage format.  So `key_package.version` says \"this KeyPackage is formatted according to this version\", while the capabilities says what other versions I support.\r\n2. With that in mind, you need to grab new KeyPackages for everyone regardless of whether you're changing version, ciphersuite, or both.  If this isn't clear, we should certainly clarify it.\r\n3. If you're worried about people not supporting the new stuff, you could maintain the hard semantic just by Removing those participants that don't support the new stuff before you ReInit.",
          "createdAt": "2022-02-13T15:53:00Z",
          "updatedAt": "2022-02-13T15:53:00Z"
        },
        {
          "author": "tomleavy",
          "authorAssociation": "CONTRIBUTOR",
          "body": "1. - Fair enough that seems reasonable\r\n\r\n2. - I don't think it's necessarily clear right now, it's more of an assumption based on an understanding of the protocol overall. I'll try to come up with something there to give more of a step by step explanation of the flow. \r\n\r\n3. - If this is a hard requirement should the doc say MUST here? If so, I'm trying to think through what equality means in terms of membership when in the event the cipher suite changes, all the credentials will also change. ",
          "createdAt": "2022-02-13T19:12:26Z",
          "updatedAt": "2022-02-14T15:17:43Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "On (3) -- I would be OK with saying that the new members MUST be the same as the old members.  The notion of \"same\" is a little squishy, given ambiguities around identifiers, but it seems like it will probably be clear in practice.  W.r.t. removing people to make an upgrade possible, when the application decides to upgrade and how the application it meets the same-member criterion is up to the application.",
          "createdAt": "2022-02-15T22:51:52Z",
          "updatedAt": "2022-02-15T22:51:52Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Discussion on virtual interim:\r\n\r\n* Maybe put \"remove before upgrade\" in implementation considerations document.",
          "createdAt": "2022-02-17T16:19:32Z",
          "updatedAt": "2022-02-17T16:19:32Z"
        },
        {
          "author": "tomleavy",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@bifurcation I meant to make this call to discuss, seem to not have the invite anymore, can you forward it to me? In terms of where this ticket is at, I was mostly raising the concerns to clarify for myself that what I _think_ is the process is actually the process. I am willing to just close this one out",
          "createdAt": "2022-02-17T17:03:14Z",
          "updatedAt": "2022-02-17T17:03:14Z"
        }
      ]
    },
    {
      "number": 596,
      "id": "I_kwDOBoyH6c5D4v6E",
      "title": "Invert definition of \"partial\" commit",
      "url": "https://github.com/mlswg/mls-protocol/issues/596",
      "state": "CLOSED",
      "author": "kkohbrok",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "The authoritative definition (in Section [13.2](https://messaginglayersecurity.rocks/mls-protocol/draft-ietf-mls-protocol.html#section-13.2)) of when to include a `path` is not the same as the summary below. For example, if an implementation adds a custom proposal type, according to the summary, a path is required, whereas according to the definition above it, no path is required.\r\n\r\nUltimately, it depends on the nature of the proposal and the desired security guarantees if a path is required. However, I think the safer option is to require a path by default and maybe leave it to the definition of the respective custom proposal to explicitly specify if a path is _not_ required.",
      "createdAt": "2022-02-15T16:50:40Z",
      "updatedAt": "2022-02-18T19:18:51Z",
      "closedAt": "2022-02-18T19:18:51Z",
      "comments": []
    },
    {
      "number": 604,
      "id": "I_kwDOBoyH6c5EZ06m",
      "title": "Unify co-path style choice",
      "url": "https://github.com/mlswg/mls-protocol/issues/604",
      "state": "CLOSED",
      "author": "br-hale",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "The co-path is written both as 'co-path' and 'copath'. As a formality check, this should be unified. ",
      "createdAt": "2022-02-23T04:32:03Z",
      "updatedAt": "2022-02-28T19:58:35Z",
      "closedAt": "2022-02-28T19:58:35Z",
      "comments": []
    },
    {
      "number": 607,
      "id": "I_kwDOBoyH6c5FDYSX",
      "title": "Should `GroupInfoTBS` contain the protocol version?",
      "url": "https://github.com/mlswg/mls-protocol/issues/607",
      "state": "CLOSED",
      "author": "stefunctional",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "[The section about adding members to a group](https://messaginglayersecurity.rocks/mls-protocol/draft-ietf-mls-protocol.html#name-adding-members-to-the-group) defines `GroupInfo` and ` GroupInfoTBS` and states the following:\r\n> The signature covers the following structure, comprising all the fields in the GroupInfo above signature\r\n\r\nAll the fields above `signature` in `GroupInfo` includes `version`, but `version` is not in `GroupInfoTBS`. Should it be or should the wording about which fields are included be amended?\r\n\r\nThank you.",
      "createdAt": "2022-03-03T14:59:54Z",
      "updatedAt": "2022-03-07T14:57:55Z",
      "closedAt": "2022-03-06T16:38:00Z",
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "In #600, the `version` field was removed from `GroupInfo`, so I think this ambiguity has been resolved.  Note that the version is still authenticated via the version string in `SignWithLabel`.",
          "createdAt": "2022-03-06T16:37:59Z",
          "updatedAt": "2022-03-06T16:37:59Z"
        },
        {
          "author": "stefunctional",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thank you.",
          "createdAt": "2022-03-07T14:57:55Z",
          "updatedAt": "2022-03-07T14:57:55Z"
        }
      ]
    },
    {
      "number": 608,
      "id": "I_kwDOBoyH6c5FJAX4",
      "title": "Completely remove leaf_index (or keep it)",
      "url": "https://github.com/mlswg/mls-protocol/issues/608",
      "state": "CLOSED",
      "author": "rohan-wire",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Under the list of changes, one of these says that leaf_index is removed. However a search for index and indeces still shows several references to the leaf_index. These should be removed/replaced as well, or explain why we need Leaf Node Reference and leaf_index and when one gets used.",
      "createdAt": "2022-03-04T19:43:38Z",
      "updatedAt": "2022-03-07T18:56:57Z",
      "closedAt": "2022-03-07T18:56:57Z",
      "comments": [
        {
          "author": "TWal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "`leaf_index` was first removed in #487 in favor of node indices, and afterward re-introduced to remove node indices in #522.\r\nDraft 12 was out between these two pull requests, I'm guessing the latter change will appear in the changelog of draft 13!",
          "createdAt": "2022-03-06T09:17:14Z",
          "updatedAt": "2022-03-06T09:17:14Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "It looks to me like the following mentions of leaf index still exist:\r\n\r\n1. The leaf node input to the tree hash\r\n2. The ratchet tree serialization scheme (for the `ratchet_tree` extension)\r\n3. The example code for array-based trees\r\n\r\nCase (3) is optional, so I don't think it's an issue.  For case (2), removing the notion of indices would make it a lot harder to describe the serialization.  For case (1), removing the index would remove some of the rigidity of the tree hash (in particular, a blank subtree of the same size would have the same hash anywhere).\r\n\r\nOverall, I'm not inclined to make this change.",
          "createdAt": "2022-03-06T16:42:32Z",
          "updatedAt": "2022-03-06T16:42:32Z"
        }
      ]
    },
    {
      "number": 616,
      "id": "I_kwDOBoyH6c5FQitd",
      "title": "Remove or refine preconfigured senders",
      "url": "https://github.com/mlswg/mls-protocol/issues/616",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "As [Raphael pointed out on the mailing list](https://mailarchive.ietf.org/arch/msg/mls/VWzhGx2XwgBqHoHIE0fvuZS1sm4/), the current preconfigured sender mechanism isn't interoperably specified.  There is no confirmation that the members of a group agree on who the allowed preconfigured senders are, so different members might respond differently.  It seems like there are two options here:\r\n\r\n1. Add the required details.  We would need a `preconfigured_senders` extension to confirm agreement to use the mechanism at all, and would probably need to have a list of senders there as well.\r\n\r\n2. Remove the feature from the base protocol.  Since an extension is required in any case, there's no pressing need to have the feature in the base protocol.\r\n\r\nPersonally, I would lean toward (2).  Early deployment experience doesn't show a lot of need for this feature.  For example, in Webex, we just have the server forward a KeyPackage instead of synthesizing an Add proposal under a preconfigured signer; the TLS authentication is as good as a preconfigured signer signature.  As long as the SenderType enum is around, the extension should be a small follow-on spec if it is really needed.",
      "createdAt": "2022-03-07T21:53:31Z",
      "updatedAt": "2022-03-23T19:33:32Z",
      "closedAt": "2022-03-23T19:33:32Z",
      "comments": [
        {
          "author": "tomleavy",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@psyoptix and I would probably prefer the first option. I will write up a more detailed reason and post to the mailing list, but the TLDR is basically that in a really long session in async messaging, server driven proposals save you from some painful logic, and the extension would improve this to allow for interop / federation cases.",
          "createdAt": "2022-03-08T03:24:10Z",
          "updatedAt": "2022-03-08T03:24:10Z"
        },
        {
          "author": "psyoptix",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I am pretty clearly in favor of option 1. Pre-configured senders are playing a key role for us in implementing automation of backend-initiated changes to the group. Things like:\r\n - initiating the removal of Bob('s phone) because his account (or device) was deprovisioned.\r\n - announcing a change to the group's properties due to system wide policy changes.\r\n \r\nHaving an audit trail (i.e. the preconfigured sender's signature on the proposal) makes this a lot easier for the group to authenticate why this action is being committed to by group members. (Also, external commits are not a good alternative as they have the unwanted side-effect of the preconfigured sender learning the new epoch's key schedule.)\r\n\r\nAs for how to agree on preconfigured sender public keys, I think a minimal solution could be to have a list of preconfigured sender public keys as a group context extension. We already have a mechanism to change it during the life time of the group (via group_context_extensions proposal) so its a pretty small change to the the RFC.",
          "createdAt": "2022-03-08T15:34:09Z",
          "updatedAt": "2022-03-08T15:56:04Z"
        },
        {
          "author": "tomleavy",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thanks Jo\u00ebl, @bifurcation that covers my feedback as well, no need for mailing list follow up",
          "createdAt": "2022-03-08T15:39:41Z",
          "updatedAt": "2022-03-08T15:39:41Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "That sounds fine to me. @tomleavy want to write up a PR?  It seems like something of the following form:\r\n\r\n```\r\n## Preconfigured Senders Extension\r\n\r\n[[ Introductory prose ]]\r\n\r\n~~~\r\nstruct {\r\n    BasicCredential senders<V>; // `identity` fields must be distinct\r\n} PreconfiguredSenders;\r\n~~~\r\n```\r\n\r\nThe idea being that BasicCredential already has the (id, public key) pair that you would need, so you would just need to say that when `sender.type = preconfigured`, `sender.sender_id` is the `identity` field from the corresponding BasicCredential.  (Also probably rename `sender_id` to `identity`.) ",
          "createdAt": "2022-03-08T17:35:56Z",
          "updatedAt": "2022-03-08T17:35:56Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Or actually, you could do things even more simply by just having the extension be a list of `SignaturePublicKey`, and having `sender_id` be a `uint32` index into the array.",
          "createdAt": "2022-03-08T17:37:35Z",
          "updatedAt": "2022-03-08T17:37:35Z"
        },
        {
          "author": "tomleavy",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Ok no problem. I'll take a look today and propose something and we can iterate ",
          "createdAt": "2022-03-09T13:56:57Z",
          "updatedAt": "2022-03-09T13:56:57Z"
        },
        {
          "author": "tomleavy",
          "authorAssociation": "CONTRIBUTOR",
          "body": "What do you think about it just being credential instead of basic credential? ",
          "createdAt": "2022-03-09T13:59:42Z",
          "updatedAt": "2022-03-09T13:59:42Z"
        },
        {
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I had the same thought. Since I kicked off the discussion, I felt the need to take a stab at closing it and I included the input from this threat and the list. See #617.\r\n\r\nMy main goal was to consolidate the instructions on signature computation and verification and I thought I might as well deal with the preconfigured senders as well. Let me know if you want to take your own stab at the preconfigured senders extension and I'll remove that part from the PR.",
          "createdAt": "2022-03-09T14:07:32Z",
          "updatedAt": "2022-03-09T14:10:50Z"
        },
        {
          "author": "tomleavy",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thanks @kkohbrok , glad I put this off until now :-) I'll take a look at your PR",
          "createdAt": "2022-03-09T19:05:16Z",
          "updatedAt": "2022-03-09T19:05:16Z"
        }
      ]
    },
    {
      "number": 623,
      "id": "I_kwDOBoyH6c5GdHi9",
      "title": "Subgroup branching bug",
      "url": "https://github.com/mlswg/mls-protocol/issues/623",
      "state": "CLOSED",
      "author": "tomleavy",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "There is currently a logical flaw in the subgroup branching flow.\r\n\r\nIn order to branch, you need to compose a `Welcome` message . A Welcome message includes `EncryptedGroupSecrets` which is defined as follows: \r\n\r\n```\r\nstruct {\r\n  KeyPackageRef new_member;\r\n  HPKECiphertext encrypted_group_secrets;\r\n} EncryptedGroupSecrets;\r\n```\r\n\r\nThe problem with this is that the `new_member` field of type `KeyPackageRef` cannot be made for existing members of the group because the leaf nodes are now `LeafNode` types. `KeyPackageRef` is now only used to add new members to the group, so we can't reuse this for sub group initialization.",
      "createdAt": "2022-03-26T20:10:03Z",
      "updatedAt": "2022-04-12T22:21:23Z",
      "closedAt": "2022-04-12T22:21:23Z",
      "comments": [
        {
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'm not sure I understand correctly. Are you suggesting when branching a group off of another group, one re-uses the leaves of the old group? If so, that's not how it's meant to work. The new group created in the process of subgroup branching should be independent from the \"parent\" group safe for the PSK, which all member have to provide upon creation of the group. In fact one should never use the same key material in the leaves of multiple groups except when the supply of key packages that a party provides via the DS is exhausted (see Section 17.4).",
          "createdAt": "2022-03-28T12:25:06Z",
          "updatedAt": "2022-03-28T12:25:06Z"
        },
        {
          "author": "tomleavy",
          "authorAssociation": "CONTRIBUTOR",
          "body": "That was part of my question. When there were key packages in the leaves, you theoretically could fork the group from a given point in time and reuse the current tree, but I wasn't sure if that was a proper solution or not. Sounds like it isn't, but either way, I think there should be clarification in the document about this. Let me write up a quick PR on it.",
          "createdAt": "2022-03-28T13:50:02Z",
          "updatedAt": "2022-03-28T13:50:02Z"
        },
        {
          "author": "tomleavy",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@kkohbrok opened https://github.com/mlswg/mls-protocol/pull/624. Would like your feedback there. We have conflicting wording here as well. What threw me off in the first place was the line indicating that LeafNodes should be the same in the sub-group, and if we are fetching new key packages they will not be the same.",
          "createdAt": "2022-03-28T15:55:49Z",
          "updatedAt": "2022-03-28T15:56:28Z"
        },
        {
          "author": "rohan-wire",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> I'm not sure I understand correctly. Are you suggesting when branching a group off of another group, one re-uses the leaves of the old group? If so, that's not how it's meant to work. The new group created in the process of subgroup branching should be independent from the \"parent\" group safe for the PSK, which all member have to provide upon creation of the group. In fact one should never use the same key material in the leaves of multiple groups except when the supply of key packages that a party provides via the DS is exhausted (see Section 17.4).\r\n\r\n@kkohbrok Konrad, could you safely derive new keys for the members of the subgroup instead? If so, that would be an enormous increase in efficiency and (especially in the federated case) make group creation timing consistent enough to do dynamically.",
          "createdAt": "2022-03-28T22:46:22Z",
          "updatedAt": "2022-03-28T22:46:22Z"
        },
        {
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@rohan-wire Nice idea! But it's tricky, since we're dealing with public key pairs that the creator of the new group doesn't know the private keys for. If we were only using HPKE schemes that support updateable public key encryption, the creator of the new group could indeed update the key in the existing group and send the \"delta\" encrypted to each corresponding member (which would still represent an overhead, but we might be able to optimize this somehow). This is similar to the RTreeKEM mechanism that @psyoptix et al. proposed at some point. To go all the way here, we'd have to do the same for the public key material in the credentials as well, which is not something we had considered before. It would be a new primitive, something like an updateable signature scheme? Probably something to consider for HPKE/MLS 2.0.\r\n\r\nWe could also allow the re-use of LeadNodes for this particular case. It would be the simpler solution and I don't think it would be catastrophic, since we have to assume that LeafNode (or KeyPackage) key material is re-used in the \"last resort\" scenario anyway, but this would definitely be something we should discuss on the mailing list, as it would break a pretty basic assumption we've made until now.",
          "createdAt": "2022-03-29T06:10:44Z",
          "updatedAt": "2022-03-29T06:10:44Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Just catching up on this.  @tomleavy nice catch here.\r\n\r\nIt seems like we have two options here:\r\n1. Require new KeyPackages (as in #624)\r\n2. Invent some way to make a new group based on LeafNodes alone\r\n\r\nI probably agree that we should do (1) in the short term, but (2) also has some appeal -- it doesn't feel right to require new KeyPackages for folks you're already in touch with -- despite it probably being more spec text.  So here's a sketch of (2) in the interest of completeness.\r\n\r\nSuppose we defined a message of the following form:\r\n\r\n```\r\nstruct {\r\n  opaque new_group_id<V>;\r\n  LeafNodeRef subgroup_members<V>;\r\n  UpdatePath path;\r\n  Extensions group_context_extensions<V>;\r\n} Branch;\r\n```\r\n\r\n... which would pretty closely parallel to Commit.  You would send it in\r\nMLSMessage and require a `confirmation_tag` in MLSMessageAuth.  Where Commit instructs the recipient to create a new epoch from the current one within the same group, Branch would instruct the recipient to create a new epoch that is the first epoch of a new group.\r\n\r\n| Field           | Commit                               | Branch                                       |\r\n|-----------------|--------------------------------------|----------------------------------------------|\r\n| Group ID        | `group_id`                           | `new_group_id`                               |\r\n| Epoch           | `epoch + 1`                          | `0`                                          |\r\n| Tree            | Tree with proposals applied          | Tree with specified leaves, otherwise empty  |\r\n| Transcript hash | Updated with Commit                  | `\"\"`                                         |\r\n| Extensions      | Carried over / specified in proposal | As specified                                 |\r\n| PSKs            | Specified in proposal(s)             | Branch PSK from the current epoch            |\r\n\r\nIn both cases, you would form an epoch / GroupContext as specified, then use the `path` to ratchet into the new epoch.\r\n\r\nI'm pretty sure that would work and have the expected security properties, though obviously formal analysis would be appreciated.  The main awkardness that occurs to me is that any members joining after the branch would have to provide new key packages.  And obviously, it would require a fair bit more spec text.\r\n\r\nAll that said, though, the exercise of working all that out has increased my impression that we should do (1) for now.  If we want something like (2) later, it can be done pretty cleanly in an extension.",
          "createdAt": "2022-03-31T20:37:31Z",
          "updatedAt": "2022-03-31T20:37:31Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed by #624 ",
          "createdAt": "2022-04-12T22:21:23Z",
          "updatedAt": "2022-04-12T22:21:23Z"
        }
      ]
    },
    {
      "number": 627,
      "id": "I_kwDOBoyH6c5GoQWG",
      "title": "\"MLS Proposal Types\" table template does not describe \"path required\"",
      "url": "https://github.com/mlswg/mls-protocol/issues/627",
      "state": "CLOSED",
      "author": "dkg",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "the \"MLS Proposal Types\" section defines a table with columns \r\n\r\n- Value\r\n- Name\r\n- Recommended\r\n- Path Required\r\n- Reference\r\n\r\nBut the template directly above the table only mentions four of the five columns.  It does not mention or describe what \"Path Required\" means.\r\nIt should probably at least make clear that the field should be either `Y` or `N`, and reference section \"Commit\" where the path requirement is discussed.\r\n",
      "createdAt": "2022-03-29T14:26:16Z",
      "updatedAt": "2022-04-01T15:03:15Z",
      "closedAt": "2022-04-01T15:03:15Z",
      "comments": []
    },
    {
      "number": 630,
      "id": "I_kwDOBoyH6c5G7N8Q",
      "title": "Secrets and Keys",
      "url": "https://github.com/mlswg/mls-protocol/issues/630",
      "state": "CLOSED",
      "author": "br-hale",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "The spec currently uses a mix of terminologies for keys/secrets. In the key schedule we have the following:\r\n------\r\nsender_data_secret | \"sender data\"\r\nencryption_secret | \"encryption\"\r\nexporter_secret | \"exporter\"\r\nauthentication_secret | \"authentication\"\r\nexternal_secret | \"external\"\r\nconfirmation_key | \"confirm\"\r\nmembership_key | \"membership\"\r\nresumption_secret | \"resumption\"\r\n-------\r\n\r\nIt would be best to provide a coherency to how we use these terms and check for consistency throughout, to avoid confusion for readers:\r\n\r\n- A simple solution would be to use \"secret\" for all cases, i.e., changing membership_key to membership_secret. \r\n\r\n- Another alternative, which may take more refining but could be useful to readers is to separate out terms based on items that are for internal protocol use versus external protocol use. For example, encryption, confirmation, membership, etc., would use \"key\" and exporter, authentication, etc., could use \"secret\", or vice versa. \r\n\r\n\r\n--Break--\r\n\r\n\r\nRef the mailinglist on confirmation vs authentication secrets, perhaps the naming of these two are a little misleading - authentication normally being within bounds of a protocol while confirmation is external to it. This confusion probably sparked some of that discussion to begin with. It _could_ be worth considering switching those terms for clarity.\r\n\r\n",
      "createdAt": "2022-04-01T15:04:35Z",
      "updatedAt": "2022-04-28T16:50:38Z",
      "closedAt": "2022-04-28T16:50:38Z",
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "I actually think we have a fairly coherent taxonomy here:\r\n\r\n* \"secret\" is something that gets fed into HKDF to derive further things\r\n* \"key\" is something that gets fed into another algorithm, e.g., HMAC\r\n\r\nLooking through the list, the ones that deviate from this pattern are:\r\n\r\n1. `resumption_secret`, which is exported to the application but expected to be kept private\r\n2. `authentication_secret`, which is exported to the application but not expected to be kept private\r\n\r\nGiven that, I would propose we update the table in question to something like the following, using `resumption_psk` because that's how it's used, and `authentication_code` to follow the \"security code\" terminology used by applications:\r\n\r\n| Label           | Secret                | Usage                                             |\r\n|:----------------|:----------------------|:--------------------------------------------------|\r\n| \"sender data\"   | `sender_data_secret`  | Deriving keys to encrypt sender data              |\r\n| \"encryption\"    | `encryption_secret`   | Deriving message encryption keys                  |\r\n| \"exporter\"      | `exporter_secret`     | Deriving exported secrets                         |\r\n| \"external\"      | `external_secret`     | Deriving the external init key                    |\r\n| \"confirm\"       | `confirmation_key`    | Computing the confirmation MAC for an epoch       |\r\n| \"membership\"    | `membership_key`      | Computing the membership MAC for an MLSPlaintext  |\r\n| \"resumption\"    | `resumption_psk`      | Proving membership in a prior epoch (via a PSK)   |\r\n| \"authentication\"| `authentication_code` | Confirming that two clients are in the same epoch |\r\n\r\n",
          "createdAt": "2022-04-28T13:15:50Z",
          "updatedAt": "2022-04-28T13:15:50Z"
        }
      ]
    },
    {
      "number": 633,
      "id": "I_kwDOBoyH6c5G-bup",
      "title": "Editorial",
      "url": "https://github.com/mlswg/mls-protocol/issues/633",
      "state": "CLOSED",
      "author": "br-hale",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "The following statement is no longer up-to-date, given addition of P-384:\r\n\"For ciphersuites using ECDSA with the NIST curves P-256 or P-521, the public key is...\"\r\n\r\nTo avoid tracking too many changes in the future for the document, I suggest the simple edit:\r\n\"For ciphersuites using ECDSA with the NIST curves, the public key is...\"",
      "createdAt": "2022-04-03T00:17:39Z",
      "updatedAt": "2022-04-12T22:26:15Z",
      "closedAt": "2022-04-12T22:26:15Z",
      "comments": []
    },
    {
      "number": 638,
      "id": "I_kwDOBoyH6c5IqMv1",
      "title": "Keys and Secrets",
      "url": "https://github.com/mlswg/mls-protocol/issues/638",
      "state": "CLOSED",
      "author": "br-hale",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Reopening #630 due to incomplete discussion and inaccuracy.\r\n\r\nThe claims presented are incorrect in response by @bifurcation demonstrate a misunderstanding of the roles of these keys and uses, and #636 constitutes a change to the fundamental uses thereof.\r\n\r\nThe authentication_secret is NOT a public value nor was it ever introduced as such. If an application is using it as a public value, that onus is on the developers, and I advise against using Cisco's implementation as a standard for MLS. As shown in the name and all original discussion, the authentication_secret is intended as a secret value (or else 'public' in the same way that the group secret is 'public). It is used for further derivation to support authentication.\r\n\r\nThis should be corrected, and such foundational changes without WG discussion should be avoided.\r\n",
      "createdAt": "2022-04-28T17:03:21Z",
      "updatedAt": "2022-05-01T14:24:16Z",
      "closedAt": "2022-05-01T14:24:16Z",
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Clearly we have a disagreement here @br-hale, but maybe let's hold off on attributing misunderstanding.\r\n\r\nIt seems like you are claiming that in order for MLS to be secure, the `authentication_secret` needs to be protected to the same level as the `epoch_secret`.  What is this based on?\r\n\r\nIf that is true, then we should probably remove the `authentication_secret` altogether.  The \"out-of-band\" protocol in which it would be confirmed would have to be part of the MLS security analysis, thus no longer out-of-band.",
          "createdAt": "2022-04-28T17:46:10Z",
          "updatedAt": "2022-04-28T17:46:10Z"
        },
        {
          "author": "br-hale",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@bifurcation that is not the claim at all - different uses imply different compromise risks. This should not be a new concept to understand. As demonstrated in the terminology, the authentication_secret is linked to authentication, not confidentiality. \r\n\r\nMLS, per specification, outsources authentication (the AS is not explicitly defined and all entity authentication within MLS relies on it). Even though it is definitionally out-of-scope and therefore out-of-band (certificates, authentication verification are entirely out-of-band of the protocol spec), we do not say that signature secret keys can be \"public\" - yet you are asserting that an authentication_secret which can support epoch-level authentication would be public. The authentication_secret is private in the same way that the exporter_value is: based on key schedule derivation, compromise of these keys should not undermine MLS, but secrecy of them can be leveraged. So, unless you are now proposing removing mention of certificates, etc. from the core protocol, there really isn't a logical basis for removing 'out-of-band' authentication mechanisms.",
          "createdAt": "2022-04-28T18:06:08Z",
          "updatedAt": "2022-04-28T18:06:08Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "What I'm trying to get at here is: What is the negative consequence if an `authentication_secret` is known by someone other than the members of a group?\r\n\r\nFor example, leaking a signature private key would enable the attacker to impersonate the corresponding member.  Leaking the `encryption_secret` would allow the attacker to decrypt all of the group's messages.\r\n\r\nWhat is the bad consequence of an `authentication_secret` becoming public?",
          "createdAt": "2022-04-28T18:14:45Z",
          "updatedAt": "2022-04-28T18:15:26Z"
        },
        {
          "author": "br-hale",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@bifurcation I am also assuming that this push to use epoch-level authentication values as public codes is based on Cisco's implementation choice. I would be curious to know why there is such insistence that all implementations also go about using authentication in the same way. If an implementation chooses to use it as a secret value to then derive an authentication code based on yet other information, why is that a problem?",
          "createdAt": "2022-04-28T18:15:32Z",
          "updatedAt": "2022-04-28T18:15:32Z"
        },
        {
          "author": "br-hale",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Publishing the authentication_secret as a public value has a similar effect as publishing the exporter_value as public - it is not an issue for MLS per protocol spec, but it would definitely be an issue for the application if it is then used for something secret thereafter. \r\n\r\nOne reason not to specify these as public values is that they are derived following the conditions placed on keys and therefore _could_ be used as secret values if desired by an application. Forcing or annotating them as immediately public, or as final 'codes', when such a use as a secret key is an out-of-scope potential is artificial and unnecessary. ",
          "createdAt": "2022-04-28T18:26:37Z",
          "updatedAt": "2022-04-28T18:26:37Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "I'm not pushing anything, I'm just trying to get the protocol to be clear.  If this thing needs to be secret, then it needs to be secret, and we need to document that so that people keep it secret.\r\n\r\nThanks for elaborating more on your concerns.  I see what you're saying -- basically the same point that @kkohbrok and I discussed [in the PR](https://github.com/mlswg/mls-protocol/pull/636#discussion_r860994871).  \r\n\r\nI think the core of the disagreement here is what we mean when we say that a value is \"public\" or \"secret\".  I mean something very specific: That the security guarantees of MLS will not be harmed if a public value is provided to the attacker, and they will be harmed if a secret value is provided to the attacker.  Importantly, \"public\" does not mean that the value must be published, or that the security guarantees of an application using MLS will not be harmed if you publish the value.  \r\n\r\nIt seems to me that in that specific taxonomy, the `authentication_secret` is \"public\" and not \"secret\".  Do you disagree?\r\n",
          "createdAt": "2022-04-28T18:54:24Z",
          "updatedAt": "2022-04-28T18:54:24Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "BTW, the notion of something being \"public\" at one layer but \"secret\" at another is not new. For example, values exported from TLS aren't secret in the sense that publishing them would compromise TLS.  You could authenticate your TLS connection by exporting a value and shouting it through megaphones across a crowd.  But the main way people use them in practice is as secrets in some other protocol.  Every WebRTC call uses SRTP keys that are exported from TLS, and many people would be very sad if these \"public\" values were published.",
          "createdAt": "2022-04-28T19:12:30Z",
          "updatedAt": "2022-04-28T19:12:30Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "If it would help, I would be happy to add some text to the Security Considerations clarifying this distinction.  Basically, draw a clear boundary around which values have to be kept confidential to the client in order to realize the security properties of the protocol.\r\n\r\nBut I still think `authentication_code` is a clearer name.  Doesn't mean you have to use it in any particular way in your application; doesn't prevent it being used as a shared secret; but also doesn't imply that the MLS library has to worry about its secrecy.",
          "createdAt": "2022-04-28T19:23:29Z",
          "updatedAt": "2022-04-28T19:23:29Z"
        },
        {
          "author": "br-hale",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Within the bounds of that particular taxonomy there is not an issue. However, while you may be following a given taxonomy, that is not a general one, one that would be widely understood by implementors, nor is it specified in the protocol spec. It is not an unreasonable taxonomy, but it certainly not a general one. If you are looking for MLS usage spec to align to your taxonomy then I do think that there should be a clarification section added.\r\n\r\nBTW as a point case on more standard terminology use, the TLS 1.3 spec uses the exact phrasing for exporters as \"exporter_master_secret\", from which the actual exporter may be derived. This aligns very closely to the authentication_secret, from which an authentication code _later_ may be derived. TLS is generic in 'exporters' after an exporter_master_secret is derived. Thus there is alignment of the term 'secret' to things that can be used for keys (have sufficient entropy), not as an alignment to public/secret at different layers. \r\n\r\nI am strongly opposed to the use of authentication_code, and see no clear definition for that in your customized taxonomy. As such, it would follow the more standard interpretations, such as message authentication codes, etc. which are indeed explicitly public values. Codes are normally an end-state in themselves, not keys. Perhaps it is a clearer name for the Cisco implementation design, but it is not a clear name for something that can/should be used for further derivations as may be more generally applicable. Following the TLS norm for exporters, the name would be \"authentication_master_secret\". The shortened \"authentication_secret\" was a good name. If you are going to provide a write-up for the custom taxonomy, then an adjustment to \"authentication_exporter\" could perhaps be made.",
          "createdAt": "2022-04-28T19:44:08Z",
          "updatedAt": "2022-04-28T19:44:42Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "The notion of a having boundary to the protocol and values that may or may not safely be exported across the boundary is not exotic or customized.  You see it in FIPS 140-2, PKCS#11, and WebCrypto, and in tools like ProVerif and Tamarin.  The only choice I'm making is in the specific words, in particular reserving \"secret\" for \"something that should not be exposed outside the protocol implementation because it would compromise the protocol\".\r\n\r\nI hope you agree that `authentication_secret` is different from say `epoch_secret` in this regard.  It would be OK for an MLS implementation to have an API for an application to access the `authentication_secret`, but it would not be OK to have an API to access the `epoch_secret`.\r\n\r\nI'm not wedded to `_code`, I just want something other than `_secret`.  If you want to align with the exported values (to which I agree it is similar), we could call it an `authentication_value`.\r\n\r\n",
          "createdAt": "2022-04-28T21:04:26Z",
          "updatedAt": "2022-04-28T21:04:26Z"
        },
        {
          "author": "br-hale",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The distinction between those documents and tools, and the MLS spec is that those tools clearly define the boundaries and terminology, vs. just anyone making terminology assumptions without them being specified in the document. Not to be pedantic, but if you want to assume specific meanings for terms relative to a threat model for MLS only, versus a general usage (\"exporter secrets\" being secrets used in other things), then you really do need to specify those assumptions within the specification itself and not various side discussions. Such specification is part of what a standard is meant to do. Within other documents this is clearly defined - i.e., what is known as a threat model - such as one sees in ProVerif and Tamarin. \r\n\r\nAssuming that you are going to add such a taxonomy, and that it follows that described by you in #630, then the correct term would be \"authentication_key\". To quote you what you said there, \r\n> \"key\" is something that gets fed into another algorithm, e.g., HMAC\r\n \r\n- which correctly aligns to a reasonable usage of the authentication_key. \r\n\r\n\r\n#630 pointed out that there is a lack of consistency in the usage of \"keys\" vs \"secrets\" throughout the document - something that still has not been addressed and should not be dropped from the issue for edits. Regardless of what taxonomy is being used or even assumed, there is no consistency in it in the spec. You seem to be commenting on adjustments only for the \"_key\" and \"_secret\" uses that appear as variables, but the commentary within the spec interchangeably use these terms for the same thing. Whatever is used should be applied consistently. It is not reasonable to assume that developers will correctly guess reasons for terminology separations particularly when they are inconsistently enforced. \r\n\r\n",
          "createdAt": "2022-04-29T00:17:30Z",
          "updatedAt": "2022-04-29T00:17:53Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "On your latter point about usage of \"keys\" vs \"secrets\" throughout the document \u2014 Sorry if I misinterpreted your intent here.  If you're seeing places where there are inconsistencies, it would be helpful if you could highlight those more specifically, or ideally send a PR to fix them.",
          "createdAt": "2022-04-29T19:24:43Z",
          "updatedAt": "2022-04-29T19:24:43Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "@br-hale had a call about this today and hashed out a couple of things:\r\n\r\n* We should be clear in general about what we mean by secrets/keys, in that we generally use them interchangeably, but sometimes use one or the other to indicate how a specific value is used\r\n* The need for secrecy of the value labeled `authentication_secret` depends on the context in which it is used.  So we should provide some text to suggest that there are different ways to use it, and use a fairly neutral name.  @br-hale  suggested `epoch_authenticator`, which I like a lot.\r\n\r\nI have attempted to implement these in #639",
          "createdAt": "2022-04-29T20:56:08Z",
          "updatedAt": "2022-04-29T20:56:08Z"
        }
      ]
    },
    {
      "number": 640,
      "id": "I_kwDOBoyH6c5JE_h5",
      "title": "Weak transcript binding of proposals by reference",
      "url": "https://github.com/mlswg/mls-protocol/issues/640",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "Bren2010"
      ],
      "labels": [
        "ready for PR"
      ],
      "body": "In #510 we changed from using full-size hash references to using truncated hashes.  This is fine for cases where the reference is only acting as a reference, so unambiguous identification is the only concern.\r\n\r\nFor proposal references, however, the hash-based reference is also the way that the proposal is incorporated into the transcript.  In this case, we end up with a looser binding with truncated hashes, since a malicious transcript need only match a subset of the bits of the hash.\r\n\r\nThis doesn\u2019t seem like a huge issue in practice, since if the hash function is broken enough to allow 128-bit collisions, we likely have deeper problems.  But it might mean that transcript integrity fails before other aspects of the protocol.\r\n\r\nTo fix this, we could either restore all hash-based identifiers to full size (basically, revert #510), or we could revert just the proposal references.  The former would be more uniform; the latter would be more parsimonious.  I\u2019m pretty ambivalent between the two.",
      "createdAt": "2022-05-04T22:56:59Z",
      "updatedAt": "2022-05-26T14:32:51Z",
      "closedAt": "2022-05-26T14:32:51Z",
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Virtual interim 2022-05-19:\r\n\r\n* Support for doing something here, given 64-bit birthday bound on collisions given 128 bit identifiers\r\n* Support for full-width everywhere\r\n",
          "createdAt": "2022-05-19T15:34:54Z",
          "updatedAt": "2022-05-19T15:34:54Z"
        }
      ]
    },
    {
      "number": 641,
      "id": "I_kwDOBoyH6c5JE_s9",
      "title": "Remove confirmation_tag from transcript",
      "url": "https://github.com/mlswg/mls-protocol/issues/641",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "On the one hand: It would simplify the transcript hash a fair bit if we omitted the confirmation_tag from the transcript.  We could get rid of the notion of the interim transcript hash.  It doesn\u2019t seem like there\u2019s much security being added by its inclusion, since it\u2019s determined by what came before.  In other words, including the confirmation tag in the transcript only serves to feed it into the next epoch secret, but the confirmation tag just summarizes the previous transcript and epoch secret, which are already fed into the next epoch secret via the init_secret.\r\n\r\nOn the other hand: The analogous value in TLS is the Finished messages, which are included in the transcript.\r\n\r\nWe should obviously only do this if supported by updated proofs.  @TWal ?\r\n",
      "createdAt": "2022-05-04T22:58:28Z",
      "updatedAt": "2022-05-19T15:36:26Z",
      "closedAt": "2022-05-19T15:36:26Z",
      "comments": [
        {
          "author": "br-hale",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Tagging @kkohbrok as we were just discussing this and how the confirmation_tag basically commits to more of the tree structure than just the rolling key derivation. I will take another look at this.",
          "createdAt": "2022-05-04T23:23:10Z",
          "updatedAt": "2022-05-04T23:23:10Z"
        },
        {
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I can't speak to the proofs, but one nice thing about including the confirmation tag in the transcript is that the transcript is a continuous aggregation of messages. As you point out @bifurcation the key schedule also indirectly includes all past messages, so I'm not overly concerned, but it generally means that the group context does not contain the \"history\" of the group anymore. So to get a value that really includes the group's history, we'd have to use an exporter, where previously, we could have just used the group context. Again, not sure this is a huge concern.\r\n\r\nOn another note: After all the cryptographic analysis that MLS has seen in the past, I find it a bit concerning that in the last minute, we're still tinkering with the cryptographic design. Intuitively, I don't think this proposed change, or the one to the membership tag computation are a problem, but I'd rather have a proof to back up that intuition. The way I understand the IETF release process, the next peer-review cryptographic proof that includes all the changes we make now is in all likelihood going to be released quite some time after the RFC itself.",
          "createdAt": "2022-05-09T07:07:53Z",
          "updatedAt": "2022-05-09T07:07:53Z"
        },
        {
          "author": "mulmarta",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Adding my 2 cents, similar @kkohbrok I'm a bit hesitant about changing the cryptographic design at this point. I would feel much more confident leaving it as is.\r\n\r\nThis being said, I think that removing the tag from the transcript should be secure. In fact, our security proof relies on the fact that agreement on the interim hash implies agreement on the confirmed hash. (This holds exactly for the reasons given by @bifurcation.) In other words, the tag is already indirectly included in the interim hash.\r\n\r\nAs a side note, if there could be many acceptable tags for 1 commit, the protocol may behave strangely. For instance, say we have a commit C with 2 possible acceptable confirmation tags T1 and T2. Say Alice accepts C with T1 and Bob accepts C with T2. They agree on the interim hash, so they have the same key schedule and can exchange application messages. However, they disagree on the confirmed hash so they will never accept commits from each other.",
          "createdAt": "2022-05-09T09:32:09Z",
          "updatedAt": "2022-05-09T09:32:09Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Virtual interim 2022-05-19:\r\n\r\n* Consensus that the simplification isn't worth the change at this point",
          "createdAt": "2022-05-19T15:36:26Z",
          "updatedAt": "2022-05-19T15:36:26Z"
        }
      ]
    },
    {
      "number": 642,
      "id": "I_kwDOBoyH6c5JE_79",
      "title": "Remove padding length from CiphertextContent",
      "url": "https://github.com/mlswg/mls-protocol/issues/642",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "As discussed [on the mailing list](https://mailarchive.ietf.org/arch/msg/mls/uqXL0UprgE7sf6NGkV5dg1yFRxk/), we should refactor `MLSCiphertextContent` so that the padding is not length-delimited, something like:\r\n\r\n```\r\nstruct {\r\n    select (content_type) { ... }\r\n    MLSMessageAuth auth;\r\n    uint8 zeros[length_of_padding];\r\n} MLSCiphertextContent;\r\n```",
      "createdAt": "2022-05-04T23:00:32Z",
      "updatedAt": "2022-05-19T14:22:37Z",
      "closedAt": "2022-05-19T14:22:37Z",
      "comments": []
    },
    {
      "number": 643,
      "id": "I_kwDOBoyH6c5JFAE_",
      "title": "Explanatory text: MLSMessageCommitContent ",
      "url": "https://github.com/mlswg/mls-protocol/issues/643",
      "state": "CLOSED",
      "author": "br-hale",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "ready for PR"
      ],
      "body": "TODO at some point: \r\nNarrative text to briefly explain MLSMessageCommitContent would be useful. At the moment this appears as a struct only twice in the spec - its contents in MLSMessageContent are defined and used frequently, but MLSMessageCommitContent is not ever mentioned in discussion text. Something as simple as a narrative comment that MLSMessageCommitContent is used as a combiner for transcript hashes and will not be referred to elsewhere would be useful, giving some scoping for the introduced term. ",
      "createdAt": "2022-05-04T23:01:36Z",
      "updatedAt": "2022-05-24T23:14:32Z",
      "closedAt": "2022-05-24T23:14:32Z",
      "comments": []
    },
    {
      "number": 644,
      "id": "I_kwDOBoyH6c5JFAFL",
      "title": "Illustrations for \u201cfiltered direct path\u201d",
      "url": "https://github.com/mlswg/mls-protocol/issues/644",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "bifurcation"
      ],
      "labels": [
        "ready for PR"
      ],
      "body": "In #587, we introduced the idea of a \"filtered direct path\".  It would be helpful to have an illustration of how a filtered direct path differs from a direct path.",
      "createdAt": "2022-05-04T23:01:38Z",
      "updatedAt": "2022-05-24T23:12:54Z",
      "closedAt": "2022-05-24T23:12:54Z",
      "comments": []
    },
    {
      "number": 645,
      "id": "I_kwDOBoyH6c5JFBts",
      "title": "Always operate on a full tree",
      "url": "https://github.com/mlswg/mls-protocol/issues/645",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "bifurcation"
      ],
      "labels": [],
      "body": "In order to use tree hashes to represent siblings in parent hashes, we had to compute a different tree hash on the right edge of the tree, pretending that the tree is full, in the sense of having `2^n` leaves.  Thus we actually have two tree hashes in play, one used for group agreement on the tree and one used for parent hash inputs.\r\n\r\nWe should consider specifying that the logical tree used by MLS is always full.  This change to the specification would not change the computations done by the protocol much, if at all.  Thanks to the fact that we no longer generate redundant nodes (#587), there is never anything non-blank to the right of the rightmost non-blank leaf anyway.  So the main impact is to insert some blank nodes between a parent node on the right edge of the tree and its right child -- and all of the algorithms in the specification already skip over such nodes.\r\n\r\nLikewise, implementations' internal represntations of the tree wouldn't have to change much, since the extra nodes could be \"virtual\".  The only time they would be noticed is when computing tree hashes.  We would have to update the description of the `ratchet_tree` extension to say that it only covers the tree up to the rightmost non-blank leaf.\r\n\r\nIt would simplify the specification in a few ways, for example: \r\n* The \"original sibling tree hash\" would just entail blanking unmerged leaves, not structure changes.  \r\n* The description of extending and truncating the tree would be much simpler.\r\n\r\nThe main cost would be extra hashes when joining, or when updating a member close to the right edge of the tree.  If you have a tree with `2^n + 1` leaves, then you have to compute tree hashes over `2^n - 1` blank leaves and their `2^n - 2` blank parents.\r\n",
      "createdAt": "2022-05-04T23:14:27Z",
      "updatedAt": "2022-06-02T21:31:09Z",
      "closedAt": "2022-06-02T21:31:09Z",
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks to @mulmarta and @TWal for helping inspire and develop this idea in discussions around #635 ",
          "createdAt": "2022-05-05T03:10:32Z",
          "updatedAt": "2022-05-05T03:10:32Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Virtual interim 2022-05-19\r\n\r\n* @mulmarta notes that the current tree hash is quite tricky to implement, so this would be a useful simplification\r\n* Doubling the hashes on a fresh tree doesn't sound too intimidating\r\n* Folks would find more concreteness useful here, interested in PR\r\n* Could we phrase this as *only* a change to TreeKEM?\r\n    * Would be premised on the equivalence of the hashed tree an the tree you operate on\r\n\r\n",
          "createdAt": "2022-05-19T15:47:19Z",
          "updatedAt": "2022-05-19T15:47:19Z"
        },
        {
          "author": "seanturner",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Discussed at 19 May interim: @bifurcation to draft a PR.",
          "createdAt": "2022-05-19T15:47:44Z",
          "updatedAt": "2022-05-19T15:47:44Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Holding a PR until after #689 lands.\r\n\r\nSome notes on what would need to change:\r\n\r\n* {{ratchet-tree-terminology}} would change from \"the unique left-balanced tree with N leaves\" to \"the unique balanced binary tree with depth `d`, where `d` is the smallest number such that `N <= 2^d`\".\r\n* {{adding-and-removing-leaves}} would either be removed, or updated so that it talks about increasing or decreasing the depth of the tree (equivalently, doubling or halving the number of leaves).\r\n* {{add}} would talk about increasing depth instead of adding leaves.\r\n* {{remove}} would talk about decreasing depth instead of removing leaves.\r\n* {{ratchet-tree-extension}} would be explicit that it only carries nodes up to the rightmost non-blank leaf.  The encoding/decoding algorithms would have to be updated.\r\n* {{array-based-trees}} and {{link-based-trees}} could probably be simplified.\r\n* We would need to make sure all figures showed full trees.",
          "createdAt": "2022-05-23T21:57:28Z",
          "updatedAt": "2022-05-23T21:57:28Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "I went ahead and filed #694 for this, based on top of #689.  Once that merges, we can update the PR to be a little easier to read.  The changes are basically as described above.\r\n\r\nOne additional note: We have actually already incurred the cost to a new joiner of hashing all the extra nodes, because they have to do it for parent hash verification anyway.  So this approach is actually a net reduction in the amount of hashing that has to be done, since they don't have to also compute the non-full-tree hashes.",
          "createdAt": "2022-05-24T18:48:57Z",
          "updatedAt": "2022-05-24T18:48:57Z"
        }
      ]
    },
    {
      "number": 647,
      "id": "I_kwDOBoyH6c5JFaA3",
      "title": "Remove context from MLSMessageContentTBM",
      "url": "https://github.com/mlswg/mls-protocol/issues/647",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Right now, MLSMessageContentTBM includes MLSMessageContentTBS, which includes the GroupContext.  This seems like an unnecessary complication.  MLSMessageContentTBM exists to be the input for the `membership_tag`, and the purpose of the `membership_tag` is to prove that the sender of the message is in the group.  That purpose would be met by MAC'ing the message itself, without additional context.  Before the message is used by the group, its signature will be verified, so the sender's knowledge of the group context will be proven at that stage.\r\n\r\nOn a semi-related note, MLSMessageContentTBM is only used when creating MLSPlaintext, so it would be more properly called MLSPlaintextTBM.\r\n\r\nPutting all that together:\r\n\r\n```\r\nstruct {\r\n  MLSMessageContent content;\r\n  MLSMessageAuth auth;\r\n} MLSPlaintextTBM;\r\n```\r\n\r\n",
      "createdAt": "2022-05-05T03:09:07Z",
      "updatedAt": "2022-05-19T14:32:17Z",
      "closedAt": "2022-05-19T14:32:17Z",
      "comments": [
        {
          "author": "mulmarta",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Like with #641 , I'm hesitant about changing the crypto design at this point. Such changes do affect the proofs.\r\n\r\nThis being said, removing the context from the MAC should be secure, but for a reason that has nothing to do with signatures. The purpose of the MAC is to protect against injections in epochs where the key schedule is secret, but some signature keys are compromised. This is achieved without MACing the context, because the context is already mixed into the derivation of the MAC key. In other words, each epoch (with its fixed unique context) uses an independent MAC key.\r\n\r\n@bifurcation I'm not sure I follow your justification. 1) The adversary can sign anything using the compromised signing keys, so I don\u2019t see how you can derive any guarantees from signatures. 2) \"Proving knowledge\" of the context doesn't seem too useful since the context only contains public values (if we send commits in the plaintext mode). I think the membership tag should prove the knowledge of the (secret) key schedule instead.",
          "createdAt": "2022-05-09T09:36:47Z",
          "updatedAt": "2022-05-09T09:36:47Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "On the interim 2022-05-19:\r\n\r\n* @psyoptix pointed out that relying on the context being put into the key is sort of a non-standard way of using MACs\r\n* @mulmarta suggested some clarification around the purpose of the membership MAC,\r\n* Agreed to close the issue and PR to avoid making significant changes to the analysis.",
          "createdAt": "2022-05-19T14:32:16Z",
          "updatedAt": "2022-05-19T14:32:16Z"
        }
      ]
    },
    {
      "number": 648,
      "id": "I_kwDOBoyH6c5JFblh",
      "title": "Clarify order of operations in processing external join",
      "url": "https://github.com/mlswg/mls-protocol/issues/648",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "ready for PR"
      ],
      "body": "In #511, we removed the requirement for an external Commit to have an Add proposal, under the theory that the required `path` already has a leaf node for the new joiner.  When I went to implement this, however, I noticed some ambiguities. \r\n\r\nFirst, the Commit processing section doesn't mention when the new joiner is added.  The obvious approach is to do the add as part of the `path` processing, but that processing presumes that the sender is already in the tree (for example, there is no provision for extending the tree).\r\n\r\nSecond, the UpdatePath for an external commit needs to be done in a specific order in order to avoid a circular dependency.  The TreeKEM encapsulation done by the joiner uses the GroupContext a context parameter, including the hash of the tree being used.  But the LeafNode in the `path.leaf_node` has to have a parent hash in it, which can only be computed after the encapsulation operation.  This circularity can be resolved, but only by preparing the UpdatePath with the following specific steps:\r\n\r\n1. Compute the path secrets\r\n2. Compute the parent hash and the new leaf node\r\n3. Compute the new tree hash\r\n4. Encrypt the path secrets to the rest of the group\r\n\r\nThat rules out some implementations that compute path secrets and encrypt them in one traversal of the direct path (this is what MLSpp does now).\r\n\r\nThe options here are basically:\r\n\r\n1. Re-add the Add proposal, thus having a throw-away temporary LeafNode for the joiner\r\n2. Specify that the UpdatePath must be computed in the specific order above\r\n\r\nTo me, (2) seems like a pretty clear winner.",
      "createdAt": "2022-05-05T03:22:55Z",
      "updatedAt": "2022-05-26T14:47:46Z",
      "closedAt": "2022-05-26T14:47:46Z",
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Actually, it seems like there's a simpler option here:\r\n\r\n* Extend the definition of an ExternalInit proposal to say that part of how it is applied is to ensure there is a blank leaf in the tree, extending the tree if necessary.  (This implies that ExternalInit must be done after any Remove.)  The leftmost blank leaf is the sender's leaf for purposes of UpdatePath processing.\r\n* The provisional tree used in encrypting path secrets is still the provisional tree, in the sense that all proposals have been applied.  This tree has a blank leaf for the UpdatePath sender.\r\n\r\nIf we clarify these points, I think everything else works unmodified.",
          "createdAt": "2022-05-23T22:10:14Z",
          "updatedAt": "2022-05-23T22:10:14Z"
        },
        {
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I agree with the first point. Even if the Add is not explicitly present, the external commit effectively emulates an Add anyway.\r\n\r\nTo the second point: The solution is only simpler if that's how you want to implement it \ud83d\ude1c. I haven't tried it, but if you have chosen a different order of implementation, i.e. perform all changes to the provisional tree (including the update path and parent hash), then compute the tree hash and then encrypt the path, you now have to go and compute an additional tree hash before applying the update path, then apply the update path and keep the partial tree hash around for later encryption/decryption.\r\n\r\nThis was not a part of MLS that I have looked at from a provable security perspective, but I'm wondering what the consequences are from a security perspective if we're including a parent hash for an incomplete provisional tree.",
          "createdAt": "2022-05-24T05:35:52Z",
          "updatedAt": "2022-05-24T05:35:52Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "It seems like the main question here is what tree is provided to TreeKEM encryptions of path secrets.  I'll call this the \"context tree\" below.\r\n\r\nIt sounds like you have in mind that the tree provided to TreeKEM has the UpdatePath applied as well as the proposals, but that's not what the spec says right now:\r\n\r\n> \"Provisional\" refers to the ratchet tree and GroupContext constructed after applying the proposals that are referenced by the Commit. \r\n\r\n> \"New\" refers to the ratchet tree and GroupContext constructed after applying the proposals and the UpdatePath (if any).\r\n\r\n> Create an UpdatePath using the provisional ratchet tree and GroupContext\r\n\r\nThe starting point for this issue is that the \"provisional\" tree right now doesn't really faithfully capture the tree you're encrypting to, at least in the sense that it has a different number of leaves.  That seemed wrong to me.\r\n\r\nIt seems like we have the following options here:\r\n\r\n1. Do nothing. \r\n    * The context tree doesn't necessarily have a blank for the joiner.\r\n    * Maximal divergence between the new tree and the context tree (among these options)\r\n    * TreeKEM encryption operates on a different tree than the context tree\r\n\r\n2. Ensure the provisional tree has a blank leaf for the joiner (as up-thread).\r\n    * Context tree has a blank leaf for the joiner, but direct path doesn't match new tree\r\n    * TreeKEM encryption can operate on the context tree, because the structure is correct\r\n\r\n3. Use the \"new\" ratchet tree as the TreeKEM context.\r\n    * Context tree is exactly the new tree -- could probably eliminate provisional\r\n    * Requires separate steps for (1) updating tree nodes and (2) encrypting path secrets\r\n    * ... when these are currently described together as effectively one operation\r\n\r\nPersonally, it seems like the answer is (2) or (3), and I probably lean toward (3).  I don't think (1) is insecure, because the context tree does capture all of the nodes to which path secrets are encrypted.  But the divergence is worrisome and it's cheap to do better.\r\n\r\nBetween (2) and (3), there's a trade-off between fidelity and spec change size.  The impact of (2) is more localized (just the ExternalInit section).  Updating the spec to do (3) will require amending the description of update paths as well as the Commit creation / processing rules (to separate update/encrypt and remove provisional, respectively).  But honestly, removing the provisional tree seems like a worthwhile simplification, so between that and the greater fidelity of the context tree, (3) seems worth the cost.",
          "createdAt": "2022-05-24T12:57:18Z",
          "updatedAt": "2022-05-24T12:57:18Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Actually, as I look into implementing this: We still need a provisional GroupContext, because the `confirmed_transcript_hash` will differ. But we can at least have two trees instead of three.",
          "createdAt": "2022-05-24T13:06:50Z",
          "updatedAt": "2022-05-24T13:06:50Z"
        }
      ]
    },
    {
      "number": 649,
      "id": "I_kwDOBoyH6c5JGCcO",
      "title": "AppAck considered harmful in large busy groups",
      "url": "https://github.com/mlswg/mls-protocol/issues/649",
      "state": "CLOSED",
      "author": "rohan-wire",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "The way the spec is written now, clients need to implement all proposal types, and they must react to appropriately to all valid proposals, including AppAck.  AppAck in a large, busy group could result in a situation where clients with longer latency connections to the DS (perhaps in a different country, using satellite, or using some wireless networks) might be effectively prevented from sending any messages, or worse could be prevented from sending AppAcks because their proposals are always a few hundred milliseconds late.\r\n\r\nI think AppAcks still have a place is relatively small groups with low message volumes, but I have a few suggestions:\r\n1) Describe this issue either in the AppAck proposal section or in the security considerations section\r\n2) I think it is reasonable for a group to consider some proposal types invalid. If there is consensus with this position, I'd like to make this clear with an extra sentence or two.  If that is not the consensus, then I will propose that only Add, Remove, and Update are assumed to be supported by each group, and other proposal types have to be explicitly added.",
      "createdAt": "2022-05-05T07:58:35Z",
      "updatedAt": "2022-05-20T17:49:00Z",
      "closedAt": "2022-05-20T17:49:00Z",
      "comments": [
        {
          "author": "tomleavy",
          "authorAssociation": "CONTRIBUTOR",
          "body": "My team had similar comments. I agree that this shouldn't be a 100% necessary thing to support. ",
          "createdAt": "2022-05-05T12:41:41Z",
          "updatedAt": "2022-05-05T12:41:41Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "I would differentiate between \"support\" in the sense of \"if you receive one, do something sensible with it\" vs. \"send this under some circumstances\".  My understanding was that the requirement here was the former, and even that the definition of \"sensible\" was up to the implementation.  The thinking being that if an application wanted to get some anti-suppression properties, it could send and verify these on some schedule, but when exactly they would be sent would be up to the application.  Does that alleviate some of the concern here?  If so, I would totally be open to clarifying that.\r\n\r\nTo @rohan-wire's point about latency, it seems like we could add an `epoch` parameter to AppAck so that you could report on past epochs' messages in a future epoch.\r\n\r\nOn considering proposal types invalid -- I think there has always been a notion that applications might have policies on which proposals are acceptable.  Not just at the proposal type level, but at even finer granularities.  Think about things like groups where only certain members are allowed to add/remove participants.  I would also be fine laying this out more explicitly, though maybe it would be a more natural fit in the architecture document.",
          "createdAt": "2022-05-05T13:30:35Z",
          "updatedAt": "2022-05-05T13:30:35Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Sorry, meant to delete a comment, closed the issue instead.",
          "createdAt": "2022-05-05T16:13:49Z",
          "updatedAt": "2022-05-05T16:13:49Z"
        },
        {
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "body": "In the past I've expressed reservations about AppAck being included in the spec. I don't think it's sufficiently general (it only handles a one specific pattern of message loss and won't work for others, per @rohan-wire's comment), and I don't like that we don't specify how to handle dropped messages in any way. The AppAck functionality is likely to just be re-invented at the application-level because of this. For example,\r\n- AppAck can't be used to implement read receipts\r\n- It doesn't help detect the suppression of handshake messages\r\n- It doesn't handle cases where some messages must be delivered and others may be dropped\r\n\r\nSo instead I would propose removing AppAck from the spec.",
          "createdAt": "2022-05-05T16:46:21Z",
          "updatedAt": "2022-05-05T16:46:21Z"
        },
        {
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "body": "I've opened a PR to that effect in #654.",
          "createdAt": "2022-05-05T17:11:43Z",
          "updatedAt": "2022-05-05T17:11:43Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Virtual interim 2022-05-19\r\n\r\n* Agreement that the bar for support is quite low\r\n* ... but you don't get a security property unless members actually do something more than the minimum\r\n* That sort of implies that you want the group to opt in to this mechanism\r\n* So we should have a new proposal type in a separate I-D",
          "createdAt": "2022-05-19T15:27:54Z",
          "updatedAt": "2022-05-19T15:27:54Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "(To be clear, AppAck should move from the main spec here to its own I-D.)",
          "createdAt": "2022-05-19T15:28:36Z",
          "updatedAt": "2022-05-19T15:28:36Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Closed by #654 ",
          "createdAt": "2022-05-20T17:49:00Z",
          "updatedAt": "2022-05-20T17:49:00Z"
        }
      ]
    },
    {
      "number": 655,
      "id": "I_kwDOBoyH6c5JK93L",
      "title": "Tree hash and Parent hash definitions are confusing",
      "url": "https://github.com/mlswg/mls-protocol/issues/655",
      "state": "CLOSED",
      "author": "rohan-wire",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Regarding the Tree Hash\r\n1. Including the parent_node in the tree hash which is supposed to be computed from the leaves, makes the definition appear circular to a new reader. Since the situation when you have blank nodes in the middle of a tree but not at the root is a rather complicated, the situation when you could calculate a tree hash using the parent_node is non-obvious.\r\n2. In the description of Tree Hash the document says that the ParentNode object is optional \"depending on whether the node is blank or not.\" This isn't clear specification language. Saying the parent_node object is present if the node is blank or present if the node is not blank would be clear. \r\n3. What if the parent node is also blank? What if the root is blank? \r\n4. I think an example with and without blank nodes would be appropriate.\r\n5. Explaining the reason why the parent_node is included will help the reader establish a better mental model.\r\n\r\nRegarding the Parent Hash\r\nI still find this section super confusing. A few points\r\n1. Using a tree hash (sibling_tree_hash) inside the parent hash is non-obvious. There should be some explanation about what property this is providing and that it is a tree hash and not a parent hash. (Honestly it was the third time I read the section that I realized that it was really the tree hash and not the parent hash of the sibling.) \r\n2. Using P, V, and S for Parent, target node, and sibling node is introduced here and never used anywhere else in the document. P for parent and S for sibling make sense. I can't tell what V is supposed to stand for, and it unfortunately could cause people to confuse the <V> vector notation used throughout, but shortly after introducing V for the target node. I propose using \"N\" for node or \"X\" instead.\r\n3. There is one reference to the filtered direct path of U. Perhaps this is V, or a child of V?\r\n4. The calculations are sufficiently complicated that I think this warrants a complete, non-trivial, worked example (possibly in an appendix). At some point we should consider providing test vectors in a future document, and this would be an ideal candidate. \r\n",
      "createdAt": "2022-05-06T09:11:52Z",
      "updatedAt": "2022-06-07T22:48:13Z",
      "closedAt": "2022-06-07T22:48:13Z",
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Regarding the Tree Hash\r\n\r\n> 1. Including the parent_node in the tree hash which is supposed to be computed\r\n> from the leaves, makes the definition appear circular to a new reader. Since the\r\n> situation when you have blank nodes in the middle of a tree but not at the root\r\n> is a rather complicated, the situation when you could calculate a tree hash\r\n> using the parent_node is non-obvious.\r\n\r\nTo be clear, the `parent_node` that is included in the tree hash is the node\r\nwhose subtree is being hashed.  The tree hash doesn't include only the leaves,\r\nit includes all the nodes in the tree.\r\n\r\nIf you mean `parent_hash`, then yes, I agree the connection is a little subtle.\r\nI've tried to explain this a little better.\r\n\r\n\r\n> 2. In the description of Tree Hash the document says that the ParentNode object\r\n> is optional \"depending on whether the node is blank or not.\" This isn't clear\r\n> specification language. Saying the parent_node object is present if the node is\r\n> blank or present if the node is not blank would be clear.\r\n\r\nUpdated this to be clear that the ParentNode is omitted if and only if the node is blank.\r\n\r\n\r\n> 3. What if the parent node is also blank? What if the root is blank?\r\n\r\nNot clear what situation you mean here.  I think the specific computations are\r\npretty clearly specified for these cases.\r\n\r\n\r\n> 4. I think an example with and without blank nodes would be appropriate.\r\n\r\nSomething like this was added in #689:\r\n\r\nhttps://github.com/mlswg/mls-protocol/blob/main/draft-ietf-mls-protocol.md#verifying-parent-hashes\r\n\r\nI extended the example and put it in an appendix.\r\n\r\n\r\n> 5. Explaining the reason why the parent_node is included will help the reader\r\n> establish a better mental model.\r\n\r\nAssuming you mean `parent_hash` here, hopefully this is addressed by the above notes. \r\n\r\n\r\n> 1. Using a tree hash (sibling_tree_hash) inside the parent hash is non-obvious.\r\n> There should be some explanation about what property this is providing and that\r\n> it is a tree hash and not a parent hash. (Honestly it was the third time I read\r\n> the section that I realized that it was really the tree hash and not the parent\r\n> hash of the sibling.)\r\n\r\nAdded a note to clarify that this is the tree hash and why.\r\n\r\n\r\n> 2. Using P, V, and S for Parent, target node, and sibling node is introduced\r\n> here and never used anywhere else in the document. P for parent and S for\r\n> sibling make sense. I can't tell what V is supposed to stand for, and it\r\n> unfortunately could cause people to confuse the vector notation used throughout,\r\n> but shortly after introducing V for the target node. I propose using \"N\" for\r\n> node or \"X\" instead.\r\n\r\nChanged to \"D\" for \"direct path\", and explained the semantics.\r\n\r\n\r\n> 3. There is one reference to the filtered direct path of U. Perhaps this is V,\r\n> or a child of V?\r\n\r\nActually it's the leaf, which is now called \"L\".\r\n\r\n\r\n> 4. The calculations are sufficiently complicated that I think this warrants a\r\n> complete, non-trivial, worked example (possibly in an appendix). At some point\r\n> we should consider providing test vectors in a future document, and this would\r\n> be an ideal candidate.\r\n\r\nI think the example linked above does a pretty good job.  Feedback obviously\r\nwelcome.  Agreed that a test vectors document will be a useful follow-on.\r\n",
          "createdAt": "2022-06-01T23:31:54Z",
          "updatedAt": "2022-06-01T23:31:54Z"
        }
      ]
    },
    {
      "number": 657,
      "id": "I_kwDOBoyH6c5JN0hi",
      "title": "Undefined behavior around removed Committer",
      "url": "https://github.com/mlswg/mls-protocol/issues/657",
      "state": "CLOSED",
      "author": "Bren2010",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "It's not clear to me from reading the spec what should happen when a Commit includes a Remove proposal for the committer.",
      "createdAt": "2022-05-06T20:30:21Z",
      "updatedAt": "2022-05-25T18:57:04Z",
      "closedAt": "2022-05-25T18:57:04Z",
      "comments": [
        {
          "author": "rohan-wire",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think that sending a Commit with a Remove Proposal for yourself (the sender of the Commit) doesn't make sense and should be invalid. If you want to remove yourself, it would be better to send a separate Remove Proposal. Then another member is obliged to Commit your Proposal. Of course if a all the members try to send a Proposal nearly simultaneously, the last member should probably Commit all the proposals before closing the group.",
          "createdAt": "2022-05-10T22:21:23Z",
          "updatedAt": "2022-05-10T22:21:23Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Yeah, I always thought it was illegal for a Commit to include a Remove for the Committer.  Flagging for @mulmarta as she's working on a proposal validation PR.",
          "createdAt": "2022-05-16T21:06:59Z",
          "updatedAt": "2022-05-16T21:06:59Z"
        },
        {
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Since the committer learns the secrets of the next epoch, committing a self-remove really should be illegal.",
          "createdAt": "2022-05-17T06:13:27Z",
          "updatedAt": "2022-05-17T06:13:27Z"
        }
      ]
    },
    {
      "number": 661,
      "id": "I_kwDOBoyH6c5Jo4xz",
      "title": "Specify that clients MUST ensure the group id is unique and fixed for each group.",
      "url": "https://github.com/mlswg/mls-protocol/issues/661",
      "state": "CLOSED",
      "author": "Bren2010",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "ready for PR"
      ],
      "body": "Group ids are signed to bind certain information to specific groups. But I can imagine a case where a user mis-uses the group id to be something like a \"room title\" which lets an adversary control the group id and introduces potential problems.\r\n\r\n- If we can prove that it's fine for a group id to be reused, then should we get rid of group ids?\r\n- If not (as I expect), then group ids need to be guaranteed to be unique [globally | per client | per signing key] and we need to specify that.",
      "createdAt": "2022-05-13T16:31:40Z",
      "updatedAt": "2022-05-28T18:56:41Z",
      "closedAt": "2022-05-28T18:56:41Z",
      "comments": [
        {
          "author": "seanturner",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Discussed at 19 May interim. @Bren2010 to generate PR documenting fresh random value approach.",
          "createdAt": "2022-05-19T15:53:43Z",
          "updatedAt": "2022-05-19T15:53:43Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Virtual interim 2022-05-19:\r\n\r\n* Agreement that some sort of uniqueness requirement is worthwhile\r\n* Main question is what scope of uniqueness should be\r\n    * Globally?  Within scope of DS? \r\n    * Fresh random value?\r\n        * Simple, but precludes application usage of the field\r\n        * Also could help avoid metadata leakage\r\n        * Client / DS should probably still check for collisions\r\n* @Bren2010 to write up a PR on the fresh random value idea",
          "createdAt": "2022-05-19T15:53:43Z",
          "updatedAt": "2022-05-19T15:53:43Z"
        },
        {
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "body": "- Group IDs must be generated randomly by creator\r\n- Clients and DS must check that group ids are unique as far as they know",
          "createdAt": "2022-05-19T15:53:44Z",
          "updatedAt": "2022-05-19T15:53:44Z"
        }
      ]
    },
    {
      "number": 663,
      "id": "I_kwDOBoyH6c5JsmQD",
      "title": "Leaf/parent indicator bit in tree hash?",
      "url": "https://github.com/mlswg/mls-protocol/issues/663",
      "state": "CLOSED",
      "author": "Bren2010",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "ready for PR"
      ],
      "body": "When computing the tree hash, should there be an indicator bit for whether the value being hashed represents a leaf or parent node?",
      "createdAt": "2022-05-15T21:48:20Z",
      "updatedAt": "2022-05-28T18:58:45Z",
      "closedAt": "2022-05-28T18:58:45Z",
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "This doesn't seem like a terrible idea.  You could either add a field `uint8 leaf_or_parent = 0/1;` to LeafNodeHashInput and ParentNodeHashInput, or define an enum and do the same, or make a `select`.  For example:\r\n\r\n```\r\nenum { reserved(0), leaf(1), parent(2), (255) } TreeNodeType;\r\n\r\nstruct {\r\n    TreeNodeType node_type;\r\n    select (TreeHashInput.node_type) {\r\n        case leaf: /* ParentNodeHashInput, as a struct or inlined */\r\n        case parent: /* ParentNodeHashInput, as a struct or inlined */\r\n    }\r\n} TreeHashInput;\r\n```\r\n",
          "createdAt": "2022-05-20T17:58:40Z",
          "updatedAt": "2022-05-20T17:58:40Z"
        }
      ]
    },
    {
      "number": 664,
      "id": "I_kwDOBoyH6c5Jxtie",
      "title": "Add a citation for AEAD limits",
      "url": "https://github.com/mlswg/mls-protocol/issues/664",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "In the \"Restrictions\" section, we say \"During each epoch senders MUST NOT encrypt more data than permitted by the security bounds of the AEAD scheme used\", without specifying the limits.  We should cite something here, probably [draft-irtf-cfrg-aead-limits](https://datatracker.ietf.org/doc/draft-irtf-cfrg-aead-limits/) (cc @chris-wood for visibility).",
      "createdAt": "2022-05-16T21:52:22Z",
      "updatedAt": "2022-05-20T17:42:21Z",
      "closedAt": "2022-05-20T17:42:21Z",
      "comments": []
    },
    {
      "number": 665,
      "id": "I_kwDOBoyH6c5JxuJP",
      "title": "Consolidate Proposal application into its own subsection",
      "url": "https://github.com/mlswg/mls-protocol/issues/665",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "bifurcation"
      ],
      "labels": [],
      "body": "* ~Specify inputs and outputs for creation~\r\n    * ~Inputs: Group state, proposals, wire format (pt/ct)~\r\n    * ~Outputs: New group state, MLSMessageContentAuth(Commit), Welcome~\r\n* ~Clarify that the \u201cProvisional\u201d GroupContext includes the extensions specified in any GroupContextExtensions proposal, if any~\r\n* Expand the rules on applying proposals to clearly address how each proposal type is processed\r\n    * Maybe pull into a separate subsection?  \u201cApplying Proposals\u201d after \"External Proposals\"\r\n* In Commit processing, remove text on applying proposals and just refer to creation steps\r\n\r\n(The ~strikethrough~ items above have been fixed by more recent PRs.  Renaming for clearer focus.)",
      "createdAt": "2022-05-16T21:55:02Z",
      "updatedAt": "2022-06-02T21:58:06Z",
      "closedAt": "2022-06-02T21:58:06Z",
      "comments": []
    },
    {
      "number": 666,
      "id": "I_kwDOBoyH6c5JxvH6",
      "title": "Clean up PSK specification",
      "url": "https://github.com/mlswg/mls-protocol/issues/666",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "ready for PR"
      ],
      "body": "* `psk_nonce` currently described at time of use.  In the \"Pre-Shared Keys\" section, we should just specify that it must always be a fresh value of length `KDF.Nh`\r\n* The ReInit provisions require `epoch=1`, but those for branching do not.  Presumably these should be the same?\r\n* Currently, the processing rules for PreSharedKey proposal says \u201cMUST be external\u201d.  This seems overly restrictive; for example, it rules out the scenario in Figure 8.  Suggest \u201cMUST NOT be branch/reinit\u201d instead.",
      "createdAt": "2022-05-16T21:58:49Z",
      "updatedAt": "2022-05-27T13:45:03Z",
      "closedAt": "2022-05-27T13:45:03Z",
      "comments": []
    },
    {
      "number": 667,
      "id": "I_kwDOBoyH6c5Jxwd_",
      "title": "Accommodate decryption-from-self in deletion schedule",
      "url": "https://github.com/mlswg/mls-protocol/issues/667",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Right now, the deletion schedule requires a key to be consumed if it is used to \"encrypt or (successfully) decrypt a message\".  This means that a client can't decrypt its own messages, because the key has already been deleted.  On the one hand, this isn't a tragedy, since in principle the client could just hold on to the plaintext.  On the other hand, it requires some lightly painful special-casing for things like proposals and application data, where the message is broadcast.  (On the third hand, receiving Commits from yourself already requires special processing.)\r\n\r\nIt seems like this could be fixed by just changing the deletion requirement to trigger only on decrypt instead of on encrypt or decrypt.  In scenarios where a sender gets her messages back, the effect would be the same, modulo an RTT.  You would have reduced FS in scenarios where the DS does not echo a message back to a sender.",
      "createdAt": "2022-05-16T22:04:44Z",
      "updatedAt": "2022-05-19T15:58:54Z",
      "closedAt": "2022-05-19T15:58:54Z",
      "comments": [
        {
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "If I understand correctly, the result of this change would be that there is no FS for the sender of any message until the end of the epoch or until the secret tree of that epoch is deleted. So you would always have reduced FS. Just in cases there is no echo, you wouldn't have needed the reduction in the first place.\r\n\r\nIn any case, I'd prefer keeping the strict deletion schedule at the cost of some slight inconvenience in the implementation. Although as you say, own commits need to be treated differently anyway.",
          "createdAt": "2022-05-17T06:25:27Z",
          "updatedAt": "2022-05-17T06:25:27Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "There wouldn't be FS with regard to the sender of a message until the sender receives the message back.  In the echo case, that is quick; in the no-echo case, it is the end of the epoch + any out-of-order delivery window, as you say.\r\n\r\nIt depends some on what the application wants as well.  If the application never needs to receive from itself and forgets what it sends after sending it, then the current situation is fine.  If the application remembers what it sends (as with current messengers), then the sender will be holding on to the plaintext anyway, so the notion of FS with regard to the sender is kind of moot.\r\n\r\nFor completeness, an intermediate position here would be to say:\r\n\r\n* MUST delete on successful decrypt\r\n* SHOULD delete on encrypt, unless required by application context (with explanatory text about decrypt-from-self).\r\n\r\nThat seems worse than the alternatives, though, because it's a hard-to-understand knob for the application to set.",
          "createdAt": "2022-05-17T14:38:56Z",
          "updatedAt": "2022-05-17T14:38:56Z"
        },
        {
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "An example of note here is the self-deleting messages feature that exist in quite a few messaging apps. Here, you want to send the message and forget it and you explicitly _don't_ want to keep the key material. I think that should be a feature that can be enabled by MLS, either by default or by letting the application choose, i.e. the intermediate position that you describe.",
          "createdAt": "2022-05-17T14:50:31Z",
          "updatedAt": "2022-05-17T14:50:31Z"
        },
        {
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "body": "This would also seem to have a higher likelihood of encryption keys accidentally being reused.",
          "createdAt": "2022-05-17T18:35:27Z",
          "updatedAt": "2022-05-17T18:35:27Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "@Bren2010 - I'm not sure I follow.  Do you mean that because the key would still exist, there's a risk of key management bugs using an old key?",
          "createdAt": "2022-05-17T19:42:06Z",
          "updatedAt": "2022-05-17T19:42:06Z"
        },
        {
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "body": "Yes, I think there's a higher risk of bugs because the key is still around and you're doing additional accounting to separate which ratchet the implementation is using for the next encryption and which is for the next decryption. Being able to delete the key after it was used, regardless of why, is a nice simplification.\r\n\r\nThe cost of that simplification is that if you want to decrypt-from-self then you need to implement an additional layer that, for example, maps hashes of sent messages to their decrypted/authenticated version. But like people have said, if you're interested in doing decrypt-from-self then you're likely already keeping records of sent messages anyway. So this shouldn't be a big additional burden.",
          "createdAt": "2022-05-17T20:48:49Z",
          "updatedAt": "2022-05-17T20:48:49Z"
        },
        {
          "author": "tomleavy",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> An example of note here is the self-deleting messages feature that exist in quite a few messaging apps. Here, you want to send the message and forget it and you explicitly _don't_ want to keep the key material. I think that should be a feature that can be enabled by MLS, either by default or by letting the application choose, i.e. the intermediate position that you describe.\n\nAgreed. I also didn't find the current situation too difficult to implement in practice when I wrote a demo of a websocket relay. It's easy enough to just have to relay filter out the sender from the broadcast or send an ack in place of the message to the sender. ",
          "createdAt": "2022-05-17T23:18:40Z",
          "updatedAt": "2022-05-17T23:18:40Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Virtual interim 2022-05-19:\r\n\r\n* Folks are uncomfortable with the reduced FS here\r\n* ... and not as concerned with the special-casing",
          "createdAt": "2022-05-19T15:58:54Z",
          "updatedAt": "2022-05-19T15:58:54Z"
        }
      ]
    },
    {
      "number": 668,
      "id": "I_kwDOBoyH6c5Jxwx7",
      "title": "Introduce GroupContext in terminology",
      "url": "https://github.com/mlswg/mls-protocol/issues/668",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "There are several references to GroupContext in the first few sections.  The details are fine where they are, but it would be good to introduce the notion that GroupContext summarizes the state of the group.",
      "createdAt": "2022-05-16T22:05:38Z",
      "updatedAt": "2022-05-20T17:44:44Z",
      "closedAt": "2022-05-20T17:44:44Z",
      "comments": []
    },
    {
      "number": 669,
      "id": "I_kwDOBoyH6c5JxxSD",
      "title": "More pictures",
      "url": "https://github.com/mlswg/mls-protocol/issues/669",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "Bren2010"
      ],
      "labels": [
        "ready for PR"
      ],
      "body": "* Add illustration of filtered direct path\r\n* Add illustration of parent hash validation, including:\r\n    * Leaves with no parent hash\r\n    * Nodes with invalid parent hash\r\n    * Skipping blank nodes\r\n* Add corresponding derivations to Appendix A\r\n* Move figure in Section 10.2 up to Section 10 as an overview",
      "createdAt": "2022-05-16T22:07:15Z",
      "updatedAt": "2022-05-24T16:59:27Z",
      "closedAt": "2022-05-24T16:59:27Z",
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "@Bren2010 Note that I have taken a stab at parts of this in #689 because it came along with some other tree stuff.",
          "createdAt": "2022-05-21T21:13:30Z",
          "updatedAt": "2022-05-21T21:13:30Z"
        },
        {
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "body": "Duplicate #644",
          "createdAt": "2022-05-24T16:59:27Z",
          "updatedAt": "2022-05-24T16:59:27Z"
        }
      ]
    },
    {
      "number": 670,
      "id": "I_kwDOBoyH6c5Jxx0E",
      "title": "Define filtered direct path in Ratchet Tree Terminology",
      "url": "https://github.com/mlswg/mls-protocol/issues/670",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "bifurcation"
      ],
      "labels": [
        "ready for PR"
      ],
      "body": "Currently defined only briefly in \"RatchetTree Evolution\".  While that's where it's primarily used, it would fit better in the terminology section, especially if we expand it a little and add an illustration.",
      "createdAt": "2022-05-16T22:09:08Z",
      "updatedAt": "2022-05-24T23:12:54Z",
      "closedAt": "2022-05-24T23:12:54Z",
      "comments": [
        {
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "body": "The problem here is that the definition of \"filtered direct path\" depends on the definition of \"resolution\" which isn't defined until a later section.",
          "createdAt": "2022-05-21T05:30:20Z",
          "updatedAt": "2022-05-21T05:30:20Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Indeed, so #689 proposes moving up the definition of resolution as well.",
          "createdAt": "2022-05-22T18:49:56Z",
          "updatedAt": "2022-05-22T18:49:56Z"
        }
      ]
    },
    {
      "number": 671,
      "id": "I_kwDOBoyH6c5JxyHb",
      "title": "Specify the algorithm for creating an UpdatePath",
      "url": "https://github.com/mlswg/mls-protocol/issues/671",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "ready for PR"
      ],
      "body": "Currently, we only have explicit algorithm steps for *validating* an UpdatePath.  We should have a similar level of concreteness for the process of creating an UpdatePath.",
      "createdAt": "2022-05-16T22:10:09Z",
      "updatedAt": "2022-06-08T17:56:13Z",
      "closedAt": "2022-06-08T17:56:13Z",
      "comments": []
    },
    {
      "number": 672,
      "id": "I_kwDOBoyH6c5JxyQg",
      "title": "Minor section reordering",
      "url": "https://github.com/mlswg/mls-protocol/issues/672",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "* \u201cAdding and Removing Leaves\u201d after \u201cSynchronizing Views of the Tree\u201d\r\n* Consider merging \u201cRatchet Tree Evolution\u201d and \u201cSynchronizing Views of the Tree\u201d and \u201cUpdate Paths\u201d\r\n* Swap \u201cJoining via External Commits\u201d and \u201cJoining via Welcome Message\u201d\r\n* Restore section break for \u201cExtensions\u201d",
      "createdAt": "2022-05-16T22:10:40Z",
      "updatedAt": "2022-06-09T19:10:14Z",
      "closedAt": "2022-06-09T19:10:14Z",
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Assuming people are OK with this, we should probably do it at a \"pause\" in PRs -- where we've merged a round and there are no new ones in flight -- in order to avoid merge conflicts.",
          "createdAt": "2022-05-20T18:01:17Z",
          "updatedAt": "2022-05-20T18:01:17Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "* Move \"Proposal List Validation\" under \"Proposals\"",
          "createdAt": "2022-05-25T18:30:14Z",
          "updatedAt": "2022-05-25T18:30:14Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "If folks are OK with this, I will just implement it before shipping the new post-LC draft.",
          "createdAt": "2022-05-31T22:05:05Z",
          "updatedAt": "2022-05-31T22:05:05Z"
        },
        {
          "author": "rohan-wire",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> * Consider merging \u201cRatchet Tree Evolution\u201d and \u201cSynchronizing Views of the Tree\u201d and \u201cUpdate Paths\u201d\r\n\r\nI would skip this one. I've now interviewed 4 developers and one product manager who are reading the spec for the first time. I think it is a lot clearer divided up.",
          "createdAt": "2022-06-06T15:42:03Z",
          "updatedAt": "2022-06-06T15:42:03Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "* Move \"Update Paths\" before \"TreeHashes\"",
          "createdAt": "2022-06-07T21:27:55Z",
          "updatedAt": "2022-06-07T21:27:55Z"
        }
      ]
    },
    {
      "number": 673,
      "id": "I_kwDOBoyH6c5Jxy0O",
      "title": "Streamline structs",
      "url": "https://github.com/mlswg/mls-protocol/issues/673",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "ready for PR"
      ],
      "body": "* The `MLSMessage*` collection of structs could be less chatty.  Suggest\r\n    * `MLSMessageContent => MessageContent`\r\n    * `MLSMessageContentAuth => AuthenticatedContent`\r\n    * `MLSMessageCommitContent => CommitContent`\r\n    * `MLSMessageCommitAuthData => CommitAuthData`\r\n* PreSharedKeys is only used once, can be inlined in GroupSecrets\r\n* Use GroupContext for the internals of GroupInfo",
      "createdAt": "2022-05-16T22:12:50Z",
      "updatedAt": "2022-06-03T18:26:12Z",
      "closedAt": "2022-06-03T18:26:12Z",
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Note:\r\n* `PreSharedKeys` was fixed in #691 \r\n* In #695, we did:\r\n    * `MLSMessageCommitContent => ConfirmedTranscriptHashInput`\r\n    * `MLSMessageAuthData => InterimTranscriptHashInput`\r\n\r\nSo only the following remain:\r\n* `MLSMessageContent => MessageContent`\r\n* `MLSMessageContentAuth => AuthenticatedContent`\r\n* Use GroupContext for the internals of GroupInfo",
          "createdAt": "2022-05-29T18:05:27Z",
          "updatedAt": "2022-05-29T18:05:51Z"
        }
      ]
    },
    {
      "number": 674,
      "id": "I_kwDOBoyH6c5JxzEH",
      "title": "Clean up references to legacy terminology",
      "url": "https://github.com/mlswg/mls-protocol/issues/674",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "ready for PR"
      ],
      "body": "* There are still several references to `MLSPlaintext` in the old sense.  These should pretty much all be changed to `MLSMessageContentAuth`.\r\n* `Credential` should be `SignaturePublicKey` in some places (e.g., `external_senders`)",
      "createdAt": "2022-05-16T22:13:53Z",
      "updatedAt": "2022-06-03T18:26:13Z",
      "closedAt": "2022-06-03T18:26:13Z",
      "comments": []
    },
    {
      "number": 676,
      "id": "I_kwDOBoyH6c5J1k2z",
      "title": "remove mention of `epoch_id` in section on Credentials",
      "url": "https://github.com/mlswg/mls-protocol/issues/676",
      "state": "CLOSED",
      "author": "kkohbrok",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "The Credentials section claims there is an epoch id field in key packages. I don't think that actually exists. My apologies if this is a duplicate issue.",
      "createdAt": "2022-05-17T15:03:11Z",
      "updatedAt": "2022-05-20T14:31:50Z",
      "closedAt": "2022-05-20T14:31:50Z",
      "comments": [
        {
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "body": "Addressed in #658 but may need to be pulled out depending on the fate of that PR",
          "createdAt": "2022-05-17T18:16:07Z",
          "updatedAt": "2022-05-17T18:16:07Z"
        }
      ]
    },
    {
      "number": 677,
      "id": "I_kwDOBoyH6c5J1nSK",
      "title": "Remove claim about PCS with Epoch change",
      "url": "https://github.com/mlswg/mls-protocol/issues/677",
      "state": "CLOSED",
      "author": "kkohbrok",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "Bren2010"
      ],
      "labels": [],
      "body": "In first paragraph, the \"Ratchet Tree Evolution\" Section states that whenever a member initiates an epoch change, they refresh the key pair in their leaves, etc. This is not the case for partial commits, where the epoch is advanced without a key update and without achieving PCS.",
      "createdAt": "2022-05-17T15:10:41Z",
      "updatedAt": "2022-05-19T05:12:02Z",
      "closedAt": "2022-05-19T05:12:02Z",
      "comments": []
    },
    {
      "number": 678,
      "id": "I_kwDOBoyH6c5J2Lok",
      "title": "Be more specific about Credential verification",
      "url": "https://github.com/mlswg/mls-protocol/issues/678",
      "state": "CLOSED",
      "author": "raphaelrobert",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "While this is spread out throughout the document, it would be beneficial to spell out in which scenarios a Credential MUST be verified (with the AS):\r\n\r\n - When fetching a KeyPackage to add a new member\r\n - When discovering a KeyPackage in an AddProposal from another member\r\n - When joining a new group (verify all other members' Credentials), both when receiving a Welcome message and when joining through an External Commit\r\n - When a member updates its leaf\r\n - ... anywhere else?",
      "createdAt": "2022-05-17T17:16:58Z",
      "updatedAt": "2022-06-02T14:27:33Z",
      "closedAt": "2022-06-02T14:27:33Z",
      "comments": []
    },
    {
      "number": 679,
      "id": "I_kwDOBoyH6c5J2NYF",
      "title": "Content encryption: Clarify generation sequence",
      "url": "https://github.com/mlswg/mls-protocol/issues/679",
      "state": "CLOSED",
      "author": "raphaelrobert",
      "authorAssociation": "MEMBER",
      "assignees": [
        "Bren2010"
      ],
      "labels": [
        "ready for PR"
      ],
      "body": "The generation numbers should be increased sequentially, gaps should be avoided to avoid unnecessary expensive operations on clients. Clients might also abort if the gap is too large to prevent attacks from malicious insiders.",
      "createdAt": "2022-05-17T17:24:17Z",
      "updatedAt": "2022-06-02T14:25:13Z",
      "closedAt": "2022-06-02T14:25:13Z",
      "comments": [
        {
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "body": "This is stated in 10.1:\r\n\r\n> The sender uses the j-th key/nonce pair in the sequence to encrypt (using the AEAD) the j-th message they send during that epoch.",
          "createdAt": "2022-05-17T18:02:42Z",
          "updatedAt": "2022-05-17T18:02:42Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "I suspect that what Raphael is worried about is that a malicious insider (someone in possession of the `sender_data_secret`) could make an MLSCiphertext with `generation` set to `0xffffffff` that would cause the receiver to do `2^32-1` HKDF invocations.  The attacker doesn't have to incur this cost because they don't need to generate the required key -- the ciphertext can be garbage because the key generation happens before the decryption does.\r\n\r\nIt seems like we could use a paragraph at the end of `{{encryption-keys}}` covering this and the fact that if you want to allow for out-of-order messages, you need to keep the intermediate keys.  Since big gaps would force you to store the keys as well as doing the hashing.\r\n\r\n> Clients might not receive messages in the order they are sent.  In order to allow for decryption of out-of-order messages, clients MAY retain keys and nonces for generations earlier than the latest received generation.  clients MAY impose a limit on the size of gaps they will allow in the generation sequence, in order to avoid generating and/or storing large numbers of such keys and nonces.\r\n\r\nA figure here might also be helpful.",
          "createdAt": "2022-05-20T18:20:47Z",
          "updatedAt": "2022-05-23T21:42:07Z"
        }
      ]
    },
    {
      "number": 681,
      "id": "I_kwDOBoyH6c5KBkyY",
      "title": "External Senders Extension is incomplete",
      "url": "https://github.com/mlswg/mls-protocol/issues/681",
      "state": "CLOSED",
      "author": "kkohbrok",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "The External Senders Extension allows clients to agree on the entities that are allowed to send external proposals, as well as the signature public keys required to verify them. It contains a list of credentials that is meant to achieve this goal. However, due to a recent change, Credentials don't necessarily contain signature public keys anymore. @bifurcation suggested to have it contain a signature public key, as well as a corresponding Credential, which allows members to verify the binding between signature public key and the owning entity's identity, which I think would be a good solution.",
      "createdAt": "2022-05-19T15:04:59Z",
      "updatedAt": "2022-05-26T14:14:18Z",
      "closedAt": "2022-05-26T14:14:18Z",
      "comments": []
    },
    {
      "number": 690,
      "id": "I_kwDOBoyH6c5KJ0ET",
      "title": "Commit secret is ambiguous when root is blank",
      "url": "https://github.com/mlswg/mls-protocol/issues/690",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "ready for PR"
      ],
      "body": "As I was pondering pathological cases related to #645, it occurred to me that we already have a slightly odd situation that can arise as a result of the suppression of redundant nodes.  When a Commit has an UpdatePath, the `commit_secret` is defined as follows:\r\n\r\n> Define commit_secret as the value path_secret[n+1] derived from the path_secret[n] value assigned to the root node.\r\n\r\nHowever, there are situations where the root node is not assigned a value, namely when the left half of the tree is blank.  For example, suppose A creates a group with B, C, D:\r\n\r\n```\r\n      Y\r\n    __|__\r\n   /     \\\r\n  X       _ = Z\r\n / \\     / \\\r\nA   B   C   D\r\n```\r\n\r\nSuppose that then C removes A and B, leaving C and D as the only leaves in the tree.  After removing A and B, the tree on which C computes an UpdatePath is as follows:\r\n\r\n```\r\n      _ = Y\r\n    __|__\r\n   /     \\\r\n  _       _ = Z\r\n / \\     / \\\r\n_   _   C   D  \r\n```\r\n\r\nC's direct path is (Z, Y), but it's filtered direct path is just (Z) because the copath subtree of Y is all blank.  So C will not generate a path_secret for Y, which means that the commit secret is not really defined.\r\n\r\nIt seems like there are two paths to fix this:\r\n\r\n1. Keep the current definition of `commit_secret` and require that a path secret always be generated for the root node\r\n    * Presumably the root node path secret would be generated directly from the path secret in the UpdatePath\r\n    * This would be simple to implement by just forcing the root node to be in the filtered direct path\r\n2. Keep the current path secret generation and specify that the `commit_secret` is derived from the last path secret in the UpdatePath \r\n    * In the above example, the last path secret from the path secret for Z\r\n\r\nI lean slightly toward (2) because it makes the computation the same for two neighbors regardless of where they are in the tree. It seems like the two options primarily differ in whether there are one or two invocations of the key derivation.\r\n",
      "createdAt": "2022-05-21T21:35:45Z",
      "updatedAt": "2022-06-02T14:47:42Z",
      "closedAt": "2022-06-02T14:47:42Z",
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Interim 2022-05-26:\r\n\r\n* @mulmarta supports doing \"end of UpdatePath plus one\"\r\n* @bifurcation to write up a PR",
          "createdAt": "2022-05-26T16:01:44Z",
          "updatedAt": "2022-05-26T16:01:44Z"
        },
        {
          "author": "mulmarta",
          "authorAssociation": "CONTRIBUTOR",
          "body": "First, both fixes are secure. I lean towards \"end of path plus one\", because it matches better my mental model: a) if any node (including root) has a child with a blank subtree, then it's blank, b) we generate `commit_secret` from the last secret generated by the committer.\r\n\r\n@bifurcation while you're at it, you could also address the empty-UpdatePath ambiguity: If a member is alone in the group and sends a commit that doesn't add anyone, his UpdatePath is empty and he doesn't know how to derive `commit_secret`. This can happen even without filtered paths, if the tree has exactly 1 node. There are 2 solutions:\r\n\r\n1. Pick a random secret\r\n2. Disallow such commits\r\n\r\nRegarding 2, does anyone know any reason we may want such commits?",
          "createdAt": "2022-05-26T16:51:42Z",
          "updatedAt": "2022-05-26T16:58:58Z"
        }
      ]
    },
    {
      "number": 693,
      "id": "I_kwDOBoyH6c5KU2j8",
      "title": "External Add proposals revisited",
      "url": "https://github.com/mlswg/mls-protocol/issues/693",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "@rohan-wire raised a few points today, which I'm trying to capture in this issue with some thoughts on proposed solutions.\r\n\r\nIn #659, we removed the usage of `new_member` to send Add proposals, in order to allow for the signature on an external commit to cover the GroupContext (which is not necessarily possible for an external Add sender).  In the discussion, the point was made that an Add proposal only really differs from a KeyPackage in that the KeyPackage doesn't have `group_id` or `epoch` fields.  Part of the resolution in #659 was a decision that folks didn't think `group_id` was a significant loss.  And I think there's pretty broad agreement that `epoch` is actively undesirable, since it means that the new joiner has to be sufficiently in sync with the group to know the epoch hasn't changed before sending its proposal.\r\n\r\nAfter talking with @rohan-wire, there are two other issues to highlight:\r\n\r\n* Losing `group_id` is a bigger deal than it might first seem in a system that has both \"prepublished KeyPackages\" and \"KeyPackage as request to be added\".  Someone could go grab a bunch of prepublished KeyPackages that they don't own, and send them in as requests to be added.  This isn't an immediate security risk, since the attacker doesn't necessarily have the private keys that go with the KeyPackages (if they do, they have other attack avenues).  But it would mean, for example, that a client would have an even less certain idea of all the groups it was a member of.\r\n\r\n* When \"requests to be added\" were expressed as Proposals, the \"request\" semantic followed from being a Proposal, which tied into the recommendations for what should be included in a Commit.  Expressing these requests in a different way, means that the \"request\" semantic rests outside of the core MLS logic.\r\n\r\nA few possible avenues come to mind for addressing these issues:\r\n\r\n1. Don't change the protocol, but document the operational considerations.  For example:\r\n    * The \"unintended join\" issue with abuse of prepublished KPs could be mitigated by a DS that supports proactive joins enforcing that the sender owns the signature key (e.g., checking that `kp.leaf_node.credential` authenticates the same identity that the DS has for the client).\r\n    * The request semantic could be captured in the architecture document / protocol overview as a thing that applications could implement if they choose. \r\n\r\n2. Re-add joiner-sent Add proposals, using a different SenderType this time to avoid the conflict with external commits.\r\n     * Say `new_member_add_proposal` and `new_member_commit`\r\n     * This would still have the epoch problem.\r\n\r\n3. Add a field to KeyPackage indicating whether the KeyPackage is general or directed to a specific group\r\n    * Something like `optional<GroupID> target_group_id`\r\n    * Require that if the field is set in an Add proposal, then it MUST match the group's ID.\r\n    * Specify that only directed KPs can be used to request to be added\r\n    * Add parallel text to proposals that recommend the the committer commit Add proposals for any directed KPs it has received.\r\n\r\n4. Define a new top level message (an entry in the MLSMessage enum) that expresses precisely the semantic we want, something like:\r\n\r\n```\r\nstruct {\r\n    opaque group_id<V>;\r\n    KeyPackage key_package;\r\n    // SignWithLabel(., \"JoinRequestTBS\", JoinRequestTBS)\r\n    opaque signature<V>;\r\n} JoinRequest;\r\n```",
      "createdAt": "2022-05-24T18:34:29Z",
      "updatedAt": "2022-06-02T16:01:52Z",
      "closedAt": "2022-06-02T16:01:52Z",
      "comments": [
        {
          "author": "rohan-wire",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thanks @bifurcation for writing this up.\r\n\r\nMy problems with using KeyPackages as a \"verb\" are more extensive than what Richard described. The rules for deciding which combinations of Proposals are valid are already pretty complicated. Relying on a new implicit mechanism that interacts with this explicit Proposal logic makes me very uncomfortable. \r\n\r\nWhile it might require some retries to get the correct epoch, I am also concerned about copy paste attacks. I think approaches 1, 3, and 4 are all vulnerable some form of copy paste attack.\r\n\r\nI propose re-adding new joiner-sent Add Proposals with a new SenderType. While catching the correct epoch can be a nuisance, I think it is a separable problem. \r\nThanks,\r\n-rohan\r\n",
          "createdAt": "2022-05-24T19:13:17Z",
          "updatedAt": "2022-05-24T19:13:53Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Personally, I'm less concerned about the flow concerns here and more concerned about epoch mismatches.\r\n\r\nIn real-time scenarios, epoch mismatches are a huge pain.  You have potentially hundreds of people joining at the beginning of a meeting and retrying a join adds a lot of latency.  So the ability for the committer to choose which requests to join go in which Commits is really important for things to work smoothly.  I would not be able to use (2) in Webex, but would gladly use (3).\r\n\r\nAs for being more implicit: I actually have the opposite concern, that allowing joiner-signed Adds is riskier from a policy POV.  In general, before someone is added to the group, some application logic at a member needs to check that the new member is acceptable.  If an Add proposal has to be made by a member, you get two opportunities to check, when the proposal is made and when it's committed.  If the new joiner makes the proposal, you lose the first. \r\n\r\n(I also have a more minor aesthetic concern about re-using the general framing for this specific niche use case.  We have this general framing that is actually general for members; they can send any content type.  External proposals and external commits are constrained to one content type, but still pretty general.  New member add proposals would be limited to one content type and one proposal type, which is getting quite narrow.)\r\n\r\nBy contrast, the semantic shift for extending KeyPackage is really pretty minor.  The semantic of KeyPackage is already \"Please make an Add proposal with this object to add me to a group\".  That's not far away from \"Please make an Add proposal to add me to ${THIS_SPECIFIC_GROUP}.\"\r\n\r\nThat seems like a smaller semantic shift than the shift from \"Someone authorized to make changes to this group proposed a change\" to \"Some rando on the Internet proposed a change\".\r\n\r\nNet of all that, I'm pretty strongly in favor of (3).",
          "createdAt": "2022-05-24T20:23:01Z",
          "updatedAt": "2022-05-24T20:23:01Z"
        },
        {
          "author": "rohan-wire",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@bifurcation I specifically mentioned copy paste attacks. I would be happy for us to have a reasonable general solution to epoch mismatches within a narrow time window, but not at the expense of an unbounded timeframe for a copy paste attack.\r\n\r\nThat said, if you want to implement some implicit KeyPackage behavior to add using authorization rules that work for your implementation and your DS is in a position to prevent those attacks, you can still do what you proposed. I'm just asking not to take away the tool we are using. \r\n\r\nIn terms of scope, external add proposals have been in the protocol document since -08 (2019). We use them extensively and implemented them in good faith. Removing them now and proposing we use an implicit approach with a know security concern that happens to solve a problem that was previously out of scope seems a bit arbitrary.\r\n\r\nProposal 2 (new SenderType) does not harm anyone else and preserves functionality in the draft. It does not prevent you from solving the epoch problem your way or in any other future way.\r\n \r\n\r\n",
          "createdAt": "2022-05-24T21:33:37Z",
          "updatedAt": "2022-05-24T21:34:23Z"
        },
        {
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "body": "I think the points raised by @bifurcation are quite valid, in particular since external proposals can still be used with preconfigured senders (and there is a better symmetry with external remove proposals). I don't see why that wouldn't be good enough in a scenario where the DS is quite involved beyond the handshake message ordering anyway.\r\n\r\nThat being said, from all the options above (3) would also be my favorite. I like the idea of purpose-bound KeyPackages.",
          "createdAt": "2022-05-24T21:59:47Z",
          "updatedAt": "2022-05-24T21:59:47Z"
        },
        {
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "body": "> Losing group_id is a bigger deal than it might first seem in a system that has both \"prepublished KeyPackages\" and \"KeyPackage as request to be added\". ... But it would mean, for example, that a client would have an even less certain idea of all the groups it was a member of.\r\n\r\nI don't understand this concern since adding someone to a group has never required their consent or knowledge. The change here is just that you can perhaps get someone else to do the adding, though I would say that's *better* in the sense that a non-malicious client doing the Add would actually send the Welcome. If the malicious user is doing the Add, they might not send a Welcome.\r\n\r\n@rohan-wire Would you mind expanding more on what you mean by copy-paste attack?\r\n\r\n> When \"requests to be added\" were expressed as Proposals, the \"request\" semantic followed from being a Proposal, which tied into the recommendations for what should be included in a Commit. Expressing these requests in a different way, means that the \"request\" semantic rests outside of the core MLS logic.\r\n\r\nThis isn't a downside, this is a core reason that it external Adds were removed. We observed that applications seem to prefer doing this themselves (at least those that spoke on the ticket / interim did).",
          "createdAt": "2022-05-24T23:01:34Z",
          "updatedAt": "2022-05-24T23:01:34Z"
        },
        {
          "author": "rohan-wire",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> > Losing group_id is a bigger deal than it might first seem in a system that has both \"prepublished KeyPackages\" and \"KeyPackage as request to be added\". ... But it would mean, for example, that a client would have an even less certain idea of all the groups it was a member of.\r\n> \r\n> I don't understand this concern since adding someone to a group has never required their consent or knowledge. The change here is just that you can perhaps get someone else to do the adding, though I would say that's _better_ in the sense that a non-malicious client doing the Add would actually send the Welcome. If the malicious user is doing the Add, they might not send a Welcome.\r\n\r\nThe concern with implying Add semantics using a bare (undirected) keypackage is we don't have any record of _anyone's_ intent to add the MLS client to the group. [I don't understand what is supposedly \"better\" about not sending an external proposal. Either way someone sends a Proposal and whoever sends a valid commit containing that Proposal is supposed to send the Welcome.]\r\n\r\n> @rohan-wire Would you mind expanding more on what you mean by copy-paste attack?\r\n\r\nAlice (in domain A) decides to join the Bananas group in domain B. Alice sends a directed KeyPackage (option 3). \r\nVariation 1: Two members of the Bananas group, Cathy and Doug, copy this request and replay it repeatedly to the group, possibly after Alice leaves the group.\r\n[Currently we only will forward a Welcome to an MLS client if the KeyPackageRef was seen when consuming a KeyPackage from the Directory; or from sending an External Proposal or External Commit in that epoch. So before this change we could scope the state needed to forward a Welcome to a specific sender, or a particular epoch. Either way this was easy to clean up.  With the current proposal this needs to be sent across all the domains in the group, and is no longer time bounded.]\r\nVariation 2: An attacker Bob on B returns an error and copies (stored) the add request. Later at a time of Bob's choosing, he sends (pastes) the request to the Bananas group, causing Alice to be added to Bananas at a different time than Alice intended. \r\n\r\n> > When \"requests to be added\" were expressed as Proposals, the \"request\" semantic followed from being a Proposal, which tied into the recommendations for what should be included in a Commit. Expressing these requests in a different way, means that the \"request\" semantic rests outside of the core MLS logic.\r\n> \r\n> This isn't a downside, this is a core reason that it external Adds were removed. We observed that applications seem to prefer doing this themselves (at least those that spoke on the ticket / interim did).\r\n\r\nWell, we are an implementer and are definitely using them and like them, so it *is* a downside for us, and it sounds like for everyone else it was a no-op, not an upside (they can do it their way whether or not External Proposals for Adds are possible or not).  \r\n\r\nFor background, we are using External Proposal Adds only to add a new client device representing a user who is already in the group. We never use them to add a different user or for a server to add a user. \r\nOur clients are not necessarily online at the same time, so there may not be an MLS member online when the request is sent. This is fine for External Proposal because each client can process and verify MlsMessage linearly.\r\nIn addition, all our use cases are federated, so the user who ends up sending the Commit which finally adds the new client often has no direct relationship with the backend/directory through which the new client normally forwards MlsCiphertext/MlsPlaintext messages or in which is stores its KeyPackages. ",
          "createdAt": "2022-05-25T19:25:24Z",
          "updatedAt": "2022-05-25T19:25:24Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "On the copy/paste risk: It occurs to me that we actually have a solution for this already: The `lifetime` field in LeafNode.  KeyPackages are already designed to expire, and that mechanism provides flexibility that matches the use case much better than `epoch`.",
          "createdAt": "2022-05-25T19:27:38Z",
          "updatedAt": "2022-05-25T19:27:38Z"
        },
        {
          "author": "rohan-wire",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> I think the points raised by @bifurcation are quite valid, in particular since external proposals can still be used with preconfigured senders (and there is a better symmetry with external remove proposals). \r\n\r\nOur use case for external add proposals is for an ordinary client adding itself (never a preconfigured sender), whereas for external removes this is always a backend taking action (preconfigured sender).\r\n\r\n>I don't see why that wouldn't be good enough in a scenario where the DS is quite involved beyond the handshake message ordering anyway.\r\n\r\nI'm not sure I follow you. Coordinating enough DS involvement across federated domains looks hard to me. Could you elaborate please?\r\n",
          "createdAt": "2022-05-25T19:32:57Z",
          "updatedAt": "2022-05-25T19:33:17Z"
        },
        {
          "author": "rohan-wire",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> On the copy/paste risk: It occurs to me that we actually have a solution for this already: The `lifetime` field in LeafNode. KeyPackages are already designed to expire, and that mechanism provides flexibility that matches the use case much better than `epoch`.\r\n\r\nGood point, although running a bunch of timers on servers is definitely more work than checking the epoch.",
          "createdAt": "2022-05-25T19:34:21Z",
          "updatedAt": "2022-05-25T19:34:21Z"
        },
        {
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "body": "> Our use case for external add proposals is for an ordinary client adding itself (never a preconfigured sender), whereas for external removes this is always a backend taking action (preconfigured sender).\r\n\r\nSo in that instance you say it is fine to use preconfigured senders, why wouldn't it be fine when adding members?\r\n\r\n> I'm not sure I follow you. Coordinating enough DS involvement across federated domains looks hard to me. Could you elaborate please?\r\n\r\nDistributing keys is indeed a hard problem in a federated environment. But I don't see how that's getting better with \"new member\" external Add proposals. In both cases, there is a signature to be verified and the key material needs to be available to the verifier.\r\n",
          "createdAt": "2022-05-26T14:09:55Z",
          "updatedAt": "2022-05-26T14:09:55Z"
        },
        {
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "body": "One more note on the preconfigured senders: They are synchronized as a group extension (something that was added recently and I forgot about it). That makes the distribution much easier and less error-prone than the external Add with sender type \"new member\".",
          "createdAt": "2022-05-26T14:15:05Z",
          "updatedAt": "2022-05-26T14:15:05Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Interim 2022-05-26:\r\n\r\n* A few comparisons:\r\n    * `new_member` Add vs. `external` Add ~ `new_member` Add includes client's intent to join\r\n    * `new_member` Add vs. directed KeyPackage ~ main difference is epoch vs. lifetime\r\n* @rohan-wire to make a PR implementing the \"new sender type\" approach\r\n* @bifurcation to make a PR implementing the \"directed KeyPackage\" approach\r\n* Aim to decide on next call",
          "createdAt": "2022-05-26T15:44:07Z",
          "updatedAt": "2022-05-26T15:44:07Z"
        }
      ]
    },
    {
      "number": 696,
      "id": "I_kwDOBoyH6c5KVvuW",
      "title": "external_key_id extension for LeafNode",
      "url": "https://github.com/mlswg/mls-protocol/issues/696",
      "state": "CLOSED",
      "author": "Bren2010",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "Bren2010"
      ],
      "labels": [],
      "body": "",
      "createdAt": "2022-05-24T23:09:46Z",
      "updatedAt": "2022-05-28T19:02:03Z",
      "closedAt": "2022-05-28T19:02:03Z",
      "comments": [
        {
          "author": "rohan-wire",
          "authorAssociation": "CONTRIBUTOR",
          "body": "What's the use case for this?",
          "createdAt": "2022-05-26T07:00:14Z",
          "updatedAt": "2022-05-26T07:00:14Z"
        },
        {
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "body": "Mentioned at the last interim, but the use-case for this feature is either:\r\n- giving applications an easier way to lookup the private key corresponding to their LeafNode\r\n- giving applications a place to put client UUIDs",
          "createdAt": "2022-05-28T16:21:02Z",
          "updatedAt": "2022-05-28T16:21:02Z"
        }
      ]
    },
    {
      "number": 700,
      "id": "I_kwDOBoyH6c5KbjVa",
      "title": "Not allowing the same member to join the group multiple times?",
      "url": "https://github.com/mlswg/mls-protocol/issues/700",
      "state": "CLOSED",
      "author": "Bren2010",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "In #675, it was pointed out that we previously had a clause:\r\n\r\n> If there are multiple Add proposals containing KeyPackages that the committer considers to represent the same client or a client already in the group (for example, identical KeyPackages or KeyPackages sharing the same Credential), the committer again chooses one to include and considers the rest invalid.\r\n\r\nBut this was amplified in #675 to say that we also can't send Add proposals for users that are already in the group. I think we should talk about if this is the actual desired behavior or not.",
      "createdAt": "2022-05-25T21:12:41Z",
      "updatedAt": "2022-06-02T14:33:31Z",
      "closedAt": "2022-06-02T14:33:31Z",
      "comments": [
        {
          "author": "rohan-wire",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I agree with Brendan. Specifically I want to make sure an MLS client can replace itself. \r\n\r\nMy other concern is that because we have no guidance yet on identity, we need to make sure that multiple instances/clients of the same user are allowed.",
          "createdAt": "2022-05-26T15:24:07Z",
          "updatedAt": "2022-05-26T15:24:07Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Interim 2022-05-26:\r\n\r\n* We want to:\r\n    * Avoid having multiple appearances of the same device\r\n    * Allow a device to resync itself\r\n* Text at issue here is \"An Add proposal is invalid if ... The Credential in the KeyPackage represents a client already in the group according to the application\" \r\n* It sounds like changing to \"... The KeyPackage represents a client already in the group according to the application\" would address the immediate concern\r\n* @Bren2010 to write a PR",
          "createdAt": "2022-05-26T16:03:51Z",
          "updatedAt": "2022-05-26T16:03:51Z"
        }
      ]
    },
    {
      "number": 711,
      "id": "I_kwDOBoyH6c5KxZr9",
      "title": "Add changelist for draft-15",
      "url": "https://github.com/mlswg/mls-protocol/issues/711",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Just filing this so that I don't forget it before posting the draft.",
      "createdAt": "2022-05-31T22:05:44Z",
      "updatedAt": "2022-06-09T19:37:22Z",
      "closedAt": "2022-06-09T19:37:22Z",
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed by #722 ",
          "createdAt": "2022-06-09T19:37:22Z",
          "updatedAt": "2022-06-09T19:37:22Z"
        }
      ]
    },
    {
      "number": 719,
      "id": "I_kwDOBoyH6c5LY216",
      "title": "Document compilation drop accents",
      "url": "https://github.com/mlswg/mls-protocol/issues/719",
      "state": "CLOSED",
      "author": "TWal",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Hello,\r\n\r\nIn the [\"contributors\" section](https://github.com/mlswg/mls-protocol/blob/main/draft-ietf-mls-protocol.md?plain=1#L5101), my name is correctly written with the \"\u00e9\" accent, however when it is compiled, the accent is dropped, e.g. [here](https://messaginglayersecurity.rocks/mls-protocol/draft-ietf-mls-protocol.html#section-18-1.14) or [here](https://messaginglayersecurity.rocks/mls-protocol/draft-ietf-mls-protocol.txt).\r\n\r\nIt looks like this letter is the only non-ascii character in the whole document, is this the expected behavior when compiling an RFC, or is it an issue in [martinthomson/i-d-template](https://github.com/martinthomson/i-d-template) that I should track?\r\n\r\nThanks!",
      "createdAt": "2022-06-08T14:04:05Z",
      "updatedAt": "2022-06-12T20:40:45Z",
      "closedAt": "2022-06-12T20:40:44Z",
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "This is a tooling issue.  Currently, the only way to include non-ASCII characters in an RFC is for them to be wrapped in a `<contact>` element in the XML.  Unfortunately, that can't be triggered from MD right now.  One this is approved, the RFC editor can massage the XML to add the required wrapping.  This was done in RFC 9147 ([md](https://github.com/tlswg/dtls13-spec/blob/master/draft-ietf-tls-dtls13.md?plain=1#L2732), [xml](https://www.rfc-editor.org/rfc/rfc9147.xml), [html](https://www.rfc-editor.org/rfc/rfc9147.html), search for \"Vyncke\").\r\n\r\nFlagging this for handling in AUTH48, which is the step in the process where we work with the RFC editor on things like this.",
          "createdAt": "2022-06-08T17:55:05Z",
          "updatedAt": "2022-06-08T17:55:05Z"
        },
        {
          "author": "seanturner",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thanks for flagging this for AUTH48. There is zero chance I would have remember this.",
          "createdAt": "2022-06-09T13:44:23Z",
          "updatedAt": "2022-06-09T13:44:23Z"
        },
        {
          "author": "cabo",
          "authorAssociation": "CONTRIBUTOR",
          "body": "What's wrong with the current kramdown-rfc support?  Please open an issue at rfc.space!",
          "createdAt": "2022-06-09T14:18:39Z",
          "updatedAt": "2022-06-09T14:18:39Z"
        },
        {
          "author": "cabo",
          "authorAssociation": "CONTRIBUTOR",
          "body": "mnot wrote this up for your convenience...\r\n\r\nhttps://github.com/cabo/kramdown-rfc/wiki/Syntax2#authors-contributors\r\n\r\n",
          "createdAt": "2022-06-09T14:24:37Z",
          "updatedAt": "2022-06-09T14:24:37Z"
        }
      ]
    },
    {
      "number": 725,
      "id": "I_kwDOBoyH6c5LqxdB",
      "title": "Missing protocol version inside Welcome?",
      "url": "https://github.com/mlswg/mls-protocol/issues/725",
      "state": "CLOSED",
      "author": "TWal",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "In #529, the `ProtocolVersion` field of `Welcome` is removed. I'm guessing the reason was that is was redundant with the ciphersuite, since the MLS version is at the time included in the ciphersuite.\r\nHowever, in #544, MLS versions were removed from ciphersuites, making the protocol version not redundant anymore with the ciphersuite.\r\n\r\nWe should probably put the MLS version back there?",
      "createdAt": "2022-06-13T14:11:06Z",
      "updatedAt": "2022-06-13T16:02:12Z",
      "closedAt": "2022-06-13T16:02:12Z",
      "comments": [
        {
          "author": "TWal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I just discovered that this is then fixed by adding the MLS version to `MLSMessage` in #600, closing.",
          "createdAt": "2022-06-13T16:02:12Z",
          "updatedAt": "2022-06-13T16:02:12Z"
        }
      ]
    },
    {
      "number": 726,
      "id": "I_kwDOBoyH6c5LrCm0",
      "title": "Missing \"signature\" argument in \"VerifyWithLabel\"",
      "url": "https://github.com/mlswg/mls-protocol/issues/726",
      "state": "CLOSED",
      "author": "TWal",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Introduced in #526.",
      "createdAt": "2022-06-13T14:59:38Z",
      "updatedAt": "2022-06-15T21:44:04Z",
      "closedAt": "2022-06-15T21:44:04Z",
      "comments": []
    },
    {
      "number": 732,
      "id": "I_kwDOBoyH6c5PITT8",
      "title": "Does sender_index start at zero or one?",
      "url": "https://github.com/mlswg/mls-protocol/issues/732",
      "state": "CLOSED",
      "author": "rohan-wire",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "The `sender_index` is used to specify which signature key/Credential in the `external_senders` extension signed an external proposal. Nothing in the protocol specification says if the index starts from zero or from one. The `leaf_index` starts from one. I suggest we specify that the `sender_index` also starts at *one*. ",
      "createdAt": "2022-08-03T17:35:07Z",
      "updatedAt": "2022-10-03T19:46:56Z",
      "closedAt": "2022-10-03T19:46:56Z",
      "comments": [
        {
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "body": "Section 5.1.1. states\r\n\r\n> Each leaf node in a ratchet tree is given an index (or leaf index), starting at 0 from the left to 2^d - 1 at the right (for a tree with 2^d leaves). A tree with 2^d leaves has 2^(d+1) - 1 nodes, including parent nodes.\r\n\r\n`sender_index` is conceptually a leaf index, so it should also start at 0.",
          "createdAt": "2022-08-03T18:13:40Z",
          "updatedAt": "2022-08-03T18:13:40Z"
        },
        {
          "author": "rohan-wire",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thanks. Yes you are right, the other indexes start at zero, so this one should as well. I will write a very short PR to make it clear.",
          "createdAt": "2022-08-06T22:28:29Z",
          "updatedAt": "2022-08-06T22:28:29Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "One thing we could do to reinforce this in the TLS syntax is define a `LeafIndex` type alias for `uint32`, so that struct definitions will remind the implementer of the semantic.\r\n\r\n```\r\nuint32 LeafIndex;\r\n```\r\n\r\nMLSpp, for example, already has uses such typing to make sure that leaf indices don't commingle with node indices. ",
          "createdAt": "2022-08-09T13:43:58Z",
          "updatedAt": "2022-08-09T13:43:58Z"
        }
      ]
    },
    {
      "number": 733,
      "id": "I_kwDOBoyH6c5PIWUN",
      "title": "MLS member removal underspecified",
      "url": "https://github.com/mlswg/mls-protocol/issues/733",
      "state": "CLOSED",
      "author": "rohan-wire",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "While implementing removals, I came to the conclusion that clients would \r\n\r\nCurrently in the MLS Protocol, when a Commit containing a Remove Proposal is sent to a group, the specification does not provide enough implementation guidance to insure that the removed member is notified of its removal.\r\n\r\nI can think of three ways a member can determine it has been removed:\r\n1. Require the DS to forward the Commit message containing the removal to all removed members.\r\n2. Require an out-of-band protocol convey this information\r\n3. Create a new MLS message type (ex: Goodbye) specifically to convey removal.\r\n\r\nForwarding the Commit message would require only one new normative statement in the MLS protocol document, some similar additional text in the MLS architecture document, and a minor change to the remove example flow diagram in the MLS protocol document. This would be a straightforward clarification. The disadvantage is that forwarding the commit to a removed member can leak other membership changes (ex: the credentials of newly added members, and the potential knowledge of which other members were removed at the same time).\r\n\r\nRequiring an out-of-band protocol to convey removal information, while possible, leaves a privacy sensitive decision out of scope, while the analogous action is a first-class part of the MLS protocol (Welcomes).\r\n\r\nUsing a new message type (ex: Goodbye) requires new specification work, but allows a message analogous to a Welcome which can inform clients individually they were removed without leaking potentially sensitive information about the new membership of the group they just departed.\r\n\r\nNote that the architecture document could require that the DS either implement 1 or 2, but leaving too many choices makes interoperability more complicated. ",
      "createdAt": "2022-08-03T17:47:32Z",
      "updatedAt": "2022-10-03T20:59:39Z",
      "closedAt": "2022-10-03T20:59:39Z",
      "comments": [
        {
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "body": "The Commit is the goodbye message. Clients are able to parse it and conclude that they have been removed. I thought that 1. was always implied, what makes you think otherwise?",
          "createdAt": "2022-08-03T17:50:35Z",
          "updatedAt": "2022-08-03T17:50:35Z"
        },
        {
          "author": "rohan-wire",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> The Commit is the goodbye message. Clients are able to parse it and conclude that they have been removed. I thought that 1. was always implied, what makes you think otherwise?\r\n\r\nI assumed this as well, but it is only *implied* in the spec, and the example flow showing a remove doesn't have an arrow going to the removed client (which would clearly be wrong if it is required). (For good or bad, a lot of implementers code from examples and then go back and check their assumptions in the body of a spec. That is why it is so important to get examples correct.)\r\nIf we decide that it's an implementation choice (and say that it is also ok to do it out of band for example) then we need to explain that in the architecture document.\r\n\r\nSo, we can\r\n1) Decide that a client MUST always get the Commit removing them; make that explicit in the protocol; fix the example; explain the privacy leak in the Security Considerations; possibly summarize this in the architecture document.\r\n2) Say that a client MUST be informed about their removal in the protocol spec and leave how to convey removals as one of these policy choices for the DS (you could even make sending the Commit a SHOULD); explain more extensively in the architecture document.\r\n3) Address the privacy issue directly by making an explicit Goodbye message.",
          "createdAt": "2022-08-06T22:26:47Z",
          "updatedAt": "2022-08-06T22:26:47Z"
        },
        {
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "body": "You introduce the notion of a 'privacy leak' and a 'privacy issue' in your last message, what exactly are you referring to?\r\n\r\nI think 1. is currently implied and examples should be adjusted if they don't reflect that.",
          "createdAt": "2022-08-09T10:11:47Z",
          "updatedAt": "2022-08-09T10:11:47Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "I think the privacy issue @rohan-wire is concerned about is something like: If other changes are made in the same Commit that removes a participant, then the removed participant can see those changes.  For example, the identities of people added to the group in that commit.\r\n\r\nIt's not totally clear to me what the security objective here is.  It seems like the point of informing a member they have been removed via a group message (Commit or Goodbye) would be to prevent the DS from lying to the member about whether they have been removed -- telling them they'd been removed when they hadn't, or vice versa.  This honestly isn't something I'm all that worried about, because (a) none of this affects the security of those who remain in the group, and (b) even if you had a message, the DS could suppress it (and thus lie in at least one direction).  The best argument that occurs to me is that being removed might (*might!*) trigger deletion of old keys, thus providing better FS for any outstanding messages in prior epochs in the event the removed member was compromised.\r\n\r\n(This is unlike the add situation, where we *need* a protocol message to provide the new joiner with the cryptographic material they need to participate in the group.  That cannot be delegated to the DS.)\r\n\r\nIf we had an explicit Goodbye message, we would have a malicious insider risk, in that a group member could generate a Goodbye for someone that was not actually removed.\r\n\r\nNet of all that, I think something like Rohan's option (2) would be my preference.  Mostly punt it to OOB, but note that the Commit COULD be used. \r\n",
          "createdAt": "2022-08-09T17:41:29Z",
          "updatedAt": "2022-08-09T17:41:29Z"
        },
        {
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "body": "> I think the privacy issue @rohan-wire is concerned about is something like: If other changes are made in the same Commit that removes a participant, then the removed participant can see those changes. For example, the identities of people added to the group in that commit.\r\n\r\nI suspect as much. I'd say that this is only a potential privacy issue because the committer can simply avoid it by issuing two commits. The leaked information about other proposals is also not necessarily sensitive. That being said, I think it would be worth mentioning this in the architecture doc.\r\n\r\n> If we had an explicit Goodbye message, we would have a malicious insider risk, in that a group member could generate a Goodbye for someone that was not actually removed.\r\n> \r\n> Net of all that, I think something like Rohan's option (2) would be my preference. Mostly punt it to OOB, but note that the Commit COULD be used.\r\n\r\nI think either (1) or (2). would work, where (2) has the added benefit of more flexibility. (3) would indeed be problematic for the reasons you mention.\r\n\r\n",
          "createdAt": "2022-08-09T18:00:28Z",
          "updatedAt": "2022-08-09T18:00:28Z"
        },
        {
          "author": "rohan-wire",
          "authorAssociation": "CONTRIBUTOR",
          "body": "It sounds like there is weak consensus that a client should be informed either by a Commit or out-of-band.\r\n\r\nI submitted PR #736 which shows a Commit going to the removed user in the example flow, and provides some guidance to a client about processing a Commit that removes itself. \r\n\r\nI'll submit a separate PR for the architecture spec that adds this to the list of things you need for a concrete DS / client implementation.",
          "createdAt": "2022-08-17T05:58:15Z",
          "updatedAt": "2022-08-17T05:58:15Z"
        },
        {
          "author": "rohan-wire",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Resolved with #736 ",
          "createdAt": "2022-10-03T20:53:16Z",
          "updatedAt": "2022-10-03T20:53:16Z"
        }
      ]
    },
    {
      "number": 734,
      "id": "I_kwDOBoyH6c5Pqrew",
      "title": "Update Jon's details",
      "url": "https://github.com/mlswg/mls-protocol/issues/734",
      "state": "CLOSED",
      "author": "seanturner",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Affiliation -> Meta Platforms\r\nAddress -> jmillican@meta.com",
      "createdAt": "2022-08-11T23:20:58Z",
      "updatedAt": "2022-09-09T17:32:42Z",
      "closedAt": "2022-09-09T17:32:42Z",
      "comments": []
    },
    {
      "number": 738,
      "id": "I_kwDOBoyH6c5QikJF",
      "title": "Update Recommended",
      "url": "https://github.com/mlswg/mls-protocol/issues/738",
      "state": "CLOSED",
      "author": "seanturner",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "The consensus in saag was to expand Recommended to include \"D\" to RFC 8447bis. Should probablly do the same here.",
      "createdAt": "2022-08-25T17:37:27Z",
      "updatedAt": "2022-10-03T20:36:26Z",
      "closedAt": "2022-10-03T20:36:26Z",
      "comments": []
    },
    {
      "number": 741,
      "id": "I_kwDOBoyH6c5RidKB",
      "title": "ResumptionPSKUsage presentation syntax",
      "url": "https://github.com/mlswg/mls-protocol/issues/741",
      "state": "CLOSED",
      "author": "seanturner",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "bifurcation"
      ],
      "labels": [],
      "body": "@bifurcation shouldn't ResumptionPSKUsage include (255)?\r\n\r\n    enum {\r\n      reserved(0),\r\n      application(1),\r\n      reinit(2),\r\n      branch(3),\r\n      (255)\r\n    } ResumptionPSKUsage;",
      "createdAt": "2022-09-09T15:23:35Z",
      "updatedAt": "2022-10-03T20:37:33Z",
      "closedAt": "2022-10-03T20:37:33Z",
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed in #740 ",
          "createdAt": "2022-10-03T20:37:33Z",
          "updatedAt": "2022-10-03T20:37:33Z"
        }
      ]
    },
    {
      "number": 742,
      "id": "I_kwDOBoyH6c5Ridvv",
      "title": "presntation syntax: comments",
      "url": "https://github.com/mlswg/mls-protocol/issues/742",
      "state": "CLOSED",
      "author": "seanturner",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "8446 says:\r\n\r\n    Comments begin with \"/*\" and end with \"*/\".\r\n\r\nThis I-D uses \"//\" for comments in the presentation syntax. We can add a section in the presentation syntax section or switch to match 8446.",
      "createdAt": "2022-09-09T15:25:43Z",
      "updatedAt": "2022-10-03T20:36:40Z",
      "closedAt": "2022-10-03T20:36:40Z",
      "comments": []
    },
    {
      "number": 748,
      "id": "I_kwDOBoyH6c5TKl-i",
      "title": "Include last updated epoch in leaf nodes?",
      "url": "https://github.com/mlswg/mls-protocol/issues/748",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Inspired by #731 -- it seems like when someone issues an Update or Commit, they know the epoch in which it will be committed, and could include that under the signature for their LeafNode.  Especially in the Commit case, this could improve validation of parent hashes, since the leaf node to which a parent node chains via the parent hash should be the leaf node in that parent node's subtree that most recently updated.  A PR would have roughly the following form:\r\n\r\n* Update LeafNode to include the following (plus corresponding updates to `LeafNodeTBS`):\r\n\r\n```diff\r\n     LeafNodeSource leaf_node_source;\r\n     select (LeafNode.leaf_node_source) {\r\n         case key_package:\r\n             Lifetime lifetime;\r\n \r\n         case update:\r\n-            struct{};\r\n+            uint64 update_epoch;\r\n \r\n         case commit:\r\n+            uint64 commit_epoch;\r\n             opaque parent_hash<V>;\r\n     }\r\n```\r\n\r\n* In `{{leaf-node-validation}}`, add the following checks:\r\n    * When verifying a Update or Commit message, check that `update_epoch` / `commit_epoch` is the current epoch\r\n    * When verifying a tree, check that for all leaves, `update_epoch` / `commit_epoch` is before the current epoch if present\r\n\r\n(Note that we cannot just add it on the signature side, as with #731, since a new joiner won't know the right values.)\r\n\r\nThe main arguments that come to mind against making this change are: (1) The above rational isn't super strong, in that it's just a check on the ordering that the parent hash already provides.  (2) This could be cleanly done in a LeafNode extension.",
      "createdAt": "2022-10-03T20:29:19Z",
      "updatedAt": "2022-12-09T14:34:31Z",
      "closedAt": "2022-12-09T14:34:31Z",
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "cc @TWal @mulmarta @kkohbrok ",
          "createdAt": "2022-10-03T20:29:36Z",
          "updatedAt": "2022-10-03T20:29:36Z"
        },
        {
          "author": "uhoreg",
          "authorAssociation": "CONTRIBUTOR",
          "body": "FWIW, this could create a problem with my proposed (experimental) [decentralised MLS work](https://gitlab.matrix.org/matrix-org/mls-ts/-/blob/decentralised2/decentralised.org) because whenever we refer to an epoch, we also need to record the member who created the epoch.  It wouldn't be a dealbreaker, though, since we could always stick that information in an extension.",
          "createdAt": "2022-10-03T20:40:43Z",
          "updatedAt": "2022-10-03T20:40:43Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Just to be confirm I understand @uhoreg -- it seems like this would capture *part* of the information you need for DMLS, but not all of it (you would still need the committer).  So it's not so much a conflict as just insufficient to solve the problem.",
          "createdAt": "2022-10-03T22:01:01Z",
          "updatedAt": "2022-10-03T22:01:01Z"
        },
        {
          "author": "uhoreg",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yes, that's correct.",
          "createdAt": "2022-10-04T01:39:09Z",
          "updatedAt": "2022-10-04T01:39:09Z"
        },
        {
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I like this change, as it further tightens the bound between the ratchet tree and the rest of the group state.",
          "createdAt": "2022-10-04T06:57:55Z",
          "updatedAt": "2022-10-04T06:57:55Z"
        },
        {
          "author": "TWal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "It reminds me of a change we proposed a while ago, about unmerged leaves:\r\nhttps://mailarchive.ietf.org/arch/msg/mls/tprFmab1jw8CXD55gY3q3D9D09w/\r\n\r\nWe proposed something similar to this: in leaf nodes whose source is update / commit, store the last modification epoch (as you are suggesting), for leaf nodes whose source is keypackage, store the addition epoch (which would not be authenticated by the leaf node of course).\r\nThen you can deduce the unmerged leaves list of every node using this new information, therefore they can be removed from the protocol.\r\nHere is how you do that:\r\nthe epoch at which a parent node was last updated is given my the maximum update epoch of its leaves whose source is commit,\r\nthe unmerged leaves for that node corresponds to leaves with source key_package whose addition postdate the last update epoch of the node.\r\n\r\nRaphael did have some comments about it that might be worth checking: https://mailarchive.ietf.org/arch/msg/mls/zguBFOGFTjXPBZX0yCdcWEqJ7Bg/\r\n\r\nIf this change were incorporated, I think it would be nice to go one step further and remove the concept of unmerged leaves.\r\nBut I would understand if people wouldn't like such a big change this late :)",
          "createdAt": "2022-10-12T15:51:14Z",
          "updatedAt": "2022-10-12T15:51:14Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Interesting idea @TWal.  Just to confirm I understand, the algorithm for recovering unmerged leaves would be something like:\r\n\r\n```\r\ndef unmerged_leaves(P):\r\n  most_recent_commit_epoch = max({ L.committed_epoch : L \\in leaves(P) })\r\n  # Note: It MUST be the case that P is parent-hash chained to the leaf from which this max comes\r\n  return { L \\in P.leaves : L.added_epoch > most_recent_commit_epoch }\r\n```\r\n\r\nThat's a pretty non-trivial algorithm to implement (unless maybe it were integrated with parent-hash validation on a tree), on top of the structure complexity to add the signed field.\r\n\r\nSo I agree that seems like a big change at this point.  But the change in this PR seems like a good compromise.",
          "createdAt": "2022-10-12T16:13:38Z",
          "updatedAt": "2022-10-12T16:13:38Z"
        },
        {
          "author": "uhoreg",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> FWIW, this could create a problem with my proposed (experimental) [decentralised MLS work](https://gitlab.matrix.org/matrix-org/mls-ts/-/blob/decentralised2/decentralised.org) because whenever we refer to an epoch, we also need to record the member who created the epoch. It wouldn't be a dealbreaker, though, since we could always stick that information in an extension.\r\n\r\nActually, looking at this again, we don't need any extra information to record the member who created the epoch, because by definition, the creator of the epoch that modified the leaf node is the owner of the leaf node.\r\n\r\nAnd, in fact, in decentralised MLS, we add a \"generation\" counter to each leaf node to enable picking the most recent key package in the event multiple trees need to be merged together and have different key packages for some leaves.  This field could be used instead of the \"generation\" extension.",
          "createdAt": "2022-10-12T19:27:25Z",
          "updatedAt": "2022-10-12T19:27:25Z"
        },
        {
          "author": "TWal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@bifurcation I implemented (and explained more thoroughly) my idea in #752. It's not such a big change actually, the notion of \"unmerged leaves\" stay there, it's just defined differently.\r\nI don't think adding a non-signed field is such a structural change, after all, the signature itself is not signed!",
          "createdAt": "2022-10-13T14:40:03Z",
          "updatedAt": "2022-10-13T14:40:03Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "There was agreement on the 2022-12-08 interim to not fix this issue.  It can be done in an extension.",
          "createdAt": "2022-12-09T14:34:31Z",
          "updatedAt": "2022-12-09T14:34:31Z"
        }
      ]
    },
    {
      "number": 753,
      "id": "I_kwDOBoyH6c5Ud2gm",
      "title": "allow sending a different Welcome message to each user",
      "url": "https://github.com/mlswg/mls-protocol/issues/753",
      "state": "CLOSED",
      "author": "uhoreg",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "From my reading, it looks like the creator of an epoch must send the exact same `Welcome` message to each new user.  However, in some systems, it is more efficient to send a different message to each user, only containing the `EncryptedGroupSecrets` intended for them, rather than the `EncryptedGroupSecrets` for all new members.  As far as I can tell, no changes are required on the recipient side.\r\n\r\nI'm running some performance testing, trying to add thousands of members at a time, and the `Welcome` messages are hundreds of kilobytes large.  In a federated environment, this could be copied to multiple servers, with the vast majority of that being unnecessary data.",
      "createdAt": "2022-10-20T19:01:21Z",
      "updatedAt": "2022-12-08T15:27:53Z",
      "closedAt": "2022-12-08T15:27:53Z",
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Good point @uhoreg. I filed #754.  In the case, you would do something like send a Welcome per home server?",
          "createdAt": "2022-10-20T19:29:50Z",
          "updatedAt": "2022-10-20T19:29:50Z"
        },
        {
          "author": "uhoreg",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thanks.\r\n\r\nWith the way that Matrix currently works, it would probably be best to send a separate message per user, since the current endpoint for sending messages directly to devices requires specifying the message separately for each recipient, and implementations (AFAIK) currently don't do deduplication.  In the future, it might be possible to do it differently.",
          "createdAt": "2022-10-21T01:54:58Z",
          "updatedAt": "2022-10-21T01:54:58Z"
        }
      ]
    },
    {
      "number": 758,
      "id": "I_kwDOBoyH6c5WilkI",
      "title": "Certificate expiration and joining groups",
      "url": "https://github.com/mlswg/mls-protocol/issues/758",
      "state": "CLOSED",
      "author": "tomleavy",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "We ran into this case, which does not seem to have a defined solution within the RFC and I'm wondering if this ambiguity should be resolved at the RFC level, or be left up to the application.\r\n\r\nExisting group with Alice, and Bob.\r\n\r\n1. Bob had a valid certificate upon being added to the group by Alice.\r\n2. Bob's certificate expires .\r\n3. Alice does a commit to add Charlie to the group.\r\n4. Bob accepts the valid commit to add Charlie.\r\n5. Charlie follows 8.3 and validates the tree. In this process if certificate expiration is enforced, then Charlie would drop the Welcome, which would not be optimal.\r\n\r\nSolution 1: Leave this behavior up to the application, consider it part of the AS. \r\n\r\nSolution 2: Add an explicit mention that credentials that expire should be considered valid after expiration once they are a member of the group.\r\n\r\nSolution 3: A committer MUST validate that all existing credentials in the tree are still considered valid at the time a commit is made. If an existing credential is no longer considered valid, then the resulting commit MUST contain a Remove proposal for the leaf containing that credential.\r\n\r\n",
      "createdAt": "2022-11-16T16:28:31Z",
      "updatedAt": "2022-12-14T14:02:09Z",
      "closedAt": "2022-12-14T14:02:09Z",
      "comments": [
        {
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "body": "Of course it would be better to have the same credential validation algorithm, but at the protocol level, there is no reason to constrain all clients to that, applications can enforce a consistent policy across clients.\r\n\r\nSo, in my mind this is not symmetric between senders and receivers and solutions 1 and 3 are not incompatible, however 2 is not acceptable IMO.\r\n\r\nI would suggest the following:\r\n- Alice MUST verify that she considers all credentials valid before adding Charlie and act if it is not the case (Solution 3)\r\n- Charlie MUST check all the credentials upon joining and act according to its authentication policy*\r\n- Charlie MUST NOT send any application message before she considers all credentials valid",
          "createdAt": "2022-11-16T17:03:55Z",
          "updatedAt": "2022-11-17T17:51:51Z"
        },
        {
          "author": "tomleavy",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> So, in my mind this is not symmetric between senders and receivers and solutions 1 and 3 are not incompatible, however 2 is not acceptable IMO.\r\n\r\nAre you suggesting that it should not be a requirement that each member of the group has the same validation algorithm? That would create forks in any case that individuals disagree on a particular credential's validity. We can of course punt to the application, but I feel like that should at least be cautioned against?\r\n\r\n",
          "createdAt": "2022-11-16T19:05:40Z",
          "updatedAt": "2022-11-16T19:05:40Z"
        },
        {
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I don't quite see how the validation algorithms are different. They are the same, just executed at different points in time. Or am I missing something here?\r\n\r\nIn any case it would be unfortunate if Charlie couldn't send any messages until someone committed to their proposal. So I would propose to change point 2 of the algorithm suggested by @beurdouche to the following:\r\n\r\n* Charlie MUST check all the credentials upon joining. If any group members have expired credentials, Charlie MUST issue a commit to remove the affected members.",
          "createdAt": "2022-11-17T08:32:23Z",
          "updatedAt": "2022-11-17T08:32:23Z"
        },
        {
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "body": "> Are you suggesting that it should not be a requirement that each member of the group has the same validation algorithm? That would create forks in any case that individuals disagree on a particular credential's validity. We can of course punt to the application, but I feel like that should at least be cautioned against?\r\n\r\nI am saying that it is not a requirement. Most applications will want to use the same algorithm, but the protocol doesn't need to make that mandatory, it is just a convenience for applications.\r\n\r\nThe protocol is designed so that each client can make its own choice. It would not create forks, as for example the case Alice decides to remove Bob, Bob is removed for everyone. I would be - ok - with the change proposed by Konrad but we need to be aware that this is a restriction on what clients can decide with respect to authentication (especially in a context where there is no AS).\r\n\r\n",
          "createdAt": "2022-11-17T17:43:59Z",
          "updatedAt": "2022-11-17T17:43:59Z"
        },
        {
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "body": "I think it's also important to remember that there may be a delay between when a user is sent a Welcome and when they process it. So when a user processes a Welcome, the first epoch they see after joining may be quite old and have expired credentials for that reason, and this epoch may not even be the most recent epoch anymore.\r\n\r\nSo I would lean towards solution 2 actually, of \"members that are joining a group just need to ignore expired credentials.\" And if the application wants to have a policy of *not sending new messages* to a group if there are expired credentials present, then that's fine but not something we need to require in the spec. Edit: Or maybe we do want to specify that, but I'd be clear that it's a check done before sending new messages, not part of processing the Welcome.",
          "createdAt": "2022-11-20T17:55:39Z",
          "updatedAt": "2022-11-20T18:03:25Z"
        },
        {
          "author": "tomleavy",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> The protocol is designed so that each client can make its own choice. It would not create forks, as for example the case Alice decides to remove Bob, Bob is removed for everyone\r\n\r\n> I think it's also important to remember that there may be a delay between when a user is sent a Welcome and when they process it.\r\n\r\nAlthough I started the dialog here around certificates and expiration, I think maybe it is useful to ignore the idea of \"expired\" credentials for now, because I agree with the comment by @beurdouche that we should try to avoid being opinionated in that regard. \r\n\r\nI think what I am trying to get across is that regardless of what credential system you use that the protocol can only operate without forks if the validation of that credential is consistent across all members while also taking into account the asynchronous nature of the protocol. If each member of the group has the same state for epoch N, they should all independently determine that new credentials presented as part of a commit are valid or invalid regardless of _when_ they process that commit. I'm viewing a credential being invalid as a trigger for rejecting a commit, which maybe in itself is a bias. \r\n\r\nNot sure if the above belongs in the protocol, the AS definition, or no where at all :-). If everyone thinks this is too restrictive of a statement I'm fine with that. \r\n\r\nMaybe a better solution to this issue is that there could be a separately defined standard way of dealing with certificates within MLS that can be more opinionated than the base protocol and introduce concepts discussed above like MUST remove of expired certs on commit, use an external packet timestamp for consistent expiration checking on the receive side, etc. I think a lot of applications would benefit from that and @psyoptix @mulmarta  and I have been doing a lot of experimentation in that area. \r\n\r\n",
          "createdAt": "2022-11-20T23:21:05Z",
          "updatedAt": "2022-11-20T23:26:09Z"
        },
        {
          "author": "psyoptix",
          "authorAssociation": "CONTRIBUTOR",
          "body": "After a couple long chats with @tomleavy and @mulmarta here's where I stand on this.\r\n\r\nA guiding thought I have is this: IMO creds aren't just for getting *in* to a group. They should also be necessary for continued participation. After all MLS is designed for sessions that can last years.\r\n\r\nThat means, I'm uneasy with an MLS design that allows me to join a group (epoch even) where someone has an invalid (e.g. expired) cred. Worse yet, I don't want MLS to let me send application messages to users with invalid creds at the time of my sending. \r\n\r\nWith that in mind, how about this approach which tries to leave as much freedom to an app/AS while still giving guidance to an app/AS that wants to ensure valid creds are needed for ongoing participation in a group and, optionally, that forks are being avoided as much as possible.\r\n\r\n- ------------------\r\nMLS clients MUST validate the creds at all leaves in a ratchet tree (via the AS) in the following cases:\r\n a. Sending a commit (validation done on new epoch's tree after applying commit).\r\n b. Receiving a commit (validation done on new epoch's tree after applying commit).\r\n c. When joining a group.\r\n d. When client wants to send an application message.\r\n- ------------------\r\n\r\nBased on this MLS now gives 3 guarantees. Call an application/AS \"consistent\" if it ensures that for any given epoch and cred in its ratchet tree, the result of any client validating the cred is the same (i.e. regardless of the time the validation is performed and which rule of a. b. or c. triggered it).\r\n\r\n(Edit: Just to further clarify \"consistency\" doesnt mean validating the same cred but when taken from different ratchet trees should have the same result. It only concerns validations pertaining to the same epoch but performed by different clients at different times.)\r\n\r\n1) Regardless of the app/AS's consistency and any insider attacks, clients only ever join epochs in which all members have valid creds.\r\n2) Regardless of the app/AS's consistency and any insider attacks, clients will never send application messages to receiver with invalid creds (at the time of sending).\r\n3) If the app/AS is consistent, all parties follow the protocol and all packets are delivered by the DS then no forks will occur.\r\n\r\nMy justification for this approach is that it strikes the following balance:\r\n- On the one hand, we now give guidance to app/AS devs for how they can enforce (1-3) if thats what they want.\r\n- On the other hand, we don't actually tie an app/AS's hands at all (e.g. compared to mandating almost no checks ever). That's because MLS says nothing about how cred validation should be implemented. Hard-coding always returning true *is* an MLS spec compliant AS. So if an app/AS doesn't want the constraints imposed by the above rules it is still free to hard-code those validations as returning true; i.e. it can skip the checks if it really needs to.\r\n\r\nIn summary: the idea is basically to tell app/AS devs when/which are the right checks to perform to get good security & availability but also to leave it up to them to make those checks meaningful.\r\n\r\nFinally, regarding \"consistency\": in my mind creds are validated relative to a context (e.g. a time-stamp for checking expiration, a root CA cert, a blockchain or even particular block for checking wallets and/or balances, etc.) One way to get consistency is for the app/AS to ensure that all clients use the same context when checking the creds in a ratchet tree regardless of when they perform their checks.",
          "createdAt": "2022-11-22T15:05:31Z",
          "updatedAt": "2022-11-23T14:28:39Z"
        },
        {
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "body": "```\r\nMLS clients MUST validate the creds at all leaves in a ratchet tree (via the AS) in the following cases:\r\na. Sending a commit (validation done on new epoch's tree after applying commit).\r\nb. Receiving a commit (validation done on new epoch's tree after applying commit).\r\nc. When joining a group.\r\nd. When client wants to send an application message.\r\n```\r\n\r\nIn my mind, applications are only ever in one of two states: A.) I'm reading backlogged messages, or B.) I've read all the messages and I'm waiting for new ones. When you're in state B, you can send messages and also check time-related things. When you're in state A, you have no idea when the messages you're reading were truly sent. We don't currently provide any way to communicate a \"context\" against which time-related things should be validated in state B. So I don't see how we can implement b or c from this list?",
          "createdAt": "2022-11-22T19:44:31Z",
          "updatedAt": "2022-11-22T19:44:31Z"
        },
        {
          "author": "psyoptix",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Implementing b. and c. in some spec compliant way is actually trivial because the spec doesnt require \"consistency\" (in the sense that I defined that term in my previous post.) The only thing the spec says about consistency is that if you want guarantee (3.) then you need consistent cred validation. So e.g. always returning true when validating in cases b. and c. while doing something more interesting for cases (a.) would be fine; i.e. spec compliant. You just wouldn't necessarily get guarantee (3.) is all.\r\n\r\nBut I figure what you meant is how to implement (a.) b. and c. to be *consistent*, right? And that'd be a good question that any app trying to avoid forks would have to think about. (Notice, the RFC *already* creates this concern for such apps with out my proposed changes because to avoid forks now you already need commit sender and receivers to agree on their validation.)\r\n\r\nIn our opinion, we landed on leaving it up to the app/AS how it guarantees consistent validations because we think there are a bunch of different but reasonable ways this could be done. Yet, which of those is best (even among just the couple we could come with on the fly) depends on things like the app's security assumptions, communication models and access to third-party services, not to mention the details of how the AS works.\r\n\r\nTo start off with, it wasn't even totally clear to us that the \"context\"-based syntax really applies to all reasonable AS designs. (Thats how we ended up on the notion of \"consistency\" as that is the more abstract and minimal guarantee we really needed to avoid forks. Context is just one way we thought of to get consistency.) But say the AS does conform to \"context\"-based syntax. Maybe the app/AS ensure consistency by only ensuring that the (possibly different!) contexts being used by clients still produce the same result. Further, even if we are more opinionated and assume an app/AS will ensure an *identical* context is used in all validation cases this still leaves room for many variations. Who chooses the context used for a given epoch? Maybe the commitor? Maybe the AS? Maybe the DS (which we already have to trust it to avoid forks)? Maybe a group-context extension? Also, how is the context distributed? Out-of band? By the AS? By the DS along with commit/welcome packets? Along with group contexts? Each made sense to us in the right setting...\r\n\r\nOne thing we toyed with for a while was the requirement that the commitor authenticates the particular context C they used when creating a commit packet (e.g. by using C as associated data or a PSK or something). But, not only is that already pretty opinionated about how consistency should be enforced, it also wasn't clear to us what the actual point is. TBH at first I was for it at first out of instinct (and ignoring the being opinionated part for the moment), but @mulmarta did a good job of convincing me that I couldn't actually justify it beyond \"it feels right\". What kind of, otherwise not possible, attack is this trying to defend against?\r\n\r\nIn the end, the point is there were enough plausible but diverging options for how to get consistency that we didnt feel comfortable enforcing anything that constrained an app/AS's options. But it's not due to lack of ways to solve for consistency. We just didn't want to be opinionated in a way we couldn't STRONGLY justify.",
          "createdAt": "2022-11-23T13:54:23Z",
          "updatedAt": "2022-11-23T14:28:46Z"
        },
        {
          "author": "tomleavy",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thanks @psyoptix. I'm not sure I agree with checking every time I send an application message as TLS sets a precedent for not checking in that case. I do agree though that I view each epoch as a session renegotiation of sorts, which means that you reevaluate if credentials you previously thought were valid are still valid according to whatever rules that are in place. I believe this conversation winds up in a place where its a very small statement in the main doc that explains how to avoid forks, and then an entirely separate document for each credential type (starting with certificates) that aims to set guidelines on how one _could_ achieve various goals like not allowing expired certs etc. Im all for helping write that document as Wickr will be using the x509 system in production quite a bit. ",
          "createdAt": "2022-11-23T15:52:59Z",
          "updatedAt": "2022-11-23T15:52:59Z"
        },
        {
          "author": "rohan-wire",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> Solution 1: Leave this behavior up to the application, consider it part of the AS.\r\n> \r\n> Solution 2: Add an explicit mention that credentials that expire should be considered valid after expiration once they are a member of the group.\r\n> \r\n> Solution 3: A committer MUST validate that all existing credentials in the tree are still considered valid at the time a commit is made. If an existing credential is no longer considered valid, then the resulting commit MUST contain a Remove proposal for the leaf containing that credential.\r\n\r\nSolution 4: Bob has to do an UpdatePath before his Credential expires with a LeafNode with a valid Credential (certificate). If he doesn't, the other members should Remove him from the group. Same goes if Bob's Credential is revoked.\r\n",
          "createdAt": "2022-11-30T00:25:38Z",
          "updatedAt": "2022-11-30T00:27:12Z"
        },
        {
          "author": "tomleavy",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@rohan-wire I think the core of the discussion at this point is more around the fact that the base protocol does not have any concept of \"expiration\" of credentials, so their behavior is undefined. Either we put an opinionated statement around it in the core protocol, or just punt to applications / another RFC. Thoughts on that?",
          "createdAt": "2022-11-30T01:04:06Z",
          "updatedAt": "2022-11-30T01:04:06Z"
        },
        {
          "author": "rohan-wire",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> @rohan-wire I think the core of the discussion at this point is more around the fact that the base protocol does not have any concept of \"expiration\" of credentials, so their behavior is undefined. Either we put an opinionated statement around it in the core protocol, or just punt to applications / another RFC. Thoughts on that?\r\n\r\nHi @tomleavy ,\r\nMy opinion is that whatever credentials you have in an MLS group should be valid (including not expired, not revoked, not too early, etc.). Therefore it would logically follow:\r\n\r\n- It is the responsibility of each member to make sure their LeafNode credentials are valid and consistent with the group policy at all times. \r\n- Any member of the group that detects another member is out of policy or invalid can remove the offending member. \r\n- To the extent possible a DS that detects that a member is out of compliance with group policy or no longer has valid credentials, can try to remove the member (ex: via an external proposal).\r\n\r\nThe definition of \"valid\" could be done per-credential type or per profile.",
          "createdAt": "2022-11-30T17:17:21Z",
          "updatedAt": "2022-11-30T17:17:21Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Side note: under the general rubric of \"validity changes over time\", revocation is also an issue!\r\n\r\nOverall, my thinking aligns with what @rohan-wire says here.  Saying that the credentials presented by group members should be valid at all times is a concise, clear standard.  It is arguably implied by the current requirement to validate credentials on joining (if you also assume that the group should be joinable at any time).  The more difficult question is how it is implemented in practical reality.\r\n\r\nI don't think we can really write hard requirements around this. The only remediation is Remove, and we don't have other situations where we say a client MUST send a specific proposal.  In part because this might conflict with application-level policies about who is allowed to send Proposals/Commits.  And it seems like there are valid situations where availability might trump authenticity (cf. browsers' click-through on expired certs).  Overall, this seems like more of an operational question than a core protocol question here.\r\n\r\nIn terms of how to reflect all this in documents: The details of how to manage credential freshness seem better suited for an implementation guidance document. (I believe @kkohbrok is gathering ideas for one?)  In the MLS protocol spec, we could add some high-level guidance, something like the following:\r\n\r\n```\r\n### Expiring Credentials\r\n\r\nIn some credential schemes, the validity status of a credential can change over\r\ntime.  For example, X.509 certificates can expire or be revoked by their issuer.\r\nTo avoid operational problems such as new joiners rejecting expired credentials\r\nin a group, applications that use such credentials should ensure that all of the\r\ncredentials in use in a group are valid.\r\n\r\nIf a member finds that its credential is invalid (or will be soon), it should\r\nissue an Update or Commit that replaces it with a valid credential.  For this\r\nreason, members SHOULD accept Update proposals and Commits issued by members\r\nwith invalid credentials, if the credential in the Update or Commit is valid.\r\n\r\nIf a member finds that another member's credential is invalid, they may issue a\r\nRemove that removes that member.  For example, an application could require a\r\nmember preparing to issue a Commit to check the tree for invalid credentials and\r\ninclude Remove proposals for those members in its Commit.  In situations where\r\nthe group tree is known to the DS, the DS could also monitor the tree for\r\ninvalid credentials and issue external Remove proposals.\r\n```\r\n\r\nI think that would fit well either in the Credentials section (between \"Credential Validation\" and \"Uniquely Idenitfying Clients\") or in the security considerations.",
          "createdAt": "2022-12-07T15:40:50Z",
          "updatedAt": "2022-12-07T15:40:50Z"
        }
      ]
    },
    {
      "number": 759,
      "id": "I_kwDOBoyH6c5W6Prz",
      "title": "Does the \"MLS\" prefix of some structs signal something?",
      "url": "https://github.com/mlswg/mls-protocol/issues/759",
      "state": "CLOSED",
      "author": "duesee",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Does anyone know why the MLS draft uses the \"MLS\" prefix for some structs, e.g., `MLSMessage` and not just `Message`? Is there (still) some logic behind this? None of the explanations I could come up with hold for all structs.\r\n\r\nMaybe this is something that just evolved over the years? If so, I would be happy to make an editorial PR to remove all of those :-)",
      "createdAt": "2022-11-21T15:12:48Z",
      "updatedAt": "2022-12-16T17:21:00Z",
      "closedAt": "2022-12-16T17:21:00Z",
      "comments": [
        {
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "body": "Historic...`TLSPlaintext`, `TLSInnerPlaintext` and `TLSCiphertext` from RFC 8446\r\nThis also helps disambiguating between message formats",
          "createdAt": "2022-11-21T15:17:16Z",
          "updatedAt": "2022-11-21T15:18:46Z"
        },
        {
          "author": "duesee",
          "authorAssociation": "CONTRIBUTOR",
          "body": ">  This also helps disambiguating between message formats\r\n\r\nCan you say more?\r\n\r\nOne of my theories was that it was used to avoid naming collisions with other possibly \"imported\" structs from other RFCs. But its `ContentType` and not `MLSContentType`, so... :-)",
          "createdAt": "2022-11-21T15:26:02Z",
          "updatedAt": "2022-11-21T15:27:50Z"
        },
        {
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "body": "Eg. A \"plaintext\" can be pretty much anything like a `TLSPlaintext` containing an `MLSCiphertext` while an MLSPlaintext has a specific format content. Structures which have more internal constraints on their values have less chances to be confused with each other.",
          "createdAt": "2022-11-21T15:31:02Z",
          "updatedAt": "2022-11-21T15:31:02Z"
        },
        {
          "author": "duesee",
          "authorAssociation": "CONTRIBUTOR",
          "body": "First of all, sorry if I widen the scope of this issue a bit.\r\n\r\nBut when you said that the terminology comes from TLS, it clicked.\r\n\r\nWhen I started to work with MLS a few weeks ago, I got confused by the term MLSPlaintext. In TLS, a TLSPlaintext is not protected and only used as a stepping stone. This is different in MLS because an MLSPlaintext is always signed and not \"converted\" into an MLSCiphertext afterwards.\u00b9 It seems close to TLS but isn't.\r\n\r\nWhich brings me back to the \"MLS\" prefix thing. Not sure how peoples' heads work, but mine tries to get rid of not useful information such as an \"MLS\" prefix. And when we remove all \"MLS\" prefixes, it becomes more clear that Plaintext is probably not the right term to describe a signed message. The prefix \"MLS\" in MLSPlaintext blurries that because now we have something \"MLS-specific\". But still, it has \"plaintext\" in its name.\r\n\r\nAlso, I thought that -- similar to the fact that \"...TBS\" is \"never send over the wire\" -- the \"MLS\" prefix denotes things that are send over the wire -- which is not true, e.g., in the case of MLSContentTBS.\r\n\r\nFurthermore, the MLS prefix makes MLSCiphertext and MLSPlaintext stand out in ...\r\n\r\n```\r\nMLSMessage\r\n    Welcome\r\n    KeyPackage\r\n    GroupInfo\r\n    MLSPlaintext // Why the prefix?\r\n    MLSCiphertext // Why the prefix?\r\n```\r\n\r\nWhat makes these variants different?\r\n\r\nWhat would have made more sense to me is something like ...\r\n\r\n```\r\nMessage\r\n    Welcome\r\n    KeyPackage\r\n    GroupInfo\r\n    MLSPlaintext -> <Named after its usage in the system>\r\n    MLSCiphertext -> <Named after its usage in the system>\r\n\r\nMLSContent    -> Content\r\nMLSContentTBS -> ContentTBS\r\nMLSContentTBM -> ContentTBM\r\nMLSSenderData    -> SenderData\r\n...\r\n```\r\n\r\nHowever, I have no good idea what a much better name would be. `MLSPlaintext -> Signed{,Message}` and `MLSCiphertext -> SignedAndEncrypted{,Message}` is a bit better IMO but clunky.\r\n\r\n\u00b9 This was the case in the past, see https://github.com/mlswg/mls-protocol/pull/706.",
          "createdAt": "2022-11-22T12:01:58Z",
          "updatedAt": "2022-11-22T12:04:03Z"
        },
        {
          "author": "TWal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> When I started to work with MLS a few weeks ago, I got confused by the term MLSPlaintext. In TLS, a TLSPlaintext is not protected and only used as a stepping stone. This is different in MLS because an MLSPlaintext is always signed and not \"converted\" into an MLSCiphertext afterwards.\u00b9 It seems close to TLS but isn't.\r\n> \u00b9 This was the case in the past, see #706.\r\n\r\nFor correctness, this was done in #523.\r\nBefore this PR, the procedure was to generate an MLSPlaintext and convert it to an MLSCiphertext. I this this is an heritage of TLS 1.3 which does the same thing ([RFC 8446, section 5.2](https://datatracker.ietf.org/doc/html/rfc8446#section-5.2)).\r\nAfter this PR, the procedure is to generate a MLSContent and convert it to MLSPlaintext or MLSCiphertext.\r\n\r\nOtherwise I agree, it would be nice to have consistent names in the document!",
          "createdAt": "2022-11-22T17:18:05Z",
          "updatedAt": "2022-11-22T17:18:05Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "I agree that the current use of \"MLS\" in struct names is inconsistent, and MLSPlaintext / MLSCiphertext aren't accurate for what those messages do now.  This will be a large-ish change, but probably worth doing to increase clarity.\r\n\r\nI did an audit of `MLS` struct names in the document and tried to think through what else they could be called.  Here's a proposal:\r\n\r\n| Before                      | After                     | Notes                                                    |\r\n|:----------------------------|:--------------------------|:---------------------------------------------------------|\r\n| MLSMessage                  | MLSMessage                | \"MLS\" because it's the thing that goes on the wire       |\r\n| MLSContent                  | GroupContent              | Content targeted to a group                              |\r\n| MLSContentTBS               | GroupContentTBS           |                                                          |\r\n| MLSContentAuthData          | GroupContentAuthData      |                                                          |\r\n| MLSAuthenticatedContent     | AuthenticatedContent      | Signed content (for a group)                             |\r\n| MLSContentTBM               | AuthenticatedContentTBM   |                                                          |\r\n| MLSSenderData               | SenderData                |                                                          |\r\n| MLSSenderDataAAD            | SenderDataAAD             |                                                          |\r\n| MLSCiphertextContent        | ContentPlaintext          | Content prepared to be a \"plaintext\" input to encryption |\r\n| MLSCiphertextContentAAD     | ContentAAD                |                                                          |\r\n| MLSPlaintext                | PublicMessage             | An auth+integrity-protected group message                |\r\n| MLSCiphertext               | PrivateMessage            | A auth+confidentiality-protected group message           |\r\n\r\nThe latter two are the most challenging.  It's difficult to get across precisely what they're about without getting super verbose.  Another route would be to use something like SignedMessage and EncryptedMessage.\r\n",
          "createdAt": "2022-12-07T14:59:29Z",
          "updatedAt": "2022-12-07T14:59:29Z"
        },
        {
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thanks for bringing this up @duesee and thanks for the proposal @bifurcation! I like the proposed changes, although might I suggest the prefix \"Message\" instead of \"Group\" for -Content -ContentTBS and -ContentAuthData? It is targeted to a group, but it's really the core content of a message.",
          "createdAt": "2022-12-07T15:12:51Z",
          "updatedAt": "2022-12-07T15:12:51Z"
        },
        {
          "author": "duesee",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thanks, @bifurcation! This looks really promising! `PublicMessage` and `PrivateMessage` are the best terms I heard so far.\r\n\r\nWhile we're at it, should we add a \"...TBE\" (To-Be-Encrypted) to the (possibly new) `ContentPlaintext`? While the `...TBS`, and `...TBM` appendices may seem intimidating at first, they provide a very good idea where to expect (and how to use) them.",
          "createdAt": "2022-12-08T10:54:58Z",
          "updatedAt": "2022-12-08T10:54:58Z"
        }
      ]
    },
    {
      "number": 760,
      "id": "I_kwDOBoyH6c5XVFUC",
      "title": "CBOR/CDDL vs. TLS Presentation Language",
      "url": "https://github.com/mlswg/mls-protocol/issues/760",
      "state": "CLOSED",
      "author": "pukkamustard",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Encoding of protocol structures are described using the TLS Presentation Language (from [RFC 8446](https://www.rfc-editor.org/rfc/rfc8446#section-3)). \r\n\r\nWere other languages formats considered? In particular were CBOR ([RFC 8949 / STD 94](https://www.rfc-editor.org/info/std94)) and the description language CDDL ([RFC 8610](https://www.rfc-editor.org/rfc/rfc8610)) considered?\r\n\r\nAdvantages of CBOR/CDDL might be more wide-spread availability of existing implementations that could facilitate usage. This might be important as the exact wire format and encoding might be more intrusive into applications and protocols using MLS than protocols using TLS.",
      "createdAt": "2022-11-26T12:41:38Z",
      "updatedAt": "2022-11-30T06:37:57Z",
      "closedAt": "2022-11-30T06:37:56Z",
      "comments": [
        {
          "author": "rohan-wire",
          "authorAssociation": "CONTRIBUTOR",
          "body": "This protocol has been in development since 2018. It has been an IETF WG document since Feb 2019. It has been through two WGLCs and in now in Publication Requested. It has at least three implementations that I am aware of. During this entire time the protocol used TLS Presentation Language. While it may have been a good idea 3-4 years ago, the time to propose a different syntax has long passed.",
          "createdAt": "2022-11-30T00:20:04Z",
          "updatedAt": "2022-11-30T00:20:04Z"
        },
        {
          "author": "pukkamustard",
          "authorAssociation": "NONE",
          "body": "Understand. Thanks for the insight.",
          "createdAt": "2022-11-30T06:37:56Z",
          "updatedAt": "2022-11-30T06:37:56Z"
        }
      ]
    },
    {
      "number": 762,
      "id": "I_kwDOBoyH6c5YLmS5",
      "title": "Interaction of MLS and application",
      "url": "https://github.com/mlswg/mls-protocol/issues/762",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "discuss",
        "review"
      ],
      "body": "_Comment by @paulwouters_\n\nI find the interaction with the application layer not clear. Not much is mentioned in this document. How can a group have an administrator? How is that enforced at the MLS layer? How do ACLs interact with MLS? (How are DoS attacks mitigated (eg spam attempts to join any group). What hooks would be in the authentication service and/or delivery server? How would clients know the properties of these two services?\n\nThis includes how it is not clear to me how race conditions are handled. What if two members try to expel each other at the same time? What if the group is so large, members always get their epoch wrong for things like Commit messages?\n\n",
      "createdAt": "2022-12-06T15:46:57Z",
      "updatedAt": "2022-12-14T16:02:10Z",
      "closedAt": "2022-12-14T16:02:10Z",
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "I think the intent was to have these issues mostly dealt with in the architecture document.  Broadly speaking, it is the DS's job to solve these problems.  For example, the DS we use in Webex chooses which member makes which commit.\r\n\r\nThis is why we have Section 3, [Operating Context](https://messaginglayersecurity.rocks/mls-protocol/draft-ietf-mls-protocol.html#name-operating-context).  There are also some brief notes in Section 14, \"[Sequencing of State Changes](https://messaginglayersecurity.rocks/mls-protocol/draft-ietf-mls-protocol.html#name-sequencing-of-state-changes).\r\n\r\nUnless we need to make this division of labor clearer, I'm inclined to close this issue with no action.\r\n",
          "createdAt": "2022-12-06T18:19:03Z",
          "updatedAt": "2022-12-06T18:19:03Z"
        },
        {
          "author": "rohan-wire",
          "authorAssociation": "CONTRIBUTOR",
          "body": "While instant messaging was one of the big motivators for MLS, it is not the only one to be implemented in the same timeframe. \r\n\r\nIn MIMI for example we are planning to have a whole work item that specifies many more constraints on how the DS would be expected to work in an *instant messaging* context. Whereas we have implementors of MLS who are planning to do things very differently for an IoT communication application. ",
          "createdAt": "2022-12-06T23:29:53Z",
          "updatedAt": "2022-12-06T23:29:53Z"
        },
        {
          "author": "paulwouters",
          "authorAssociation": "NONE",
          "body": "I'll reread the architecture bit again about the DS, but it still feels to me it could be made more clear.",
          "createdAt": "2022-12-07T00:43:49Z",
          "updatedAt": "2022-12-07T00:43:49Z"
        }
      ]
    },
    {
      "number": 763,
      "id": "I_kwDOBoyH6c5YLmTu",
      "title": "Security against malicious members?",
      "url": "https://github.com/mlswg/mls-protocol/issues/763",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "discuss",
        "review"
      ],
      "body": "_Comment by @paulwouters_\n\nThere seems to be no group \"owner\", so inviting one member X, could that member than delete members from the group until the group is empty?\n\nApparently, there is ACLs for this, but the document doesn't describe how ACLS would work or how these would be implemented.\n\n",
      "createdAt": "2022-12-06T15:46:58Z",
      "updatedAt": "2022-12-14T16:02:10Z",
      "closedAt": "2022-12-14T16:02:10Z",
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "You are correct that MLS is \"egalitarian\" by default, in that any member can perform any action.  This capability can be limited by policy, enforced either at the endpoints or at the DS (the latter requiring handshake messages to be unencrypted).  This is discussed in the MLS architecture document, e.g., in the [Access Control](https://messaginglayersecurity.rocks/mls-architecture/draft-ietf-mls-architecture.html#name-access-control) section.\r\n\r\nI would be open to adding some security considerations noting this.  But seeing as it's already in the architecture, I would be inclined to close this issue with no action.",
          "createdAt": "2022-12-06T18:22:33Z",
          "updatedAt": "2022-12-06T18:22:33Z"
        }
      ]
    },
    {
      "number": 764,
      "id": "I_kwDOBoyH6c5YLmUk",
      "title": "Should B receive its own Commit back?",
      "url": "https://github.com/mlswg/mls-protocol/issues/764",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "discuss",
        "review",
        "to close"
      ],
      "body": "_Comment by @paulwouters_\n\nFigure 4 shows:\n\n~~~ \n\n                                                             Group\n   A              B     ...      Z          Directory        Channel\n   |              |              |              |              |\n   |              | Update(B)    |              |              |\n   |              +------------------------------------------->|\n   |              |              |              | Update(B)    |\n   |<----------------------------------------------------------+\n   |              |<-------------------------------------------+\n   |              |              |<----------------------------+\n~~~\nDoes the Group channel really send Update(B) back to B ? Same for the following \"Commit(Upd)\" from A that is sent back to A?\n\n",
      "createdAt": "2022-12-06T15:46:59Z",
      "updatedAt": "2022-12-08T14:16:34Z",
      "closedAt": "2022-12-08T12:40:42Z",
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "B *definitely* needs to receive Commit(Upd), since that contains fresh entropy from A that B needs to advance to the next epoch.  B doesn't need to receive Update(B), but can cleanly ignore it if it does.  Since we've described the group channel as a broadcast channel, it seems clearer to just show a straight broadcast.",
          "createdAt": "2022-12-06T18:27:08Z",
          "updatedAt": "2022-12-06T18:27:08Z"
        },
        {
          "author": "TWal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "For completeness, A also needs to receive Commit(Upd) to know that its commit was chosen by the DS for the current epoch.",
          "createdAt": "2022-12-08T09:29:08Z",
          "updatedAt": "2022-12-08T09:29:08Z"
        },
        {
          "author": "paulwouters",
          "authorAssociation": "NONE",
          "body": "Maybe worth a sentence ?\n\nSent using a virtual keyboard on a phone\n\n> On Dec 8, 2022, at 04:29, Th\u00e9ophile Wallez ***@***.***> wrote:\n> \n> \ufeff\n> For completeness, A also needs to receive Commit(Upd) to know that its commit was chosen by the DS for the current epoch.\n> \n> \u2014\n> Reply to this email directly, view it on GitHub, or unsubscribe.\n> You are receiving this because you were mentioned.\n",
          "createdAt": "2022-12-08T13:29:08Z",
          "updatedAt": "2022-12-08T13:29:08Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "There already is a sentence:\r\n\r\n> Only after A has received its Commit message back from the server does it update its state to reflect the new member's addition",
          "createdAt": "2022-12-08T14:16:34Z",
          "updatedAt": "2022-12-08T14:16:34Z"
        }
      ]
    },
    {
      "number": 765,
      "id": "I_kwDOBoyH6c5YLmVh",
      "title": "Section 6.3 use of \"member\"",
      "url": "https://github.com/mlswg/mls-protocol/issues/765",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "discuss",
        "review",
        "to close"
      ],
      "body": "_Comment by @paulwouters_\n\n~~~ \n   Each member of a group presents a credential that provides one or\n   more identities for the member,\n~~~\nI am unsure if \"one or more identities for the member\" refers to identies for a single client or was meant as \"a user can have multiple clients\". The way it reads now is that it would be a single client that can have multiple identities. But then could a user have multiple identities on one client that do not match multiple identities on other clients.\n\n",
      "createdAt": "2022-12-06T15:47:00Z",
      "updatedAt": "2022-12-08T12:40:42Z",
      "closedAt": "2022-12-08T12:40:42Z",
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Your interpretation is correct.   Each credential can present multiple identities, for example, a certificate with dNSName and sRVName entries.  And each member's credential is independent (MLS doesn't have a notion of devices belonging to the same user).  So my laptop could present `(rFC822Name=rlb@ipv.sx, dNSName=rlb.ipv.sx)` and my phone could present `(rFC822Name=rlb@ipv.sx, SRVName=_xmpp.ipv.sx)`.  Just like in principle a TLS connection could have the server present a certificate with a pile of DNS names in it, and the client could present a different certificate with a different, possibly overlapping, pile of DNS names in it.  It's up to the application to have a sensible identifier and credential scheme, with the cites to RFC 6125 as guidance.\r\n\r\nSo I think the text is correct as it stands.",
          "createdAt": "2022-12-06T18:37:33Z",
          "updatedAt": "2022-12-06T18:37:33Z"
        }
      ]
    },
    {
      "number": 766,
      "id": "I_kwDOBoyH6c5YLmWN",
      "title": "ENUMs limited to 1 octet?",
      "url": "https://github.com/mlswg/mls-protocol/issues/766",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "discuss",
        "review"
      ],
      "body": "_Comment by @paulwouters_\n\n~~~ \n\u00a0enum {\n       reserved(0),\n       mls10(1),\n       (255)\n   } ProtocolVersion;\n~~~\nWould it really do harm to turn this into two octets? I don't think message size is a real concern here. Same for ContentType and SenderType. Note: thank you for skipping 0 as a valid entry!! Implementers applaud you :)\n\n",
      "createdAt": "2022-12-06T15:47:01Z",
      "updatedAt": "2022-12-09T14:02:19Z",
      "closedAt": "2022-12-09T14:02:19Z",
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Yep, we have tried to reserve 0 in all the enums, precisely because I was a grumpy implementor!",
          "createdAt": "2022-12-06T18:38:23Z",
          "updatedAt": "2022-12-06T18:38:23Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "On the one hand, yes, one octet is not that much more, and it saves worrying about space.  On the other hand, in its long life, TLS has only exhausted 4 of its 65k versions, and its HandshakeType and ContentType enums are both still comfortable at 1 byte (the analogous to the other ProposalType and ContentType here).\r\n\r\nAmong the identifiers we have, we should be most worried about the intended extension points, namely ExtensionType and ProposalType.  Both of those are `uint16` already.  There's no mechanism for adding new values to ContentType and SenderType, so I would leave them at `uint8`.  (Technically they could be updated by an extension -- but an extension could also make them 16 bits!)\r\n\r\nI can live with expanding ProtocolVersion, in case we decide to do some of the GREASE-like stuff that QUIC is doing.\r\n",
          "createdAt": "2022-12-06T18:49:34Z",
          "updatedAt": "2022-12-06T18:49:34Z"
        },
        {
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "body": "I don't have a strong opinion about this either, but if we make this 16-bit wide, we should do the same for consistency for ContentType, SenderType & WireFormat (the MLS extension document does introduce a new WireFormat for example).",
          "createdAt": "2022-12-06T21:16:03Z",
          "updatedAt": "2022-12-06T21:16:03Z"
        },
        {
          "author": "rohan-wire",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Hi,\r\nI don't think there is any expectation that we are going to exhaust the version space (and we could do an extension later to fix that in the event we are wildly successful).\r\n\r\nAs for the idea that implementations will be easier if things are aligned on 16-bit or 32-bit boundaries, that doesn't help us because the Vector lengths are variable.\r\n\r\nI would leave this as is.",
          "createdAt": "2022-12-06T23:37:33Z",
          "updatedAt": "2022-12-06T23:37:33Z"
        },
        {
          "author": "paulwouters",
          "authorAssociation": "NONE",
          "body": "I can agree with the reasoning here",
          "createdAt": "2022-12-07T00:39:07Z",
          "updatedAt": "2022-12-07T00:39:07Z"
        }
      ]
    },
    {
      "number": 767,
      "id": "I_kwDOBoyH6c5YLmW6",
      "title": "Epoch rollover?",
      "url": "https://github.com/mlswg/mls-protocol/issues/767",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "discuss",
        "review",
        "to close"
      ],
      "body": "_Comment by @paulwouters_\n\nWhat happens if members maliciously create huge amounts of epochs and it hits 2^64 ?\n\n",
      "createdAt": "2022-12-06T15:47:02Z",
      "updatedAt": "2022-12-08T12:40:43Z",
      "closedAt": "2022-12-08T12:40:43Z",
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Creating an epoch requires at least a signature operation (in addition to a bunch of other stuff).  On my M1 Pro MacBook, `openssl speed` reports 584,846 ~= 2^19 ECDSA P-256 signatures per second.  At that rate, it would take more than a million years to overflow the epoch field.  Even with a couple more generations of Moore's law, we've got a pretty good margin!  And PQ signatures will make us even safer.\r\n\r\nPropose closing with no action.",
          "createdAt": "2022-12-06T18:54:18Z",
          "updatedAt": "2022-12-06T18:54:18Z"
        },
        {
          "author": "paulwouters",
          "authorAssociation": "NONE",
          "body": "Fair :)\r\n\r\n though doing 2^19 epoch increments per second does seem to lock out real clients, but I guess you wil say the DS has to rate limit those from clients and the DS isn't further specified in the arch or protocol doc :P",
          "createdAt": "2022-12-06T18:58:16Z",
          "updatedAt": "2022-12-06T18:58:16Z"
        },
        {
          "author": "paulwouters",
          "authorAssociation": "NONE",
          "body": "feel free to close with no action",
          "createdAt": "2022-12-06T19:39:05Z",
          "updatedAt": "2022-12-06T19:39:05Z"
        },
        {
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "body": "For context, rate-limiting is something that is part of any production-grade messaging system. I don't think MLS should have to introduce that notion.",
          "createdAt": "2022-12-06T21:17:58Z",
          "updatedAt": "2022-12-06T21:17:58Z"
        }
      ]
    },
    {
      "number": 768,
      "id": "I_kwDOBoyH6c5YLmX8",
      "title": "Padding with zeros",
      "url": "https://github.com/mlswg/mls-protocol/issues/768",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "discuss",
        "review",
        "to close"
      ],
      "body": "_Comment by @paulwouters_\n\nWhile I appreciate the zeros only for padding to avoid side channel communications, wouldn't it be too late if the if there were non-zeros in the padding? Since this message could be encrypted to multiple parties in the part of the tree, wouldn't it make sense to send a kind of alert message to everyone? That way, at least two people in the tree couldn't work together ? So instead of \"MUST be rejected as malformed\" do something that MUST send a message to everyone with \"some content warning\" ?\n\n",
      "createdAt": "2022-12-06T15:47:04Z",
      "updatedAt": "2022-12-08T12:40:43Z",
      "closedAt": "2022-12-08T12:40:43Z",
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "To be clear, the padding scheme only applies to messages that are encrypted once to the whole group.  Every recipient decrypts with the same key.  So every member who correctly checks the padding will fail.  That seems to me to imply there's no need for an explicit alert, since everyone should reach the same conclusion independently.  Of course, if an application wanted to freak out in some way in response to this error, it is free to do so.\r\n\r\nPropose closing with no action.",
          "createdAt": "2022-12-06T19:03:33Z",
          "updatedAt": "2022-12-06T19:03:33Z"
        }
      ]
    },
    {
      "number": 769,
      "id": "I_kwDOBoyH6c5YLmZD",
      "title": "XOR guard",
      "url": "https://github.com/mlswg/mls-protocol/issues/769",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "discuss",
        "review",
        "to close"
      ],
      "body": "_Comment by @paulwouters_\n\nShould there be text saying that if the \"reuse guard\" random returns four zero bytes, it should be run again? Maybe add this to 7.3.2 where MLSSenderData has additional constrains.\n\n",
      "createdAt": "2022-12-06T15:47:05Z",
      "updatedAt": "2022-12-09T20:15:16Z",
      "closedAt": "2022-12-09T20:15:16Z",
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Having four zero bytes isn't inherently harmful, since the nonce itself is already randomized.  The problem would be if the reuse guard producer produced repeated values (*and* the generation failed to advance).  Maybe all-zeros is indicative of this, maybe it's just bad luck.\r\n\r\nThat said, this change seems harmless, so I'm open to it if people want it.  But I would be incline to close with no action.\r\n\r\ncc @Bren2010 since this was his addition",
          "createdAt": "2022-12-06T19:06:29Z",
          "updatedAt": "2022-12-06T19:06:29Z"
        },
        {
          "author": "paulwouters",
          "authorAssociation": "NONE",
          "body": "fine to close.",
          "createdAt": "2022-12-09T20:15:09Z",
          "updatedAt": "2022-12-09T20:15:09Z"
        }
      ]
    },
    {
      "number": 770,
      "id": "I_kwDOBoyH6c5YLmag",
      "title": "KDF.Nh",
      "url": "https://github.com/mlswg/mls-protocol/issues/770",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "discuss",
        "review"
      ],
      "body": "_Comment by @paulwouters_\n\n~~~ \n   The key and nonce provided to the AEAD are computed as the KDF of the\n   first KDF.Nh bytes of the ciphertext generated in the previous\n   section.\n~~~\nI don't think I understand the security model here? What happens if the previous ciphertext has 00's for the first KDF.Nh bytes?\n\n",
      "createdAt": "2022-12-06T15:47:06Z",
      "updatedAt": "2022-12-16T17:02:46Z",
      "closedAt": "2022-12-16T17:02:46Z",
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "The ciphertext sample here is just acting as a salt to produce several distinct key/nonce pairs from a single `sender_data_secret`.  So as with #769, all-zeros isn't inherently harmful here, unless it happens repeatedly.\r\n\r\n(Note that this scheme was inspired by [the QUIC header protection scheme](https://www.rfc-editor.org/rfc/rfc9001#name-header-protection-sample), except the latter only uses 16 bytes of sample and XOR instead of AEAD.)\r\n\r\nIf the content encryption is done properly, then the probability of any particular value is vanishingly small, due to the ciphertext looking like random data.\r\n\r\nSomeone could construct a ciphertext that results in nonce reuse, e.g., having the same `KDF.Nh` bytes as a previous message.  However, note that the harm here is done when the reused key/nonce is used to *encrypt* and the encrypted sender info is published to the attacker.  This means that the attack cannot be mounted from *outside* the group.  Even if the attacker can cause a sender to encrypt a given plaintext, the attacker would not know the key with which it would be encrypted.  So the best attack is for an *insider* to the group to leak the sender info.\r\n\r\ncc @TWal who did some analysis on this IIRC",
          "createdAt": "2022-12-06T19:26:01Z",
          "updatedAt": "2022-12-06T19:26:01Z"
        },
        {
          "author": "TWal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I didn't do analysis on this, however I'm a bit concerned by the assertion \"due to the ciphertext looking like random data\".\r\nI don't think this is a standard security assumption we do on AEADs?\r\nFor example if I take a secure AEAD, and build a new one by prefixing `KDF.Nh` zeroes, the new AEAD is as secure as the original one?\r\n\r\nTo make sure that there is no key/nonce re-use, I think it would be better to use a full hash on the ciphertext, but it increases computation cost.",
          "createdAt": "2022-12-08T10:13:17Z",
          "updatedAt": "2022-12-08T10:13:17Z"
        },
        {
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yeah, I'm also a bit wary of this assumption. I think this would correspond to $-AE or $-IND-CCA security for the AEAD scheme. Wasn't this inspired by QUIC somehow (maybe header encryption)? In any case, if we don't do so already, we might want to explicitly note this in the ciphersuite section to ensure that AEAD schemes added in the future indeed produce pseudorandom ciphertexts. ",
          "createdAt": "2022-12-08T11:29:02Z",
          "updatedAt": "2022-12-08T11:29:02Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "It also occurs to me that `MLSSenderData` is only 12 bytes long (and 12 < 16), so we could change this to literally do what QUIC does:\r\n\r\n```\r\nciphertext_sample = ciphertext[0:16]\r\nmask = AES-ECB(sender_data, sample)[0:12]\r\nencrypted_sender_data = sender_data ^ mask;\r\n```\r\n\r\n(And there's a parallel for ChaCha)\r\n\r\nThat would more clearly benefit from any QUIC analysis, and would save an extra auth tag.  It would be a minor pain to implement, because you would need access to a raw cipher as well as an AEAD mode.",
          "createdAt": "2022-12-08T12:47:42Z",
          "updatedAt": "2022-12-08T12:47:42Z"
        },
        {
          "author": "TWal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "It looks like it also relies on the ciphertext prefix being random?\r\n\r\nI dislike this approach which is too low-level in my opinion, I would prefer staying with high-level cryptographic primitives.",
          "createdAt": "2022-12-14T15:31:45Z",
          "updatedAt": "2022-12-14T15:31:45Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "I filed #770 to try to address this.  Basically, I argue that the same arguments from Bellare et al. that apply to QUIC header protection also apply here.  The PR also adds a requirement that AEADs act as PRFs, as discussed here.",
          "createdAt": "2022-12-14T16:48:24Z",
          "updatedAt": "2022-12-14T16:48:24Z"
        }
      ]
    },
    {
      "number": 771,
      "id": "I_kwDOBoyH6c5YLmbw",
      "title": "Time is not on our side?",
      "url": "https://github.com/mlswg/mls-protocol/issues/771",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "discuss",
        "review",
        "to close"
      ],
      "body": "_Comment by @paulwouters_\n\n~~~ \nmeasured in seconds since the Unix epoch (1970-01-01T00:00:00Z)\n~~~\nWhy use a time format that dies in 2038 already? IRC is older than the time given to MLS to survive :P\n\n",
      "createdAt": "2022-12-06T15:47:07Z",
      "updatedAt": "2022-12-08T12:40:43Z",
      "closedAt": "2022-12-08T12:40:43Z",
      "comments": [
        {
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "body": "This would be true for int32. But the lifetime struct is uint64.",
          "createdAt": "2022-12-06T18:33:38Z",
          "updatedAt": "2022-12-06T18:33:38Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Yep, what @Bren2010 said.  We're good until the year 584,942,419,325. (More or less.  I didn't account for leap days.)\r\n\r\nPropose closing with no action.",
          "createdAt": "2022-12-06T19:28:12Z",
          "updatedAt": "2022-12-06T19:28:12Z"
        }
      ]
    },
    {
      "number": 772,
      "id": "I_kwDOBoyH6c5YLmcd",
      "title": "lifetime field",
      "url": "https://github.com/mlswg/mls-protocol/issues/772",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "discuss",
        "review",
        "to close"
      ],
      "body": "_Comment by @paulwouters_\n\n~~~ \n   it is RECOMMENDED that the\n   client verifies that the current time is within the range of\n   the lifetime field.\n~~~\nWhy RECOMMENDED and not MUST ?\n\n",
      "createdAt": "2022-12-06T15:47:09Z",
      "updatedAt": "2022-12-09T20:15:46Z",
      "closedAt": "2022-12-09T20:15:46Z",
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Because the protocol is designed to be asynchronous, there may be some time between when a new member is added and when another member sees the Commit adding the member.  In the interim, the KeyPackage may have expired.\r\n\r\nPropose closing with no action.",
          "createdAt": "2022-12-06T19:29:43Z",
          "updatedAt": "2022-12-06T19:29:43Z"
        },
        {
          "author": "rohan-wire",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think making this a MUST is reasonable. We just need to make it clear to clients adding KeyPackages that they are responsible for making sure their uploaded KeyPackages have a reasonable lifetime. Likewise another client using a KeyPackage has no business sending an Add proposal with a KeyPackage which is expired or about to expire.  ",
          "createdAt": "2022-12-06T23:45:49Z",
          "updatedAt": "2022-12-06T23:45:49Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "That logic seems really fraught @rohan-wire.  That would mean that in addition to checking that the KP is valid now, the Proposer/Committer has to check make an estimate of how long it will take the Commit to get to everyone.  That doesn't seem very feasible.",
          "createdAt": "2022-12-07T14:04:17Z",
          "updatedAt": "2022-12-07T14:04:17Z"
        },
        {
          "author": "paulwouters",
          "authorAssociation": "NONE",
          "body": "thanks for the clarification. Can be closed",
          "createdAt": "2022-12-09T20:14:30Z",
          "updatedAt": "2022-12-09T20:14:30Z"
        }
      ]
    },
    {
      "number": 773,
      "id": "I_kwDOBoyH6c5YLmdS",
      "title": "Section 8.4",
      "url": "https://github.com/mlswg/mls-protocol/issues/773",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "discuss",
        "review",
        "to close"
      ],
      "body": "_Comment by @paulwouters_\n\n~~~ \n   path_secret[0] is sampled at random\n~~~\nWhat does this mean? What is sampling? What is the sample used for ?\n\nSimilar in [Section 8.5](https://www.ietf.org/archive/id/draft-ietf-mls-protocol-15.html#section-8.5):\n\n~~~ \nSet the encryption_key to the public key of a freshly sampled key pair\n~~~\n",
      "createdAt": "2022-12-06T15:47:10Z",
      "updatedAt": "2022-12-08T12:40:44Z",
      "closedAt": "2022-12-08T12:40:44Z",
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "\"Sampling\" just means \"pulling random bytes from the [CSP]RNG.  Do you have a way you would prefer to phrase it?",
          "createdAt": "2022-12-06T19:32:10Z",
          "updatedAt": "2022-12-06T19:32:10Z"
        }
      ]
    },
    {
      "number": 774,
      "id": "I_kwDOBoyH6c5YLmeH",
      "title": "Section 13/14 Race conditions ?",
      "url": "https://github.com/mlswg/mls-protocol/issues/774",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "discuss",
        "review",
        "to close"
      ],
      "body": "_Comment by @paulwouters_\n\nIn [Section 13.4.3.2](https://www.ietf.org/archive/id/draft-ietf-mls-protocol-15.html#section-13.4.3.2), but also elsewhere, I am confused how race conditions are handled. In this section, if two clients try to each add a a new member for an External Commit join, one of them will fail on the epoch being wrong.\n\nIsn't there a similar race with removing? And any other operation that changes the epoch? How are all these race conditions handled?\n\n[Section 14](https://www.ietf.org/archive/id/draft-ietf-mls-protocol-15.html#section-14) does not really clarify this to me.\n\n",
      "createdAt": "2022-12-06T15:47:11Z",
      "updatedAt": "2022-12-08T12:40:44Z",
      "closedAt": "2022-12-08T12:40:44Z",
      "comments": [
        {
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "body": "Race conditions are discussed in section 4.2 of the arch document.",
          "createdAt": "2022-12-06T18:35:45Z",
          "updatedAt": "2022-12-06T18:35:45Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "In addition to what @Bren2010 says, in the non-external Commit case, the [proposal list validation rules](https://messaginglayersecurity.rocks/mls-protocol/draft-ietf-mls-protocol.html#name-proposal-list-validation) mean that the Committer needs to resolve any races among proposals.  For example, if two members add the same new member, then it's up to the committer to choose one according to its local policy.",
          "createdAt": "2022-12-06T19:35:20Z",
          "updatedAt": "2022-12-06T19:35:20Z"
        }
      ]
    },
    {
      "number": 775,
      "id": "I_kwDOBoyH6c5YLmfF",
      "title": "Section 15.1",
      "url": "https://github.com/mlswg/mls-protocol/issues/775",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "discuss",
        "review",
        "to close"
      ],
      "body": "_Comment by @paulwouters_\n\nWhy not at least always pad to a length of like 1000 bytes to avoid some of the very obvious information leaks by length? It would cover most \"single line\" conversation sentences. Maybe a SHOULD pad to a minimum of X ?\n\n",
      "createdAt": "2022-12-06T15:47:12Z",
      "updatedAt": "2022-12-08T12:40:44Z",
      "closedAt": "2022-12-08T12:40:44Z",
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "I would be disinclined to do this.  The meaningful boundaries are highly application-specific.",
          "createdAt": "2022-12-06T19:36:30Z",
          "updatedAt": "2022-12-06T19:36:30Z"
        },
        {
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "body": "I agree with @bifurcation on this, there is no telling what padding size makes sense in general. In some scenarios, MLS could be used to encrypt rather short messages, in which case a substantially larger padding size would be unnecessary.",
          "createdAt": "2022-12-06T21:30:32Z",
          "updatedAt": "2022-12-06T21:30:32Z"
        },
        {
          "author": "rohan-wire",
          "authorAssociation": "CONTRIBUTOR",
          "body": "This is actually mentioned in the MLS architecture document how this is an [operational decision](https://www.ietf.org/archive/id/draft-ietf-mls-architecture-09.html#section-6-12.1)\r\n\"If there's any policy on how or when to pad messages\"\r\n",
          "createdAt": "2022-12-06T23:53:32Z",
          "updatedAt": "2022-12-06T23:53:32Z"
        },
        {
          "author": "paulwouters",
          "authorAssociation": "NONE",
          "body": "I guess there is padding at the application level, and padding at the MLS message level. I guess I agree it makes little sense at the MLS layer",
          "createdAt": "2022-12-07T00:33:54Z",
          "updatedAt": "2022-12-07T00:33:54Z"
        }
      ]
    },
    {
      "number": 776,
      "id": "I_kwDOBoyH6c5YLmgE",
      "title": "NOOPs ?",
      "url": "https://github.com/mlswg/mls-protocol/issues/776",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "discuss",
        "review",
        "to close"
      ],
      "body": "_Comment by @paulwouters_\n\nAs stated before, I miss a defined NOOP command that allows for a continuous IPTFS like constant stream of data that would hide better when a member is conversing at all or not.\n\n",
      "createdAt": "2022-12-06T15:47:13Z",
      "updatedAt": "2022-12-08T12:40:45Z",
      "closedAt": "2022-12-08T12:40:45Z",
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "To save folks a search, I assume IPTFS is this: https://datatracker.ietf.org/doc/html/draft-ietf-ipsecme-iptfs\r\n\r\nThis is a question for the application layer protocol.  MLS doesn't define what goes in application payloads, so an application could certainly implement something like this.  The analogy to IPsec is that MLS is almost all IKE, and the application messages are ESP, so just like IPTFS goes within ESP, what you're proposing would be some new thing that would go on inside of MLS application messages.\r\n\r\nPropose closing with no action.",
          "createdAt": "2022-12-06T19:40:48Z",
          "updatedAt": "2022-12-06T19:40:48Z"
        },
        {
          "author": "paulwouters",
          "authorAssociation": "NONE",
          "body": "That's a good point, thanks. So for application messages it is out of scope. But would one want to be able to hide the fact that member change operations happened?  eg do this at the MLS layer to avoid people gaining information based on whether there were or were not MLS (non-application) messages ?",
          "createdAt": "2022-12-06T19:45:01Z",
          "updatedAt": "2022-12-06T19:45:01Z"
        },
        {
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "body": "The best protection against this kind of eavesdropping would be to use `MLSCiphertext` for handshake messages as well (i.e. Commits and Proposals).\r\nWe had quite a bit of discussion about hiding as much metadata as possible, and the result is that the only leaked metadata in the payload is the header of `MLSCiphertext`:\r\n\r\n```\r\nstruct {\r\n    opaque group_id<V>;\r\n    uint64 epoch;\r\n    ContentType content_type;\r\n    ...\r\n} MLSCiphertext;\r\n```\r\n\r\nYou'll note that the content type is a part of it, we deemed that to be a reasonable tradeoff at the time given that its sensitivity is not typically high. Having a NOOP operation would mandate a specific new content type, rendering the NOOP ineffective as a mechanism to confuse an observer.",
          "createdAt": "2022-12-06T21:39:24Z",
          "updatedAt": "2022-12-06T21:39:24Z"
        },
        {
          "author": "paulwouters",
          "authorAssociation": "NONE",
          "body": "ok, thanks for the explanation. I guess this will be up to the application layer.",
          "createdAt": "2022-12-07T00:55:55Z",
          "updatedAt": "2022-12-07T00:55:55Z"
        }
      ]
    },
    {
      "number": 777,
      "id": "I_kwDOBoyH6c5YLmhI",
      "title": "Section 17",
      "url": "https://github.com/mlswg/mls-protocol/issues/777",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "discuss",
        "review"
      ],
      "body": "_Comment by @paulwouters_\n\nAlgorithm entries use two octets (65535) but only allow 255 Private Use entries. I think that might be a little low. Maybe allow 0xf000 - 0xffff or something ?\n\n",
      "createdAt": "2022-12-06T15:47:14Z",
      "updatedAt": "2022-12-08T16:06:17Z",
      "closedAt": "2022-12-08T16:06:17Z",
      "comments": [
        {
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "body": "I agree this should be changed. CCing @seanturner, who I believe initially proposed this.",
          "createdAt": "2022-12-06T21:41:11Z",
          "updatedAt": "2022-12-06T21:41:11Z"
        }
      ]
    },
    {
      "number": 778,
      "id": "I_kwDOBoyH6c5YLmhz",
      "title": "Section 17.6",
      "url": "https://github.com/mlswg/mls-protocol/issues/778",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "discuss",
        "review",
        "to close"
      ],
      "body": "_Comment by @paulwouters_\n\n~~~ \nThis document registers the \"message/mls\"\n~~~\nWhy not use \"mls/message\" and keep everything within one namespace?\n\n",
      "createdAt": "2022-12-06T15:47:15Z",
      "updatedAt": "2022-12-08T12:40:45Z",
      "closedAt": "2022-12-08T12:40:45Z",
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Recall that [the way a media type is structured](https://www.rfc-editor.org/rfc/rfc6838) is `<top level type>/<subtype>`.  The intent here is to describe \"a message carrying MLS data\", not \"MLS data carrying a message\".  This deliberately leaves the type of any data carried within the MLS message unspecified, possibly to be described by [some framing layer within the application data](https://datatracker.ietf.org/doc/draft-mahy-mimi-content/).\r\n\r\nPropose closing with no action.",
          "createdAt": "2022-12-06T19:50:17Z",
          "updatedAt": "2022-12-06T19:50:17Z"
        },
        {
          "author": "rohan-wire",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The envisioned use of the `message/mls` media type is to allow another protocol (for example HTTP) to carry an MLS-encoded message (for example a `GroupInfo` object, some `MlsCiphertext`, or a `KeyPackage`). This is quite a popular implementation model.\r\n\r\nFor details of how an `MlsCiphertext` can express the format of an application message it carries, please see [Content Type Advertisement for MLS](https://www.ietf.org/id/draft-mahy-mls-content-adv-00.html).",
          "createdAt": "2022-12-06T23:20:47Z",
          "updatedAt": "2022-12-06T23:20:47Z"
        },
        {
          "author": "paulwouters",
          "authorAssociation": "NONE",
          "body": "Thanks for the clarification. No action needed.",
          "createdAt": "2022-12-07T00:46:45Z",
          "updatedAt": "2022-12-07T00:46:45Z"
        }
      ]
    },
    {
      "number": 779,
      "id": "I_kwDOBoyH6c5YLmix",
      "title": "memberlist unavailble before joining",
      "url": "https://github.com/mlswg/mls-protocol/issues/779",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "comment",
        "review",
        "to close"
      ],
      "body": "_Comment by @paulwouters_\n\n~~~ \n   When a client A wants to establish a group with B and C, it first\n   initializes a group state containing only itself and downloads\n   KeyPackages for B and C.  For each member, A generates an Add and\n   Commit message adding that member, and broadcasts them to the group.\n~~~\nSo if A joins before B, A cannot tell B will become a group member ? eg the fact that A invited B and C is not visible to C or B and might come as a surprise.\n\n",
      "createdAt": "2022-12-06T15:47:17Z",
      "updatedAt": "2022-12-08T12:40:45Z",
      "closedAt": "2022-12-08T12:40:45Z",
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "I'm not sure what you're seeing as missing here.  Everyone has full visibility.  A starts the group and initiates the Adds of B and C.  (Let's assume this is done in two commits, and not one.)  When B joins, they're told that A is in the group, then they learn that A added C via the Commit.  When C joins, they're told that A and B are already here.  If B disagrees with C being in the group (say), they're free to remove C.\r\n\r\nPropose closing with no action.",
          "createdAt": "2022-12-06T22:32:32Z",
          "updatedAt": "2022-12-06T22:32:32Z"
        },
        {
          "author": "rohan-wire",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Also, at the application layer, if you wanted to publish (for example) a moderation policy or a \"list of authorized domains\" policy, or a credential policy and a set of trusted root certificates for validating members of the group, you could do that in a GroupContextExtension so everyone in the group could see it and agree that it was the same. Leaving this out of the base protocol, but having the tools to do this is one of my favorite features of MLS.",
          "createdAt": "2022-12-06T23:59:09Z",
          "updatedAt": "2022-12-06T23:59:09Z"
        },
        {
          "author": "paulwouters",
          "authorAssociation": "NONE",
          "body": "fine with me. thanks",
          "createdAt": "2022-12-07T00:28:34Z",
          "updatedAt": "2022-12-07T00:28:34Z"
        }
      ]
    },
    {
      "number": 780,
      "id": "I_kwDOBoyH6c5YLmjk",
      "title": "Prospective member or member ?",
      "url": "https://github.com/mlswg/mls-protocol/issues/780",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "comment",
        "review"
      ],
      "body": "_Comment by @paulwouters_\n\n~~~ \n   It also generates a Welcome message and sends this directly to the\n  new member\n~~~\nShould this be \"prospective member\" or \"invitee\" ? They haven't joined yet, have they?\n\n",
      "createdAt": "2022-12-06T15:47:18Z",
      "updatedAt": "2022-12-09T13:23:40Z",
      "closedAt": "2022-12-09T13:23:40Z",
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "From the perspective of the group, they are joined.  Once the Commit adding the new member is processed and the new epoch starts, that member is able to access the group's secrets.  The only thing \"provisional\" about the membership is that the new member hasn't initialized their local state.  We use \"new member\" consistently to mean the subject of an Add proposal, and I don't think this is a big enough distinction to merit more terminology.",
          "createdAt": "2022-12-06T22:34:58Z",
          "updatedAt": "2022-12-06T22:34:58Z"
        },
        {
          "author": "rohan-wire",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Another way to look at it is that keying information from the new member is already incorporated into the group, therefore they are a member and not a provisional member.",
          "createdAt": "2022-12-07T00:02:04Z",
          "updatedAt": "2022-12-07T00:02:04Z"
        },
        {
          "author": "paulwouters",
          "authorAssociation": "NONE",
          "body": "Ah yes. Perhaps a single line explaining this at the quoted location could be useful, but is not required",
          "createdAt": "2022-12-07T00:26:52Z",
          "updatedAt": "2022-12-07T00:26:52Z"
        }
      ]
    },
    {
      "number": 781,
      "id": "I_kwDOBoyH6c5YLmkU",
      "title": "\"server\" is ambiguous here",
      "url": "https://github.com/mlswg/mls-protocol/issues/781",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "comment",
        "review"
      ],
      "body": "_Comment by @paulwouters_\n\n~~~ \n   Only after A\n   has received its Commit message back from the server\n~~~\nWhat server? The Delivery Service ?\n\n",
      "createdAt": "2022-12-06T15:47:19Z",
      "updatedAt": "2022-12-09T13:23:40Z",
      "closedAt": "2022-12-09T13:23:40Z",
      "comments": []
    },
    {
      "number": 782,
      "id": "I_kwDOBoyH6c5YL0CN",
      "title": "Section 6.3 use of \"member\"",
      "url": "https://github.com/mlswg/mls-protocol/issues/782",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "duplicate",
        "discuss",
        "review"
      ],
      "body": "_Comment by @paulwouters_\n\n~~~ \n   Each member of a group presents a credential that provides one or\n   more identities for the member,\n~~~\nI am unsure if \"one or more identities for the member\" refers to identies for a single client or was meant as \"a user can have multiple clients\". The way it reads now is that it would be a single client that can have multiple identities. But then could a user have multiple identities on one client that do not match multiple identities on other clients.\n\n",
      "createdAt": "2022-12-06T16:07:42Z",
      "updatedAt": "2022-12-06T16:38:25Z",
      "closedAt": "2022-12-06T16:38:25Z",
      "comments": []
    },
    {
      "number": 783,
      "id": "I_kwDOBoyH6c5YL0DF",
      "title": "ENUMs limited to 1 octet?",
      "url": "https://github.com/mlswg/mls-protocol/issues/783",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "duplicate",
        "discuss",
        "review"
      ],
      "body": "_Comment by @paulwouters_\n\n~~~ \n\u00a0enum {\n       reserved(0),\n       mls10(1),\n       (255)\n   } ProtocolVersion;\n~~~\nWould it really do harm to turn this into two octets? I don't think message size is a real concern here. Same for ContentType and SenderType. Note: thank you for skipping 0 as a valid entry!! Implementers applaud you :)\n\n",
      "createdAt": "2022-12-06T16:07:43Z",
      "updatedAt": "2022-12-06T16:38:26Z",
      "closedAt": "2022-12-06T16:38:26Z",
      "comments": []
    },
    {
      "number": 784,
      "id": "I_kwDOBoyH6c5YL0Dr",
      "title": "Epoch rollover?",
      "url": "https://github.com/mlswg/mls-protocol/issues/784",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "duplicate",
        "discuss",
        "review"
      ],
      "body": "_Comment by @paulwouters_\n\nWhat happens if members maliciously create huge amounts of epochs and it hits 2^64 ?\n\n",
      "createdAt": "2022-12-06T16:07:44Z",
      "updatedAt": "2022-12-06T16:38:26Z",
      "closedAt": "2022-12-06T16:38:26Z",
      "comments": []
    },
    {
      "number": 785,
      "id": "I_kwDOBoyH6c5YL0EL",
      "title": "Padding with zeros",
      "url": "https://github.com/mlswg/mls-protocol/issues/785",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "duplicate",
        "discuss",
        "review"
      ],
      "body": "_Comment by @paulwouters_\n\nWhile I appreciate the zeros only for padding to avoid side channel communications, wouldn't it be too late if the if there were non-zeros in the padding? Since this message could be encrypted to multiple parties in the part of the tree, wouldn't it make sense to send a kind of alert message to everyone? That way, at least two people in the tree couldn't work together ? So instead of \"MUST be rejected as malformed\" do something that MUST send a message to everyone with \"some content warning\" ?\n\n",
      "createdAt": "2022-12-06T16:07:46Z",
      "updatedAt": "2022-12-06T16:38:26Z",
      "closedAt": "2022-12-06T16:38:26Z",
      "comments": []
    },
    {
      "number": 786,
      "id": "I_kwDOBoyH6c5YL0Ew",
      "title": "XOR guard",
      "url": "https://github.com/mlswg/mls-protocol/issues/786",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "duplicate",
        "discuss",
        "review"
      ],
      "body": "_Comment by @paulwouters_\n\nShould there be text saying that if the \"reuse guard\" random returns four zero bytes, it should be run again? Maybe add this to 7.3.2 where MLSSenderData has additional constrains.\n\n",
      "createdAt": "2022-12-06T16:07:47Z",
      "updatedAt": "2022-12-06T16:38:27Z",
      "closedAt": "2022-12-06T16:38:27Z",
      "comments": []
    },
    {
      "number": 787,
      "id": "I_kwDOBoyH6c5YL0FO",
      "title": "KDF.Nh",
      "url": "https://github.com/mlswg/mls-protocol/issues/787",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "duplicate",
        "discuss",
        "review"
      ],
      "body": "_Comment by @paulwouters_\n\n~~~ \n   The key and nonce provided to the AEAD are computed as the KDF of the\n   first KDF.Nh bytes of the ciphertext generated in the previous\n   section.\n~~~\nI don't think I understand the security model here? What happens if the previous ciphertext has 00's for the first KDF.Nh bytes?\n\n",
      "createdAt": "2022-12-06T16:07:48Z",
      "updatedAt": "2022-12-06T16:38:27Z",
      "closedAt": "2022-12-06T16:38:27Z",
      "comments": []
    },
    {
      "number": 788,
      "id": "I_kwDOBoyH6c5YL0F5",
      "title": "Time is not on our side?",
      "url": "https://github.com/mlswg/mls-protocol/issues/788",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "duplicate",
        "discuss",
        "review"
      ],
      "body": "_Comment by @paulwouters_\n\n~~~ \nmeasured in seconds since the Unix epoch (1970-01-01T00:00:00Z)\n~~~\nWhy use a time format that dies in 2038 already? IRC is older than the time given to MLS to survive :P\n\n",
      "createdAt": "2022-12-06T16:07:49Z",
      "updatedAt": "2022-12-06T16:38:27Z",
      "closedAt": "2022-12-06T16:38:27Z",
      "comments": []
    },
    {
      "number": 789,
      "id": "I_kwDOBoyH6c5YL0Gf",
      "title": "lifetime field",
      "url": "https://github.com/mlswg/mls-protocol/issues/789",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "duplicate",
        "discuss",
        "review"
      ],
      "body": "_Comment by @paulwouters_\n\n~~~ \n   it is RECOMMENDED that the\n   client verifies that the current time is within the range of\n   the lifetime field.\n~~~\nWhy RECOMMENDED and not MUST ?\n\n",
      "createdAt": "2022-12-06T16:07:50Z",
      "updatedAt": "2022-12-06T16:38:28Z",
      "closedAt": "2022-12-06T16:38:28Z",
      "comments": []
    },
    {
      "number": 790,
      "id": "I_kwDOBoyH6c5YL0HJ",
      "title": "Section 8.4",
      "url": "https://github.com/mlswg/mls-protocol/issues/790",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "duplicate",
        "discuss",
        "review"
      ],
      "body": "_Comment by @paulwouters_\n\n~~~ \n   path_secret[0] is sampled at random\n~~~\nWhat does this mean? What is sampling? What is the sample used for ?\n\nSimilar in [Section 8.5](https://www.ietf.org/archive/id/draft-ietf-mls-protocol-15.html#section-8.5):\n\n~~~ \nSet the encryption_key to the public key of a freshly sampled key pair\n~~~\n",
      "createdAt": "2022-12-06T16:07:52Z",
      "updatedAt": "2022-12-06T16:38:28Z",
      "closedAt": "2022-12-06T16:38:28Z",
      "comments": []
    },
    {
      "number": 791,
      "id": "I_kwDOBoyH6c5YL0Ht",
      "title": "Section 13/14 Race conditions ?",
      "url": "https://github.com/mlswg/mls-protocol/issues/791",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "duplicate",
        "discuss",
        "review"
      ],
      "body": "_Comment by @paulwouters_\n\nIn [Section 13.4.3.2](https://www.ietf.org/archive/id/draft-ietf-mls-protocol-15.html#section-13.4.3.2), but also elsewhere, I am confused how race conditions are handled. In this section, if two clients try to each add a a new member for an External Commit join, one of them will fail on the epoch being wrong.\n\nIsn't there a similar race with removing? And any other operation that changes the epoch? How are all these race conditions handled?\n\n[Section 14](https://www.ietf.org/archive/id/draft-ietf-mls-protocol-15.html#section-14) does not really clarify this to me.\n\n",
      "createdAt": "2022-12-06T16:07:53Z",
      "updatedAt": "2022-12-06T16:38:28Z",
      "closedAt": "2022-12-06T16:38:28Z",
      "comments": []
    },
    {
      "number": 792,
      "id": "I_kwDOBoyH6c5YL0IX",
      "title": "Section 15.1",
      "url": "https://github.com/mlswg/mls-protocol/issues/792",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "duplicate",
        "discuss",
        "review"
      ],
      "body": "_Comment by @paulwouters_\n\nWhy not at least always pad to a length of like 1000 bytes to avoid some of the very obvious information leaks by length? It would cover most \"single line\" conversation sentences. Maybe a SHOULD pad to a minimum of X ?\n\n",
      "createdAt": "2022-12-06T16:07:54Z",
      "updatedAt": "2022-12-06T16:38:29Z",
      "closedAt": "2022-12-06T16:38:29Z",
      "comments": []
    },
    {
      "number": 793,
      "id": "I_kwDOBoyH6c5YL0I2",
      "title": "NOOPs ?",
      "url": "https://github.com/mlswg/mls-protocol/issues/793",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "duplicate",
        "discuss",
        "review"
      ],
      "body": "_Comment by @paulwouters_\n\nAs stated before, I miss a defined NOOP command that allows for a continuous IPTFS like constant stream of data that would hide better when a member is conversing at all or not.\n\n",
      "createdAt": "2022-12-06T16:07:55Z",
      "updatedAt": "2022-12-06T16:38:29Z",
      "closedAt": "2022-12-06T16:38:29Z",
      "comments": []
    },
    {
      "number": 794,
      "id": "I_kwDOBoyH6c5YL0JU",
      "title": "Section 17",
      "url": "https://github.com/mlswg/mls-protocol/issues/794",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "duplicate",
        "discuss",
        "review"
      ],
      "body": "_Comment by @paulwouters_\n\nAlgorithm entries use two octets (65535) but only allow 255 Private Use entries. I think that might be a little low. Maybe allow 0xf000 - 0xffff or something ?\n\n",
      "createdAt": "2022-12-06T16:07:57Z",
      "updatedAt": "2022-12-06T16:38:29Z",
      "closedAt": "2022-12-06T16:38:29Z",
      "comments": []
    },
    {
      "number": 795,
      "id": "I_kwDOBoyH6c5YL0J6",
      "title": "Section 17.6",
      "url": "https://github.com/mlswg/mls-protocol/issues/795",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "duplicate",
        "discuss",
        "review"
      ],
      "body": "_Comment by @paulwouters_\n\n~~~ \nThis document registers the \"message/mls\"\n~~~\nWhy not use \"mls/message\" and keep everything within one namespace?\n\n",
      "createdAt": "2022-12-06T16:07:58Z",
      "updatedAt": "2022-12-06T16:38:30Z",
      "closedAt": "2022-12-06T16:38:30Z",
      "comments": []
    },
    {
      "number": 796,
      "id": "I_kwDOBoyH6c5YL0Ka",
      "title": "Can?",
      "url": "https://github.com/mlswg/mls-protocol/issues/796",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "comment",
        "review",
        "to close"
      ],
      "body": "_Comment by @paulwouters_\n\n~~~ \n   The set of members\n   involved in the group can change from one epoch to the next\n~~~\nIsn't it the definition of epoch that there is a change in members? Paul: i think members refreshing their keys also means a new epoch?\n\n",
      "createdAt": "2022-12-06T16:07:59Z",
      "updatedAt": "2022-12-08T12:40:45Z",
      "closedAt": "2022-12-08T12:40:45Z",
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Right, if there are no Add or Remove proposals, then the membership does not change.   So you could have say Update or PSK proposals, or no proposals at all (just refresh the committer's leaf).\r\n\r\nPropose closing with no action.",
          "createdAt": "2022-12-06T22:38:03Z",
          "updatedAt": "2022-12-06T22:38:03Z"
        },
        {
          "author": "paulwouters",
          "authorAssociation": "NONE",
          "body": "thanks. yes you can close this one",
          "createdAt": "2022-12-07T00:52:57Z",
          "updatedAt": "2022-12-07T00:52:57Z"
        }
      ]
    },
    {
      "number": 797,
      "id": "I_kwDOBoyH6c5YL0Kz",
      "title": "May implement correctly :-)",
      "url": "https://github.com/mlswg/mls-protocol/issues/797",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "comment",
        "review"
      ],
      "body": "_Comment by @paulwouters_\n\n~~~ \n   An implementation MAY use\n   any tree representation and associated algorithms, as long as they\n   produce correct protocol messages.\n~~~\nThis MAY is super weird. Is it allowed to implement in such a way that they to NOT produce correct protocol messages? :-)\n\nRemove the entire sentence or lowercase the MAY?\n\n",
      "createdAt": "2022-12-06T16:08:00Z",
      "updatedAt": "2022-12-09T13:23:40Z",
      "closedAt": "2022-12-09T13:23:40Z",
      "comments": []
    },
    {
      "number": 798,
      "id": "I_kwDOBoyH6c5YL0Ld",
      "title": "7 or 8 members",
      "url": "https://github.com/mlswg/mls-protocol/issues/798",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "comment",
        "review"
      ],
      "body": "_Comment by @paulwouters_\n\nFigure 10 claims to have seven members, but I count 8, namely Y,T,X,A,B,E,F and G  (not counting W, the root)\n\n",
      "createdAt": "2022-12-06T16:08:01Z",
      "updatedAt": "2022-12-09T13:23:41Z",
      "closedAt": "2022-12-09T13:23:41Z",
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Actually, it only has five!  A, B, E, F, and G.  Recall that members are at the leaves of the tree.",
          "createdAt": "2022-12-06T22:54:55Z",
          "updatedAt": "2022-12-06T22:54:55Z"
        },
        {
          "author": "paulwouters",
          "authorAssociation": "NONE",
          "body": "Ah right :)",
          "createdAt": "2022-12-07T00:52:00Z",
          "updatedAt": "2022-12-07T00:52:00Z"
        }
      ]
    },
    {
      "number": 799,
      "id": "I_kwDOBoyH6c5YL0MC",
      "title": "Setion 8.7 MAY",
      "url": "https://github.com/mlswg/mls-protocol/issues/799",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "comment",
        "review"
      ],
      "body": "_Comment by @paulwouters_\n\n~~~ \n   An implementation MAY use any\n   algorithm that produces the correct tree in its internal\n   representation.\n~~~\nAnother weird MAY here. Again, I would just lowercase it as this is just a pointer to a human decision, not a 2119 based protocol enforcement.\n\n",
      "createdAt": "2022-12-06T16:08:02Z",
      "updatedAt": "2022-12-09T13:23:41Z",
      "closedAt": "2022-12-09T13:23:41Z",
      "comments": []
    },
    {
      "number": 800,
      "id": "I_kwDOBoyH6c5YL0Mq",
      "title": "Section 9.5 MLS Exporter",
      "url": "https://github.com/mlswg/mls-protocol/issues/800",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "comment",
        "review",
        "to close"
      ],
      "body": "_Comment by @paulwouters_\n\nI assume the export is always available to ALL members of the group ? For example for use as PSK to authenticated a TLS video stream?\n\n",
      "createdAt": "2022-12-06T16:08:04Z",
      "updatedAt": "2022-12-08T12:40:46Z",
      "closedAt": "2022-12-08T12:40:46Z",
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Yes, everyone in the group has the `epoch_secret` (by definition), so everyone can compute the `exporter_secret` and any exported values.  For example, this is how the proposed [MLS integration with SFrame](https://datatracker.ietf.org/doc/draft-barnes-sframe-mls/) works.\r\n\r\nPropose closing with no action.",
          "createdAt": "2022-12-06T23:01:14Z",
          "updatedAt": "2022-12-06T23:01:14Z"
        },
        {
          "author": "paulwouters",
          "authorAssociation": "NONE",
          "body": "thanks for the clarification.",
          "createdAt": "2022-12-07T00:49:50Z",
          "updatedAt": "2022-12-07T00:49:50Z"
        }
      ]
    },
    {
      "number": 801,
      "id": "I_kwDOBoyH6c5YL0NN",
      "title": "Section 10.1 encryption size",
      "url": "https://github.com/mlswg/mls-protocol/issues/801",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "comment",
        "review"
      ],
      "body": "_Comment by @paulwouters_\n\n~~~ \nEach key/nonce pair MUST NOT be used to encrypt more than one message.\n~~~\nIsn't there technically also limits to how much one AEAD key and one nonce can be used to encrypt a (very very) large message? I guess this could not happen, but is there some formal message size limit in MLS ? (looking at the vectors at the start, limits could be higher than 2^64 ?)\n\n",
      "createdAt": "2022-12-06T16:08:05Z",
      "updatedAt": "2022-12-09T13:23:42Z",
      "closedAt": "2022-12-09T13:23:42Z",
      "comments": []
    },
    {
      "number": 802,
      "id": "I_kwDOBoyH6c5YL_wG",
      "title": "Time is not on our side?",
      "url": "https://github.com/mlswg/mls-protocol/issues/802",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "duplicate",
        "discuss",
        "review"
      ],
      "body": "_Comment by @paulwouters_\n\n~~~ \nmeasured in seconds since the Unix epoch (1970-01-01T00:00:00Z)\n~~~\nWhy use a time format that dies in 2038 already? IRC is older than the time given to MLS to survive :P\n\n",
      "createdAt": "2022-12-06T16:26:15Z",
      "updatedAt": "2022-12-06T16:38:30Z",
      "closedAt": "2022-12-06T16:38:30Z",
      "comments": []
    },
    {
      "number": 803,
      "id": "I_kwDOBoyH6c5YL_xN",
      "title": "lifetime field",
      "url": "https://github.com/mlswg/mls-protocol/issues/803",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "duplicate",
        "discuss",
        "review"
      ],
      "body": "_Comment by @paulwouters_\n\n~~~ \n   it is RECOMMENDED that the\n   client verifies that the current time is within the range of\n   the lifetime field.\n~~~\nWhy RECOMMENDED and not MUST ?\n\n",
      "createdAt": "2022-12-06T16:26:16Z",
      "updatedAt": "2022-12-06T16:38:30Z",
      "closedAt": "2022-12-06T16:38:30Z",
      "comments": []
    },
    {
      "number": 804,
      "id": "I_kwDOBoyH6c5YL_yF",
      "title": "Section 8.4",
      "url": "https://github.com/mlswg/mls-protocol/issues/804",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "duplicate",
        "discuss",
        "review"
      ],
      "body": "_Comment by @paulwouters_\n\n~~~ \n   path_secret[0] is sampled at random\n~~~\nWhat does this mean? What is sampling? What is the sample used for ?\n\nSimilar in [Section 8.5](https://www.ietf.org/archive/id/draft-ietf-mls-protocol-15.html#section-8.5):\n\n~~~ \nSet the encryption_key to the public key of a freshly sampled key pair\n~~~\n",
      "createdAt": "2022-12-06T16:26:18Z",
      "updatedAt": "2022-12-06T16:38:31Z",
      "closedAt": "2022-12-06T16:38:31Z",
      "comments": []
    },
    {
      "number": 805,
      "id": "I_kwDOBoyH6c5YL_yx",
      "title": "Section 13/14 Race conditions ?",
      "url": "https://github.com/mlswg/mls-protocol/issues/805",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "duplicate",
        "discuss",
        "review"
      ],
      "body": "_Comment by @paulwouters_\n\nIn [Section 13.4.3.2](https://www.ietf.org/archive/id/draft-ietf-mls-protocol-15.html#section-13.4.3.2), but also elsewhere, I am confused how race conditions are handled. In this section, if two clients try to each add a a new member for an External Commit join, one of them will fail on the epoch being wrong.\n\nIsn't there a similar race with removing? And any other operation that changes the epoch? How are all these race conditions handled?\n\n[Section 14](https://www.ietf.org/archive/id/draft-ietf-mls-protocol-15.html#section-14) does not really clarify this to me.\n\n",
      "createdAt": "2022-12-06T16:26:19Z",
      "updatedAt": "2022-12-06T16:38:31Z",
      "closedAt": "2022-12-06T16:38:31Z",
      "comments": []
    },
    {
      "number": 806,
      "id": "I_kwDOBoyH6c5YL_zr",
      "title": "Section 15.1",
      "url": "https://github.com/mlswg/mls-protocol/issues/806",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "duplicate",
        "discuss",
        "review"
      ],
      "body": "_Comment by @paulwouters_\n\nWhy not at least always pad to a length of like 1000 bytes to avoid some of the very obvious information leaks by length? It would cover most \"single line\" conversation sentences. Maybe a SHOULD pad to a minimum of X ?\n\n",
      "createdAt": "2022-12-06T16:26:20Z",
      "updatedAt": "2022-12-06T16:38:32Z",
      "closedAt": "2022-12-06T16:38:32Z",
      "comments": []
    },
    {
      "number": 807,
      "id": "I_kwDOBoyH6c5YL_0q",
      "title": "NOOPs ?",
      "url": "https://github.com/mlswg/mls-protocol/issues/807",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "duplicate",
        "discuss",
        "review"
      ],
      "body": "_Comment by @paulwouters_\n\nAs stated before, I miss a defined NOOP command that allows for a continuous IPTFS like constant stream of data that would hide better when a member is conversing at all or not.\n\n",
      "createdAt": "2022-12-06T16:26:21Z",
      "updatedAt": "2022-12-06T16:38:32Z",
      "closedAt": "2022-12-06T16:38:32Z",
      "comments": []
    },
    {
      "number": 808,
      "id": "I_kwDOBoyH6c5YL_1v",
      "title": "Section 17",
      "url": "https://github.com/mlswg/mls-protocol/issues/808",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "duplicate",
        "discuss",
        "review"
      ],
      "body": "_Comment by @paulwouters_\n\nAlgorithm entries use two octets (65535) but only allow 255 Private Use entries. I think that might be a little low. Maybe allow 0xf000 - 0xffff or something ?\n\n",
      "createdAt": "2022-12-06T16:26:23Z",
      "updatedAt": "2022-12-06T16:38:32Z",
      "closedAt": "2022-12-06T16:38:32Z",
      "comments": []
    },
    {
      "number": 809,
      "id": "I_kwDOBoyH6c5YL_2t",
      "title": "Section 17.6",
      "url": "https://github.com/mlswg/mls-protocol/issues/809",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "duplicate",
        "discuss",
        "review"
      ],
      "body": "_Comment by @paulwouters_\n\n~~~ \nThis document registers the \"message/mls\"\n~~~\nWhy not use \"mls/message\" and keep everything within one namespace?\n\n",
      "createdAt": "2022-12-06T16:26:24Z",
      "updatedAt": "2022-12-06T16:38:33Z",
      "closedAt": "2022-12-06T16:38:33Z",
      "comments": []
    },
    {
      "number": 810,
      "id": "I_kwDOBoyH6c5YL_3v",
      "title": "Section 10.2",
      "url": "https://github.com/mlswg/mls-protocol/issues/810",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "comment",
        "review",
        "to close"
      ],
      "body": "_Comment by @paulwouters_\n\n~~~ \n   Members MAY keep\n   unconsumed values around for some reasonable amount of time to handle\n   out-of-order message delivery.\n~~~\nWhy is this MAY and not SHOULD?\n\n",
      "createdAt": "2022-12-06T16:26:25Z",
      "updatedAt": "2022-12-08T12:40:46Z",
      "closedAt": "2022-12-08T12:40:46Z",
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "It's not an interoperability requirement, it's purely an application consideration.  If the application ensures that there's never a situation where you need old state from MLS, then you don't need to keep old MLS state.  For example, in an application using the proposed [MLS SFrame integration](https://datatracker.ietf.org/doc/draft-barnes-sframe-mls/), the SFrame layer handles out-of-order delivery, and the MLS layer doesn't have to.  And of course, you should delete secrets as quickly as practical.\r\n\r\nPropose closing with no action.",
          "createdAt": "2022-12-06T23:08:26Z",
          "updatedAt": "2022-12-06T23:08:26Z"
        },
        {
          "author": "paulwouters",
          "authorAssociation": "NONE",
          "body": "Ok, but it reads a bit as you \"MAY be reasonable\" instead of you \"SHOULD be reasonable\" :)\r\n\r\nBut it is fine to leave as is if that is the preference.",
          "createdAt": "2022-12-07T00:49:05Z",
          "updatedAt": "2022-12-07T00:49:05Z"
        }
      ]
    },
    {
      "number": 811,
      "id": "I_kwDOBoyH6c5YL_4p",
      "title": "Section 12",
      "url": "https://github.com/mlswg/mls-protocol/issues/811",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "comment",
        "review"
      ],
      "body": "_Comment by @paulwouters_\n\nWhat happens if on the same Delivery Service, two groups with the same group id are created? Why doesn't the protocol split the group id, so one part (prefix) is always created by the DS ?\n\n",
      "createdAt": "2022-12-06T16:26:26Z",
      "updatedAt": "2022-12-09T14:14:48Z",
      "closedAt": "2022-12-09T14:14:48Z",
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "To be clear, just because the specification says \"set by the creator\", that doesn't mean that it is necessarily set by the MLS library.  The creator (including its application logic) can use whatever process they want to to choose the group ID, say asking the DS for one.  I think most applications expect to use group IDs that align with some other application identifier, e.g., a GUID for the application context that the MLS group serves.\r\n\r\nAll that said, the impact of a Group ID collision should be minimal.  The key schedule incorporates all sorts of other things, so even if the groups have the same ID and same membership (even the same leaves in the tree), they will have different epoch secrets.  So the risk of some application-layer confusion would be the main concern, but it's up to the application to sort that out.\r\n\r\nI don't think the requires any action, but cc @TWal for thoughts on how this is reflected in the formal models.",
          "createdAt": "2022-12-06T23:15:32Z",
          "updatedAt": "2022-12-06T23:15:32Z"
        },
        {
          "author": "rohan-wire",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Indeed, in our implementation the (MLS and) Wire client has to create a conversation object with a bunch of application-layer parameters before creating an MLS group. It gets back an MLS Group ID (among other things) which the DS will forward messages to.",
          "createdAt": "2022-12-07T00:11:13Z",
          "updatedAt": "2022-12-07T00:11:13Z"
        },
        {
          "author": "TWal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Guaranteeing group_id uniqueness is also useful for implementation purpose, for example to have a map group_id -> group state.\r\nHopefully some kind of uniqueness is guaranteed in 13.4.3: \"New members MUST verify that group_id is unique among the groups they're currently participating in\".\r\n\r\nAbout the impact on formal models, I don't have a proof for the key schedule (yet). @kkohbrok might understand things better here.\r\nOn the authentication side of things (which I have formalized), the leaf signature + parent-hash says \"I have seen all these subtrees (the subtrees rooted at nodes modified by the last commit of this leaf) in the group with this group_id\".\r\nIf two groups have the same group_id, it means you can take a leaf signature in one group and put it in another group.\r\nI don't think it would help attacking confidentiality though, the group_id plays no part in bootstrapping TreeKEM's invariants.",
          "createdAt": "2022-12-08T10:05:14Z",
          "updatedAt": "2022-12-08T10:05:14Z"
        },
        {
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I don't think we can assume that it's random for our e2ee guarantees and I don't think we have to since we thoroughly include all other group information in the key schedule. So while we have to assume that an adversary can \"replay\" an existing group to a certain degree (by using the same group id), the key schedule will diverge as soon as the group changes in any way.\r\n\r\nAlso flagging @ericcornelissen who I believe has a better understanding of the potential threats than I do.",
          "createdAt": "2022-12-08T11:39:52Z",
          "updatedAt": "2022-12-08T11:39:52Z"
        },
        {
          "author": "ericcornelissen",
          "authorAssociation": "CONTRIBUTOR",
          "body": "From my understanding you're correct @kkohbrok.\r\n\r\nIn slightly more details: our analysis[^1] depends on the [group **context**](https://github.com/mlswg/mls-protocol/blob/438f36e65e5ece3b699af6df1738e1393ee75d14/draft-ietf-mls-protocol.md?rgh-link-date=2022-12-08T22%3A34%3A38Z#group-context) for domain separation only. Since MLS includes the `tree_hash` and `confirmed_transcript_hash` in the group context, the key schedule is guaranteed (assuming collision resistant hashing) to diverge as the group changes. Actually, an application of this idea can be found in #453.\r\n\r\n[^1]: https://eprint.iacr.org/2021/137",
          "createdAt": "2022-12-08T22:34:38Z",
          "updatedAt": "2022-12-08T22:47:44Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks @ericcornelissen.  So it sounds to me like there's no security impact to group ID collisions.  So I think we can close this with no action.",
          "createdAt": "2022-12-08T22:44:39Z",
          "updatedAt": "2022-12-08T22:44:39Z"
        },
        {
          "author": "paulwouters",
          "authorAssociation": "NONE",
          "body": "yes this can be closed.",
          "createdAt": "2022-12-09T13:28:07Z",
          "updatedAt": "2022-12-09T13:28:07Z"
        }
      ]
    },
    {
      "number": 812,
      "id": "I_kwDOBoyH6c5YL_50",
      "title": "Section 13.2",
      "url": "https://github.com/mlswg/mls-protocol/issues/812",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "comment",
        "review",
        "to close"
      ],
      "body": "_Comment by @paulwouters_\n\n~~~ \n   For a regular, i.e. not external, commit the list is invalid if any\n   of the following occurs:\n\n   [...]\n~~~\nWhy not list the requirements instead of what makes it invalid ?\n\n",
      "createdAt": "2022-12-06T16:26:28Z",
      "updatedAt": "2022-12-08T12:40:46Z",
      "closedAt": "2022-12-08T12:40:46Z",
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "The overall vibe here is that the committer has a free hand in choosing which proposals go into a Commit, but there are certain things they can't do.  Thus the negative framing.  But obviously given DeMorgan's law, the two formulations are equivalent.\r\n\r\nIn the spirit of minimizing changes at this late stage, I would propose closing without action.",
          "createdAt": "2022-12-06T23:20:27Z",
          "updatedAt": "2022-12-06T23:20:27Z"
        },
        {
          "author": "rohan-wire",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I got some feedback from our implementors that this language was quite useful. When you are implementing a specific feature set for a deadline, what you are going to send is a small subset of the things that you might receive in the future. Having a negative list like this makes the validation logic clear.\r\n\r\nAlso, the amount of text required to write the corresponding positive list probably runs more than twice as long.",
          "createdAt": "2022-12-07T00:15:44Z",
          "updatedAt": "2022-12-07T00:15:44Z"
        },
        {
          "author": "paulwouters",
          "authorAssociation": "NONE",
          "body": "that's fine with me",
          "createdAt": "2022-12-07T00:20:54Z",
          "updatedAt": "2022-12-07T00:20:54Z"
        }
      ]
    },
    {
      "number": 813,
      "id": "I_kwDOBoyH6c5YL_6t",
      "title": "Discuss metadata privacy",
      "url": "https://github.com/mlswg/mls-protocol/issues/813",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "comment",
        "review"
      ],
      "body": "_Comment by @paulwouters_\n\nThat is quite some information that must be publicly available to allow external Add requests. This leaks information, eg same epoch means the group membership did not change, etc etc. I hope this will appear in the Security Considerations later :)\n\n",
      "createdAt": "2022-12-06T16:26:29Z",
      "updatedAt": "2022-12-14T16:02:11Z",
      "closedAt": "2022-12-14T16:02:11Z",
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "I suppose between this and #779, we should add a subsection to the Security Considerations on metadata privacy.",
          "createdAt": "2022-12-06T23:21:56Z",
          "updatedAt": "2022-12-06T23:21:56Z"
        },
        {
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "body": "I'm not sure #823 actually resolves this?",
          "createdAt": "2022-12-07T22:51:40Z",
          "updatedAt": "2022-12-07T22:51:40Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Oops, that's correct @Bren2010.  Had it in my notes among the others.",
          "createdAt": "2022-12-08T03:34:22Z",
          "updatedAt": "2022-12-08T03:34:22Z"
        }
      ]
    },
    {
      "number": 814,
      "id": "I_kwDOBoyH6c5YL_7p",
      "title": "Section 15.3",
      "url": "https://github.com/mlswg/mls-protocol/issues/814",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "comment",
        "review"
      ],
      "body": "_Comment by @paulwouters_\n\n~~~ \nThis is in addition to ensuring that these nonce and key pairs are promptly\n   deleted when the epoch ends.\n~~~\nThis sentence with a hidden MUST is stuck between a sentence with MAY and a sentence with SHOULD. Perhaps make the MUST explicit ?\n\n",
      "createdAt": "2022-12-06T16:26:30Z",
      "updatedAt": "2022-12-09T13:23:42Z",
      "closedAt": "2022-12-09T13:23:42Z",
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "This is already well covered in the [deletion schedule](https://messaginglayersecurity.rocks/mls-protocol/draft-ietf-mls-protocol.html#name-deletion-schedule) discussion, but I can add a cross-reference.",
          "createdAt": "2022-12-06T23:23:31Z",
          "updatedAt": "2022-12-06T23:23:31Z"
        },
        {
          "author": "paulwouters",
          "authorAssociation": "NONE",
          "body": "I meant just rephase the sentence so it contains \"MUST delete when the epoch ends\"",
          "createdAt": "2022-12-07T00:45:05Z",
          "updatedAt": "2022-12-07T00:45:05Z"
        }
      ]
    },
    {
      "number": 815,
      "id": "I_kwDOBoyH6c5YL_8d",
      "title": "Citations to security analysis",
      "url": "https://github.com/mlswg/mls-protocol/issues/815",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "comment",
        "review"
      ],
      "body": "_Comment by @paulwouters_\n\n~~~ \nthough a complete security analysis is outside of the scope of this document.\n~~~\nHmmm :P\n\n",
      "createdAt": "2022-12-06T16:26:31Z",
      "updatedAt": "2022-12-14T16:02:11Z",
      "closedAt": "2022-12-14T16:02:11Z",
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Cf. RFC 8446\r\n\r\n> Appendix E. Overview of Security Properties\r\n> \r\n>   A complete security analysis of TLS is outside the scope of this document.\r\n\r\nWe could provide some more citations to the analyses that are now in the literature if you think that would help.",
          "createdAt": "2022-12-06T23:26:49Z",
          "updatedAt": "2022-12-06T23:26:49Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "CC @psyoptix @TWal @mulmarta for citations",
          "createdAt": "2022-12-06T23:27:07Z",
          "updatedAt": "2022-12-06T23:27:07Z"
        },
        {
          "author": "rohan-wire",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> Cf. RFC 8446\r\n> \r\n> > Appendix E. Overview of Security Properties\r\n> > A complete security analysis of TLS is outside the scope of this document.\r\n> \r\n> We could provide some more citations to the analyses that are now in the literature if you think that would help.\r\n\r\nThey are also in this architecture document PR:\r\nhttps://github.com/mlswg/mls-architecture/pull/119/files",
          "createdAt": "2022-12-07T00:18:39Z",
          "updatedAt": "2022-12-07T00:18:39Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Oh good, I'll just add a citation over to mls-architecture.",
          "createdAt": "2022-12-07T14:16:47Z",
          "updatedAt": "2022-12-07T14:16:47Z"
        }
      ]
    },
    {
      "number": 816,
      "id": "I_kwDOBoyH6c5YL_9T",
      "title": "Section 16.2",
      "url": "https://github.com/mlswg/mls-protocol/issues/816",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "comment",
        "review",
        "to close"
      ],
      "body": "_Comment by @paulwouters_\n\n~~~ \n   The second form of authentication is that group members can verify a\n   message originated from a particular member of the group.  This is\n   guaranteed by a digital signature on each message from the sender's\n   signature key.\n~~~\nMaybe add a sentence saying this means there is no repudiation of messages?\n\n",
      "createdAt": "2022-12-06T16:26:32Z",
      "updatedAt": "2022-12-08T12:40:47Z",
      "closedAt": "2022-12-08T12:40:47Z",
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "I would prefer not to say anything like that here, because the degree to which signature implies non-repudiation depends on a bunch of context for how the signature keys are managed.  Clearly if you have long term or certified keys, then yes, there's a pretty high degree of non-repudiation.  But people are also interested in configuring MLS to be deniable, e.g., by exchanging signature keys over a deniable channel.\r\n\r\nSo I would propose closing this with no action.",
          "createdAt": "2022-12-06T23:32:06Z",
          "updatedAt": "2022-12-06T23:32:06Z"
        },
        {
          "author": "paulwouters",
          "authorAssociation": "NONE",
          "body": "Ah, that is a very good point. In my head I was thinking signature means proof of key and key is proven to person. But that might certainly not be the case here.",
          "createdAt": "2022-12-07T00:41:31Z",
          "updatedAt": "2022-12-07T00:41:31Z"
        }
      ]
    },
    {
      "number": 817,
      "id": "I_kwDOBoyH6c5YL_-T",
      "title": "Section 17.1",
      "url": "https://github.com/mlswg/mls-protocol/issues/817",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "comment",
        "review"
      ],
      "body": "_Comment by @paulwouters_\n\n~~~ \n   Additionally clients that run predominantly on mobile\n   processors can choose ChaCha20Poly1305 over AES-GCM for performance\n   reasons.\n~~~\nCitation needed? I think most phones have AES(_GCM) in hardware too ? Also compared to HPKE operations and the times for epoch/group reinit, does this performance really matter? (eg waking up from sleep to increment the epoch would make the symmetric encryption cost pretty irrelevant. I would remove this sentence.\n\n",
      "createdAt": "2022-12-06T16:26:34Z",
      "updatedAt": "2022-12-09T13:23:42Z",
      "closedAt": "2022-12-09T13:23:42Z",
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "I'll remove the \"mobile processors\" bit and phrase it a little more evenhandedly (\"can choose ChaCha or GCM\"), but I think it's fair to say that there might be environments where ChaCha/Poly is more performant than AES-GCM.",
          "createdAt": "2022-12-06T23:34:12Z",
          "updatedAt": "2022-12-06T23:34:12Z"
        },
        {
          "author": "paulwouters",
          "authorAssociation": "NONE",
          "body": "Thanks. I do think you might be right that \"there are\", but I also do not think \"mobile\" is that :)",
          "createdAt": "2022-12-07T00:40:15Z",
          "updatedAt": "2022-12-07T00:40:15Z"
        }
      ]
    },
    {
      "number": 818,
      "id": "I_kwDOBoyH6c5YL__J",
      "title": "Section 17.2",
      "url": "https://github.com/mlswg/mls-protocol/issues/818",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "comment",
        "review",
        "to close"
      ],
      "body": "_Comment by @paulwouters_\n\nWhat is the logic to make MLS_128_DHKEMX25519_AES128GCM_SHA256_Ed25519 the only MTI? It contains both FIPS and not FIPS items, pleasing no one.\n\n",
      "createdAt": "2022-12-06T16:26:35Z",
      "updatedAt": "2022-12-08T12:40:47Z",
      "closedAt": "2022-12-08T12:40:47Z",
      "comments": [
        {
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "body": "I remember arguing that the FIPS suite should be MTI at one of the interims. The argument (iirc) was that people that need FIPS are going to implement FIPS anyways, so the MTI should be the one that's subjectively / widely-considered best. \"But then wouldn't a FIPS-only client not conform to the RFC?\" Yes, but the people that require FIPS will not care.",
          "createdAt": "2022-12-06T18:39:48Z",
          "updatedAt": "2022-12-06T18:39:48Z"
        },
        {
          "author": "paulwouters",
          "authorAssociation": "NONE",
          "body": "Well I know from IKEv2/IPsec, that we do take this into account and do ensure there is only FIPS MITM.\r\nI also know we are discussing this in openpgp and also for that reason are adding AES_GCM there.\r\n\r\nSo if the only reasoning is \"FIPS will force people to break RFCs anyway\", that's kinda weak :P",
          "createdAt": "2022-12-06T19:41:26Z",
          "updatedAt": "2022-12-06T19:41:26Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "> ... do ensure there is only FIPS MITM\r\n\r\nYou mean \"MTI\"?  I don't think the MITM folks care about FIPS :)\r\n\r\nI think @Bren2010's summary captures the state of the art pretty well.  Note as well that [X25519 and Ed25519 are slated for inclusion in the relevant FIPS standards](https://csrc.nist.gov/News/2017/Transition-Plans-for-Key-Establishment-Schemes), so this will soon be moot anyway.  (For some government-speed definition of \"soon\".)  So yes, some FIPS folks might be sad in the short run, but things will even out.\r\n\r\nThe working group had a robust discussion on this, and landed on this as a compromise that could get consensus.  I don't think these FIPS concerns are worth upsetting that consensus.",
          "createdAt": "2022-12-06T23:51:16Z",
          "updatedAt": "2022-12-06T23:51:16Z"
        },
        {
          "author": "rohan-wire",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Realistically, most folks using end-to-end encrypted instant messaging today are already using a variation of the DoubleRatchet protocol, using Ed25519. Many of our largest customers normally use FIPS, but have exceptions to use Ed25519 in this context and have no problem using Ed25519 for MLS.",
          "createdAt": "2022-12-07T00:28:41Z",
          "updatedAt": "2022-12-07T00:28:41Z"
        },
        {
          "author": "paulwouters",
          "authorAssociation": "NONE",
          "body": "(yes MTI :)\r\n\r\nThat NIST doc is from 2017, so I\"m not sure what you mean with \"soon\" :)\r\n\r\nI personally think it should be fixed but won't block it. Let's see what the IESG says though :)",
          "createdAt": "2022-12-07T00:36:16Z",
          "updatedAt": "2022-12-07T00:36:16Z"
        }
      ]
    },
    {
      "number": 819,
      "id": "I_kwDOBoyH6c5YMAAE",
      "title": "Nits",
      "url": "https://github.com/mlswg/mls-protocol/issues/819",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "comment",
        "review"
      ],
      "body": "_Comment by @paulwouters_\n\nI personally don't like the _underscored_ words in the html rendering of the document\n\nIt \"blank\" the new American spelling of \"blanc\" ?\n\n~~~ \nhas a corresponding _hash_ that summarizes the contents\n~~~\nI find \"summarizes\" a strange word here. It is not the hash contains a summary one can read.\n\n[SECG] has no IETF equivalent? Should it?\n\nproposaland -> proposal and\n\n~~~ \n           Figure 13: Cleaning up after removing the third member\n~~~\nI would say \"after removing member C\"  (avoid ambiguity about \"every third\")\n\n~~~ \n   This section defines _tree\n   hashes_, and _parent hashes_ are defined in [Section 8.9](https://www.ietf.org/archive/id/draft-ietf-mls-protocol-15.html#section-8.9)\n~~~\nI read this wrong the first way, the \",\" vanishes due to the _unscores_. Maybe: This section defines _tree hashes_, the next section defines _parent hashes_. Or alternatively, leave onlthe the first sentence in 8.8, then put the remainder and next section in two subsections (so 8.8.1 and 8.8.2)\n\n~~~ \nFor example, a malicious group member could send\n~~~\nMaybe: For example, a malicious group member could otherwise send\n\n~~~ \nto previously compromised public keys.\n~~~\nMaybe: to public keys whose private key was previously compromised.\n\n~~~ \nPost-compromise security is also provided for new groups\n~~~\nThis reads a little odd as \"new groups\" would have no history and thus no previous compromise.\n\n",
      "createdAt": "2022-12-06T16:26:36Z",
      "updatedAt": "2022-12-09T13:28:02Z",
      "closedAt": "2022-12-09T13:28:02Z",
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Filed #820 \r\n\r\n> I personally don't like the underscored words in the html rendering of the document\r\n\r\nI think it's important to emphasize the terms being defined, and this seems more readable than a definition list.\r\n\r\n\r\n> > has a corresponding _hash_ that summarizes the contents\r\n>\r\n> I find \"summarizes\" a strange word here. It is not the hash contains a summary one can read.\r\n\r\nNote that a hash function is often called a \"message digest\", in the same sense as the \"Weekly github digest\" that goes to the mailing list.\r\n\r\n\r\n> [SECG] has no IETF equivalent? Should it?\r\n\r\nI think referring to SECG is still pretty state-of-the-art.  But apparently RFC 8446 moved on from that, so I updated to use that representation.\r\n",
          "createdAt": "2022-12-06T18:09:42Z",
          "updatedAt": "2022-12-06T18:09:42Z"
        }
      ]
    },
    {
      "number": 825,
      "id": "I_kwDOBoyH6c5Ygax8",
      "title": "Clarify that AS needs to see both signature key and credential",
      "url": "https://github.com/mlswg/mls-protocol/issues/825",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2022-12-08T15:35:40Z",
      "updatedAt": "2022-12-09T20:14:37Z",
      "closedAt": "2022-12-09T20:14:37Z",
      "comments": []
    },
    {
      "number": 826,
      "id": "I_kwDOBoyH6c5YgmtD",
      "title": "Create an IANA registry for WireFormat values",
      "url": "https://github.com/mlswg/mls-protocol/issues/826",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2022-12-08T16:03:47Z",
      "updatedAt": "2022-12-09T14:33:55Z",
      "closedAt": "2022-12-09T14:33:54Z",
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed by #821 ",
          "createdAt": "2022-12-09T14:33:54Z",
          "updatedAt": "2022-12-09T14:33:54Z"
        }
      ]
    },
    {
      "number": 834,
      "id": "I_kwDOBoyH6c5ZMV9P",
      "title": "Faster remove?",
      "url": "https://github.com/mlswg/mls-protocol/issues/834",
      "state": "CLOSED",
      "author": "TWal",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "When removing a participant, we blank its path up to the root because it might know the private key inside these nodes.\r\nWe actually know precisely which nodes contain private key that are known to this participant: it is nodes for which the participant is not an umerged leaf.\r\n\r\nFrom this remark, we could design an alternative Remove that produces less blank nodes:\r\n- blank all nodes on the path for which the participant is unmerged\r\n- remove the participant from the unmerged leaves list of other nodes\r\n\r\nI think this would preserve the parent-hash invariants, but would need to check more thoroughly.\r\n(the intuition might rely on an invariant that is not checked on unmerged leaves, which is that the set of nodes for which a node is unmerged forms a connected path from the leaf going up [note that this invariant would have been true for free with #752!])\r\n\r\nPros:\r\n- less blank nodes are produced\r\n- removing a participant just after adding it does not change the tree, it's not that useful but it's a pretty property!\r\n\r\nCons:\r\n- the remove definition is more complex\r\n- the optimization isn't great if the participant is merged for most nodes (e.g., it has issued an UpdatePath in the past)\r\n\r\nWhat do you think?",
      "createdAt": "2022-12-14T11:26:43Z",
      "updatedAt": "2022-12-19T15:02:22Z",
      "closedAt": "2022-12-19T15:02:22Z",
      "comments": [
        {
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "It sounds nice and it really sounds like it's secure enough, but I'm not sure it's not a bit too late for this.",
          "createdAt": "2022-12-14T12:58:41Z",
          "updatedAt": "2022-12-14T12:58:41Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "My personal analysis here:\r\n\r\n* If we do Remove like this, we should do Update as well.  It's the same, you just don't remove from `unmerged_leaves`\r\n* On the one hand, this gives some better symmetry to the `unmerged_leaves` calculations and might make things slightly faster\r\n* On the other hand, this is pretty late for a substantive change and I don't expect the performance gain to be huge.\r\n\r\nOverall, I'm more worried about the security analysis than the practicalities.  If @TWal can get his model updated and checked in a timely manner, I would probably take this change.\r\n\r\n(...more detailed notes below this line...)\r\n\r\nPractically speaking, it's a small spec diff.  (Note that we should cover Update here as well, which requires slightly different logic.)\r\n\r\n``` diff\r\n@@ -3599,7 +3599,9 @@ A member of the group applies an Update message by taking the following steps:\r\n \r\n * Replace the sender's LeafNode with the one contained in the Update proposal\r\n \r\n-* Blank the intermediate nodes along the path from the sender's leaf to the root\r\n+* For each intermediate node along the path from the sender's leaf to the root:\r\n+  If the member's leaf node is not listed in the `unmerged_leaves` field of the\r\n+  intermediate node, then blank the intermediate node.\r\n  \r\n@@ -3621,7 +3623,10 @@ A member of the group applies a Remove message by taking the following steps:\r\n \r\n * Replace the leaf node L with a blank node\r\n \r\n-* Blank the intermediate nodes along the path from L to the root\r\n+* For each intermediate node along the path from the sender's leaf to the root:\r\n+    * If the member's leaf node is listed in the `unmerged_leaves` field of the\r\n+      intermediate node, then remove the entry from `unmerged_leaves`.\r\n+    * Otherwise, blank the intermediate node.\r\n```\r\n\r\nI expect the implementation diff will be similarly small, something like:\r\n\r\n``` diff\r\n-def blank_path(self, index):\r\n+def blank_path_if_unmerged(self, index, remove):\r\n   path = self.direct_path(index)\r\n   for node in path:\r\n-    node.set_to_blank()\r\n+    if index in node.unmerged_leaves:\r\n+      if remove:\r\n+        node.unmerged_leaves.remove(index)\r\n+      # else do nothing\r\n+    else:\r\n+      node.set_to_blank()\r\n```",
          "createdAt": "2022-12-14T14:26:12Z",
          "updatedAt": "2022-12-14T14:26:12Z"
        },
        {
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "body": "I think this would introduce a new attack.\r\n\r\nThe unmerged leaves entry effectively becomes a \"do not delete\" marker for parent nodes. An attacker can use this to stay in the tree longer than intended and thus violate the tree invariant. Similar to the attack Joel presented a while back, the attacker can prepare a special tree in the following way:\r\n\r\n - The adds its leaf index to the unmerged leaves list of all of its direct path parent nodes.\r\n - The attacker also updates its parent hash extension (by simulating a fake Commit) so that the new parent hash now covers the updated unmerged leaves lists.\r\n - The attacker presents this new ratchet tree to the victim.\r\n\r\n - The victim joins the group either by Welcome or by External Commit\r\n - When validating the ratchet tree, the victim does not detect the ruse because all parent hash extensions from all leaves in the tree check out.\r\n - The victim (or anyone who joined after the victim) proceeds to remove the attacker from the group.\r\n - While doing so, the victim now only blanks the attacker's leaf node and leaves the attacker's direct path intact because of the markers.\r\n - The attacker is now seemingly removed, but still knows secrets of the ratchet tree.\r\n \r\nThis can possibly be prevented by introducing additional validation for new joiners, but it seems very brittle nonetheless.\r\n\r\nGiven that in a group where updates are frequent, this wouldn't bring much of a performance benefit I would not be inclined to go forward with this. We would need much more analysis and it's a bit late for that.",
          "createdAt": "2022-12-14T15:07:41Z",
          "updatedAt": "2022-12-14T15:07:41Z"
        },
        {
          "author": "TWal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Can you explain the attack more thoroughly with actual tree examples?\r\nI'm having trouble understanding it.",
          "createdAt": "2022-12-14T15:13:01Z",
          "updatedAt": "2022-12-14T15:13:01Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "@raphaelrobert I don't think the attack works as you describe it, or if it does, we need stronger parent hash validation rules regardless of this PR.  Any node that has ever sent a Commit should not be unmerged, so it should be impossible to both have a leaf sign a parent hash chain and appear as unmerged in any of its parents, as happens in your putative tree.\r\n\r\nI agree that some analysis is needed.  The only question is how quickly it can be done.  What I'm wondering is whether some of @TWal's earlier work can be updated.",
          "createdAt": "2022-12-14T15:18:05Z",
          "updatedAt": "2022-12-14T15:18:14Z"
        },
        {
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "body": "@bifurcation Yes, stronger validation rules are needed. Right now what you describe is not enforced, hence my qualification as an attack. I also agree that these rules could be added regardless. ",
          "createdAt": "2022-12-14T15:20:30Z",
          "updatedAt": "2022-12-14T15:20:30Z"
        },
        {
          "author": "TWal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I don't understand why we need stronger validation rules.\r\nWhen joining a group, invariants are checked on the tree, like the well-formedness of unmerged leaves or the validity of parent-hashes.\r\nA tree with these invariants is then secure: the signature of the leaf parent-hash-linked to a node covers the whole subtree at the time of signing, which forbids the old double-join attacks. You can't break TreeKEM's invariants without breaking the parent-hash invariants.\r\n\r\nTherefore I think we just need to prove that the new Remove preserves the MLS invariants (unmerged leaves are well-formed + every node is parent-hash linked to a node below it). If that is true, I can update my formal proofs quickly I think.",
          "createdAt": "2022-12-14T15:27:26Z",
          "updatedAt": "2022-12-14T15:27:26Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "@TWal As I understand what @raphaelrobert  is proposing, the idea is that the attacker A prepares a tree of the following form, where:\r\n\r\n* [A] indicates A is unmerged\r\n* But A knows Q and R\r\n* A's leaf signs a parent hash chain (A -> Q -> R)\r\n* B need not be aware any of this is going on\r\n\r\nIn other words, it's like A added C to (A, B) in a full Commit, but with A also marked as unmerged at Q and R.\r\n\r\n```\r\n      R[A]\r\n    __|__\r\n   /     \\\r\n  Q[A]    _\r\n / \\     / \\\r\nA   B   C   _\r\n```\r\n\r\nA sends this tree to C in a Welcome.  If C subsequently tries to remove A, then according to this PR, you would end up with the following tree:\r\n\r\n```\r\n      R'\r\n    __|__\r\n   /     \\\r\n  Q       _\r\n / \\     / \\\r\n_   B   C   _\r\n```\r\n\r\nSince the attacker A knows Q, and C encrypted the path secret for R' to Q, A still knows the group secrets.\r\n",
          "createdAt": "2022-12-14T15:31:28Z",
          "updatedAt": "2022-12-14T15:31:28Z"
        },
        {
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "body": "Right now we have the following validation rules in the spec:\r\n\r\n---\r\n\r\n - Verify the integrity of the ratchet tree.\r\n - Verify that the tree hash of the ratchet tree matches the tree_hash field in GroupInfo.\r\n - For each non-empty parent node, verify that it is \"parent-hash valid\", as described in [Section 7.9.2](https://messaginglayersecurity.rocks/mls-protocol/draft-ietf-mls-protocol.html#verifying-parent-hashes).\r\n - For each non-empty leaf node, validate the LeafNode as described in [Section 7.3](https://messaginglayersecurity.rocks/mls-protocol/draft-ietf-mls-protocol.html#leaf-node-validation).\r\n - For each non-empty parent node, verify that each entry in the node's unmerged_leaves represents a non-blank leaf node that is a descendant of the parent node.\r\n\r\n---\r\n\r\nOnly the last rule concerns the unmerged leaves. That rule is not enough to prevent an attacker who is a regular member of the tree to add its leaf index to the unmerged leaves list of all the parent nodes in its direct path.",
          "createdAt": "2022-12-14T15:32:01Z",
          "updatedAt": "2022-12-14T15:32:01Z"
        },
        {
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "body": "@bifurcation Thanks for the illustration, that's exactly what I had in mind.",
          "createdAt": "2022-12-14T15:32:49Z",
          "updatedAt": "2022-12-14T15:32:49Z"
        },
        {
          "author": "TWal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "For D to be parent-hash-linked to P (with child C), there is the following rule:\r\n```\r\nD is in the resolution of C, and the intersection of P's unmerged_leaves with the subtree under C is equal to the resolution of C with D removed.\r\n```\r\n\r\nWith D = C = A and P = Q, the intersection of P's unmerged leaves with the subtree under C is [A], and the resolution of C with D removed is [].\r\nTherefore the tree will be rejected by the participant processing the Welcome.",
          "createdAt": "2022-12-14T15:44:13Z",
          "updatedAt": "2022-12-14T15:44:13Z"
        },
        {
          "author": "TWal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Note that it is similar to the example 2 of #713, and that parent-hash was modified to prevent these kind of modifications.",
          "createdAt": "2022-12-14T15:46:30Z",
          "updatedAt": "2022-12-14T15:46:30Z"
        },
        {
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "body": "@TWal It looks like the parent hash verification rule you mention does indeed prevent the attack. Given how unintuitive that rule is I a) missed it and b) I cannot say if it prevents the attack in all scenarios (although my intuition is it does). So it really comes down to proofs at this point.",
          "createdAt": "2022-12-14T16:21:43Z",
          "updatedAt": "2022-12-14T16:21:43Z"
        },
        {
          "author": "TWal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The rule is a ninja equation designed by @bifurcation in #713. I agree that it is not easy to understand!\r\nIt captures two facts:\r\n- D and P were updated at the same time, and their unmerged leaves is coherent with this fact: `D.unmerged_leaves = Intersection(P.unmerged_leaves, Subtree(D))`\r\n- the nodes between D and P were filtered, hence they are blank, and the co-path subtree are mostly empty (they might contain unmerged leaves of P)\r\n\r\nFrom this we can prove the strong guarantees discussed in #713 and #731.",
          "createdAt": "2022-12-14T16:57:52Z",
          "updatedAt": "2022-12-14T16:57:52Z"
        },
        {
          "author": "TWal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Note: if you look at the revised parent-hash link conditions in #752, it's much easier to understand why the attack doesn't work: it's the condition `LastUpdateEpoch(P) = LastUpdateEpoch(D)` which will be broken.",
          "createdAt": "2022-12-14T17:08:58Z",
          "updatedAt": "2022-12-14T17:08:58Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "I thought I had an attack case, based on the following tree (`*` = parent hash link, B malicioiusly added the `[B]` entries), but the original sibling tree hash stopped it.\r\n\r\n```\r\n              T[B]\r\n        ______|______\r\n      */             \\\r\n      R[B]            _\r\n    __|__           __|__\r\n   /     \\*        /     \\\r\n  Q       S       _       _\r\n / \\*   */ \\     / \\     / \\ \r\nA   B   C   D   E   F   _   _\r\n```\r\n\r\nWhich points toward a simple, intuitive argument for why this proposal is OK:\r\n\r\n**Claim:** Given an honestly constructed tree, a malicious group member can't modify it to add themselves to unmerged_leaves for a node whose private key they know\r\n\r\n**Proof:**\r\n* If they know the private key because they set it, you can't be unmerged in it because [the parent-hash chaining rules forbid it](https://github.com/mlswg/mls-protocol/pull/835#discussion_r1048719223)\r\n* If they know the private key because the received it from someone else, then their leaf is covered by the original sibling subtree hash.  If they add themselves to unmerged_leaves, they'll be removed from the original sibling tree, and that hash will be invalid.",
          "createdAt": "2022-12-14T18:23:21Z",
          "updatedAt": "2022-12-14T18:23:21Z"
        },
        {
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "body": "@TWal Is the F* spec in mls-proposal up-to-date enough so that I can double check how things currently work there? Or did you ninja this by hand :D ? ",
          "createdAt": "2022-12-14T18:29:19Z",
          "updatedAt": "2022-12-14T18:29:19Z"
        },
        {
          "author": "TWal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@beurdouche the parent-hash link invariant is defined [here](https://github.com/Inria-Prosecco/treesync/blob/main/mls-star/fstar/treesync/code/MLS.TreeSync.Invariants.ParentHash.fst) and the parent hash guarantees theorem is proved [here](https://github.com/Inria-Prosecco/treesync/blob/main/mls-star/fstar/treesync/proofs/MLS.TreeSync.Proofs.ParentHashGuarantees.fst), and Richard found the ninja equation [here](https://github.com/mlswg/mls-protocol/pull/713#issuecomment-1146288574) if that's what you're asking for!\r\n\r\n@bifurcation I don't understand why you closed the issue as completed?\r\n\r\nThe proof goes as follows.\r\n\r\nFrom the parent hash guarantees, we know that the signature covers all the subtree it the participant modified, at the time of their last modification (we name them the \"original subtrees\").\r\nWhen a private key is generated for a node, the participant generating it:\r\n- send it to the leaves in the corresponding subtree\r\n- signs the corresponding subtree (via parent-hash)\r\n\r\nNote that in every subtree signature (via parent-hash), there is the property that the private hpke key of the node is known only by the leaves of that subtree.\r\n\r\nWhen you receive tree, you check every signature and compute every original subtree, and get back the property that the private hpke key of each node is known only to leaves in its original subtree.\r\n\r\nTherefore, if you have an attack, it means you found a way to break the invariants checked when joining a group.\r\nIt might be the case that the new Remove does break the invariants and we would need to strengthen them (as tried in #835), but my feeling is that it should work fine without additional invariants.\r\nI'll check in the next days and keep you up-to-date!",
          "createdAt": "2022-12-14T21:27:17Z",
          "updatedAt": "2022-12-14T21:27:17Z"
        },
        {
          "author": "TWal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thinking about an actual proof, I find that it does break the invariants:\r\n\r\nSuppose we start with the following tree (which is valid, although we can't get it with normal operations)\r\n```\r\n      Y[C]   \r\n    __|__    \r\n  */     \\   \r\n  X       Z  \r\n / \\*    / \\*\r\nA   B   C   D\r\n```\r\n\r\nRemoving C makes:\r\n```\r\n      Y\r\n    __|__    \r\n  */     \\   \r\n  X       _  \r\n / \\*    / \\\r\nA   B   _   D\r\n```\r\n\r\nIt breaks the parent-hash link X -> Y, because the original sibling tree hash is not the same.\r\n\r\nIn practice, it's not possible to have the situation with C unmerged for Y but not for Z, but it's not an invariant checked when joining a group, so we can't rely on it\u2026\r\nNote that this invariant is guaranteed for free with the unmerged leaves defined as in #752 :)",
          "createdAt": "2022-12-15T11:24:21Z",
          "updatedAt": "2022-12-15T11:24:21Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "I'm sorry, I hit the wrong button when commenting!",
          "createdAt": "2022-12-15T14:43:03Z",
          "updatedAt": "2022-12-15T14:43:03Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "It's concerning that we have trees that are valid according to the validation rules but can't be produced by normal operations.  It seems like that calls for more validation.\r\n\r\nI noticed as I was looking at this yesterday that I don't think we are validating two (equivalent) properties that are true for every real case of an unmerged leaf:\r\n\r\n* If X is unmerged at P, then it is unmerged at every node below P (P's descendants)\r\n* If X is not unmerged at P, then it is not unmerged at every node above P (P's ancestors)\r\n\r\nMore generally, I wonder if there's a connection here, that unmerged Remove is safe if and only if the tree validation rules prevent trees that could not have arisen naturally.\r\n\r\nI would argue that we should fix the latter issue anyway.  I filed #837 for this.\r\n\r\n\r\n",
          "createdAt": "2022-12-15T15:28:34Z",
          "updatedAt": "2022-12-15T15:28:34Z"
        },
        {
          "author": "rohan-wire",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Hi, I don't think this optimization is worth it. At least in the IM use case, I see lots of problems anytime there is a build-up of unmerged leaves. I see unmerged leaves as a transient situation that should not be encouraged nor optimized.",
          "createdAt": "2022-12-16T02:47:27Z",
          "updatedAt": "2022-12-16T02:47:27Z"
        },
        {
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The optimization does seem elegant, but at the very least this change should be brought to the list. In particular, I'd love to hear @MartaMularczyk's and @psyoptix' opinion on this from a provable security perspective before we consider merging this into the spec.",
          "createdAt": "2022-12-16T07:48:03Z",
          "updatedAt": "2022-12-16T07:48:03Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "After discussion at the interim 2022-12-16, there was agreement that this change is not worth making.",
          "createdAt": "2022-12-19T15:02:09Z",
          "updatedAt": "2022-12-19T15:02:09Z"
        }
      ]
    },
    {
      "number": 840,
      "id": "I_kwDOBoyH6c5ZVre5",
      "title": "IANA considerations for signature labels?",
      "url": "https://github.com/mlswg/mls-protocol/issues/840",
      "state": "CLOSED",
      "author": "TWal",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "The `Label` of `SignWithLabel` absolutely needs to be unique for every signature happening in the protocol, for security and avoid signature ambiguity.\r\nThat includes signatures happening in extensions.\r\n\r\nShould this be referenced in a IANA considerations to ensure there is no conflict in the future? Or at least say something about this somewhere?\r\n\r\nWe have to think how to design things well here to be future-proof: the `SignContent` structure must be used for every signature done with the leaf signature keys, which includes what might happen in extensions but also in future versions of MLS.\r\nIf future versions of MLS could avoid doing [what TLS 1.3 did to dis-ambiguate signatures with TLS 1.2](https://www.rfc-editor.org/rfc/rfc8446.html#section-4.4.3), that would be great!",
      "createdAt": "2022-12-15T17:53:30Z",
      "updatedAt": "2022-12-16T17:04:27Z",
      "closedAt": "2022-12-16T17:04:27Z",
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "This seems to come down to whether we expect the signature keys used for MLS authentication to be used outside of MLS (otherwise there's no risk of confusion) and if so, whether this spec has any influence on that usage. If you're using your MLS key to sign Bitcoin transactions, we can't do much to help that.  \r\n\r\nNote that there is not an issue for future version of MLS here.  The label is constructed as `\"MLS 1.0 \" + Label`, so a future version could just increment the `1.0` part of that.\r\n\r\nGiven all that, I might prefer a recommendation that signature keys not be reused across contexts, rather than trying to accommodate reuse.\r\n\r\nIf we do something here, we should do something analogous to the [TLS exporter labels](https://www.iana.org/assignments/tls-parameters/tls-parameters.xhtml#exporter-labels) registry, which are similarly intended for domain separation between different use cases.  We should probably consider making an exporter label registry anyway.",
          "createdAt": "2022-12-15T23:05:04Z",
          "updatedAt": "2022-12-15T23:05:04Z"
        },
        {
          "author": "TWal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I agree, we shouldn't do anything about someone using the MLS signature key in another protocol.\r\n\r\nAbout future MLS versions: I agree, but note that there is a length tag before that.\r\nIt means that we impose to all signature of future MLS versions to start with `opaque label<V>;` (including the quic integer)\r\nIs it something acceptable or not, I don't now. I just think we should have in mind that the decisions we make now on `SignContent` will have an impact on the design of future MLS versions.\r\n\r\nAbout extensions: in the extensions document, there is a signature computed with `SignWithLabel(\u2026, \"TargetedMessageTBS\", \u2026)`\r\nIf two extensions were to use the same label then this could lead to security problems, this is why I think the labels should be in some registry to ensure they are all unique.\r\nOne other thing we could do is to separate all extensions signatures from the core MLS signatures, for exemple using the label \"MLS 1.0 extension [label from extension]\"? Like that a bogus extension can't introduce a security flaw in core MLS that way?",
          "createdAt": "2022-12-16T12:03:50Z",
          "updatedAt": "2022-12-16T12:03:50Z"
        }
      ]
    },
    {
      "number": 846,
      "id": "I_kwDOBoyH6c5adXIR",
      "title": "Change log missing for -16 and -17",
      "url": "https://github.com/mlswg/mls-protocol/issues/846",
      "state": "CLOSED",
      "author": "rohan-wire",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2023-01-03T16:38:37Z",
      "updatedAt": "2023-03-13T18:38:14Z",
      "closedAt": "2023-03-13T18:38:13Z",
      "comments": []
    },
    {
      "number": 856,
      "id": "I_kwDOBoyH6c5eGHtj",
      "title": "Consider greasing your registries",
      "url": "https://github.com/mlswg/mls-protocol/issues/856",
      "state": "CLOSED",
      "author": "DavidSchinazi",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "(First off, I know that I'm super late in the process so feel free to tell me to go away and I'll do that.)\r\n\r\nI see that MLS is creating [8 new IANA registries](https://www.ietf.org/archive/id/draft-ietf-mls-protocol-17.html#section-17). I think it would benefit the protocol to reserve a few codepoints from all of these registries for [GREASE](https://www.rfc-editor.org/rfc/rfc8701.html). That'll help avoid ossification down the line.",
      "createdAt": "2023-02-09T21:46:24Z",
      "updatedAt": "2023-03-12T17:59:21Z",
      "closedAt": "2023-03-12T17:59:21Z",
      "comments": [
        {
          "author": "rohan-wire",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@DavidSchinazi \r\nHow would this work in MLS. In GREASE the client proposes values to a server (which the server should never support). The client is expected to propose these values and also reject them. This works fine because clients don't talk to clients.\r\n\r\nIn MLS, clients send messages directly to other clients, and create groups based on capabilities advertised in KeyPackages. How would you prevent a \"dummy\" ciphersuite or version number from being used in an MLS group?",
          "createdAt": "2023-02-13T18:09:29Z",
          "updatedAt": "2023-02-13T18:09:29Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The GREASE RFC is specific to TLS where extensions are client-initiated, but the concept applies anywhere and is not specific to client-server protocols. To support GREASE, all we need is:\r\n* reserve some codepoints in the IANA registry to avoid future collisions\r\n* when sender sends its list of supported values, it randomly adds a value from the GREASE set\r\n* no changes are made on the receiver\r\n\r\nBecause of this, the receivers will ignore the GREASE codepoints and there is no risk of negotiating them. Another way to say this is: don't implement GREASE by adding the codepoints to your supported set, instead only add a random one from your send serialization code.",
          "createdAt": "2023-02-13T19:49:39Z",
          "updatedAt": "2023-02-13T19:49:39Z"
        },
        {
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "body": "Some thoughts:\r\n\r\nI think we expect many/most MLS deployments to be single-party, where the same organization controls the client and server software. As such, GREASE has less value than in a TLS context, because if that organization wants to exercise a new extension point they can easily correct any errors in their software that would prevent them from doing so. MLS is also expected to be layered on top of an encrypted transport protocol, which prevents third-party meddling to begin with.\r\n\r\nOn a more philosophical note -- If GREASE is supposed to prevent poorly maintained client software or middleware from breaking the protocol when extension points are exercised that they don't understand, then does it really still work if GREASE is a core part of the protocol? If the semantic of some field in the protocol is that unexpected values should be ignored, it seems just as easy for a negligent engineer to write the code \"break if there's something besides X, Y, or Z\" as it is to write \"break if there's something besides X, Y, Z, or one of the GREASE codepoints\". Correspondingly, I'm not sure that we have historical validation from TLS that GREASE works.",
          "createdAt": "2023-02-14T01:38:53Z",
          "updatedAt": "2023-02-14T01:38:53Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "We have some solid validation from HTTP that grease works. In both HTTP/2 and HTTP/3, receivers are supposed to ignore unknown frames. HTTP/2 was launched without grease, and trying to use extensions caused enough breakage that they had to be removed. HTTP/3 launched with grease, and a few implementations send random data, so broken servers were found and fixed before they got prevalent.\r\n\r\nRegarding the philosophical point, grease isn't meant to avoid malicious implementors - you can always write code that looks at grease. Grease is meant to avoid lazy implementors, of which we have solid existence proofs.",
          "createdAt": "2023-02-14T02:19:24Z",
          "updatedAt": "2023-02-14T02:19:24Z"
        },
        {
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "body": "Right, I wasn't thinking of malicious implementors, just negligent ones. There are places where the \"receiver\" portion of an MLS client does need to be aware of GREASE. These immediately come to mind:\r\n\r\n1. A `RequiredCapabilities` extension shouldn't be allowed to contain GREASE codepoints even though all members may \"support\" that codepoint\r\n2. Proposal types that are GREASE shouldn't be allowed to be sent even though all members may \"support\" that proposal type\r\n3. GREASE codepoints shouldn't be considered when deciding whether a group uses the \"best\" version & ciphersuite for all members, as one of these codepoints may naively look \"better\" than a real one\r\n\r\nThese would all seem to carry the risk of accidentally writing the code I said earlier, \"break if there's something besides X, Y, Z, or one of the GREASE codepoints\" because GREASE is being intentionally excluded before those other checks happen.\r\n\r\nFwiw, I'm not against this idea, I'm just not sure of the right way to translate it to MLS.",
          "createdAt": "2023-02-14T06:55:35Z",
          "updatedAt": "2023-02-14T06:55:35Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "That's not right, the whole point of grease is for it to not modify receiver code. No one ever \"supports\" grease code points, they just randomly send them. Since receiving an unknown value in `RequiredCapabilities` would break a group, then we definitely should not send grease in that scenario. Determining the \"best\" version/ciphersuite/etc requires first making the intersection set of supported versions, and grease would never be in that set since no one \"supports\" grease code points.",
          "createdAt": "2023-02-14T16:24:54Z",
          "updatedAt": "2023-02-14T16:24:54Z"
        },
        {
          "author": "rohan-wire",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> That's not right, the whole point of grease is for it to not modify receiver code. No one ever \"supports\" grease code points, they just randomly send them. Since receiving an unknown value in `RequiredCapabilities` would break a group, then we definitely should not send grease in that scenario. Determining the \"best\" version/ciphersuite/etc requires first making the intersection set of supported versions, and grease would never be in that set since no one \"supports\" grease code points.\r\n\r\nIf that is the case, then it seems you have eliminated all the places you might have used GREASE. I don't there is an obvious translation because MLS is fundamentally a clients-to-clients protocol instead of a client-to-server protocol.",
          "createdAt": "2023-02-15T21:17:10Z",
          "updatedAt": "2023-02-15T21:17:10Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Grease isn't about clients or servers, it's about senders and receivers - which MLS has. When a clients sends its capabilities, it can for example grease the list of cipher suites - that won't break a group because receivers ignore cipher suites they don't support.",
          "createdAt": "2023-02-15T22:31:32Z",
          "updatedAt": "2023-02-15T22:31:32Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Another way to think about this: you can (and should) grease anything where recipients ignore unknown/unrecognized values. So for MLS, I'd base the list off of this text: `A client initiating a group MUST ignore all unrecognized ciphersuites, extensions, and other parameters. Otherwise, it may fail to interoperate with newer clients.`",
          "createdAt": "2023-02-15T23:15:19Z",
          "updatedAt": "2023-02-15T23:15:32Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Just to make this a little more concrete, I think that this is the text we would want GREASE around:\r\n\r\n> A client initiating a group MUST ignore all unrecognized ciphersuites, extensions, and other parameters\r\n\r\nSo a PR would basically do the following:\r\n\r\n* Register GREASE values for ciphersuites, extension types, proposal types, credential types\r\n* Recommend that clients include a random selection of GREASE values in:\r\n    * The `ciphersuites`, `extensions`, `proposals`, and `credentials` fields of `Capabilities`\r\n    * The `extensions` fields of `KeyPackage` and `GroupInfo` (which are effectively ephemeral), with random extension data",
          "createdAt": "2023-02-27T22:33:05Z",
          "updatedAt": "2023-02-27T22:33:05Z"
        }
      ]
    },
    {
      "number": 860,
      "id": "I_kwDOBoyH6c5eMo3C",
      "title": "Loosen chain requirements",
      "url": "https://github.com/mlswg/mls-protocol/issues/860",
      "state": "CLOSED",
      "author": "ekr",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "> For an X.509 credential, each entry in the chain represents a single DER-encoded X.509 certificate. The chain is ordered such that the first entry (chain[0]) is the end-entity certificate and each subsequent certificate in the chain MUST be the issuer of the previous certificate. The public key encoded in the subjectPublicKeyInfo of the end-entity certificate MUST be identical to the signature_key in the LeafNode containing this credential.\r\n\r\nI'm sorry I missed this previously, but this requirement was a source of trouble in TLS and was removed in RFC 8446, which allows extra certificates in the middle. Was there a conscious decision to be more strict here.",
      "createdAt": "2023-02-10T21:40:24Z",
      "updatedAt": "2023-03-07T17:53:56Z",
      "closedAt": "2023-03-07T17:53:56Z",
      "comments": [
        {
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "body": "I don't recall this ever being discussed. I think it was just added and nobody ever objected.",
          "createdAt": "2023-02-10T22:42:58Z",
          "updatedAt": "2023-02-10T22:42:58Z"
        },
        {
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@ekr can you elaborate a little bit? The way I read it the requirement is just that there is a valid signature chain, i.e. that one certificate signs the next and so on.",
          "createdAt": "2023-02-11T14:13:26Z",
          "updatedAt": "2023-02-11T14:13:26Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "@ekr - I deliberately reverted to the original TLS level of strictness here, in hopes that in starting over with a new ecosystem we could reset things to a cleaner state.  Do you think there are legitimate reasons for violating the strict rule, or is it just a common misconfiguration in TLS servers?  I would not really be inclined to accommodate the latter.\r\n\r\n@kkohbrok - I believe what @ekr is envisioning are cases where there are multiple valid chains, say via old and new versions of an intermediate certificate.  So you might do something like provide a \"chain\" of the form (leaf, old_intermediate, new_intermediate), with the idea that the client could verify using whichever one makes it happy.",
          "createdAt": "2023-02-11T15:51:16Z",
          "updatedAt": "2023-02-11T15:51:16Z"
        },
        {
          "author": "tomleavy",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@bifurcation take a look at the comment I left on the PR. I can see your point about starting over as being valid, but one thing that also caught my eye in the TLS RFC was language around allowing a root CA to be left out of the chain since those could potentially already exist in a local trust store. ",
          "createdAt": "2023-02-11T16:48:46Z",
          "updatedAt": "2023-02-11T16:49:13Z"
        },
        {
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I see. Thanks @bifurcation for the clarification. Maybe we can phrase it in such a way that whatever the credential includes (added intermediary certificates or left-out root certificates) in the end the local client MUST be able to create a continuous certificate chain from the leaf to the root. Do we need to define how the client does that? Since we're already pushing everything else related to authentication into the AS, I'm inclined to say no.",
          "createdAt": "2023-02-13T06:56:15Z",
          "updatedAt": "2023-02-13T06:56:15Z"
        }
      ]
    },
    {
      "number": 880,
      "id": "I_kwDOBoyH6c5n8PdC",
      "title": "Figure 14: \"Derivation of ratchet tree keys along a direct path\" don't correspond to the prose",
      "url": "https://github.com/mlswg/mls-protocol/issues/880",
      "state": "CLOSED",
      "author": "TWal",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "In the diagram, it looks like `path_secret[0]` and the leaf node's public/private keys are generated from `leaf_secret`.\r\nHowever this is not what the prose says: \"`path_secret[0]` is sampled at random\" and \"Generate a fresh HPKE key pair for the leaf\".\r\n\r\nLooks like it's an artifact from past versions of MLS?",
      "createdAt": "2023-06-06T13:11:06Z",
      "updatedAt": "2023-07-18T14:20:42Z",
      "closedAt": "2023-07-18T14:20:41Z",
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed in #883 ",
          "createdAt": "2023-07-18T14:20:41Z",
          "updatedAt": "2023-07-18T14:20:41Z"
        }
      ]
    },
    {
      "number": 881,
      "id": "I_kwDOBoyH6c5oG1Dj",
      "title": "Minor problem in transcript hash message formats",
      "url": "https://github.com/mlswg/mls-protocol/issues/881",
      "state": "CLOSED",
      "author": "TWal",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "tl;dr: I noticed something a bit inconvenient while working on security proofs, it does not require a change because we can get around the problem and we are so late in the standardization process, but I figured out I would not keep my discovery for myself in case it bothers other people.\r\n\r\n# The problem\r\n\r\nWhile working on my MLS security proofs, I realized that the transcript hash message formats were a bit problematic.\r\n\r\n```\r\nconfirmed_transcript_hash_[0] = \"\"; /* zero-length octet string */\r\ninterim_transcript_hash_[0] = \"\"; /* zero-length octet string */\r\n\r\nconfirmed_transcript_hash_[epoch] =\r\n    Hash(interim_transcript_hash_[epoch - 1] ||\r\n        ConfirmedTranscriptHashInput_[epoch]);\r\n\r\ninterim_transcript_hash_[epoch] =\r\n    Hash(confirmed_transcript_hash_[epoch] ||\r\n        InterimTranscriptHashInput_[epoch]);\r\n```\r\n\r\nLet's look at the problem on `interim_transcript_hash`. To reduce transcript hash collision to a hash collision, we need non-ambiguity of the hash input message format: for each bytestring given as input to the hash (i.e. `confirmed_transcript_hash_[epoch] || InterimTranscriptHashInput_[epoch]`), it corresponds to a unique pair `(confirmed_transcript_hash, InterimTranscriptHashInput)`.\r\nIt would be fine if `confirmed_transcript_hash` always had the same length, the hash input would be non-ambiguous.\r\nHowever, it is not the case, with the special case `confirmed_transcript_hash_[0] = \"\"`, whose length is then differing.\r\nThe same problem happens with `confirmed_transcript_hash` whose hash input is ambiguous.\r\n\r\nTo make this more concrete, if `InterimTranscriptHashInput_[0] = confirmed_transcript_hash_[epoch] || InterimTranscriptHashInput_[epoch]`, then `interim_transcript_hash_[0] = interim_transcript_hash_[epoch]`, which is problematic.\r\n\r\n# It's not that bad\r\n\r\nWe can note that `interim_transcript_hash_[0]` is never used. Indeed, the group initialization says:\r\n\r\n- Derive the confirmation_key for the epoch as described in [Section 8](https://messaginglayersecurity.rocks/mls-protocol/draft-ietf-mls-protocol.html#key-schedule).\r\n- Compute a confirmation_tag over the empty confirmed_transcript_hash using the confirmation_key as described in [Section 6.1](https://messaginglayersecurity.rocks/mls-protocol/draft-ietf-mls-protocol.html#content-authentication).\r\n- Compute the updated interim_transcript_hash from the confirmed_transcript_hash and the confirmation_tag as described in [Section 8.2](https://messaginglayersecurity.rocks/mls-protocol/draft-ietf-mls-protocol.html#transcript-hashes)\r\n\r\nSo we only need to look at `interim_transcript_hash` hash input, which is defined as:\r\n\r\n```\r\nstruct {\r\n    /* same as opaque confirmation_tag<V>; */\r\n    MAC confirmation_tag;\r\n} InterimTranscriptHashInput;\r\n```\r\n\r\nIn practice, MAC output a fixed-length tag, so the actual `InterimTranscriptHashInput` that will be used will have fixed-length, which allows to prove non-ambiguity of `interim_transcript_hash`'s hash input message format.\r\n\r\n# How to do it better\r\n\r\nI propose the following solutions, from the ones I prefer to the ones I like less:\r\n- instead of doing a concatenation by hand, let's do it in the TLS presentation language: put `opaque confirmed_transcript_hash<V>;` in `InterimTranscriptHashInput` (same for `ConfirmedTranscriptHashInput`)\r\n- reverse the concatenation: since both `InterimTranscriptHashInput` and `ConfirmedTranscriptHashInput` have internal length tags, it is fine to concatenate arbitrary data after them, similarly as it is done with padding in `PrivateMessageContent`\r\n- initialize the first transcript hashes with things that have the same length as the hash function",
      "createdAt": "2023-06-07T20:21:53Z",
      "updatedAt": "2023-08-29T17:13:20Z",
      "closedAt": "2023-08-29T17:13:20Z",
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "RFC 9420 has been published, so we can't address this in the base MLS protocol.  If we do a next version / revision, we could take this up.",
          "createdAt": "2023-08-29T17:13:20Z",
          "updatedAt": "2023-08-29T17:13:20Z"
        }
      ]
    }
  ],
  "pulls": [
    {
      "number": 1,
      "id": "MDExOlB1bGxSZXF1ZXN0MTUxMjI4OTAz",
      "title": "Add a document skeleton",
      "url": "https://github.com/mlswg/mls-protocol/pull/1",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "",
      "createdAt": "2017-11-07T21:14:13Z",
      "updatedAt": "2019-12-17T10:09:30Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "14ac4b54880589153c6f152d846f7038c84a6ced",
      "headRepository": null,
      "headRefName": "skeleton",
      "headRefOid": "ba0bcf9369237ba1e2db13f645bb9be722537992",
      "closedAt": "2017-11-07T21:14:21Z",
      "mergedAt": "2017-11-07T21:14:21Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "53fc5e6d289a3c69fb7c6a9cd9478a28298c2101"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 2,
      "id": "MDExOlB1bGxSZXF1ZXN0MTUxMjM4NTg4",
      "title": "Braindump an introduction",
      "url": "https://github.com/mlswg/mls-protocol/pull/2",
      "state": "MERGED",
      "author": "katrielalex",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "Also add myself as an author, and compensate for emacs's proclivities.",
      "createdAt": "2017-11-07T21:57:38Z",
      "updatedAt": "2019-12-17T10:09:24Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "53fc5e6d289a3c69fb7c6a9cd9478a28298c2101",
      "headRepository": null,
      "headRefName": "master",
      "headRefOid": "36fd171fe3c6e066b446184b60618e9bf5e7d607",
      "closedAt": "2017-11-07T21:57:56Z",
      "mergedAt": "2017-11-07T21:57:56Z",
      "mergedBy": "katrielalex",
      "mergeCommit": {
        "oid": "7ce36ea1ce18360af81fc64525ff44b2cecb8ec2"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 3,
      "id": "MDExOlB1bGxSZXF1ZXN0MTUxMjM5OTY0",
      "title": "A bunch of TLS syntax and diagrams",
      "url": "https://github.com/mlswg/mls-protocol/pull/3",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "",
      "createdAt": "2017-11-07T22:03:41Z",
      "updatedAt": "2019-12-17T10:09:20Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "7ce36ea1ce18360af81fc64525ff44b2cecb8ec2",
      "headRepository": null,
      "headRefName": "protocol",
      "headRefOid": "57bd1360c5bc2caac40aafe40e24c904e4635c9f",
      "closedAt": "2017-11-07T22:03:49Z",
      "mergedAt": "2017-11-07T22:03:49Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "b88d812550d80b269daf825dc56dc5211c7a29a3"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 4,
      "id": "MDExOlB1bGxSZXF1ZXN0MTUxMjQxOTk0",
      "title": "Add a brief description of ART and root key computation",
      "url": "https://github.com/mlswg/mls-protocol/pull/4",
      "state": "MERGED",
      "author": "jmillican",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "",
      "createdAt": "2017-11-07T22:13:30Z",
      "updatedAt": "2019-12-17T10:09:16Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "b88d812550d80b269daf825dc56dc5211c7a29a3",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "art-description",
      "headRefOid": "05e30b1c244fa078a7eb2fff4d59e64ca609b02b",
      "closedAt": "2017-11-07T22:17:16Z",
      "mergedAt": "2017-11-07T22:17:16Z",
      "mergedBy": "jmillican",
      "mergeCommit": {
        "oid": "8bdeb004d86038cdef6a9c805328d45b9b64ec63"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 5,
      "id": "MDExOlB1bGxSZXF1ZXN0MTUxMjQ5NTU4",
      "title": "Briefly outline leaf updates",
      "url": "https://github.com/mlswg/mls-protocol/pull/5",
      "state": "MERGED",
      "author": "jmillican",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "",
      "createdAt": "2017-11-07T22:51:39Z",
      "updatedAt": "2019-12-17T10:09:11Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "8bdeb004d86038cdef6a9c805328d45b9b64ec63",
      "headRepository": null,
      "headRefName": "leaf_key",
      "headRefOid": "7900f0a007f4262f324f416bfc9087e95c18a775",
      "closedAt": "2017-11-07T22:51:46Z",
      "mergedAt": "2017-11-07T22:51:45Z",
      "mergedBy": "jmillican",
      "mergeCommit": {
        "oid": "7b69093b7e8980d8e713554c18debf677bfc40b9"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 6,
      "id": "MDExOlB1bGxSZXF1ZXN0MTUxMjYyMDAz",
      "title": "Some prose",
      "url": "https://github.com/mlswg/mls-protocol/pull/6",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "",
      "createdAt": "2017-11-08T00:09:34Z",
      "updatedAt": "2019-12-17T10:09:54Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "7b69093b7e8980d8e713554c18debf677bfc40b9",
      "headRepository": null,
      "headRefName": "prose",
      "headRefOid": "bc1a822950c4abae18c5e9bfb32a31b2932618c3",
      "closedAt": "2017-11-08T00:09:40Z",
      "mergedAt": "2017-11-08T00:09:40Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "63c315f135d4b4d14e953cc35825f64d145f8f30"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 8,
      "id": "MDExOlB1bGxSZXF1ZXN0MTY0OTE5ODI2",
      "title": "State change sequencing / Message protection",
      "url": "https://github.com/mlswg/mls-protocol/pull/8",
      "state": "MERGED",
      "author": "raphaelrobert",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "",
      "createdAt": "2018-01-24T17:55:14Z",
      "updatedAt": "2019-12-17T10:09:58Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "cecefc7b1ba78e1fb092009325ffa483e44054cc",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "raphaelrobert",
      "headRefOid": "ce52c906f36aafd02c7150a95a6dd11c4aeb74b0",
      "closedAt": "2018-01-24T18:48:47Z",
      "mergedAt": "2018-01-24T18:48:47Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "308dc72b99c81ec1d7c7e912033fb54741ebd460"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 9,
      "id": "MDExOlB1bGxSZXF1ZXN0MTY0OTc2MTk4",
      "title": "Protocol Details",
      "url": "https://github.com/mlswg/mls-protocol/pull/9",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "editorial",
        "functionality"
      ],
      "body": "This PR adds a pretty complete description of the protocol.  The only major thing that's missing is `Init`, which should be straightforward-ish to construct.  @jmillican want to take a stab at that?",
      "createdAt": "2018-01-24T22:07:30Z",
      "updatedAt": "2019-12-17T10:08:50Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "308dc72b99c81ec1d7c7e912033fb54741ebd460",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "protocol2",
      "headRefOid": "4bc7a941672db04c7e8085ac447a90545da56085",
      "closedAt": "2018-01-24T22:07:43Z",
      "mergedAt": "2018-01-24T22:07:43Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "eef91e51ccbf0ea4fd3611d7e31b45b1be876dfe"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 10,
      "id": "MDExOlB1bGxSZXF1ZXN0MTY1MDc5MTIy",
      "title": "Point to the security requirements in the architecture doc.",
      "url": "https://github.com/mlswg/mls-protocol/pull/10",
      "state": "MERGED",
      "author": "katrielalex",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "",
      "createdAt": "2018-01-25T10:21:00Z",
      "updatedAt": "2019-12-17T10:08:12Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "eef91e51ccbf0ea4fd3611d7e31b45b1be876dfe",
      "headRepository": null,
      "headRefName": "master",
      "headRefOid": "8cc06d6d91bc3f69c769837c57669fa9f68fbbde",
      "closedAt": "2018-01-25T10:21:10Z",
      "mergedAt": "2018-01-25T10:21:10Z",
      "mergedBy": "katrielalex",
      "mergeCommit": {
        "oid": "c09abcdf5f443cda52d2ace0f425c53c1fa1f762"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 11,
      "id": "MDExOlB1bGxSZXF1ZXN0MTY1NzI2NzUy",
      "title": "Start writing \u00a7Security Considerations",
      "url": "https://github.com/mlswg/mls-protocol/pull/11",
      "state": "MERGED",
      "author": "katrielalex",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "",
      "createdAt": "2018-01-29T14:58:04Z",
      "updatedAt": "2019-12-17T10:07:56Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "d7d5fe7f60574ba0c56efd8e799347dbe82f463a",
      "headRepository": null,
      "headRefName": "sec-consid",
      "headRefOid": "616e4d54169b77e128d54f298aa186c422d9591d",
      "closedAt": "2018-01-29T14:58:13Z",
      "mergedAt": "2018-01-29T14:58:13Z",
      "mergedBy": "katrielalex",
      "mergeCommit": {
        "oid": "2411124066d2b1b4ab48c0da063e6cd22f7e2fcc"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 12,
      "id": "MDExOlB1bGxSZXF1ZXN0MTY1ODU0NDk2",
      "title": "Reference and terminology fixes",
      "url": "https://github.com/mlswg/mls-protocol/pull/12",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "editorial",
        "terminology"
      ],
      "body": "",
      "createdAt": "2018-01-30T00:15:04Z",
      "updatedAt": "2019-12-17T10:07:45Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "2bd4803415bf0f5b8c631da6b5498b68823acaca",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "protocol2",
      "headRefOid": "f8c8f3ecc5c77839e8110e65160048651d3e7686",
      "closedAt": "2018-01-30T00:20:10Z",
      "mergedAt": "2018-01-30T00:20:10Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "d76f2502507019b74688b660ef318c50dc8e3600"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 13,
      "id": "MDExOlB1bGxSZXF1ZXN0MTY1ODU2NDAw",
      "title": "Expand on the ratchet trees section",
      "url": "https://github.com/mlswg/mls-protocol/pull/13",
      "state": "MERGED",
      "author": "jmillican",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "Prose for how ratchet trees work.",
      "createdAt": "2018-01-30T00:29:12Z",
      "updatedAt": "2019-12-17T10:07:26Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "d76f2502507019b74688b660ef318c50dc8e3600",
      "headRepository": null,
      "headRefName": "flesh_out_trees",
      "headRefOid": "60a4a60de1a637e3a1b540147e1a394ef6db8ea9",
      "closedAt": "2018-01-30T01:10:59Z",
      "mergedAt": "2018-01-30T01:10:59Z",
      "mergedBy": "jmillican",
      "mergeCommit": {
        "oid": "f5291786d729046c375ff95e9ea028dd4a81bb78"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 14,
      "id": "MDExOlB1bGxSZXF1ZXN0MTY1ODYyMTM2",
      "title": "Expand on the blank nodes section",
      "url": "https://github.com/mlswg/mls-protocol/pull/14",
      "state": "MERGED",
      "author": "jmillican",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "",
      "createdAt": "2018-01-30T01:13:59Z",
      "updatedAt": "2019-12-17T10:07:21Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "f5291786d729046c375ff95e9ea028dd4a81bb78",
      "headRepository": null,
      "headRefName": "blank_nodes",
      "headRefOid": "08877f7c3c26c591212fc1893d494bc77285d860",
      "closedAt": "2018-01-30T01:14:06Z",
      "mergedAt": "2018-01-30T01:14:06Z",
      "mergedBy": "jmillican",
      "mergeCommit": {
        "oid": "02893efeeac653917c87bded5ab3602c94e9aa92"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 15,
      "id": "MDExOlB1bGxSZXF1ZXN0MTY1ODY1OTkw",
      "title": "Flesh out Merkle tree description",
      "url": "https://github.com/mlswg/mls-protocol/pull/15",
      "state": "MERGED",
      "author": "jmillican",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "",
      "createdAt": "2018-01-30T01:45:05Z",
      "updatedAt": "2019-12-17T10:07:16Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "02893efeeac653917c87bded5ab3602c94e9aa92",
      "headRepository": null,
      "headRefName": "merkle",
      "headRefOid": "e0e89f7ce3bffd7dcfd6a643ae1dd240d32b6c19",
      "closedAt": "2018-01-30T01:45:13Z",
      "mergedAt": "2018-01-30T01:45:13Z",
      "mergedBy": "jmillican",
      "mergeCommit": {
        "oid": "42a85542b4bb318a7fe8800fc98e7fcb25dddc2e"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 16,
      "id": "MDExOlB1bGxSZXF1ZXN0MTY2MDM5NjEw",
      "title": "Expand on the prose describing the common tree properties",
      "url": "https://github.com/mlswg/mls-protocol/pull/16",
      "state": "MERGED",
      "author": "jmillican",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "",
      "createdAt": "2018-01-30T17:00:34Z",
      "updatedAt": "2019-12-17T10:07:12Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "42a85542b4bb318a7fe8800fc98e7fcb25dddc2e",
      "headRepository": null,
      "headRefName": "expand_trees_prose",
      "headRefOid": "7bc6522eefdb36a373465e2394d04e9e2724ae6e",
      "closedAt": "2018-01-30T17:00:41Z",
      "mergedAt": "2018-01-30T17:00:41Z",
      "mergedBy": "jmillican",
      "mergeCommit": {
        "oid": "cdc8f4f0a2595104922dc3791ea5df3b73e237cc"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 17,
      "id": "MDExOlB1bGxSZXF1ZXN0MTY2MzAxNzEw",
      "title": "Prose-ify the bullet points in the introduction",
      "url": "https://github.com/mlswg/mls-protocol/pull/17",
      "state": "MERGED",
      "author": "katrielalex",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "",
      "createdAt": "2018-01-31T16:02:21Z",
      "updatedAt": "2019-12-17T10:07:07Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "cdc8f4f0a2595104922dc3791ea5df3b73e237cc",
      "headRepository": null,
      "headRefName": "master",
      "headRefOid": "eb1d50fdedd82bb0dc54a01cd471f04a73c9ebf0",
      "closedAt": "2018-01-31T16:03:06Z",
      "mergedAt": "2018-01-31T16:03:06Z",
      "mergedBy": "katrielalex",
      "mergeCommit": {
        "oid": "b83c2c3122ca72817a140307e66473fb17e24403"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 18,
      "id": "MDExOlB1bGxSZXF1ZXN0MTY2MzA2NDcz",
      "title": "Expand bullet points into subheadings in binary trees section",
      "url": "https://github.com/mlswg/mls-protocol/pull/18",
      "state": "MERGED",
      "author": "jmillican",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "",
      "createdAt": "2018-01-31T16:18:07Z",
      "updatedAt": "2019-12-17T10:07:01Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "b83c2c3122ca72817a140307e66473fb17e24403",
      "headRepository": null,
      "headRefName": "improve_terminology_section",
      "headRefOid": "668240c6aa2520fe3c18633d75ebd1f2ef11a3b3",
      "closedAt": "2018-01-31T16:20:49Z",
      "mergedAt": "2018-01-31T16:20:49Z",
      "mergedBy": "katrielalex",
      "mergeCommit": {
        "oid": "167e5215a3ed8f4a7048424f6f31056f03e4b6a8"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 19,
      "id": "MDExOlB1bGxSZXF1ZXN0MTY2MzEzODMy",
      "title": "Trim some of the proliferation of section headers",
      "url": "https://github.com/mlswg/mls-protocol/pull/19",
      "state": "MERGED",
      "author": "katrielalex",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "",
      "createdAt": "2018-01-31T16:43:15Z",
      "updatedAt": "2019-12-17T10:06:55Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "167e5215a3ed8f4a7048424f6f31056f03e4b6a8",
      "headRepository": null,
      "headRefName": "master",
      "headRefOid": "aa68a027ff8f10dd9dcf526210d45ebb86b008b6",
      "closedAt": "2018-01-31T16:47:27Z",
      "mergedAt": "2018-01-31T16:47:27Z",
      "mergedBy": "jmillican",
      "mergeCommit": {
        "oid": "3f123b56d2db495c03fc97182162db2e3cc84484"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3OTI5OTY0ODg=",
          "commit": {
            "abbreviatedOid": "aa68a02"
          },
          "author": "jmillican",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-01-31T16:47:22Z",
          "updatedAt": "2018-01-31T16:47:22Z",
          "comments": []
        }
      ]
    },
    {
      "number": 20,
      "id": "MDExOlB1bGxSZXF1ZXN0MTY2MzIzNDgw",
      "title": "Start a section on group tree operations",
      "url": "https://github.com/mlswg/mls-protocol/pull/20",
      "state": "MERGED",
      "author": "jmillican",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "",
      "createdAt": "2018-01-31T17:18:14Z",
      "updatedAt": "2019-12-17T10:06:34Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "3f123b56d2db495c03fc97182162db2e3cc84484",
      "headRepository": null,
      "headRefName": "group_initialisation",
      "headRefOid": "7baad56787bde688e44e010ae57ccb8a711a8c5c",
      "closedAt": "2018-01-31T17:18:21Z",
      "mergedAt": "2018-01-31T17:18:21Z",
      "mergedBy": "jmillican",
      "mergeCommit": {
        "oid": "801935fe8337b40708acf4e6ccc61e92a2591b12"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 22,
      "id": "MDExOlB1bGxSZXF1ZXN0MTY2NDMwMDcz",
      "title": "Editorial",
      "url": "https://github.com/mlswg/mls-protocol/pull/22",
      "state": "MERGED",
      "author": "ekr",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "",
      "createdAt": "2018-02-01T02:41:04Z",
      "updatedAt": "2019-12-17T10:06:23Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "801935fe8337b40708acf4e6ccc61e92a2591b12",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "ekr_edit",
      "headRefOid": "b029364bc54cac5fbd09c92e353ac0fe3f8a2be0",
      "closedAt": "2018-02-01T02:41:22Z",
      "mergedAt": "2018-02-01T02:41:22Z",
      "mergedBy": "ekr",
      "mergeCommit": {
        "oid": "178d585d147cac7f233ed5aa8c7b4f8716a47bbb"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 23,
      "id": "MDExOlB1bGxSZXF1ZXN0MTY2NDUzMjkx",
      "title": "Minor editorial and typo fixes",
      "url": "https://github.com/mlswg/mls-protocol/pull/23",
      "state": "MERGED",
      "author": "beurdouche",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "",
      "createdAt": "2018-02-01T06:24:17Z",
      "updatedAt": "2019-12-17T10:06:16Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "1e726dbaf9650d76b4e301b331713ea65f9d3b5c",
      "headRepository": "beurdouche/mls-protocol",
      "headRefName": "editorial_0",
      "headRefOid": "9194e6c32d3075e0ff005941039973f33345a2f5",
      "closedAt": "2018-02-01T06:24:25Z",
      "mergedAt": "2018-02-01T06:24:25Z",
      "mergedBy": "beurdouche",
      "mergeCommit": {
        "oid": "653a0023b715a6deefb5b53187cdcb0f968af438"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 24,
      "id": "MDExOlB1bGxSZXF1ZXN0MTY2NDU1NzEx",
      "title": "RLB edit pass",
      "url": "https://github.com/mlswg/mls-protocol/pull/24",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "editorial",
        "recommendation"
      ],
      "body": "",
      "createdAt": "2018-02-01T06:43:23Z",
      "updatedAt": "2019-12-17T10:04:49Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "653a0023b715a6deefb5b53187cdcb0f968af438",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "rlb-edit-pass",
      "headRefOid": "efd2f5583137bbc4e63c807b2b72e03382b57a22",
      "closedAt": "2018-02-01T06:47:40Z",
      "mergedAt": "2018-02-01T06:47:40Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "c4feec23b01d6f44487be9460bc675467e7c2314"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3OTMxNzk1MjU=",
          "commit": {
            "abbreviatedOid": "2fa6ed3"
          },
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-02-01T06:44:34Z",
          "updatedAt": "2018-02-01T06:44:34Z",
          "comments": [
            {
              "originalPosition": 618,
              "body": "typo",
              "createdAt": "2018-02-01T06:44:34Z",
              "updatedAt": "2018-02-01T06:47:32Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3OTMxNzk1OTA=",
          "commit": {
            "abbreviatedOid": "2fa6ed3"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-02-01T06:44:59Z",
          "updatedAt": "2018-02-01T06:44:59Z",
          "comments": [
            {
              "originalPosition": 618,
              "body": "Wow, that was fast\r\n",
              "createdAt": "2018-02-01T06:44:59Z",
              "updatedAt": "2018-02-01T06:47:32Z"
            }
          ]
        }
      ]
    },
    {
      "number": 25,
      "id": "MDExOlB1bGxSZXF1ZXN0MTY2NDU4Nzk4",
      "title": "Add concreteness",
      "url": "https://github.com/mlswg/mls-protocol/pull/25",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "editorial",
        "recommendation"
      ],
      "body": "",
      "createdAt": "2018-02-01T07:05:46Z",
      "updatedAt": "2019-12-17T10:04:32Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "c4feec23b01d6f44487be9460bc675467e7c2314",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "rlb-edit-pass",
      "headRefOid": "ac469a95b9210395ee4602d4b85c3a471701fb8a",
      "closedAt": "2018-02-01T07:05:52Z",
      "mergedAt": "2018-02-01T07:05:52Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "3942cd5c3eed8723595e4444ba0f5e8ea5ce1a56"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 26,
      "id": "MDExOlB1bGxSZXF1ZXN0MTY2NDcxNjM4",
      "title": "Technical bug fixes due to implementation",
      "url": "https://github.com/mlswg/mls-protocol/pull/26",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "editorial",
        "recommendation"
      ],
      "body": "Noticed some bugs in the spec as I was working on aligning the Go implementation.",
      "createdAt": "2018-02-01T08:27:11Z",
      "updatedAt": "2019-12-17T10:04:18Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "3942cd5c3eed8723595e4444ba0f5e8ea5ce1a56",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "rlb-edit-pass",
      "headRefOid": "6b31f38bdd47b730b007eeb3f72432158c6faccb",
      "closedAt": "2018-02-01T08:27:32Z",
      "mergedAt": "2018-02-01T08:27:31Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "76d2db1f18ec9f553a0096b02ddb65b4d511e4c6"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 27,
      "id": "MDExOlB1bGxSZXF1ZXN0MTY2NTQyNDkx",
      "title": "Review on the current protocol specification",
      "url": "https://github.com/mlswg/mls-protocol/pull/27",
      "state": "MERGED",
      "author": "beurdouche",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "editorial",
        "recommendation"
      ],
      "body": "",
      "createdAt": "2018-02-01T13:52:15Z",
      "updatedAt": "2019-12-17T10:05:06Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "80cd9d1e8320d8ec6d49f8308b6c95c5d4b0a177",
      "headRepository": "beurdouche/mls-protocol",
      "headRefName": "update.0",
      "headRefOid": "362e9f5c162489a9d8e1891ba4d3a123010d822a",
      "closedAt": "2018-02-01T20:32:10Z",
      "mergedAt": "2018-02-01T20:32:10Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "10b1db9861a4475e39f59349eb70e965d5e3ac13"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3OTM0MDg2NTk=",
          "commit": {
            "abbreviatedOid": "fa9e653"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2018-02-01T19:32:35Z",
          "updatedAt": "2018-02-01T19:38:24Z",
          "comments": [
            {
              "originalPosition": 452,
              "body": "Request from the cache",
              "createdAt": "2018-02-01T19:32:35Z",
              "updatedAt": "2018-02-01T19:53:30Z"
            },
            {
              "originalPosition": 383,
              "body": "I would say \"potential group member\"",
              "createdAt": "2018-02-01T19:33:13Z",
              "updatedAt": "2018-02-01T19:53:30Z"
            },
            {
              "originalPosition": 383,
              "body": "and then \"that a current gorup member\"",
              "createdAt": "2018-02-01T19:33:22Z",
              "updatedAt": "2018-02-01T19:53:30Z"
            },
            {
              "originalPosition": 508,
              "body": "I would just condense these to say something like \"... derive key material for symmetric operations such as encryption/AEAD and MAC.\"",
              "createdAt": "2018-02-01T19:35:19Z",
              "updatedAt": "2018-02-01T19:53:30Z"
            },
            {
              "originalPosition": 519,
              "body": "SGTM",
              "createdAt": "2018-02-01T19:35:44Z",
              "updatedAt": "2018-02-01T19:53:30Z"
            },
            {
              "originalPosition": 527,
              "body": "Change \"strong indication\" to \"proof\"?\r\n",
              "createdAt": "2018-02-01T19:36:10Z",
              "updatedAt": "2018-02-01T19:53:30Z"
            },
            {
              "originalPosition": 533,
              "body": "Please add text.",
              "createdAt": "2018-02-01T19:36:28Z",
              "updatedAt": "2018-02-01T19:53:30Z"
            },
            {
              "originalPosition": 540,
              "body": "I think the idea is to cover it in a MAC / AEAD rather than mixing it into the key.  That way you can verify authenticity of the new thing even if you don't have the old thing.",
              "createdAt": "2018-02-01T19:37:16Z",
              "updatedAt": "2018-02-01T19:53:30Z"
            },
            {
              "originalPosition": 550,
              "body": "s/secret/private/",
              "createdAt": "2018-02-01T19:37:29Z",
              "updatedAt": "2018-02-01T19:53:30Z"
            },
            {
              "originalPosition": 550,
              "body": "(In general, I try to use \"private\" for asymmetric secrets, and \"secret\" for symmetric) ",
              "createdAt": "2018-02-01T19:37:51Z",
              "updatedAt": "2018-02-01T19:53:30Z"
            },
            {
              "originalPosition": 559,
              "body": "\"honnest\"",
              "createdAt": "2018-02-01T19:38:03Z",
              "updatedAt": "2018-02-01T19:53:30Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3OTM0MTYxMTc=",
          "commit": {
            "abbreviatedOid": "362e9f5"
          },
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-02-01T19:54:58Z",
          "updatedAt": "2018-02-01T19:54:59Z",
          "comments": [
            {
              "originalPosition": 59,
              "body": "Wasn't immediately sure on how to expand here.",
              "createdAt": "2018-02-01T19:54:59Z",
              "updatedAt": "2018-02-01T19:54:59Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3OTM0MTYyODU=",
          "commit": {
            "abbreviatedOid": "362e9f5"
          },
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-02-01T19:55:29Z",
          "updatedAt": "2018-02-01T19:55:29Z",
          "comments": [
            {
              "originalPosition": 59,
              "body": "I did the rest of the changes according to your comments @bifurcation ",
              "createdAt": "2018-02-01T19:55:29Z",
              "updatedAt": "2018-02-01T19:55:29Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3OTM0MjcxNzY=",
          "commit": {
            "abbreviatedOid": "362e9f5"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-02-01T20:31:43Z",
          "updatedAt": "2018-02-01T20:31:43Z",
          "comments": []
        }
      ]
    },
    {
      "number": 28,
      "id": "MDExOlB1bGxSZXF1ZXN0MTY2NTg4Njk1",
      "title": "make things make",
      "url": "https://github.com/mlswg/mls-protocol/pull/28",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "weekly-digest"
      ],
      "body": "",
      "createdAt": "2018-02-01T16:37:08Z",
      "updatedAt": "2019-12-17T10:03:39Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "76d2db1f18ec9f553a0096b02ddb65b4d511e4c6",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "make-fix",
      "headRefOid": "6eb5ff68a934c974efd760244dbc62bd696e0cb6",
      "closedAt": "2018-02-01T16:37:15Z",
      "mergedAt": "2018-02-01T16:37:15Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "8c22ac17164702c7d3f101db8f338208bb8859c5"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 29,
      "id": "MDExOlB1bGxSZXF1ZXN0MTY2NjA3OTEw",
      "title": "Add a contributors list",
      "url": "https://github.com/mlswg/mls-protocol/pull/29",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "",
      "createdAt": "2018-02-01T17:51:31Z",
      "updatedAt": "2019-12-17T10:03:30Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "8c22ac17164702c7d3f101db8f338208bb8859c5",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "contributors",
      "headRefOid": "0f419a16e5cf26af1eb14a248df70d09bd57faba",
      "closedAt": "2018-02-01T17:51:48Z",
      "mergedAt": "2018-02-01T17:51:47Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "d8989450c3f87ef66e81f4a817f200ae570217b9"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 30,
      "id": "MDExOlB1bGxSZXF1ZXN0MTY2NjI3OTI2",
      "title": "Some revisions",
      "url": "https://github.com/mlswg/mls-protocol/pull/30",
      "state": "MERGED",
      "author": "ekr",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "editorial",
        "recommendation"
      ],
      "body": "",
      "createdAt": "2018-02-01T19:21:15Z",
      "updatedAt": "2019-12-17T10:03:13Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "d8989450c3f87ef66e81f4a817f200ae570217b9",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "ekr_revisions2",
      "headRefOid": "880458e95463bf92cfcbd5229cc3f33eb94e1e5d",
      "closedAt": "2018-02-01T19:23:34Z",
      "mergedAt": "2018-02-01T19:23:34Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "80cd9d1e8320d8ec6d49f8308b6c95c5d4b0a177"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 31,
      "id": "MDExOlB1bGxSZXF1ZXN0MTY2NjM0MDcy",
      "title": "Explicitly note open issues",
      "url": "https://github.com/mlswg/mls-protocol/pull/31",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "",
      "createdAt": "2018-02-01T19:47:43Z",
      "updatedAt": "2019-12-17T10:02:54Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "80cd9d1e8320d8ec6d49f8308b6c95c5d4b0a177",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "open-issues",
      "headRefOid": "1e02f0fcf38e9cdd0941a544767d0d5a2382009e",
      "closedAt": "2018-02-01T20:27:28Z",
      "mergedAt": "2018-02-01T20:27:28Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "94201ffb72bfb49907829aa19f9ccc4bcd069013"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 32,
      "id": "MDExOlB1bGxSZXF1ZXN0MTY2NjUwMDc5",
      "title": "A few tweaks to the top part of the doc",
      "url": "https://github.com/mlswg/mls-protocol/pull/32",
      "state": "MERGED",
      "author": "jmillican",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "",
      "createdAt": "2018-02-01T20:58:37Z",
      "updatedAt": "2019-12-17T10:02:48Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "10b1db9861a4475e39f59349eb70e965d5e3ac13",
      "headRepository": null,
      "headRefName": "few_tweaks",
      "headRefOid": "9708555b06606e60de5ddd33fe3757f50ddd32cf",
      "closedAt": "2018-02-01T21:01:39Z",
      "mergedAt": "2018-02-01T21:01:39Z",
      "mergedBy": "jmillican",
      "mergeCommit": {
        "oid": "1c0a12ded892afe58f3e843ce01b13d25b902fdd"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 33,
      "id": "MDExOlB1bGxSZXF1ZXN0MTY2NjU3OTEw",
      "title": "minor changes specifying two different types of authentication",
      "url": "https://github.com/mlswg/mls-protocol/pull/33",
      "state": "MERGED",
      "author": "kwonalbert",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "editorial",
        "functionality"
      ],
      "body": "",
      "createdAt": "2018-02-01T21:34:37Z",
      "updatedAt": "2019-12-17T10:02:32Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "1c0a12ded892afe58f3e843ce01b13d25b902fdd",
      "headRepository": null,
      "headRefName": "master",
      "headRefOid": "0bc4a1ea5bbb0a3a22e0d9b0122190f97a05ed13",
      "closedAt": "2018-02-01T21:35:44Z",
      "mergedAt": "2018-02-01T21:35:44Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "73b886d514a57b971b22f31294c4e2ec0aaa33b1"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 34,
      "id": "MDExOlB1bGxSZXF1ZXN0MTY2NjYwMzY0",
      "title": "Title and reference fixes",
      "url": "https://github.com/mlswg/mls-protocol/pull/34",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "",
      "createdAt": "2018-02-01T21:45:27Z",
      "updatedAt": "2019-12-17T10:01:54Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "73b886d514a57b971b22f31294c4e2ec0aaa33b1",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "title",
      "headRefOid": "fc26f237878c8de288e16e82f825e9d0b2a530de",
      "closedAt": "2018-02-01T21:45:34Z",
      "mergedAt": "2018-02-01T21:45:34Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "cf70d28484d6d0d08f5e6df051cbe1ca40dfa992"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 36,
      "id": "MDExOlB1bGxSZXF1ZXN0MTY2NjY1NTky",
      "title": "Add a note to cite ART paper",
      "url": "https://github.com/mlswg/mls-protocol/pull/36",
      "state": "MERGED",
      "author": "jmillican",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "",
      "createdAt": "2018-02-01T22:08:58Z",
      "updatedAt": "2019-12-17T10:01:50Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "cf70d28484d6d0d08f5e6df051cbe1ca40dfa992",
      "headRepository": null,
      "headRefName": "note_to_cite_art",
      "headRefOid": "868846c93f01c8956d1ba6784c438dd241d69c4a",
      "closedAt": "2018-02-01T22:09:33Z",
      "mergedAt": "2018-02-01T22:09:33Z",
      "mergedBy": "jmillican",
      "mergeCommit": {
        "oid": "33cd37932e60dd566308df6b9ff6ec3082470611"
      },
      "comments": [
        {
          "author": "jmillican",
          "authorAssociation": "COLLABORATOR",
          "body": "We should probably have this cited there, as the security proof is pretty core to things.",
          "createdAt": "2018-02-01T22:09:30Z",
          "updatedAt": "2018-02-01T22:09:30Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 37,
      "id": "MDExOlB1bGxSZXF1ZXN0MTY2NjY3MjYz",
      "title": "Fix compilation by reordering references",
      "url": "https://github.com/mlswg/mls-protocol/pull/37",
      "state": "MERGED",
      "author": "katrielalex",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "weekly-digest"
      ],
      "body": "Because xml2rfc is crazy, if the first reference in a reference list\r\ndoes not include an author then xml2rfc will _actually crash_ with an\r\nUnboundLocalError (http://xml2rfc.xml.resource.narkive.com/DzQ2CS0L/243-version-2-cli-problem-in-html-rendering-of-minimal-references):\r\n\r\n```\r\nxml2rfc -q draft-barnes-mls-protocol.xml -o draft-barnes-mls-protocol.htmltmp --html\r\nTraceback (most recent call last):\r\n  File \"/usr/local/bin/xml2rfc\", line 225, in <module>\r\n    main()\r\n  File \"/usr/local/bin/xml2rfc\", line 192, in main\r\n    htmlwriter.write(filename)\r\n  File \"/Users/katrielalex/Library/Python/2.7/lib/python/site-packages/xml2rfc/writers/base.py\", line 1218, in write\r\n    self._build_document()\r\n  File \"/Users/katrielalex/Library/Python/2.7/lib/python/site-packages/xml2rfc/writers/base.py\", line 1164, in _build_document\r\n    self.write_reference_list(reference_list)\r\n  File \"/Users/katrielalex/Library/Python/2.7/lib/python/site-packages/xml2rfc/writers/html.py\", line 569, in write_reference_list\r\n    a.tail = ', '\r\nUnboundLocalError: local variable 'a' referenced before assignment\r\n```\r\n\r\nYes, this is crazy. In lieu of actually fixing the problem, here we\r\njust reorder the references so it compiles.",
      "createdAt": "2018-02-01T22:17:07Z",
      "updatedAt": "2019-12-17T10:01:31Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "33cd37932e60dd566308df6b9ff6ec3082470611",
      "headRepository": null,
      "headRefName": "master",
      "headRefOid": "a34b5ae1647f33731c327fca53a68c36fcd72f2e",
      "closedAt": "2018-02-01T22:17:57Z",
      "mergedAt": "2018-02-01T22:17:57Z",
      "mergedBy": "katrielalex",
      "mergeCommit": {
        "oid": "ccab586f647bd978d101baa3b89078f9e9fb7da1"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 38,
      "id": "MDExOlB1bGxSZXF1ZXN0MTY2NjcwMzA5",
      "title": "Add an OPEN ISSUE about the signatures on identity keys breaking deniability",
      "url": "https://github.com/mlswg/mls-protocol/pull/38",
      "state": "MERGED",
      "author": "katrielalex",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "editorial",
        "privacy"
      ],
      "body": "FAO @raphaelrobert ",
      "createdAt": "2018-02-01T22:31:36Z",
      "updatedAt": "2019-12-17T09:55:04Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "ccab586f647bd978d101baa3b89078f9e9fb7da1",
      "headRepository": null,
      "headRefName": "master",
      "headRefOid": "806ab2ea720dcba03ea579117c31537b8ad3b805",
      "closedAt": "2018-02-01T22:31:51Z",
      "mergedAt": "2018-02-01T22:31:51Z",
      "mergedBy": "katrielalex",
      "mergeCommit": {
        "oid": "702b4f4ede84279d03e9a740817cd699e297947d"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 39,
      "id": "MDExOlB1bGxSZXF1ZXN0MTY2NzA5NjQ2",
      "title": "Add disclaimer of fitness",
      "url": "https://github.com/mlswg/mls-protocol/pull/39",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "",
      "createdAt": "2018-02-02T03:23:34Z",
      "updatedAt": "2019-12-17T09:54:39Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "702b4f4ede84279d03e9a740817cd699e297947d",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "disclaimer",
      "headRefOid": "6106e400116b8e84549d54a33002448eaee4342b",
      "closedAt": "2018-02-02T03:26:58Z",
      "mergedAt": "2018-02-02T03:26:58Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "33b9abfb52be3eefca8099d4351ac1ab446f450f"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 40,
      "id": "MDExOlB1bGxSZXF1ZXN0MTY2NzExMzQ0",
      "title": "Real cite to ART",
      "url": "https://github.com/mlswg/mls-protocol/pull/40",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "",
      "createdAt": "2018-02-02T03:40:50Z",
      "updatedAt": "2019-12-17T09:54:33Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "33b9abfb52be3eefca8099d4351ac1ab446f450f",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "cite",
      "headRefOid": "9c16aef25722b9e03aff509dec1e61c3c1b5b057",
      "closedAt": "2018-02-02T03:40:57Z",
      "mergedAt": "2018-02-02T03:40:57Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "76f0a6af08d580086c0bd6ca10b2c20666e81dbf"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 41,
      "id": "MDExOlB1bGxSZXF1ZXN0MTY2NzIwMjkx",
      "title": "Fix a minor computation bug",
      "url": "https://github.com/mlswg/mls-protocol/pull/41",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "bug",
        "editorial"
      ],
      "body": "",
      "createdAt": "2018-02-02T05:22:11Z",
      "updatedAt": "2019-12-17T09:54:26Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "76f0a6af08d580086c0bd6ca10b2c20666e81dbf",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "bugfix",
      "headRefOid": "503665f476602ad13e7f2f679f9636b02d4fb207",
      "closedAt": "2018-02-02T05:22:21Z",
      "mergedAt": "2018-02-02T05:22:21Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "3afc78a3dbb5c530edadf75ede5e5ff72bfaa1f7"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 42,
      "id": "MDExOlB1bGxSZXF1ZXN0MTY2NzIwMzUy",
      "title": "Example figure in key schedule",
      "url": "https://github.com/mlswg/mls-protocol/pull/42",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "",
      "createdAt": "2018-02-02T05:22:46Z",
      "updatedAt": "2019-12-17T09:54:13Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "3afc78a3dbb5c530edadf75ede5e5ff72bfaa1f7",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "diagram",
      "headRefOid": "ff9d95da7e1ec841a4274bf1e5cd21814498ef9a",
      "closedAt": "2018-09-10T22:11:30Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "This PR is obsolete.",
          "createdAt": "2018-09-10T22:11:30Z",
          "updatedAt": "2018-09-10T22:11:30Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3OTM2NDU4Mzg=",
          "commit": {
            "abbreviatedOid": "ff9d95d"
          },
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2018-02-02T14:58:14Z",
          "updatedAt": "2018-02-02T14:59:17Z",
          "comments": [
            {
              "originalPosition": 19,
              "body": "Something seems wrong about the HKDFs here. I think the second one is taking its inputs from the wrong place.",
              "createdAt": "2018-02-02T14:58:14Z",
              "updatedAt": "2018-02-02T14:59:17Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3OTM2ODI4NDU=",
          "commit": {
            "abbreviatedOid": "ff9d95d"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-02-02T16:49:49Z",
          "updatedAt": "2018-02-02T16:51:53Z",
          "comments": [
            {
              "originalPosition": 19,
              "body": "Ignore the direction of the inputs.  That's just there to make the diagram fit on the page.  Do you agree that the HKDF -> Epoch -> Fanout process matches the above diagram?\r\n\r\nAs far as inputs, the intent is to match text above and the sections below:\r\n\r\n> For UserAdd or GroupAdd, the new user does not know the prior epoch init secret. Instead, entropy from the prior epoch is added via the update secret, and an all-zero vector with the same length as a hash output is used in the place of the init secret\r\n\r\n> The update secret resulting from this change is the output of a DH computation between the private key for the root of the ratchet tree and the add public key from the previous epoch\r\n\r\n> The update secret resulting from this change is the secret for the root node of the ratchet tree",
              "createdAt": "2018-02-02T16:49:49Z",
              "updatedAt": "2018-02-02T16:51:53Z"
            }
          ]
        }
      ]
    },
    {
      "number": 43,
      "id": "MDExOlB1bGxSZXF1ZXN0MTY2ODgyNTk3",
      "title": "Presubmit revisions",
      "url": "https://github.com/mlswg/mls-protocol/pull/43",
      "state": "MERGED",
      "author": "ekr",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "",
      "createdAt": "2018-02-02T19:21:03Z",
      "updatedAt": "2019-12-17T09:53:59Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "79aee69664ab9de6743f37c2d4cd876b6a4ff90e",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "presubmit_revisions",
      "headRefOid": "c327a205aa221be5fda9351e2b2e870633393af3",
      "closedAt": "2018-02-02T19:28:15Z",
      "mergedAt": "2018-02-02T19:28:15Z",
      "mergedBy": "eomara",
      "mergeCommit": {
        "oid": "b65a9877a6d9abaf481fde1604fa1b4a03c15d38"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3OTM3MzAwNDM=",
          "commit": {
            "abbreviatedOid": "c327a20"
          },
          "author": "eomara",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-02-02T19:28:09Z",
          "updatedAt": "2018-02-02T19:28:09Z",
          "comments": []
        }
      ]
    },
    {
      "number": 44,
      "id": "MDExOlB1bGxSZXF1ZXN0MTY2ODg2NDA4",
      "title": "Explain frontiers and provide an example tree",
      "url": "https://github.com/mlswg/mls-protocol/pull/44",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "",
      "createdAt": "2018-02-02T19:39:27Z",
      "updatedAt": "2019-12-17T09:53:22Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "b65a9877a6d9abaf481fde1604fa1b4a03c15d38",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "frontier",
      "headRefOid": "994940819e51bcdf903576ee51da764419c8191d",
      "closedAt": "2018-02-02T19:42:30Z",
      "mergedAt": "2018-02-02T19:42:30Z",
      "mergedBy": "ekr",
      "mergeCommit": {
        "oid": "4fcede42e2beb429e31aeb64c6855458f54bfc08"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 45,
      "id": "MDExOlB1bGxSZXF1ZXN0MTY3NzEyNzk1",
      "title": "Fixes from Bob Harold",
      "url": "https://github.com/mlswg/mls-protocol/pull/45",
      "state": "MERGED",
      "author": "katrielalex",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "",
      "createdAt": "2018-02-07T14:48:28Z",
      "updatedAt": "2019-12-17T09:52:46Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "fe423d81405b21527e06eb975e2dc8f97d88351a",
      "headRepository": "katrielalex/mls-protocol",
      "headRefName": "fixes",
      "headRefOid": "19be1fe2e7b0506fca0c3d6804ee355160832658",
      "closedAt": "2018-02-07T14:50:23Z",
      "mergedAt": "2018-02-07T14:50:23Z",
      "mergedBy": "katrielalex",
      "mergeCommit": {
        "oid": "57db650f4a4b026f7a2ebf46b0738f24d92bc1fa"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3OTQ3MzQyNTk=",
          "commit": {
            "abbreviatedOid": "19be1fe"
          },
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-02-07T14:49:39Z",
          "updatedAt": "2018-02-07T14:49:39Z",
          "comments": []
        }
      ]
    },
    {
      "number": 46,
      "id": "MDExOlB1bGxSZXF1ZXN0MTY4OTg2MzY4",
      "title": "\"Groups\" is ambiguous",
      "url": "https://github.com/mlswg/mls-protocol/pull/46",
      "state": "MERGED",
      "author": "mnot",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "It first reads as if MLS allows groups to communicate with each other, which I don't *think* is the intent.",
      "createdAt": "2018-02-13T23:38:13Z",
      "updatedAt": "2019-12-17T09:52:37Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "57db650f4a4b026f7a2ebf46b0738f24d92bc1fa",
      "headRepository": null,
      "headRefName": "patch-1",
      "headRefOid": "32665c667695f83ac54d9403f204365303911c72",
      "closedAt": "2018-02-14T08:01:14Z",
      "mergedAt": "2018-02-14T08:01:14Z",
      "mergedBy": "beurdouche",
      "mergeCommit": {
        "oid": "000d62d0fd28501fef54e82961df5a5ac6cf7c84"
      },
      "comments": [
        {
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "body": "Thanks Mark ;)",
          "createdAt": "2018-02-14T08:01:17Z",
          "updatedAt": "2018-02-14T08:01:17Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 48,
      "id": "MDExOlB1bGxSZXF1ZXN0MTc1NzEzMTQ0",
      "title": "Remove GroupInitKey from Handshake; add to GroupAdd",
      "url": "https://github.com/mlswg/mls-protocol/pull/48",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "enhancement",
        "security"
      ],
      "body": "In implementing MLS, I found that having a `GroupInitKey` attached to all `Handshake` messages was almost never useful.  There's also a dangerous ambiguity between whether the `GroupInitKey` for a `Handshake` represents the state of the group before or after applying the change in the message.  \"After\" is the answer you want if you want to use historical `Handshake` messages as a way of distributing `GroupInitKey`s, but that requires emulating the change when signing the message -- and doing the emulation might rely on the `GroupInitKey`!\r\n\r\nInstead of all that complication, this PR just removes the `GroupInitKey` from `Handshake` and adds it to `GroupAdd`, where its construction and utility are both obvious.",
      "createdAt": "2018-03-17T18:03:46Z",
      "updatedAt": "2019-12-17T09:52:14Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "54420306144c793c18e8aa32268844c341a626f4",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "message-simplify",
      "headRefOid": "60448667e86dd8889f49ebd6d7301eeed147c75c",
      "closedAt": "2018-09-10T22:12:06Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "This PR is overtaken by the changes in #59 ",
          "createdAt": "2018-09-10T22:12:06Z",
          "updatedAt": "2018-09-10T22:12:06Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTA0Nzc4NDQy",
          "commit": {
            "abbreviatedOid": "6044866"
          },
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-03-17T21:10:30Z",
          "updatedAt": "2018-03-17T21:10:30Z",
          "comments": []
        }
      ]
    },
    {
      "number": 49,
      "id": "MDExOlB1bGxSZXF1ZXN0MTc1NzE2NjI4",
      "title": "Example code for tree math",
      "url": "https://github.com/mlswg/mls-protocol/pull/49",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "The math for left-balanced binary trees is very reliable once you have it right, but can be hard to get right from scratch.  This PR provides an appendix that explains a theory and code for managing these trees.",
      "createdAt": "2018-03-17T19:19:04Z",
      "updatedAt": "2019-12-17T09:50:34Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "eca365da10223eef64eda050427fc07c5f5ac254",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "tree-math",
      "headRefOid": "41d151124cbd3c08c76f5df59afd255f8be27abd",
      "closedAt": "2018-09-19T21:20:57Z",
      "mergedAt": "2018-09-19T21:20:57Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "eadb31c11ba1f447f86ca107e6c52cefcd66722f"
      },
      "comments": [
        {
          "author": "suhasHere",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I feel this is  very useful to have in the draft for implementors. What should be the plan to merge it ? @bifurcation ",
          "createdAt": "2018-09-13T22:24:43Z",
          "updatedAt": "2018-09-13T22:24:43Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTA0Nzc2MTU1",
          "commit": {
            "abbreviatedOid": "b70f9f7"
          },
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "Thanks ! I expect that it's going to be very useful for implementers. I am trusting that it is correct Python syntax ;) Pointed out a potential typo in the comments.",
          "createdAt": "2018-03-17T19:33:56Z",
          "updatedAt": "2018-03-17T21:07:03Z",
          "comments": [
            {
              "originalPosition": 51,
              "body": "s/../\"If a node's children are at different levels, then...\" ?",
              "createdAt": "2018-03-17T19:33:56Z",
              "updatedAt": "2018-09-19T21:17:36Z"
            },
            {
              "originalPosition": 41,
              "body": "Ok.",
              "createdAt": "2018-03-17T19:44:57Z",
              "updatedAt": "2018-09-19T21:17:36Z"
            },
            {
              "originalPosition": 53,
              "body": "Ok.",
              "createdAt": "2018-03-17T19:45:05Z",
              "updatedAt": "2018-09-19T21:17:36Z"
            },
            {
              "originalPosition": 63,
              "body": "Ok.",
              "createdAt": "2018-03-17T19:45:18Z",
              "updatedAt": "2018-09-19T21:17:36Z"
            },
            {
              "originalPosition": 67,
              "body": "Ok.",
              "createdAt": "2018-03-17T20:06:25Z",
              "updatedAt": "2018-09-19T21:17:36Z"
            },
            {
              "originalPosition": 74,
              "body": "Ok.",
              "createdAt": "2018-03-17T20:35:53Z",
              "updatedAt": "2018-09-19T21:17:36Z"
            },
            {
              "originalPosition": 84,
              "body": "Seems Ok.",
              "createdAt": "2018-03-17T20:50:25Z",
              "updatedAt": "2018-09-19T21:17:36Z"
            },
            {
              "originalPosition": 103,
              "body": "Ok.",
              "createdAt": "2018-03-17T20:53:59Z",
              "updatedAt": "2018-09-19T21:17:36Z"
            },
            {
              "originalPosition": 96,
              "body": "I am pressed by time and this one is more difficult. I'll get back to it later...",
              "createdAt": "2018-03-17T20:55:40Z",
              "updatedAt": "2018-09-19T21:17:36Z"
            },
            {
              "originalPosition": 113,
              "body": "Ok.",
              "createdAt": "2018-03-17T20:56:18Z",
              "updatedAt": "2018-09-19T21:17:36Z"
            },
            {
              "originalPosition": 124,
              "body": "Ok.",
              "createdAt": "2018-03-17T20:57:14Z",
              "updatedAt": "2018-09-19T21:17:36Z"
            },
            {
              "originalPosition": 135,
              "body": "Ok.",
              "createdAt": "2018-03-17T20:58:10Z",
              "updatedAt": "2018-09-19T21:17:36Z"
            },
            {
              "originalPosition": 159,
              "body": "Ok.",
              "createdAt": "2018-03-17T20:59:04Z",
              "updatedAt": "2018-09-19T21:17:36Z"
            },
            {
              "originalPosition": 147,
              "body": "Seems Ok. Yet another pair of eyes might be nice.",
              "createdAt": "2018-03-17T21:02:42Z",
              "updatedAt": "2018-09-19T21:17:36Z"
            }
          ]
        }
      ]
    },
    {
      "number": 50,
      "id": "MDExOlB1bGxSZXF1ZXN0MTk4NDgyMTk5",
      "title": "Per-user KDF ratchets for message protection",
      "url": "https://github.com/mlswg/mls-protocol/pull/50",
      "state": "CLOSED",
      "author": "Scratch-net",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "This PR is a work towards message protection for MLS. It specifies separate KDF ratchets per every user to eliminate possible nonce reuse.",
      "createdAt": "2018-06-30T15:48:57Z",
      "updatedAt": "2019-12-17T09:49:38Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "c81dd324d4e8a894766d5965c78f6d4ad68907ad",
      "headRepository": "Scratch-net/mls-protocol",
      "headRefName": "kdf",
      "headRefOid": "f53b1c6542b04d3be579bf180991c5f704311b8f",
      "closedAt": "2018-10-19T16:54:33Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "Scratch-net",
          "authorAssociation": "NONE",
          "body": "Hey @beurdouche, thanks! \r\nMade amends as per your comments, see my latest commit. The scheme still may need some love but overall I hope it became better ) ",
          "createdAt": "2018-07-17T06:37:18Z",
          "updatedAt": "2018-07-17T06:37:18Z"
        },
        {
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "body": "Looks Good, Thanks Alexey ! : )",
          "createdAt": "2018-07-17T15:44:58Z",
          "updatedAt": "2018-07-17T15:44:58Z"
        },
        {
          "author": "Scratch-net",
          "authorAssociation": "NONE",
          "body": "fixed & squashed",
          "createdAt": "2018-07-17T15:47:33Z",
          "updatedAt": "2018-07-17T15:47:33Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "This was obsoleted by #54 ",
          "createdAt": "2018-10-19T16:54:33Z",
          "updatedAt": "2018-10-19T16:54:33Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTM3NTQxMTUy",
          "commit": {
            "abbreviatedOid": "b27b441"
          },
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "Hi Alexey, here are a few comments...\r\nI might have misunderstood stuff so, tell me if I did...\r\n",
          "createdAt": "2018-07-16T18:28:22Z",
          "updatedAt": "2019-12-17T09:49:18Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "Maybe you want to use the `Epoch secret` instead which is the secret generated from mixing the previous `Init secret` and the `Update secret` (what I believe you call the \"root key\") ?\r\nThe other solution, which I use, is to fork from the \"message_master_secret\".",
              "createdAt": "2018-07-16T18:28:22Z",
              "updatedAt": "2018-07-17T15:47:22Z"
            },
            {
              "originalPosition": 14,
              "body": "This is unused in the diagram at the moment. I think adding a second figure before the existing one, starting from the s/Epoch secret/Whatever, would be nice...",
              "createdAt": "2018-07-16T18:38:48Z",
              "updatedAt": "2018-07-17T15:47:22Z"
            },
            {
              "originalPosition": 29,
              "body": "TreeKEM will provide you with the same Handshake Key Schedule so I believe that this works for TreeKEM as-well. Maybe add it, or remove the reference to ART ? : )",
              "createdAt": "2018-07-16T18:42:24Z",
              "updatedAt": "2018-07-17T15:47:22Z"
            },
            {
              "originalPosition": 36,
              "body": "I don't think this is correct, you need at least an HKDF expand here. \r\n(if you meant `Extract` as `Expand`, then you probably need an orther `Extract` just on top...)\r\nYou could also probably re-use the `Derive-Client-Secret(Secret, Index, Msg)` you defined earlier or you could do something in the following style (for example):\r\n\r\n```\r\n    \r\n                         Chain secret[N-1]  ----> HKDF_Expand (...) =\r\n                                   |              Key[N-1], Nonce[N-1]\r\n                                   V\r\n          Constant --->    HKDF-Extract\r\n                        = Chain secret[N] ----> HKDF_Expand (...) =\r\n                                    |           Key[N], Nonce[N]\r\n                                    V\r\n                                    ...\r\n\r\n```\r\n\r\nIn my case, I use the TLS style instead so both keys and nonces get mixed-back in...",
              "createdAt": "2018-07-16T18:44:37Z",
              "updatedAt": "2018-07-17T15:47:22Z"
            },
            {
              "originalPosition": 32,
              "body": "Use `~~~` as apparently 5 `~` is causing some trouble...\r\nhttps://github.com/ekr/mls-protocol/pull/52",
              "createdAt": "2018-07-16T19:12:48Z",
              "updatedAt": "2018-07-17T15:47:22Z"
            },
            {
              "originalPosition": 43,
              "body": "The 2nd and 3rd iterations of the chain are not needed.",
              "createdAt": "2018-07-16T19:21:48Z",
              "updatedAt": "2018-07-17T15:47:22Z"
            },
            {
              "originalPosition": 21,
              "body": "Do you mean \"message\" as the `Context` like is done in TLS (aka or the Handshake message causing the group's `Epoch secret` to change) here or just some label like \"client secret\" ?\r\nIn the later version, the syntax can just be called `label` instead and should be defined.\r\nIn both cases a length 255 bytes is largely enough...",
              "createdAt": "2018-07-16T19:36:12Z",
              "updatedAt": "2018-07-17T15:47:22Z"
            },
            {
              "originalPosition": 60,
              "body": "In MLS there are many epochs for many things, maybe `s/epoch/group epoch` would help clarity ?",
              "createdAt": "2018-07-16T19:45:37Z",
              "updatedAt": "2018-07-17T15:47:22Z"
            },
            {
              "originalPosition": 7,
              "body": "s/his/its or s/his/a ?",
              "createdAt": "2018-07-16T19:54:46Z",
              "updatedAt": "2018-07-17T15:47:22Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTM3NjgyMjkz",
          "commit": {
            "abbreviatedOid": "a7d1809"
          },
          "author": "Scratch-net",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-07-17T05:43:59Z",
          "updatedAt": "2018-07-17T05:43:59Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "Agree ) ",
              "createdAt": "2018-07-17T05:43:59Z",
              "updatedAt": "2018-07-17T15:47:22Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTM3Njg1Nzgy",
          "commit": {
            "abbreviatedOid": "a7d1809"
          },
          "author": "Scratch-net",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-07-17T06:06:06Z",
          "updatedAt": "2018-07-17T06:06:06Z",
          "comments": [
            {
              "originalPosition": 29,
              "body": "Fixed ",
              "createdAt": "2018-07-17T06:06:06Z",
              "updatedAt": "2018-07-17T15:47:22Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTM3ODk0MTA0",
          "commit": {
            "abbreviatedOid": "69b7e63"
          },
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-07-17T15:44:02Z",
          "updatedAt": "2018-07-17T15:44:02Z",
          "comments": [
            {
              "originalPosition": 21,
              "body": "Apple Keyboard ? When I press 9, 99 appears... ;P",
              "createdAt": "2018-07-17T15:44:02Z",
              "updatedAt": "2018-07-17T15:47:22Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTM3ODk0ODMz",
          "commit": {
            "abbreviatedOid": "69b7e63"
          },
          "author": "Scratch-net",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-07-17T15:45:34Z",
          "updatedAt": "2018-07-17T15:45:34Z",
          "comments": [
            {
              "originalPosition": 21,
              "body": "Ah, mess, no, windows ) fill fix",
              "createdAt": "2018-07-17T15:45:34Z",
              "updatedAt": "2018-07-17T15:47:22Z"
            }
          ]
        }
      ]
    },
    {
      "number": 51,
      "id": "MDExOlB1bGxSZXF1ZXN0MTk4ODA1NDU0",
      "title": "Introducing TreeKEM as a Group Key Exchange for IETF 102",
      "url": "https://github.com/mlswg/mls-protocol/pull/51",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "security",
        "privacy",
        "performance",
        "functionality"
      ],
      "body": "This PR contains several changes that I just wanted to get in for the IETF 102 deadline.\r\n\r\n* Add TreeKEM as an option (leveraging some Beurdouche work)\r\n* Refactor GroupAdd to always do \"simulated UserAdd\"\r\n* Delete -> Remove\r\n",
      "createdAt": "2018-07-02T22:29:26Z",
      "updatedAt": "2019-12-17T09:47:07Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "54420306144c793c18e8aa32268844c341a626f4",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "treekem-rlb",
      "headRefOid": "802d499877be05c63be3a318088c29caee4121c7",
      "closedAt": "2018-07-02T22:33:49Z",
      "mergedAt": "2018-07-02T22:33:48Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "2a065e72717e7d15cee27e0b7fb464eab5b177c6"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 52,
      "id": "MDExOlB1bGxSZXF1ZXN0MjAxNDY4ODcy",
      "title": "fix broken art",
      "url": "https://github.com/mlswg/mls-protocol/pull/52",
      "state": "MERGED",
      "author": "josephlhall",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "not sure what was happening here, but moving to the three tilde fixes it.",
      "createdAt": "2018-07-14T20:58:10Z",
      "updatedAt": "2019-12-17T09:45:27Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "702556a14b793923771f5a61e5d832e96bebf5ed",
      "headRepository": "josephlhall/mls-protocol",
      "headRefName": "master",
      "headRefOid": "8ce1e1185df9d987be8fda993e2ae67b3ad9ec48",
      "closedAt": "2018-07-16T16:10:04Z",
      "mergedAt": "2018-07-16T16:10:04Z",
      "mergedBy": "beurdouche",
      "mergeCommit": {
        "oid": "676785d1f4530b0627e194c161384bf2f9b40c64"
      },
      "comments": [
        {
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "body": "Thanks.",
          "createdAt": "2018-07-16T16:10:14Z",
          "updatedAt": "2018-07-16T16:10:14Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 53,
      "id": "MDExOlB1bGxSZXF1ZXN0MjAxNjg5OTQz",
      "title": "Minor fixes for figure and text after adding TreeKEM",
      "url": "https://github.com/mlswg/mls-protocol/pull/53",
      "state": "MERGED",
      "author": "beurdouche",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "",
      "createdAt": "2018-07-16T16:22:10Z",
      "updatedAt": "2019-12-17T10:11:32Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "676785d1f4530b0627e194c161384bf2f9b40c64",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "upstream/beurdouche_fix_treekem",
      "headRefOid": "75370010be1794fc3a9111178b7dc725d7e92ae0",
      "closedAt": "2018-07-16T16:49:31Z",
      "mergedAt": "2018-07-16T16:49:31Z",
      "mergedBy": "raphaelrobert",
      "mergeCommit": {
        "oid": "c81dd324d4e8a894766d5965c78f6d4ad68907ad"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 54,
      "id": "MDExOlB1bGxSZXF1ZXN0MjAxNjkwNzc3",
      "title": "Message Protection",
      "url": "https://github.com/mlswg/mls-protocol/pull/54",
      "state": "MERGED",
      "author": "beurdouche",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "security",
        "privacy",
        "performance",
        "functionality"
      ],
      "body": "This is one of the options regarding Message Protection discussed in Montreal...",
      "createdAt": "2018-07-16T16:25:35Z",
      "updatedAt": "2019-12-17T09:44:40Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "2437780914c5d0325f08c53cad79258d8d4aa6b4",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "upstream/beurdouche_msgprotection",
      "headRefOid": "630e0594c70ee3da1a1954b906001ac401edf9f9",
      "closedAt": "2018-09-14T17:09:35Z",
      "mergedAt": "2018-09-14T17:09:35Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "eca365da10223eef64eda050427fc07c5f5ac254"
      },
      "comments": [
        {
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "body": "@raphaelrobert Fixed ! Thanks Rapha\u00ebl !",
          "createdAt": "2018-08-29T15:45:11Z",
          "updatedAt": "2018-08-29T15:45:11Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTUwMjg4ODUz",
          "commit": {
            "abbreviatedOid": "63204bf"
          },
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2018-08-28T19:50:58Z",
          "updatedAt": "2018-08-28T20:51:08Z",
          "comments": [
            {
              "originalPosition": 58,
              "body": "Why is this SHOULD and not a MUST? Presumably it's an interop failure if they don't, right?",
              "createdAt": "2018-08-28T19:50:59Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 61,
              "body": "Don't use the term non-repudiability here. It's a hot button. Say rather \"to authenticate the message from a particular member, signatures are required\"",
              "createdAt": "2018-08-28T19:52:00Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 63,
              "body": "The ciphersuite does not specify a signature scheme.",
              "createdAt": "2018-08-28T19:53:32Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 67,
              "body": "bound",
              "createdAt": "2018-08-28T19:53:55Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 73,
              "body": "This sentence is grammatically problematic. Provide the justification first and then the instruction.",
              "createdAt": "2018-08-28T19:54:40Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 76,
              "body": "This is not going to be obvious. You want to say something about what that bound is.",
              "createdAt": "2018-08-28T19:55:20Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 78,
              "body": "Is this just redundant with the previous sentence.",
              "createdAt": "2018-08-28T19:55:35Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 83,
              "body": "You can't just say this is obvious. You need to explain it.",
              "createdAt": "2018-08-28T19:55:55Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 88,
              "body": "summarized. Also, what's the colon doing after this sentence.",
              "createdAt": "2018-08-28T19:56:09Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 99,
              "body": "Why are you expanding with sender here? IT's not necessary if you did it previously. Similarly, put the \"mls app\" labels elsewhere and just do \"key\" and\"iv\"\r\n\r\nAlso, \"key\", and \"iv\" are ",
              "createdAt": "2018-08-28T19:57:02Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 135,
              "body": "You already said this.",
              "createdAt": "2018-08-28T19:57:27Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 140,
              "body": "I don't understand this text. You have separate chains for each sender, so why do you need to synchronize these.",
              "createdAt": "2018-08-28T19:58:06Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 151,
              "body": "This just all seems kind of confused about the model",
              "createdAt": "2018-08-28T19:59:59Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 210,
              "body": "See above about should, must, etc.",
              "createdAt": "2018-08-28T20:38:16Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 216,
              "body": "How do I know how long signature_length is? There's no guarantee that all algorithms will have fixed-length sigs.",
              "createdAt": "2018-08-28T20:39:05Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 221,
              "body": "a 4 GB group identifier seems very long. Is this supposed to be sonething different?",
              "createdAt": "2018-08-28T20:40:26Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 222,
              "body": "Should this just be |epoch|",
              "createdAt": "2018-08-28T20:40:37Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 226,
              "body": "Typically you would do this as opaque encrypted_content<0..2^32-1>;",
              "createdAt": "2018-08-28T20:41:12Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 240,
              "body": "This field does not seem to appear. Is it now called |generation|",
              "createdAt": "2018-08-28T20:41:47Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 245,
              "body": "It looks to me like this structure would let me transplant messages between groups, right? I get that nonrepudiation has that structure in general, but it seems worse in this case, because without signing the metadata I can transplant things undetectably.",
              "createdAt": "2018-08-28T20:44:27Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 250,
              "body": "reasonable.",
              "createdAt": "2018-08-28T20:44:49Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 254,
              "body": "What does enforced mean here? That the receiver or the sender?",
              "createdAt": "2018-08-28T20:47:43Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 258,
              "body": "traditional",
              "createdAt": "2018-08-28T20:47:50Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 269,
              "body": "How is it implemented above?",
              "createdAt": "2018-08-28T20:48:16Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 276,
              "body": "or the leaf keys, right?",
              "createdAt": "2018-08-28T20:50:01Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 282,
              "body": "This is pretty vague. At least leave a placeholder for a real discussion.",
              "createdAt": "2018-08-28T20:50:28Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 289,
              "body": "This whole section feels kind of rushed. What do (say) Wire and Allo use for keeping old keys?",
              "createdAt": "2018-08-28T20:51:02Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTUwMzMxOTc3",
          "commit": {
            "abbreviatedOid": "63204bf"
          },
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "Thanks @ekr ! I fixed bunch of issues you mentioned that weren't caught by previous reviews.\r\n\r\nI added a few TODOs to cover some of the items you suggested, but since the PR adds already a lot of text I didn't wanted to define more things (ie. like the way the signature algorithm is selected: ciphersuite or negotiation...). ",
          "createdAt": "2018-08-28T21:51:41Z",
          "updatedAt": "2018-08-28T22:11:11Z",
          "comments": [
            {
              "originalPosition": 58,
              "body": "Fixed, Thanks !",
              "createdAt": "2018-08-28T21:51:41Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 61,
              "body": "Fixed, Thanks !",
              "createdAt": "2018-08-28T21:57:54Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 67,
              "body": "Fixed, Thanks !",
              "createdAt": "2018-08-28T21:57:58Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 73,
              "body": "Fixed, Thanks !",
              "createdAt": "2018-08-28T21:58:00Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 76,
              "body": "Rephrased and added an [TODO]",
              "createdAt": "2018-08-28T21:58:02Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 78,
              "body": "Fixed, Thanks !",
              "createdAt": "2018-08-28T21:58:04Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 83,
              "body": "Fixed, Thanks !",
              "createdAt": "2018-08-28T21:58:05Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 88,
              "body": "Fixed, Thanks !",
              "createdAt": "2018-08-28T21:58:10Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 99,
              "body": "Fixed. Label were leftovers, because the same diagram could be used for both per-participant and group chainings. Thanks !",
              "createdAt": "2018-08-28T21:58:20Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 135,
              "body": "Fixed.",
              "createdAt": "2018-08-28T21:58:28Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 140,
              "body": "Fixed, Thanks ! Leftovers from the multi-proposal PR.",
              "createdAt": "2018-08-28T21:58:32Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 151,
              "body": "Rewrote this ! Thanks",
              "createdAt": "2018-08-28T21:58:58Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 210,
              "body": "Fixed, Thanks !",
              "createdAt": "2018-08-28T22:00:02Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 216,
              "body": "Went for `opaque signature<0..2^32-1>;`",
              "createdAt": "2018-08-28T22:00:28Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 221,
              "body": "Changed to a 32 byte identifier for now",
              "createdAt": "2018-08-28T22:00:52Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 222,
              "body": "Fixed, Thanks !",
              "createdAt": "2018-08-28T22:01:18Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 226,
              "body": "Fixed, Thanks !",
              "createdAt": "2018-08-28T22:01:22Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 240,
              "body": "Fixed, Thanks !",
              "createdAt": "2018-08-28T22:02:06Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 245,
              "body": "Nice catch, as you said the signature must cover the metadata (typically gid, epoch, generation).\r\nI rephrased",
              "createdAt": "2018-08-28T22:03:47Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 250,
              "body": "Fixed, Thanks !",
              "createdAt": "2018-08-28T22:03:51Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 254,
              "body": "I rephrased to something like \"Application messages should be padded to provide some resistance to traffic analysis\"",
              "createdAt": "2018-08-28T22:04:48Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 258,
              "body": "Fixed, Thanks !",
              "createdAt": "2018-08-28T22:04:52Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 269,
              "body": "Added a TODO.",
              "createdAt": "2018-08-28T22:05:44Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 276,
              "body": "I rephrased and expanded to say that anything that can be used to re-derive keys should disappear as well.\r\n",
              "createdAt": "2018-08-28T22:06:52Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 282,
              "body": "Added a discussion item.",
              "createdAt": "2018-08-28T22:07:11Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 289,
              "body": "Javascript lol ?",
              "createdAt": "2018-08-28T22:07:31Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTUwNDYwNjA2",
          "commit": {
            "abbreviatedOid": "e7e108f"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-08-29T08:47:48Z",
          "updatedAt": "2018-08-29T08:47:48Z",
          "comments": [
            {
              "originalPosition": 59,
              "body": "is not -> does not",
              "createdAt": "2018-08-29T08:47:48Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTUwNDYwODcy",
          "commit": {
            "abbreviatedOid": "e7e108f"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-08-29T08:48:32Z",
          "updatedAt": "2018-08-29T08:56:15Z",
          "comments": [
            {
              "originalPosition": 66,
              "body": "his -> their",
              "createdAt": "2018-08-29T08:48:32Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 233,
              "body": "provide",
              "createdAt": "2018-08-29T08:52:54Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTUwMzUzODc0",
          "commit": {
            "abbreviatedOid": "e7e108f"
          },
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2018-08-28T23:23:47Z",
          "updatedAt": "2018-08-31T22:14:41Z",
          "comments": [
            {
              "originalPosition": 178,
              "body": "But how does this work? You need to define the input to the signature fxn.",
              "createdAt": "2018-08-28T23:23:47Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 9,
              "body": "Doesn't basically everything here change the wire protocol",
              "createdAt": "2018-08-31T22:03:35Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 74,
              "body": "I would just have \"mls\" as part of the basic label in HKDF-Expand_Label",
              "createdAt": "2018-08-31T22:05:21Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 102,
              "body": "I think you want to say here that you should use signatures, but the rules about what algorithm are used are kind of separate.",
              "createdAt": "2018-08-31T22:06:15Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 110,
              "body": "each message sent.",
              "createdAt": "2018-08-31T22:06:34Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 113,
              "body": "I'm not sure what this says.\r\n",
              "createdAt": "2018-08-31T22:06:53Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 120,
              "body": "I'm not following this. The rules here require one AEAD per key/nonce pair.",
              "createdAt": "2018-08-31T22:07:24Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 142,
              "body": "If you use the nonce directly like this rather than as an IV mask on message seq, then you absolutely can never use the same keys twice.",
              "createdAt": "2018-08-31T22:08:42Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 180,
              "body": "There is no good reason for this restriction. It doesn't make the key schedule any easier.",
              "createdAt": "2018-08-31T22:09:35Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 186,
              "body": "This is still pretty confused. Because the application secrets are per-sender, and the nonce is derived directly, you absolutely must use each application secret once.\r\n\r\n",
              "createdAt": "2018-08-31T22:10:12Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 216,
              "body": "This section is in conflict with the previous section.",
              "createdAt": "2018-08-31T22:10:45Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 268,
              "body": "This is ungrammatical/",
              "createdAt": "2018-08-31T22:11:23Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 271,
              "body": "This is not a normative requirement, because the normative requirement is the structure below. Just move this to afterwards and then use it as an explanation for why.",
              "createdAt": "2018-08-31T22:11:50Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 313,
              "body": "1. This isn't a reasonable requirement because \"above\" is the entire app.\r\n2. The sender is the one who decides whether to pad but the receiver is the one you want to have constant time, so this is not an enforceable must.\r\n",
              "createdAt": "2018-08-31T22:13:31Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 322,
              "body": "This is ungrammatical. \r\n\r\n",
              "createdAt": "2018-08-31T22:14:17Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 328,
              "body": "Why?",
              "createdAt": "2018-08-31T22:14:27Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 334,
              "body": "No, see above.",
              "createdAt": "2018-08-31T22:14:37Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTUxNTY0NDgw",
          "commit": {
            "abbreviatedOid": "234897d"
          },
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "Thanks @ekr ! I made a bunch of changes to resolve your comments. It seems there was still some legacy text that was conflicting.",
          "createdAt": "2018-08-31T22:26:57Z",
          "updatedAt": "2018-08-31T23:58:58Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "Added the `*` for all listed items.",
              "createdAt": "2018-08-31T22:26:57Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 74,
              "body": "I am keeping it for \"symmetry\" with the other labels.",
              "createdAt": "2018-08-31T22:29:55Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 102,
              "body": "I removed the last part of the sentence. We can add rules back when we deal with authentication later.",
              "createdAt": "2018-08-31T22:31:00Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 110,
              "body": "Fixed, Thanks !",
              "createdAt": "2018-08-31T22:31:13Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 113,
              "body": "I rewrote the sentence, the intent was to say that the next application message is gonna be used to derive fresh AEAD key/nonce for the future message.",
              "createdAt": "2018-08-31T22:40:20Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 120,
              "body": "I removed this. It was a leftover from an old scenario where we could encrypt multiple messages under the same key.",
              "createdAt": "2018-08-31T22:48:31Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 142,
              "body": "Yes, I believe this is the intent, you wouldn't even get forward secrecy for messages otherwise.",
              "createdAt": "2018-08-31T22:49:11Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 180,
              "body": "I removed it, indeed this is not necessary for the current scenario, it was for the group-chaining scenario.\r\nTo get causal consistency, we only need senders to monotonically increment their generation.",
              "createdAt": "2018-08-31T22:51:15Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 186,
              "body": "I removed this because it was a leftover of the non-monotonic handling of the counters for the group-chaining version.",
              "createdAt": "2018-08-31T23:02:36Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 216,
              "body": "Fixed. Thanks !",
              "createdAt": "2018-08-31T23:08:34Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 268,
              "body": "Fixed, Thanks !",
              "createdAt": "2018-08-31T23:15:07Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 271,
              "body": "Reordered and made a minor rewrite to eliminate more grammatical mistakes.",
              "createdAt": "2018-08-31T23:15:53Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 313,
              "body": "Fair enough, I slightly changed the paragraph and moved to say that the padding removal SHOULD be implemented in constant time.",
              "createdAt": "2018-08-31T23:27:03Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 322,
              "body": "Thanks, I reworked the phrasing.",
              "createdAt": "2018-08-31T23:40:35Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 328,
              "body": "I updated the text, actually we MUST NOT keep the previous application secret when we chain, we have to retain the key/nonce for an out-of-order message that we didn't receive yet otherwise I am quite sure we loose FS.",
              "createdAt": "2018-08-31T23:44:30Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 334,
              "body": "I removed that part, it was due to the group-chaining variant.",
              "createdAt": "2018-08-31T23:54:52Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTUxNTc2MDQ0",
          "commit": {
            "abbreviatedOid": "50a4959"
          },
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "Getting closer.",
          "createdAt": "2018-09-01T00:09:52Z",
          "updatedAt": "2018-09-01T00:14:15Z",
          "comments": [
            {
              "originalPosition": 86,
              "body": "Why in most cases? It should never happen.",
              "createdAt": "2018-09-01T00:09:52Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 86,
              "body": "This text generally seems like it needs work:\r\n\r\nThe rules are these:\r\n\r\n1. Senders MUST only use each secret once\r\n2. Receivers MUST delete an application secret once it has been used to successfully decrypt something.\r\n3. Receivers SHOULD delete application secrets once any newer application secret has been used but MAY keep the corresponding leaf keys around for some reasonable period.\r\n",
              "createdAt": "2018-09-01T00:12:10Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 66,
              "body": "This is ungrammatical.",
              "createdAt": "2018-09-01T00:13:03Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 127,
              "body": "My point is that this wasn't normative. It's just descriptive. So the MUST should not be capitalized.",
              "createdAt": "2018-09-01T00:13:37Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 146,
              "body": "Is it used for that? IT's more about message size side chanels.",
              "createdAt": "2018-09-01T00:14:00Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTUyMjM4NzE0",
          "commit": {
            "abbreviatedOid": "50a4959"
          },
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "Thanks @ekr : )",
          "createdAt": "2018-09-04T20:25:35Z",
          "updatedAt": "2018-09-04T20:27:05Z",
          "comments": [
            {
              "originalPosition": 66,
              "body": "Fixed, Thanks !",
              "createdAt": "2018-09-04T20:25:35Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 86,
              "body": "I rewrote this part. Thanks !",
              "createdAt": "2018-09-04T20:26:04Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 127,
              "body": "Fixed, Thanks !",
              "createdAt": "2018-09-04T20:26:12Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 146,
              "body": "Yeah, tired I guess : ) Fixed, Thanks !",
              "createdAt": "2018-09-04T20:26:33Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTUzNzI0NDc4",
          "commit": {
            "abbreviatedOid": "aac4efd"
          },
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2018-09-10T11:07:38Z",
          "updatedAt": "2018-09-10T11:14:13Z",
          "comments": [
            {
              "originalPosition": 74,
              "body": "OK, but we should remove all of these",
              "createdAt": "2018-09-10T11:07:38Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 142,
              "body": "Well, this way you would get key reuse.",
              "createdAt": "2018-09-10T11:09:33Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 201,
              "body": "This doesn't seem quite right. You MUST discard those as soon as used.",
              "createdAt": "2018-09-10T11:10:26Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 225,
              "body": "This seems to duplicate the daigram above.",
              "createdAt": "2018-09-10T11:11:10Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 240,
              "body": "This duplicates a statement above",
              "createdAt": "2018-09-10T11:11:23Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 245,
              "body": "```\r\nopaque content<0..2^32-1>\r\n```",
              "createdAt": "2018-09-10T11:11:48Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 246,
              "body": "How is this actually going to work? There might be multiple signing keys, right?",
              "createdAt": "2018-09-10T11:12:27Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 279,
              "body": "You don't say how this structure is to be used.",
              "createdAt": "2018-09-10T11:13:15Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 277,
              "body": "```\r\nopaque content<0..2^32-1>;\r\n```",
              "createdAt": "2018-09-10T11:13:27Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 272,
              "body": "I would make a type for this.",
              "createdAt": "2018-09-10T11:13:46Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTUzNzMzNTgy",
          "commit": {
            "abbreviatedOid": "aac4efd"
          },
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-09-10T11:39:11Z",
          "updatedAt": "2018-09-10T12:08:18Z",
          "comments": [
            {
              "originalPosition": 74,
              "body": "Ok, I removed all of them for now. Though I liked the idea of having the \"MLS\" prefix in the label... ",
              "createdAt": "2018-09-10T11:39:11Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 142,
              "body": "That is not what I meant indeed, so I removed the `_[sender]` suffixes",
              "createdAt": "2018-09-10T11:40:48Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 201,
              "body": "Indeed, I made the requirement stronger...",
              "createdAt": "2018-09-10T11:47:59Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 225,
              "body": "Removed it.",
              "createdAt": "2018-09-10T12:02:18Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 240,
              "body": "I didn't find a good way to remove the duplication atm. Let's do this in the next iteration, someone more skilled in english than me should polish the text after anyway...",
              "createdAt": "2018-09-10T12:03:08Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 245,
              "body": "Fixed",
              "createdAt": "2018-09-10T12:03:17Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 246,
              "body": "We only have a single identity key per participant at the moment.",
              "createdAt": "2018-09-10T12:04:01Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 277,
              "body": "Fixed, Thanks !",
              "createdAt": "2018-09-10T12:07:01Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 279,
              "body": "I rephrased to \"The signature used in the MLSPlaintext is computed over the MLSSignatureContent\r\nwhich covers the metadata ...\"",
              "createdAt": "2018-09-10T12:07:29Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTUzNzQzMDEx",
          "commit": {
            "abbreviatedOid": "660b41c"
          },
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-09-10T12:10:38Z",
          "updatedAt": "2018-09-10T12:10:38Z",
          "comments": [
            {
              "originalPosition": 272,
              "body": "I don't think that it is necessary to do it now; it seems quite self contained anyway...",
              "createdAt": "2018-09-10T12:10:38Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTUzOTg1ODEw",
          "commit": {
            "abbreviatedOid": "660b41c"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "I think this is ready to land with these comments addressed.",
          "createdAt": "2018-09-10T22:17:16Z",
          "updatedAt": "2018-09-10T22:31:54Z",
          "comments": [
            {
              "originalPosition": 48,
              "body": "This tag isn't necessary.  Kramdown automatically makes a tag of this character from the content of the heading.",
              "createdAt": "2018-09-10T22:17:16Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 81,
              "body": "If you're going to use `application_secret_[0]`, this should be `init_secret_[n]`.",
              "createdAt": "2018-09-10T22:18:04Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 240,
              "body": "This isn't necessary.  In practice, it will be provided by application context, and it will be authenticated by including it under the message signature.",
              "createdAt": "2018-09-10T22:22:24Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 244,
              "body": "This is redundant; the vector provides its own length.",
              "createdAt": "2018-09-10T22:22:45Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 272,
              "body": "Assuming we're going to land #59, It seems like we can just use the `GroupState`:\r\n\r\n```\r\nstruct {\r\n    GroupState state; // includes epoch, group_id\r\n    uint32 sender;\r\n    uint32 generation;\r\n    opaque content<0..2^32-1>;\r\n} MLSSignatureContent;\r\n```\r\n\r\nIf we agree that's the right path, we can just land this as-is, and I'll update #59 to patch it.",
              "createdAt": "2018-09-10T22:24:58Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 304,
              "body": "I don't think this is necessary.",
              "createdAt": "2018-09-10T22:26:36Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 246,
              "body": "For consistency with the prose above, I might call this an `Application` message, and `MLSPlaintext -> ApplicationPlaintext`.  It may be that once we get to handshake encryption, we'll want a record layer that's more TLS-like (and thus usable for encrypting both Application and Handshake messages.  But for now, this is specific to `Application` messages.",
              "createdAt": "2018-09-10T22:31:17Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTU0MDAyMzkw",
          "commit": {
            "abbreviatedOid": "660b41c"
          },
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "@bifurcation Fixed, Thanks :)",
          "createdAt": "2018-09-10T23:26:43Z",
          "updatedAt": "2018-09-10T23:43:24Z",
          "comments": [
            {
              "originalPosition": 48,
              "body": "Fixed, Thanks !",
              "createdAt": "2018-09-10T23:26:43Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 81,
              "body": "Fixed, Thanks !",
              "createdAt": "2018-09-10T23:27:42Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 244,
              "body": "Fixed, Thanks !",
              "createdAt": "2018-09-10T23:29:50Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 240,
              "body": "This is because you think of it as an ID for the conversation, while I think of it as an ID over the conversation AND a specific set of users. Also, I don't think we should depend on the Application for this but the opposite.",
              "createdAt": "2018-09-10T23:34:57Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 246,
              "body": "Ack, fixed.",
              "createdAt": "2018-09-10T23:36:17Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 272,
              "body": "Let's patch it up on your side. I am still not convinced by the `GroupState` thing, so let's wait and see what others think :)",
              "createdAt": "2018-09-10T23:39:07Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 304,
              "body": "Removed, Thanks !",
              "createdAt": "2018-09-10T23:39:32Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTU0ODMzMDQ4",
          "commit": {
            "abbreviatedOid": "951c4d4"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2018-09-12T20:37:18Z",
          "updatedAt": "2018-09-12T20:39:02Z",
          "comments": [
            {
              "originalPosition": 129,
              "body": "Actually, it occurs to me that you have a simultaneous-send issue here -- two senders can chose to transmit based on the same application secret, and then you have nonce reuse, which I hear is bad.\r\n\r\nAt the IETF meeting, we had discussed two potential approaches here:\r\n\r\n1. Per-sender hash ratchets\r\n2. A single hash ratchet for the group folding in sender information at key/nonce generation time\r\n\r\nYou need to do one of those here.  I continue to prefer the second one, and it is a smaller delta on what you have here.  You would just need to change the \"\" in the nonce/key derivations to some encoding of the sender ID.",
              "createdAt": "2018-09-12T20:37:19Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 136,
              "body": "Is there a reason this is `Derive-Secret` instead of `Hkdf-Expand-Label` [as in TLS 1.3](https://tools.ietf.org/html/rfc8446#section-7.2)?",
              "createdAt": "2018-09-12T20:37:47Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 139,
              "body": "The diagram below this should be deleted.",
              "createdAt": "2018-09-12T20:38:40Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 146,
              "body": "Extra blank line",
              "createdAt": "2018-09-12T20:38:53Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTU0ODM5MDAx",
          "commit": {
            "abbreviatedOid": "951c4d4"
          },
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-09-12T20:53:06Z",
          "updatedAt": "2018-09-12T20:53:06Z",
          "comments": [
            {
              "originalPosition": 129,
              "body": "No they can't do it, maybe it is not clear enough but this is the per-sender chaining here, so the Participant application secret is used...",
              "createdAt": "2018-09-12T20:53:06Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTU0ODM5NDQy",
          "commit": {
            "abbreviatedOid": "951c4d4"
          },
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-09-12T20:54:14Z",
          "updatedAt": "2018-09-12T20:54:14Z",
          "comments": [
            {
              "originalPosition": 136,
              "body": "This is a secret to secret derivation so there is no need to expand yes ?",
              "createdAt": "2018-09-12T20:54:14Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTU0ODQwMTQ4",
          "commit": {
            "abbreviatedOid": "951c4d4"
          },
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-09-12T20:56:12Z",
          "updatedAt": "2018-09-12T20:56:12Z",
          "comments": [
            {
              "originalPosition": 129,
              "body": "\"each participant's Application secret chain looks as follows after the initial\r\nderivation:\"",
              "createdAt": "2018-09-12T20:56:12Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTU0ODU3MTk3",
          "commit": {
            "abbreviatedOid": "82a2030"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-09-12T21:45:05Z",
          "updatedAt": "2018-09-12T21:51:06Z",
          "comments": [
            {
              "originalPosition": 132,
              "body": "Thanks, this is clearer.  Two minor edits / quetions:\r\n\r\nHowever, the subscripts should indicate that this is a fanout.  I would propose having the root be something like `application_secret` (no subscript), then have the specific application secrets be double-subscripted, e.g., `app_secret_[sender]_[0]`.\r\n\r\nYou might want to use a separate label (app sender?) for this stage as opposed to the linear updates.",
              "createdAt": "2018-09-12T21:45:06Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 152,
              "body": "Same comment about subscripting",
              "createdAt": "2018-09-12T21:45:38Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTU0ODYyNTAw",
          "commit": {
            "abbreviatedOid": "82a2030"
          },
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-09-12T22:03:10Z",
          "updatedAt": "2018-09-12T22:04:49Z",
          "comments": [
            {
              "originalPosition": 132,
              "body": "Fixed, Thanks ! : )",
              "createdAt": "2018-09-12T22:03:10Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 152,
              "body": "Fixed, Thanks !",
              "createdAt": "2018-09-12T22:03:21Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTU0ODY5OTAw",
          "commit": {
            "abbreviatedOid": "5a58f25"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-09-12T22:33:26Z",
          "updatedAt": "2018-09-12T22:33:26Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTU1NTI2ODY3",
          "commit": {
            "abbreviatedOid": "5a58f25"
          },
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "I'm going to approve this in the interest of moving forward, but it still is pretty rough.",
          "createdAt": "2018-09-14T14:42:53Z",
          "updatedAt": "2018-09-14T14:48:24Z",
          "comments": [
            {
              "originalPosition": 162,
              "body": "This is basically unreadable. I guess it's OK because it's in an OPEN ISSUE, but...",
              "createdAt": "2018-09-14T14:42:53Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 177,
              "body": "You probably need to sharpen this point becauseit's a much more important security consideration than the next two.",
              "createdAt": "2018-09-14T14:43:20Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 272,
              "body": "Please make an open issue marker.",
              "createdAt": "2018-09-14T14:43:51Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 271,
              "body": "\"to avoid...\" -> \"to prevent Group participants from impersonating\"",
              "createdAt": "2018-09-14T14:45:59Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 278,
              "body": "\"more than\"",
              "createdAt": "2018-09-14T14:46:13Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 280,
              "body": "\"leaking an interval\" isn't clear.",
              "createdAt": "2018-09-14T14:46:26Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 287,
              "body": "\"less susceptible to serve\" is ungrammatical",
              "createdAt": "2018-09-14T14:46:48Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 291,
              "body": "leaked to the adversary by the ciphertext length",
              "createdAt": "2018-09-14T14:47:07Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 295,
              "body": "padding with zero-valued bytes before AEAD encryption",
              "createdAt": "2018-09-14T14:47:21Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 300,
              "body": "at the MLS layer and above layers",
              "createdAt": "2018-09-14T14:47:41Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            },
            {
              "originalPosition": 309,
              "body": "If they are able to retrieve ... participants can decrypt",
              "createdAt": "2018-09-14T14:48:04Z",
              "updatedAt": "2018-09-14T16:42:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTU1NTUxMjY1",
          "commit": {
            "abbreviatedOid": "5a58f25"
          },
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "Improvements according to Ekr's comments...",
          "createdAt": "2018-09-14T15:38:55Z",
          "updatedAt": "2018-09-14T16:44:56Z",
          "comments": [
            {
              "originalPosition": 162,
              "body": "I rewrote this. The issue is meant to make sure we make sure we have everything we need in the HKDF context to achieve our security goal. For a per-participant chaining like we have now, the current empty context seems ok, but we'll have to make sure.",
              "createdAt": "2018-09-14T15:38:55Z",
              "updatedAt": "2018-09-14T16:44:56Z"
            },
            {
              "originalPosition": 177,
              "body": "I added a mention to Forward Secrecy here.",
              "createdAt": "2018-09-14T16:20:09Z",
              "updatedAt": "2018-09-14T16:44:56Z"
            },
            {
              "originalPosition": 272,
              "body": "Done.",
              "createdAt": "2018-09-14T16:24:48Z",
              "updatedAt": "2018-09-14T16:44:56Z"
            },
            {
              "originalPosition": 271,
              "body": "Fixed, Thanks !",
              "createdAt": "2018-09-14T16:26:15Z",
              "updatedAt": "2018-09-14T16:44:56Z"
            },
            {
              "originalPosition": 278,
              "body": "Fixed, Thanks !",
              "createdAt": "2018-09-14T16:26:37Z",
              "updatedAt": "2018-09-14T16:44:56Z"
            },
            {
              "originalPosition": 280,
              "body": "Fixed, Thanks !",
              "createdAt": "2018-09-14T16:27:30Z",
              "updatedAt": "2018-09-14T16:44:56Z"
            },
            {
              "originalPosition": 287,
              "body": "Fixed, Thanks !",
              "createdAt": "2018-09-14T16:30:17Z",
              "updatedAt": "2018-09-14T16:44:56Z"
            },
            {
              "originalPosition": 291,
              "body": "Fixed, Thanks !",
              "createdAt": "2018-09-14T16:33:43Z",
              "updatedAt": "2018-09-14T16:44:56Z"
            },
            {
              "originalPosition": 295,
              "body": "Fixed, Thanks !",
              "createdAt": "2018-09-14T16:36:21Z",
              "updatedAt": "2018-09-14T16:44:56Z"
            },
            {
              "originalPosition": 300,
              "body": "Fixed, Thanks !",
              "createdAt": "2018-09-14T16:36:34Z",
              "updatedAt": "2018-09-14T16:44:56Z"
            },
            {
              "originalPosition": 309,
              "body": "Fixed, Thanks !",
              "createdAt": "2018-09-14T16:39:40Z",
              "updatedAt": "2018-09-14T16:44:56Z"
            }
          ]
        }
      ]
    },
    {
      "number": 55,
      "id": "MDExOlB1bGxSZXF1ZXN0MjA4Njc2NTIz",
      "title": "Rename from draft-barnes to draft-ietf",
      "url": "https://github.com/mlswg/mls-protocol/pull/55",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "Note: If you have an existing clone, you will need to delete `.targets.mk` at the root level of the clone in order for `make submit` to work. (`make` will still work fine)",
      "createdAt": "2018-08-15T20:46:06Z",
      "updatedAt": "2019-12-17T09:44:18Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "c81dd324d4e8a894766d5965c78f6d4ad68907ad",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "rename",
      "headRefOid": "2835872e13ecf62222239007306d5217e8f8ef21",
      "closedAt": "2018-08-15T20:47:26Z",
      "mergedAt": "2018-08-15T20:47:26Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "ab13578981f8eb60efced50f0b2573917a512a3d"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 56,
      "id": "MDExOlB1bGxSZXF1ZXN0MjEwMTI1ODk0",
      "title": "TLS 1.3 has become RFC 8446",
      "url": "https://github.com/mlswg/mls-protocol/pull/56",
      "state": "MERGED",
      "author": "loganaden",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "",
      "createdAt": "2018-08-22T13:01:40Z",
      "updatedAt": "2019-12-17T09:44:07Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "2437780914c5d0325f08c53cad79258d8d4aa6b4",
      "headRepository": "loganaden/mls-protocol",
      "headRefName": "master",
      "headRefOid": "70c335ae15b7a2901a9ef9298e1bb85c63215fd8",
      "closedAt": "2018-08-31T21:40:44Z",
      "mergedAt": "2018-08-31T21:40:44Z",
      "mergedBy": "beurdouche",
      "mergeCommit": {
        "oid": "2e74d28dba77b3dc4d1345508347f6b916f01b38"
      },
      "comments": [
        {
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "body": "Thanks !",
          "createdAt": "2018-08-31T21:46:20Z",
          "updatedAt": "2018-08-31T21:46:20Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTUxNTUwNTgz",
          "commit": {
            "abbreviatedOid": "70c335a"
          },
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-08-31T21:14:24Z",
          "updatedAt": "2018-08-31T21:14:24Z",
          "comments": []
        }
      ]
    },
    {
      "number": 58,
      "id": "MDExOlB1bGxSZXF1ZXN0MjE0NDI1MTk3",
      "title": "Remove UserAdd",
      "url": "https://github.com/mlswg/mls-protocol/pull/58",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "bifurcation"
      ],
      "labels": [
        "security",
        "functionality"
      ],
      "body": "I would like to remove the UserAdd functionality that's in the current document, and the GroupInitKey construct that supports it.  We will need to support a flow where a device can join without an explicit invite.  But that mechanism will also have to be limited,  since it leaks information out of the group.  It will be cleaner to get a GroupAdd-only system working first, then figure out how to add this back in.",
      "createdAt": "2018-09-10T19:54:42Z",
      "updatedAt": "2019-12-17T09:43:59Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "2e74d28dba77b3dc4d1345508347f6b916f01b38",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "remove-user-add",
      "headRefOid": "fdbbe78d3557df36b45b9d305bb376270d498a80",
      "closedAt": "2018-09-12T20:30:10Z",
      "mergedAt": "2018-09-12T20:30:10Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "f3f2fd32e77da19338c2e4915ddd0e8f1e233901"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTU0MDMxMjU5",
          "commit": {
            "abbreviatedOid": "223aa99"
          },
          "author": "suhasHere",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-09-11T02:31:33Z",
          "updatedAt": "2018-09-11T02:31:33Z",
          "comments": [
            {
              "originalPosition": 258,
              "body": "nit: should we include info about  identity frontier and ratcher_frontier inclusion in the above para ?",
              "createdAt": "2018-09-11T02:31:33Z",
              "updatedAt": "2018-09-12T20:29:57Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTU0MDMxNzU3",
          "commit": {
            "abbreviatedOid": "223aa99"
          },
          "author": "suhasHere",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-09-11T02:35:44Z",
          "updatedAt": "2018-09-11T02:35:44Z",
          "comments": [
            {
              "originalPosition": 115,
              "body": "since we no longer have groupInitKeys, should we remove the \"or group\" part of the sentence above ?",
              "createdAt": "2018-09-11T02:35:44Z",
              "updatedAt": "2018-09-12T20:29:57Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTU0MDMxOTE3",
          "commit": {
            "abbreviatedOid": "223aa99"
          },
          "author": "suhasHere",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Small claritifcation questions .. otherwise LGTM\r\n\ud83d\udc4d ",
          "createdAt": "2018-09-11T02:37:03Z",
          "updatedAt": "2018-09-11T02:37:03Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTU0MTUyODM2",
          "commit": {
            "abbreviatedOid": "223aa99"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "I think the (temporary) simplification makes sense. LGTM except for the missing definitions mentioned in-line.",
          "createdAt": "2018-09-11T11:07:40Z",
          "updatedAt": "2018-09-11T11:08:51Z",
          "comments": [
            {
              "originalPosition": 258,
              "body": "I agree that those definitions would make sense.",
              "createdAt": "2018-09-11T11:07:40Z",
              "updatedAt": "2018-09-12T20:29:57Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTU0ODI5ODQw",
          "commit": {
            "abbreviatedOid": "223aa99"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-09-12T20:28:59Z",
          "updatedAt": "2018-09-12T20:28:59Z",
          "comments": [
            {
              "originalPosition": 258,
              "body": "Done, though note that this whole section will get overwritten by #59  :)",
              "createdAt": "2018-09-12T20:28:59Z",
              "updatedAt": "2018-09-12T20:29:57Z"
            }
          ]
        }
      ]
    },
    {
      "number": 59,
      "id": "MDExOlB1bGxSZXF1ZXN0MjE0NDQ0MzQ0",
      "title": "Authn v2",
      "url": "https://github.com/mlswg/mls-protocol/pull/59",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "bifurcation"
      ],
      "labels": [
        "security",
        "functionality"
      ],
      "body": "This PR reflects a concrete scheme on top of #58 that implements the authentication framework discussed on the list recently.  There are a few major changes:\r\n\r\n* Defines a `GroupState` structure that is incorporated into the key schedule and signatures\r\n* Adds a `Welcome` message that provisions a new member with roster and tree information\r\n* Removes the Merkle tree over group identities (and related definitions), since all participants now keep the full roster",
      "createdAt": "2018-09-10T21:06:48Z",
      "updatedAt": "2019-12-17T09:43:41Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "eca365da10223eef64eda050427fc07c5f5ac254",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "authn-v2",
      "headRefOid": "1e6c2915f1a1bcd9529f7d053930428b61fc60db",
      "closedAt": "2018-09-19T21:50:28Z",
      "mergedAt": "2018-09-19T21:50:28Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "414b7008c89986e21fc93a067ee174a1bc76e78d"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTUzOTcyMDg1",
          "commit": {
            "abbreviatedOid": "bb1c658"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2018-09-10T21:32:54Z",
          "updatedAt": "2018-09-10T21:35:11Z",
          "comments": [
            {
              "originalPosition": 118,
              "body": "`transcript_hash` is not defined anywhere AFAICT",
              "createdAt": "2018-09-10T21:32:54Z",
              "updatedAt": "2018-09-19T21:04:54Z"
            },
            {
              "originalPosition": 143,
              "body": "affects -> effects",
              "createdAt": "2018-09-10T21:34:24Z",
              "updatedAt": "2018-09-19T21:04:54Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTUzOTg2MTk1",
          "commit": {
            "abbreviatedOid": "95f121c"
          },
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "Globally I think this goes in the right direction but I have a few concerns:\r\n+ I am fine with removing `GroupAdd` for now\r\n- I would have preferred to keep the paragraph on TreeKEM\r\n- Even though I understand factoring out everything into  `GroupState` structure can be helpful, we should avoid using it for everything (like in the Key Schedule and Handshake messages <> Add) when we only need to use specific information. I think it was better before.",
          "createdAt": "2018-09-10T22:18:12Z",
          "updatedAt": "2018-09-10T23:23:20Z",
          "comments": [
            {
              "originalPosition": 256,
              "body": "Can you please replace`2^24-1` sizes by`2^32-1` instead ? I don't think we need more of this TLS nonsense to save one byte in the encoded length.",
              "createdAt": "2018-09-10T22:18:12Z",
              "updatedAt": "2018-09-19T21:04:54Z"
            },
            {
              "originalPosition": 285,
              "body": "This doesn't mean anything... does it represent the maximum numbers of participants in the group ?",
              "createdAt": "2018-09-10T22:20:38Z",
              "updatedAt": "2018-09-19T21:04:54Z"
            },
            {
              "originalPosition": 289,
              "body": "What do you mean by \"identity and public key for the holder of the slot\". Do you mean the current signature and encryption public keys ?\r\n(signature pubkey, which is currently the long term identity key in the rest of the text)",
              "createdAt": "2018-09-10T22:22:13Z",
              "updatedAt": "2018-09-19T21:04:54Z"
            },
            {
              "originalPosition": 291,
              "body": "That seems very implementation specific. The concern of the spec is not to say that you should consume that space even it it is empty.",
              "createdAt": "2018-09-10T22:26:33Z",
              "updatedAt": "2018-09-19T21:04:54Z"
            },
            {
              "originalPosition": 309,
              "body": "KeyExchange <> (Group operation = Handshake message)",
              "createdAt": "2018-09-10T22:29:18Z",
              "updatedAt": "2018-09-19T21:04:54Z"
            },
            {
              "originalPosition": 350,
              "body": "Add or remove brackets on the other `transcript_hash`.",
              "createdAt": "2018-09-10T22:34:32Z",
              "updatedAt": "2018-09-19T21:04:54Z"
            },
            {
              "originalPosition": 523,
              "body": "I don't like the \"key exchange\" terminology very much here, we even't are exchanging keys...",
              "createdAt": "2018-09-10T22:40:31Z",
              "updatedAt": "2018-09-19T21:04:54Z"
            },
            {
              "originalPosition": 384,
              "body": "Why would you want pass the entire state here instead of just the message, the current secret and eventually the log ?",
              "createdAt": "2018-09-10T22:44:42Z",
              "updatedAt": "2018-09-19T21:04:54Z"
            },
            {
              "originalPosition": 525,
              "body": "Can you explain the reasoning for having the entire GroupState here, it seems only useful for `Add` ?",
              "createdAt": "2018-09-10T22:46:27Z",
              "updatedAt": "2018-09-19T21:04:54Z"
            },
            {
              "originalPosition": 542,
              "body": "I don't understand this change in terminology. We are not choosing between Diffie-Hellmann vs RSA here.. : )",
              "createdAt": "2018-09-10T22:49:03Z",
              "updatedAt": "2018-09-19T21:04:54Z"
            },
            {
              "originalPosition": 562,
              "body": "Same, I think HandshakeType was fine...",
              "createdAt": "2018-09-10T22:49:42Z",
              "updatedAt": "2018-09-19T21:04:54Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTU0MDQyMjk0",
          "commit": {
            "abbreviatedOid": "95f121c"
          },
          "author": "suhasHere",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-09-11T03:58:15Z",
          "updatedAt": "2018-09-11T03:58:15Z",
          "comments": [
            {
              "originalPosition": 65,
              "body": "nit: \"an Add message\"",
              "createdAt": "2018-09-11T03:58:15Z",
              "updatedAt": "2018-09-19T21:04:54Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTU0MjI2ODQ3",
          "commit": {
            "abbreviatedOid": "95f121c"
          },
          "author": "suhasHere",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "I  think the overall direction seems good. Have few nits overall , but given we will be discussing the content at the interim , LGTM",
          "createdAt": "2018-09-11T14:21:55Z",
          "updatedAt": "2018-09-11T14:35:26Z",
          "comments": [
            {
              "originalPosition": 628,
              "body": "size repeated twice",
              "createdAt": "2018-09-11T14:21:56Z",
              "updatedAt": "2018-09-19T21:04:54Z"
            },
            {
              "originalPosition": 256,
              "body": "Wondering where is __Credential__ defined ?",
              "createdAt": "2018-09-11T14:23:25Z",
              "updatedAt": "2018-09-19T21:04:54Z"
            },
            {
              "originalPosition": 295,
              "body": "nit .. for readers beneifit , might be useful to explain the size formula ?",
              "createdAt": "2018-09-11T14:25:39Z",
              "updatedAt": "2018-09-19T21:04:54Z"
            },
            {
              "originalPosition": 301,
              "body": "Wonder how the Welcome message race is resolved when multiple existing members end up adding the same new member?",
              "createdAt": "2018-09-11T14:26:27Z",
              "updatedAt": "2018-09-19T21:04:54Z"
            },
            {
              "originalPosition": 308,
              "body": "reword .. each change --> each update to group state ?",
              "createdAt": "2018-09-11T14:27:10Z",
              "updatedAt": "2018-09-19T21:04:54Z"
            },
            {
              "originalPosition": 259,
              "body": "transcript_hash description is missing below",
              "createdAt": "2018-09-11T14:27:48Z",
              "updatedAt": "2018-09-19T21:04:54Z"
            },
            {
              "originalPosition": 396,
              "body": "Trying to understand the need for entire group state in generating the Label ? ",
              "createdAt": "2018-09-11T14:29:41Z",
              "updatedAt": "2018-09-19T21:04:54Z"
            },
            {
              "originalPosition": 772,
              "body": "Remove message type isn't defined. ",
              "createdAt": "2018-09-11T14:34:23Z",
              "updatedAt": "2018-09-19T21:04:54Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTU0NzkwNTY2",
          "commit": {
            "abbreviatedOid": "95f121c"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-09-12T18:43:31Z",
          "updatedAt": "2018-09-12T18:43:31Z",
          "comments": [
            {
              "originalPosition": 285,
              "body": "Actually, this can be eliminated, since it can be derived from the length of the `tree` vector.",
              "createdAt": "2018-09-12T18:43:31Z",
              "updatedAt": "2018-09-19T21:04:54Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTU0NzkxMjAz",
          "commit": {
            "abbreviatedOid": "95f121c"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-09-12T18:45:05Z",
          "updatedAt": "2018-09-12T18:45:05Z",
          "comments": [
            {
              "originalPosition": 289,
              "body": "\"Public key\" == \"Signature public key\".  (\"Identity\" is whatever opaque string the application assigns)  Note that because this state can change, we're not committed to using long-term identity keys.",
              "createdAt": "2018-09-12T18:45:05Z",
              "updatedAt": "2018-09-19T21:04:54Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTU0NzkyMDI5",
          "commit": {
            "abbreviatedOid": "95f121c"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-09-12T18:47:05Z",
          "updatedAt": "2018-09-12T18:47:06Z",
          "comments": [
            {
              "originalPosition": 291,
              "body": "I don't know why you think this is implementation specific.  In the current system, there is an \"owner\" of each leaf in the tree, and the participants need to agree on the leaf-to-owner assignment.  So you can compress your storage locally, but you need to be able to reconstruct this vector.",
              "createdAt": "2018-09-12T18:47:05Z",
              "updatedAt": "2018-09-19T21:04:54Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTU0NzkyNTE3",
          "commit": {
            "abbreviatedOid": "95f121c"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-09-12T18:48:20Z",
          "updatedAt": "2018-09-12T18:48:21Z",
          "comments": [
            {
              "originalPosition": 309,
              "body": "I'll change `KeyExchange` to something else, maybe `GroupOperation`.",
              "createdAt": "2018-09-12T18:48:21Z",
              "updatedAt": "2018-09-19T21:04:54Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTU0NzkzMTcz",
          "commit": {
            "abbreviatedOid": "95f121c"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-09-12T18:49:53Z",
          "updatedAt": "2018-09-12T18:49:53Z",
          "comments": [
            {
              "originalPosition": 384,
              "body": "I don't know what you mean by log.  Anything you hash in here is something the endpoints have to agree on, or else they end up at different keys.  So the idea is to include everything we want the endpoints to agree on.",
              "createdAt": "2018-09-12T18:49:53Z",
              "updatedAt": "2018-09-19T21:04:54Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTU0NzkzMzMw",
          "commit": {
            "abbreviatedOid": "95f121c"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-09-12T18:50:15Z",
          "updatedAt": "2018-09-12T18:50:16Z",
          "comments": [
            {
              "originalPosition": 525,
              "body": "See the authentication discussion on the list.",
              "createdAt": "2018-09-12T18:50:15Z",
              "updatedAt": "2018-09-19T21:04:54Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTU0ODE2MzQx",
          "commit": {
            "abbreviatedOid": "95f121c"
          },
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "state": "CHANGES_REQUESTED",
          "body": "Thanks @bifurcation ! I still think we should NOT use the entire group state everywhere in the key schedule but only what we need to get the cryptographic security properties we want, so I would prefer holding that change for a next iteration... Other than with fixes you marked as resolved, I think this is good to go :+1:",
          "createdAt": "2018-09-12T19:53:35Z",
          "updatedAt": "2018-09-12T20:31:11Z",
          "comments": [
            {
              "originalPosition": 291,
              "body": "I understand the text as:\r\nthe `size` represents the max number /\\ the length must be equal to the value\r\n==> the roster is as big as the max and not as the number of participants...\r\nwhich I interpreted as the way to store this in a flat buffer",
              "createdAt": "2018-09-12T19:53:35Z",
              "updatedAt": "2018-09-19T21:04:54Z"
            },
            {
              "originalPosition": 384,
              "body": "I think I disagree with the fact that you need to use the entire group state every time to make sure everybody agrees on the same thing. Intuitively the previous definition encompassed all group operations through the Handshake messages (`Msg`), which includes the signatures, which is enough to get the weak authentication (group-membership) property. I think it is a good practice to include incrementally what we need to be able to prove the cryptographic security properties we want and not the opposite which is just gonna be annoying for proofs. I would strongly be in favor of keeping the previous definition for now.",
              "createdAt": "2018-09-12T20:21:31Z",
              "updatedAt": "2018-09-19T21:04:54Z"
            },
            {
              "originalPosition": 396,
              "body": "Same comment here, I prefer the previous definition for now...",
              "createdAt": "2018-09-12T20:22:55Z",
              "updatedAt": "2018-09-19T21:04:54Z"
            },
            {
              "originalPosition": 525,
              "body": "Maybe I misread but I couldn't find anything about that there.",
              "createdAt": "2018-09-12T20:25:34Z",
              "updatedAt": "2018-09-19T21:04:54Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTU0OTEyMzMw",
          "commit": {
            "abbreviatedOid": "95f121c"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-09-13T02:47:21Z",
          "updatedAt": "2018-09-13T02:47:21Z",
          "comments": [
            {
              "originalPosition": 256,
              "body": "Good catch, I forgot to do that.",
              "createdAt": "2018-09-13T02:47:21Z",
              "updatedAt": "2018-09-19T21:04:54Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTU0OTEyNjk4",
          "commit": {
            "abbreviatedOid": "95f121c"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-09-13T02:50:10Z",
          "updatedAt": "2018-09-13T02:50:10Z",
          "comments": [
            {
              "originalPosition": 301,
              "body": "Added an open issue.",
              "createdAt": "2018-09-13T02:50:10Z",
              "updatedAt": "2018-09-19T21:04:54Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTU0OTI3NzA0",
          "commit": {
            "abbreviatedOid": "ebdbb4e"
          },
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "state": "CHANGES_REQUESTED",
          "body": "I think you are almost good to go here... : )",
          "createdAt": "2018-09-13T04:50:46Z",
          "updatedAt": "2018-09-13T05:40:04Z",
          "comments": [
            {
              "originalPosition": 295,
              "body": "Should that be `CredentialType` instead ?",
              "createdAt": "2018-09-13T04:50:46Z",
              "updatedAt": "2018-09-19T21:04:54Z"
            },
            {
              "originalPosition": 285,
              "body": "This is still in the text...",
              "createdAt": "2018-09-13T04:53:23Z",
              "updatedAt": "2018-09-19T21:04:54Z"
            },
            {
              "originalPosition": 323,
              "body": "Maybe you could use `2^32` instead ? There is no language support for `uint24_t` whatsoever. I think `2^16` would be too small to be future-proof but `2^24` is far too big so going to `2^32` would be fine... `2^24` or `2^48` are one of the bad things in TLS.\r\n(edited to remove the undesired aggressive tone : )... )*",
              "createdAt": "2018-09-13T04:54:18Z",
              "updatedAt": "2018-09-19T21:04:54Z"
            },
            {
              "originalPosition": 289,
              "body": "`s/public key/signature public key/` still needs to be implemented, it is unclear otherwise",
              "createdAt": "2018-09-13T04:57:20Z",
              "updatedAt": "2018-09-19T21:04:54Z"
            },
            {
              "originalPosition": 412,
              "body": "If we don't use the `_[N]` subscript to give the precise version of the secrets, maybe just use `GroupState` instead of `GroupState_n` ?",
              "createdAt": "2018-09-13T05:00:12Z",
              "updatedAt": "2018-09-19T21:04:54Z"
            },
            {
              "originalPosition": 508,
              "body": "`key_exchange` is now called `GroupOperation`",
              "createdAt": "2018-09-13T05:02:31Z",
              "updatedAt": "2018-09-19T21:04:54Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTU1MTc4MTMx",
          "commit": {
            "abbreviatedOid": "ebdbb4e"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2018-09-13T16:59:33Z",
          "updatedAt": "2018-09-13T17:54:00Z",
          "comments": [
            {
              "originalPosition": 295,
              "body": "#L719 stipulates it should indeed be `CredentialType`",
              "createdAt": "2018-09-13T16:59:33Z",
              "updatedAt": "2018-09-19T21:04:54Z"
            },
            {
              "originalPosition": 323,
              "body": "While `2^16` is roughly the order of magnitude until which MLS should work well, I agree that it should rather be `2^32` instead of `2^24`.",
              "createdAt": "2018-09-13T17:05:29Z",
              "updatedAt": "2018-09-19T21:04:54Z"
            },
            {
              "originalPosition": 517,
              "body": "discared -> discard",
              "createdAt": "2018-09-13T17:11:02Z",
              "updatedAt": "2018-09-19T21:04:54Z"
            },
            {
              "originalPosition": 537,
              "body": "The order is probably wrong, since the `Welcome` message should only be sent if the `Add` message succeeded. We should think some more about synchronicity issues that we want to avoid. \r\nIdeally the `Add` and `Welcome` message are on atomic operation in which all old and new members are notified at the same time. However since the existing member now waits for the `Add` to be successful before sending the (rather large) `Welcome`, there might be edge cases when the `Welcome` is never sent because the inviting member went offline too early.\r\nFor now I think we should keep this as an open issue. Going forward we should consider improvements, such as splitting the `Welcome` into a light header that gets reliably dispatched at the same time with the `Add` and a larger message containing the roster and the tree.",
              "createdAt": "2018-09-13T17:24:04Z",
              "updatedAt": "2018-09-19T21:04:54Z"
            },
            {
              "originalPosition": 627,
              "body": "Obviously if the verification fails, none of the changes should be applied.",
              "createdAt": "2018-09-13T17:28:28Z",
              "updatedAt": "2018-09-19T21:04:54Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTU3MDE3ODU4",
          "commit": {
            "abbreviatedOid": "1e80e32"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-09-19T20:55:03Z",
          "updatedAt": "2018-09-19T20:55:03Z",
          "comments": [
            {
              "originalPosition": 295,
              "body": "Done.",
              "createdAt": "2018-09-19T20:55:03Z",
              "updatedAt": "2018-09-19T21:04:54Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTU3MDE4Mjg0",
          "commit": {
            "abbreviatedOid": "1e80e32"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-09-19T20:56:14Z",
          "updatedAt": "2018-09-19T20:56:14Z",
          "comments": [
            {
              "originalPosition": 323,
              "body": "I don't think this is as much of an implementation issue as you do; all the decoders out there just read the relevant bytes into a uint32_t and carry on.  But I'll change it for the moment; we can try to economize on bytes later.",
              "createdAt": "2018-09-19T20:56:14Z",
              "updatedAt": "2018-09-19T21:04:54Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTU3MDIwOTMy",
          "commit": {
            "abbreviatedOid": "1e80e32"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-09-19T21:03:06Z",
          "updatedAt": "2018-09-19T21:03:06Z",
          "comments": [
            {
              "originalPosition": 537,
              "body": "Note that there's an open issue for this a few lines further down.  I agree that this is a tricky sync to get right.  Shoving the Welcome message in the Add message might simplify this, but the cost of sending an O(N) size message to everyone seems steep. ",
              "createdAt": "2018-09-19T21:03:06Z",
              "updatedAt": "2018-09-19T21:04:54Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTU3MDI3NzQ0",
          "commit": {
            "abbreviatedOid": "1e6c291"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-09-19T21:22:20Z",
          "updatedAt": "2018-09-19T21:22:20Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTU3MDMxNzc0",
          "commit": {
            "abbreviatedOid": "1e6c291"
          },
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-09-19T21:33:48Z",
          "updatedAt": "2018-09-19T21:33:48Z",
          "comments": []
        }
      ]
    },
    {
      "number": 60,
      "id": "MDExOlB1bGxSZXF1ZXN0MjE2NzEzNjM3",
      "title": "Substitute AES-128-GCM with AES-256-GCM",
      "url": "https://github.com/mlswg/mls-protocol/pull/60",
      "state": "CLOSED",
      "author": "raphaelrobert",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "security",
        "recommendation"
      ],
      "body": "",
      "createdAt": "2018-09-19T17:12:06Z",
      "updatedAt": "2019-12-17T09:43:05Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "eca365da10223eef64eda050427fc07c5f5ac254",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "aes-128-256",
      "headRefOid": "d26e72793725be04057201c025e82ae0be3649f5",
      "closedAt": "2018-09-20T10:58:29Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": []
    },
    {
      "number": 61,
      "id": "MDExOlB1bGxSZXF1ZXN0MjE2NzQ4NTAz",
      "title": "Fix broken links",
      "url": "https://github.com/mlswg/mls-protocol/pull/61",
      "state": "MERGED",
      "author": "katrielalex",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "Previously they used to point to mlswg.github.io/... but that doesn't work now that we have a homepage there",
      "createdAt": "2018-09-19T19:22:11Z",
      "updatedAt": "2019-12-17T09:42:38Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "eca365da10223eef64eda050427fc07c5f5ac254",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "fix-links",
      "headRefOid": "ba2bb6ef1865e1cb9d7a13999e2344fbb07b226b",
      "closedAt": "2018-09-19T19:23:04Z",
      "mergedAt": "2018-09-19T19:23:04Z",
      "mergedBy": "katrielalex",
      "mergeCommit": {
        "oid": "2fe65163c761124496fb25310027db2e22357e72"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 62,
      "id": "MDExOlB1bGxSZXF1ZXN0MjE2NzkwMTEw",
      "title": "Use nonces in ECIES derived from the shared secret ",
      "url": "https://github.com/mlswg/mls-protocol/pull/62",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "security",
        "performance",
        "functionality"
      ],
      "body": "This matches the behavior in TLS, and saves space (due to not having to send the nonce).",
      "createdAt": "2018-09-19T22:02:25Z",
      "updatedAt": "2019-12-17T09:42:29Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "414b7008c89986e21fc93a067ee174a1bc76e78d",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "treekem-revision",
      "headRefOid": "d03059bbc301cfbe48b573f46b8f07bf04d37040",
      "closedAt": "2018-09-19T22:22:39Z",
      "mergedAt": "2018-09-19T22:22:39Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "e73cea7d0a8257d50897f8d45410f1902bdc9c42"
      },
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Merging based on r+ from @beurdouche out of band",
          "createdAt": "2018-09-19T22:22:35Z",
          "updatedAt": "2018-09-19T22:22:35Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTU3MDQxMzUx",
          "commit": {
            "abbreviatedOid": "564f214"
          },
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-09-19T22:04:22Z",
          "updatedAt": "2018-09-19T22:04:23Z",
          "comments": [
            {
              "originalPosition": 38,
              "body": "HKDF Expand Label ?",
              "createdAt": "2018-09-19T22:04:23Z",
              "updatedAt": "2018-09-19T22:15:02Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTU3MDQxODU3",
          "commit": {
            "abbreviatedOid": "564f214"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-09-19T22:06:07Z",
          "updatedAt": "2018-09-19T22:06:07Z",
          "comments": [
            {
              "originalPosition": 38,
              "body": "No, just HKDF-Expand.  HKDF-Expand-Label isn't defined here (only in TLS), and in any case, we're using a different label.",
              "createdAt": "2018-09-19T22:06:07Z",
              "updatedAt": "2018-09-19T22:15:02Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTU3MDQyNTMy",
          "commit": {
            "abbreviatedOid": "564f214"
          },
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-09-19T22:08:44Z",
          "updatedAt": "2018-09-19T22:08:44Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTU3MDQyNjEw",
          "commit": {
            "abbreviatedOid": "564f214"
          },
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-09-19T22:09:03Z",
          "updatedAt": "2018-09-19T22:09:03Z",
          "comments": [
            {
              "originalPosition": 38,
              "body": "Ack, this is good for me then...",
              "createdAt": "2018-09-19T22:09:03Z",
              "updatedAt": "2018-09-19T22:15:02Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTU3MDQyNzcw",
          "commit": {
            "abbreviatedOid": "564f214"
          },
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-09-19T22:09:42Z",
          "updatedAt": "2018-09-19T22:09:42Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "Though I think this is already the case... (at least in the paper)",
              "createdAt": "2018-09-19T22:09:42Z",
              "updatedAt": "2018-09-19T22:15:02Z"
            }
          ]
        }
      ]
    },
    {
      "number": 63,
      "id": "MDExOlB1bGxSZXF1ZXN0MjE3MjI0NjE5",
      "title": "Allow bigger sizes for PQ primitives",
      "url": "https://github.com/mlswg/mls-protocol/pull/63",
      "state": "CLOSED",
      "author": "beurdouche",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "security",
        "performance",
        "functionality",
        "? follow-up"
      ],
      "body": "By discussing with MSR, I realized that some NIST PQ candidates can't be used easily by TLS because signatures can be bigger that `2^16` bytes.\r\n\r\nSince we already consume a lot for bandwidth, I am not concerned at all about two more bytes to encode the length of signatures on each ciphertext so I suggest we move to `opaque signature <0..2^32-1>` instead to be future-proof.\r\n",
      "createdAt": "2018-09-21T09:31:13Z",
      "updatedAt": "2019-12-17T10:10:54Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "eeecb749e3d74e141786c5574c3c05db8e8cd4ef",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "signatures_large",
      "headRefOid": "034501231be77bd49b647fcdef5886dff3deafd3",
      "closedAt": "2018-10-19T16:57:16Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "body": "Having more flexibility with the payload size sounds reasonable.\r\nOne day having signatures that big if however another kind of challenge.",
          "createdAt": "2018-09-21T12:29:12Z",
          "updatedAt": "2018-09-21T12:29:12Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "@beurdouche if you could fix the merge conflicts, I'm OK with this.",
          "createdAt": "2018-10-05T20:36:12Z",
          "updatedAt": "2018-10-05T20:36:12Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "As I said in the WG meeting, I don't think this is a good idea. If we end up having primitives this big, we are going to have lots of problems and will probably want a better architecture (e.g., signatures that batch multiple messages).",
          "createdAt": "2018-10-05T20:39:53Z",
          "updatedAt": "2018-10-05T20:39:53Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "I agree with EKR here.  PQ is probably going to require different designs, not just bigger crypto values.  If someone wants to make a concrete proposal for shimming in a PQ scheme here, which would run into these limits, I would be open to reconsidering this.",
          "createdAt": "2018-10-19T16:57:16Z",
          "updatedAt": "2018-10-19T16:57:16Z"
        },
        {
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "body": "FYI, even though this is closed this will be the basis of PQ experiment in real products, just with a different protocol version.\r\nPs: Please don't delete other people branches.",
          "createdAt": "2018-10-19T17:02:10Z",
          "updatedAt": "2018-10-19T17:02:10Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 64,
      "id": "MDExOlB1bGxSZXF1ZXN0MjE4NDYyMDA5",
      "title": "Change from AES-GCM to AES-SIV",
      "url": "https://github.com/mlswg/mls-protocol/pull/64",
      "state": "CLOSED",
      "author": "galadran",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "enhancement",
        "security",
        "? follow-up"
      ],
      "body": "[Mailing List Post](https://mailarchive.ietf.org/arch/msg/mls/gvszahIKpQ5CYJG-ARwi9MGURGo)",
      "createdAt": "2018-09-26T21:34:33Z",
      "updatedAt": "2019-12-17T09:41:32Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "e73cea7d0a8257d50897f8d45410f1902bdc9c42",
      "headRepository": "galadran/mls-protocol",
      "headRefName": "aes-siv",
      "headRefOid": "39c128d8614267f32579f8e7e87d1450e07b0c2a",
      "closedAt": "2019-01-08T01:09:31Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "I'm not sure I see a lot of value here. The current discipline is one key per message, so is there a special reason to believe that clients will be careless about nonces.",
          "createdAt": "2018-09-27T03:45:03Z",
          "updatedAt": "2018-09-27T03:45:03Z"
        },
        {
          "author": "galadran",
          "authorAssociation": "NONE",
          "body": "> I'm not sure I see a lot of value here. The current discipline is one key per message, so is there a special reason to believe that clients will be careless about nonces.\r\n\r\nHi ekr, \r\n\r\nUsing one key per message just lifts the problem to a different layer, we're relying on implementers getting the state handling right and never reusing a key. (Since if they reuse a key, they will reuse a nonce). \r\n\r\nVerifying correct nonce/key usage is difficult. Using implicit nonces and testing for compatibility gives us an assurance that most uses are correct, but says little about edge cases which are hard to test exhaustively. With AES-GCM, these edge cases lead to an immediate loss of authenticity and possible total compromise. With AES-SIV, these edge cases have very minimal impact as the adversary only learns if the two plaintexts were equal.",
          "createdAt": "2018-09-27T06:52:20Z",
          "updatedAt": "2018-09-27T06:52:20Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "Yes, my question is: is there a special reason to be believe that MLS implementations will get this wrong as opposed to (say) TLS 1.3 or SRTP implementations, both of which use implicit nonces.",
          "createdAt": "2018-09-27T07:27:56Z",
          "updatedAt": "2018-09-27T07:27:56Z"
        },
        {
          "author": "galadran",
          "authorAssociation": "NONE",
          "body": "Yes.\r\n\r\n- MLS is many party as opposed to two \r\n- MLS is highly stateful in order to achieve PFS and PCS\r\n- MLS is asynchronous\r\n- MLS sessions are expected to continue despite a device suddenly losing power \r\n- MLS is a completely new and complex protocol\r\n\r\nI already described some of the situations in which SIV offers significant benefits over implicit nonces on the mailing list.\r\n\r\nFinally, it seems premature to declare implicit nonces to have fixed all the nonce issues in TLS. Let's give TLS 1.3 another decade (or two) before declaring it perfect. ",
          "createdAt": "2018-09-27T07:58:01Z",
          "updatedAt": "2018-09-27T07:58:01Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "On Thu, Sep 27, 2018 at 12:58 AM Dennis Jackson <notifications@github.com>\nwrote:\n\n>\n>    - MLS sessions are expected to continue despite a device suddenly\n>    losing power\n>\n> This last is the only one of these that seems particularly relevant, given\nthat each sender uses its own keys. I'd be interested in hearing from\nimplementors whether they consider this kind of state loss to be an issue.\n\n\n>\n> Finally, it seems premature to declare implicit nonces to have fixed all\n> the nonce issues in TLS. Let's give TLS 1.3 another decade (or two) before\n> declaring it perfect.\n>\nThis misrepresents what I said, which was nothing like claiming that TLS\n1.3 nonce handling was perfect.\n\nWith that said, I would again refer you to SRTP , which has used implicit\nnonces for a very long time. Do you have any evidence that nonce reuse has\nbeen a problem here?\n",
          "createdAt": "2018-09-27T08:04:27Z",
          "updatedAt": "2018-09-27T08:04:27Z"
        },
        {
          "author": "galadran",
          "authorAssociation": "NONE",
          "body": "> With that said, I would again refer you to SRTP , which has used implicit nonces for a very long time. Do you have any evidence that nonce reuse has been a problem here?\r\n\r\nI have no idea. Let's assume that SRTP has no nonce reuse problems. What is the conclusion?  \r\n\r\nI've described some of the differences between synchronous, essentially stateless, 2-party protocols and MLS. I've referenced a catastrophic nonce reuse attack which implicit nonces would not have mitigated (KRACK on WPA2). There are clear scenarios where SIV provides a tangible security benefit _in addition to_  implicit nonces. \r\n\r\nThere are reasons not to use SIV in applications like TLS, as SIV only encrypts at ~70% of the speed of GCM. However, I don't think they apply to us considering the public key operations we will be doing anyway. Equally in 2014 SIV was less widely supported, since then it has found its way into OpenSSL and BoringSSL. ",
          "createdAt": "2018-09-27T08:34:56Z",
          "updatedAt": "2018-09-27T08:34:56Z"
        },
        {
          "author": "grittygrease",
          "authorAssociation": "NONE",
          "body": "Following up on this. This suggestion was discussed at the first interim and there was not a lot of enthusiasm for making the change.",
          "createdAt": "2019-01-08T01:09:31Z",
          "updatedAt": "2019-01-08T01:09:31Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 65,
      "id": "MDExOlB1bGxSZXF1ZXN0MjE4NDk0MzM5",
      "title": "Fix typos.",
      "url": "https://github.com/mlswg/mls-protocol/pull/65",
      "state": "MERGED",
      "author": "Bren2010",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "",
      "createdAt": "2018-09-27T00:50:17Z",
      "updatedAt": "2019-12-17T09:39:50Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "e73cea7d0a8257d50897f8d45410f1902bdc9c42",
      "headRepository": "Bren2010/mls-protocol",
      "headRefName": "fix-typos",
      "headRefOid": "04ea1d1afbbf4b2d84e8fa304c4f622a3ff983c8",
      "closedAt": "2018-10-02T10:34:06Z",
      "mergedAt": "2018-10-02T10:34:05Z",
      "mergedBy": "beurdouche",
      "mergeCommit": {
        "oid": "04ea1d1afbbf4b2d84e8fa304c4f622a3ff983c8"
      },
      "comments": [
        {
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "body": "@Bren2010 Hi Brendan ! Would you mind please revert the last of the 3 changes. Even though the sentence is not amazing and your change correct, I find it better to keep explicit the fact that the root should not be included, instead of having to infer it from the fact it has no siblings :) Thanks ! ",
          "createdAt": "2018-09-27T05:27:09Z",
          "updatedAt": "2018-09-27T05:27:09Z"
        },
        {
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "body": "You don't have to infer it -- direct paths are defined to never include the root node in the sentence just before.",
          "createdAt": "2018-09-27T06:08:54Z",
          "updatedAt": "2018-09-27T06:08:54Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 66,
      "id": "MDExOlB1bGxSZXF1ZXN0MjE5NDUzODM1",
      "title": "Remove ART",
      "url": "https://github.com/mlswg/mls-protocol/pull/66",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "security",
        "functionality"
      ],
      "body": "There was agreement at the MLS interim of September 2018 to focus further development on TreeKEM, not ART.  This PR implements that change.",
      "createdAt": "2018-10-01T17:26:16Z",
      "updatedAt": "2019-12-17T09:39:44Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "e73cea7d0a8257d50897f8d45410f1902bdc9c42",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "no-art",
      "headRefOid": "1899cbab6da535c466537ef9c62ea4226c0d4096",
      "closedAt": "2018-10-01T20:27:30Z",
      "mergedAt": "2018-10-01T20:27:30Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "9b7d7e91dbcbd190d144b3435b2e5f516a6b6547"
      },
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks for the reviews, @beurdouche and @dwd ",
          "createdAt": "2018-10-01T20:27:25Z",
          "updatedAt": "2018-10-01T20:27:25Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTYwNDAzMTcx",
          "commit": {
            "abbreviatedOid": "67063f3"
          },
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-10-01T17:30:00Z",
          "updatedAt": "2018-10-01T17:31:35Z",
          "comments": [
            {
              "originalPosition": 190,
              "body": "s/primities/primitives",
              "createdAt": "2018-10-01T17:30:00Z",
              "updatedAt": "2018-10-01T20:26:44Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTYwNDA0NzA5",
          "commit": {
            "abbreviatedOid": "2136e1b"
          },
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-10-01T17:34:02Z",
          "updatedAt": "2018-10-01T17:34:02Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTYwNDY0NTI3",
          "commit": {
            "abbreviatedOid": "2136e1b"
          },
          "author": "dwd",
          "authorAssociation": "NONE",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-10-01T20:10:08Z",
          "updatedAt": "2018-10-01T20:13:02Z",
          "comments": [
            {
              "originalPosition": 170,
              "body": "As below, s/primities/primitives/",
              "createdAt": "2018-10-01T20:10:08Z",
              "updatedAt": "2018-10-01T20:26:44Z"
            }
          ]
        }
      ]
    },
    {
      "number": 67,
      "id": "MDExOlB1bGxSZXF1ZXN0MjE5NDY0NzMw",
      "title": "Remove double-join with the \"partial tree\" approach",
      "url": "https://github.com/mlswg/mls-protocol/pull/67",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "enhancement",
        "security"
      ],
      "body": "This PR updates the procedures for Add and Remove to remove double-joins.  The cost is a potential increase in the size of GroupOperation messages in the case of incomplete trees.\r\n\r\nDepends on #66 ",
      "createdAt": "2018-10-01T18:04:19Z",
      "updatedAt": "2019-12-17T09:39:08Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "8b353d63adf2b10df7f6e8ade88e8a996aaf6c63",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "resolution",
      "headRefOid": "082b47553fc3015a07e4dc38ad9fa1fe38bc035d",
      "closedAt": "2018-10-22T11:43:58Z",
      "mergedAt": "2018-10-22T11:43:58Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "53675bf8ea04a57300f13bda13039dd6cca197be"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTYwNDU5MDQ3",
          "commit": {
            "abbreviatedOid": "7a7cd37"
          },
          "author": "josephlhall",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-10-01T19:55:29Z",
          "updatedAt": "2018-10-01T19:55:29Z",
          "comments": [
            {
              "originalPosition": 95,
              "body": "Don't need the twiddles in the markdown if it's not pre-formatted?",
              "createdAt": "2018-10-01T19:55:29Z",
              "updatedAt": "2018-10-21T19:17:59Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTYwNDYwMTU1",
          "commit": {
            "abbreviatedOid": "7a7cd37"
          },
          "author": "josephlhall",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-10-01T19:58:22Z",
          "updatedAt": "2018-10-01T19:58:23Z",
          "comments": [
            {
              "originalPosition": 145,
              "body": "\"node 2 is [] (the empty list)\"",
              "createdAt": "2018-10-01T19:58:22Z",
              "updatedAt": "2018-10-21T19:17:59Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTYwNDYwMjgz",
          "commit": {
            "abbreviatedOid": "7a7cd37"
          },
          "author": "josephlhall",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-10-01T19:58:43Z",
          "updatedAt": "2018-10-01T19:58:43Z",
          "comments": [
            {
              "originalPosition": 146,
              "body": "\"node 3 is the list [A, CD]\"",
              "createdAt": "2018-10-01T19:58:43Z",
              "updatedAt": "2018-10-21T19:17:59Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTYyMjcxNzU2",
          "commit": {
            "abbreviatedOid": "79f6172"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2018-10-06T22:13:46Z",
          "updatedAt": "2018-10-06T22:41:12Z",
          "comments": [
            {
              "originalPosition": 145,
              "body": "This leaks the group secret of the current epoch to the new participant.",
              "createdAt": "2018-10-06T22:13:46Z",
              "updatedAt": "2018-10-21T19:17:59Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTYyMjcyODE3",
          "commit": {
            "abbreviatedOid": "79f6172"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-10-06T23:13:07Z",
          "updatedAt": "2018-10-06T23:13:07Z",
          "comments": [
            {
              "originalPosition": 145,
              "body": "If we go for the solution proposed on the mailing list, this should be the hash of the current group secret and the other members should perform the hash as they process the Add message.",
              "createdAt": "2018-10-06T23:13:07Z",
              "updatedAt": "2018-10-21T19:17:59Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTYyMjg0MTQ0",
          "commit": {
            "abbreviatedOid": "79f6172"
          },
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2018-10-07T09:47:31Z",
          "updatedAt": "2018-10-07T10:21:11Z",
          "comments": [
            {
              "originalPosition": 57,
              "body": "Isn't it the public key of the sibling node to whom you encrypt to and not the public key of the node you send ? \r\nYou compute that one from the new secret, but BTW I don't think we explain how to derive the public enc keys of a node from the secret at the moment.",
              "createdAt": "2018-10-07T09:47:31Z",
              "updatedAt": "2018-10-21T19:17:59Z"
            },
            {
              "originalPosition": 145,
              "body": "I think I have the same understanding here. This must definitely be a hash otherwise it will reveal not only the current epoch secret but also all previous ones defeating basically FS and PCS all together. I can take care of fixing it in a separate PR if you want...",
              "createdAt": "2018-10-07T10:13:40Z",
              "updatedAt": "2018-10-21T19:17:59Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTY2NjA1MDIx",
          "commit": {
            "abbreviatedOid": "79f6172"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-10-19T16:39:25Z",
          "updatedAt": "2018-10-19T16:39:25Z",
          "comments": [
            {
              "originalPosition": 145,
              "body": "You guys have an off-by-one error :)  This is the `init_secret` at the **output** of the current epoch's key schedule, not the input.  So it can't be used to derive the current epoch secret.\r\n\r\nThe whole reason that we have an `init_secret` (as opposed to chaining from one `epoch_secret` to the next) is so that you can give it to someone to allow them to initialize without giving away the current epoch secrets.  \r\n\r\n@beurdouche not sure what you mean about going backward.  Key schedule is all HDKFing along, so it's not reversible.",
              "createdAt": "2018-10-19T16:39:25Z",
              "updatedAt": "2018-10-21T19:17:59Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTY2NjA1MTAx",
          "commit": {
            "abbreviatedOid": "79f6172"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-10-19T16:39:38Z",
          "updatedAt": "2018-10-19T16:39:38Z",
          "comments": [
            {
              "originalPosition": 145,
              "body": "In any case, I'll add some notes to clarify.",
              "createdAt": "2018-10-19T16:39:38Z",
              "updatedAt": "2018-10-21T19:17:59Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTY2NjA5NTA1",
          "commit": {
            "abbreviatedOid": "ad73080"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-10-19T16:52:39Z",
          "updatedAt": "2018-10-19T16:52:39Z",
          "comments": [
            {
              "originalPosition": 57,
              "body": "Suppose you've got the following structure:\r\n\r\n```\r\n   D2\r\n  /  \\\r\n /    \\\r\nD1    Sib\r\n```\r\n\r\n... where `D1` and `D2` are on the direct path, and `Sib` is not.  Then the encrypted value that's transmitted is `(pk(D2), Enc(pk(Sib); secret(D2)))`.  \r\n\r\nI'll revise to try to make this clearer.",
              "createdAt": "2018-10-19T16:52:39Z",
              "updatedAt": "2018-10-21T19:17:59Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTY2NjE2OTE0",
          "commit": {
            "abbreviatedOid": "ad73080"
          },
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-10-19T17:13:52Z",
          "updatedAt": "2018-10-19T17:13:53Z",
          "comments": [
            {
              "originalPosition": 145,
              "body": "Well I understand how you read it but the diagram is ill-numbered then, because the `init_secret` is actually at the *input* of the the key schedule. The very first one is the `init_secret[0] = {0}` and is actually needed.",
              "createdAt": "2018-10-19T17:13:52Z",
              "updatedAt": "2018-10-21T19:17:59Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTY2NjE5NzA0",
          "commit": {
            "abbreviatedOid": "79f6172"
          },
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-10-19T17:21:19Z",
          "updatedAt": "2018-10-19T17:21:20Z",
          "comments": [
            {
              "originalPosition": 145,
              "body": "I don't think you understand us regarding the Group operation transcript. If it is not a hash, it contains all group operation messages since the beginning of the group. You can trivially process all these and compute all keys for all previous application messages hence trivially defeating all secrecy.  It also works for future messages as long as the participant you compromise doesn't update. This needs to be a hash, I don't understand why you would think this is safe. @raphaelrobert ?",
              "createdAt": "2018-10-19T17:21:19Z",
              "updatedAt": "2018-10-21T19:17:59Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTY2NjI4NDUw",
          "commit": {
            "abbreviatedOid": "ad73080"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-10-19T17:44:56Z",
          "updatedAt": "2018-10-19T17:44:56Z",
          "comments": [
            {
              "originalPosition": 145,
              "body": "Oh, I think it is safe because in order to process the GroupOperation messages, you need to have one of the corresponding private keys, which means you need to be in the group!\r\n\r\nI'm happy to convert the transcript to a hash (there's no reason for anyone to have the whole thing, unlike the roster and the tree).  But I don't think it's necessary for this to be secure.",
              "createdAt": "2018-10-19T17:44:56Z",
              "updatedAt": "2018-10-21T19:17:59Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTY2NjM2MDIw",
          "commit": {
            "abbreviatedOid": "ad73080"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-10-19T18:05:03Z",
          "updatedAt": "2018-10-19T18:05:04Z",
          "comments": [
            {
              "originalPosition": 145,
              "body": "cf #73 ",
              "createdAt": "2018-10-19T18:05:04Z",
              "updatedAt": "2018-10-21T19:17:59Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTY2NjM4NTYz",
          "commit": {
            "abbreviatedOid": "ad73080"
          },
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "Ok with #73 ",
          "createdAt": "2018-10-19T18:12:15Z",
          "updatedAt": "2018-10-19T18:12:15Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTY2NzU0MzM0",
          "commit": {
            "abbreviatedOid": "90c452d"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-10-20T16:22:35Z",
          "updatedAt": "2018-10-20T16:22:35Z",
          "comments": [
            {
              "originalPosition": 145,
              "body": "Ok, the terminology was not clear for `init_secret`. If it is the group secret of the next epoch, it works of course.\r\nAnd #73 seems to take care of the transcript (I'll review separately).",
              "createdAt": "2018-10-20T16:22:35Z",
              "updatedAt": "2018-10-21T19:17:59Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTY2NzU0NzU0",
          "commit": {
            "abbreviatedOid": "ad73080"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "I suppose it is because this PR is WIP, but the Remove HS section is still the old one with double-joins.",
          "createdAt": "2018-10-20T16:36:18Z",
          "updatedAt": "2018-10-20T17:01:15Z",
          "comments": [
            {
              "originalPosition": 41,
              "body": "This reads strange (but it's its correct). Maybe go for:\r\n\r\n\"This way the next epoch's group secret is pre-computed for the new member. The current epoch's group secret is not revealed to the new member.\"",
              "createdAt": "2018-10-20T16:36:19Z",
              "updatedAt": "2018-10-21T19:17:59Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTY2Nzk3NDcz",
          "commit": {
            "abbreviatedOid": "082b475"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-10-21T19:22:22Z",
          "updatedAt": "2018-10-21T19:22:22Z",
          "comments": []
        }
      ]
    },
    {
      "number": 68,
      "id": "MDExOlB1bGxSZXF1ZXN0MjIyNjY4ODY0",
      "title": "updating 2119 paragraph",
      "url": "https://github.com/mlswg/mls-protocol/pull/68",
      "state": "MERGED",
      "author": "seanturner",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "Including the \"new\" 2119 paragraph.",
      "createdAt": "2018-10-13T18:58:01Z",
      "updatedAt": "2018-10-14T12:31:18Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "eeecb749e3d74e141786c5574c3c05db8e8cd4ef",
      "headRepository": "seanturner/mls-protocol",
      "headRefName": "2119-lang",
      "headRefOid": "12496ac1fa6f5404d1aedc9cffa1874bd731f4b7",
      "closedAt": "2018-10-14T12:31:18Z",
      "mergedAt": "2018-10-14T12:31:18Z",
      "mergedBy": "beurdouche",
      "mergeCommit": {
        "oid": "69b098c129fd32d4181722bf4492cc80dae6e426"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 69,
      "id": "MDExOlB1bGxSZXF1ZXN0MjIyNjY5MTQ0",
      "title": "renaming s5.1",
      "url": "https://github.com/mlswg/mls-protocol/pull/69",
      "state": "MERGED",
      "author": "seanturner",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "There are two \"Terminology\" sections so I renamed the 2nd one \"Tree Computations Terminology\" to match the reference in s2.",
      "createdAt": "2018-10-13T19:03:16Z",
      "updatedAt": "2018-10-14T12:33:10Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "eeecb749e3d74e141786c5574c3c05db8e8cd4ef",
      "headRepository": "seanturner/mls-protocol",
      "headRefName": "s5.1_title",
      "headRefOid": "d670cd478ff65e51b1d37e8bc518cb8667f1d850",
      "closedAt": "2018-10-14T12:33:10Z",
      "mergedAt": "2018-10-14T12:33:10Z",
      "mergedBy": "beurdouche",
      "mergeCommit": {
        "oid": "939cab2b414518f26ac18b592b1d9ba9c5d6c6e1"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 71,
      "id": "MDExOlB1bGxSZXF1ZXN0MjI0MzU5MDY1",
      "title": "Add explicit key confirmation",
      "url": "https://github.com/mlswg/mls-protocol/pull/71",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "security",
        "functionality"
      ],
      "body": "At the MLS interim, the major feedback regarding authentication was that it would be good practice to provide explicit key confirmation.  This PR adds an explicit confirmation field to Handshake messages, containing a MAC over the proposed (updated) state of the group, together with the latest handshake message.",
      "createdAt": "2018-10-19T17:32:38Z",
      "updatedAt": "2019-12-17T09:38:12Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "d160a02d4729899dfeedbac381a2380661e23993",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "authn-v3",
      "headRefOid": "c55b9f3fb07f0531b08130aa4a0dce29c8fcb516",
      "closedAt": "2018-10-22T12:49:45Z",
      "mergedAt": "2018-10-22T12:49:45Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "4e243852e9abd5391e3a38273322860d6bd58262"
      },
      "comments": [
        {
          "author": "jmillican",
          "authorAssociation": "COLLABORATOR",
          "body": "Reflecting on offline conversation here:\r\n\r\nThis PR derives a new key, then calculates the MAC over both the HS message and the group state; that others verify. PR 72 derives a new key, then sends that to the others to verify they all got the same key. We assume that, as the key was derived from a tree with this group state, it must be correct.\r\n\r\nThese appear to test basically the same property, but I probably prefer this PR unless we can formally verify that they have the same properties (or at least the relevant ones); in which case 72 is a little more efficient.",
          "createdAt": "2018-10-21T19:45:03Z",
          "updatedAt": "2018-10-21T19:45:03Z"
        },
        {
          "author": "jmillican",
          "authorAssociation": "COLLABORATOR",
          "body": "So one question would be under what circumstances would this verify something that won't be verified by failing AEAD on any associated messages that decrypt? Or is it more just that we've now decoupled updates and message sending, so without a failing AEAD we need this to confirm too?",
          "createdAt": "2018-10-21T19:48:39Z",
          "updatedAt": "2018-10-21T19:48:39Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks, @jmillican.  Absolutely agree that this needs more discussion.  I'll send a ping on the list shortly.",
          "createdAt": "2018-10-21T23:27:18Z",
          "updatedAt": "2018-10-21T23:27:18Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "@jmillican To answer your question, yes, the idea here is to fail before you get to the AEAD stage.  In the spec before this PR merged, group members that arrived at different states would have different keys, but they would never find out that was the case until there was an AEAD failure.  With this PR (or #72), a peer know that if processing of a Handshake message succeeds, then it has the same GroupState as the sender.",
          "createdAt": "2018-10-22T12:51:51Z",
          "updatedAt": "2018-10-22T12:51:51Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTY2Nzk4Mjc2",
          "commit": {
            "abbreviatedOid": "c55b9f3"
          },
          "author": "jmillican",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Agreed that we need further discussion with academics, and modelling of the properties, but this seems good to provisionally merge.",
          "createdAt": "2018-10-21T19:49:59Z",
          "updatedAt": "2018-10-21T19:49:59Z",
          "comments": []
        }
      ]
    },
    {
      "number": 72,
      "id": "MDExOlB1bGxSZXF1ZXN0MjI0MzYwNzcw",
      "title": "Add explicit key confirmation (alternate approach)",
      "url": "https://github.com/mlswg/mls-protocol/pull/72",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "duplicate"
      ],
      "body": "This PR is an alternative approach to #71.  Instead of using an explicit MAC, we derive a confirmation value in the key schedule and just publish that.  Since the key schedule already folds in the GroupState (and thus the transcript of GroupOperations), the only gap here is that the signature on the Handshake message isn't included.",
      "createdAt": "2018-10-19T17:40:04Z",
      "updatedAt": "2019-12-17T10:11:25Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "d160a02d4729899dfeedbac381a2380661e23993",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "authn-v3.1",
      "headRefOid": "d4a638ced4276b262c7ff4923870ea662c946398",
      "closedAt": "2019-01-07T22:37:16Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing in light of WG discussion preferring the other approach.",
          "createdAt": "2019-01-07T22:37:16Z",
          "updatedAt": "2019-01-07T22:37:16Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTY2NjM3NDQw",
          "commit": {
            "abbreviatedOid": "d4a638c"
          },
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-10-19T18:09:10Z",
          "updatedAt": "2018-10-19T18:09:11Z",
          "comments": [
            {
              "originalPosition": 25,
              "body": "Can't we send the next `init_secret`instead ?",
              "createdAt": "2018-10-19T18:09:10Z",
              "updatedAt": "2018-10-19T18:09:11Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTY2NjUwODI5",
          "commit": {
            "abbreviatedOid": "d4a638c"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-10-19T18:46:28Z",
          "updatedAt": "2018-10-19T18:46:28Z",
          "comments": [
            {
              "originalPosition": 25,
              "body": "That seems bad, since the `init_secret` feeds into the next `epoch_secret`.  It does get mixed with the `update_secret` there, but it would still would make me even more worried than this proposal does.",
              "createdAt": "2018-10-19T18:46:28Z",
              "updatedAt": "2018-10-19T18:46:28Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTY2NjY1MDI5",
          "commit": {
            "abbreviatedOid": "d4a638c"
          },
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-10-19T19:28:04Z",
          "updatedAt": "2018-10-19T19:28:04Z",
          "comments": [
            {
              "originalPosition": 25,
              "body": "Indeed it is preferable to avoid it. I was just wondering if we can reuse something we already have...",
              "createdAt": "2018-10-19T19:28:04Z",
              "updatedAt": "2018-10-19T19:28:04Z"
            }
          ]
        }
      ]
    },
    {
      "number": 73,
      "id": "MDExOlB1bGxSZXF1ZXN0MjI0MzY0OTM5",
      "title": "Convert transcript to a hash",
      "url": "https://github.com/mlswg/mls-protocol/pull/73",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "enhancement",
        "security",
        "privacy"
      ],
      "body": "There is no reason for the members of a conversation to keep the whole history of group operations, but they should agree on it.",
      "createdAt": "2018-10-19T17:56:23Z",
      "updatedAt": "2019-12-17T09:37:27Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "d160a02d4729899dfeedbac381a2380661e23993",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "transcript-hash",
      "headRefOid": "713d2d90532c90b9cacb426a698eaf4560de3018",
      "closedAt": "2018-10-19T18:46:37Z",
      "mergedAt": "2018-10-19T18:46:37Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "8b353d63adf2b10df7f6e8ade88e8a996aaf6c63"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTY2NjM2OTg4",
          "commit": {
            "abbreviatedOid": "713d2d9"
          },
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-10-19T18:07:47Z",
          "updatedAt": "2018-10-19T18:07:47Z",
          "comments": []
        }
      ]
    },
    {
      "number": 74,
      "id": "MDExOlB1bGxSZXF1ZXN0MjI0NTY1NjY5",
      "title": "Add note that new clients should send an update to preserve efficienc\u2026",
      "url": "https://github.com/mlswg/mls-protocol/pull/74",
      "state": "MERGED",
      "author": "jmillican",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "recommendation",
        "performance"
      ],
      "body": "Add note that new clients should send an update to preserve efficiency of the protocol.",
      "createdAt": "2018-10-21T20:08:30Z",
      "updatedAt": "2019-12-17T09:37:12Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "8b353d63adf2b10df7f6e8ade88e8a996aaf6c63",
      "headRepository": "jmillican/mls-protocol",
      "headRefName": "new_client_updates",
      "headRefOid": "9fb9bf4bd350717d49fd73594d2a0853268f011a",
      "closedAt": "2018-10-21T22:40:49Z",
      "mergedAt": "2018-10-21T22:40:49Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "cd707b3ee6a1ef0e1f8fe8616b6ebb5b574567b3"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTY2ODA0MjEy",
          "commit": {
            "abbreviatedOid": "9fb9bf4"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-10-21T22:40:43Z",
          "updatedAt": "2018-10-21T22:40:43Z",
          "comments": []
        }
      ]
    },
    {
      "number": 75,
      "id": "MDExOlB1bGxSZXF1ZXN0MjI0NjkxMDEz",
      "title": "Editorial fixes pre -02",
      "url": "https://github.com/mlswg/mls-protocol/pull/75",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "",
      "createdAt": "2018-10-22T14:02:13Z",
      "updatedAt": "2019-12-17T09:36:47Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "4e243852e9abd5391e3a38273322860d6bd58262",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "editorial-pre-02",
      "headRefOid": "96ee6caba66e17e44cd9cf1e4f8a572f7e628c76",
      "closedAt": "2018-10-22T14:02:34Z",
      "mergedAt": "2018-10-22T14:02:34Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "a9a6ae277c0502843108bdabb7407e49253624f9"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 77,
      "id": "MDExOlB1bGxSZXF1ZXN0MjMyOTY5MTEz",
      "title": "Trivial fix \"leaf leaf\" to \"the leaf\"",
      "url": "https://github.com/mlswg/mls-protocol/pull/77",
      "state": "MERGED",
      "author": "keaston",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "",
      "createdAt": "2018-11-22T12:51:40Z",
      "updatedAt": "2019-12-17T09:36:41Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "a9a6ae277c0502843108bdabb7407e49253624f9",
      "headRepository": "keaston/mls-protocol",
      "headRefName": "patch-1",
      "headRefOid": "a3da181a9942bb2f6eb739787a3d9cb431f31b3f",
      "closedAt": "2018-11-26T14:41:41Z",
      "mergedAt": "2018-11-26T14:41:41Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "d99882ca4e8d8af57c3d88dd23352c47438a1152"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 78,
      "id": "MDExOlB1bGxSZXF1ZXN0MjM1OTA0ODcw",
      "title": "Change order of fields in UserInitKey struct",
      "url": "https://github.com/mlswg/mls-protocol/pull/78",
      "state": "MERGED",
      "author": "raphaelrobert",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "algorithm is now before identity_key for easier parsing",
      "createdAt": "2018-12-04T17:58:41Z",
      "updatedAt": "2019-12-17T09:36:30Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "d99882ca4e8d8af57c3d88dd23352c47438a1152",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "userinitkey-details",
      "headRefOid": "73c506384b662b0e69e29760c3111ebde3e82c62",
      "closedAt": "2018-12-04T17:59:53Z",
      "mergedAt": "2018-12-04T17:59:53Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "1d6f0276cd0ec57e29205b084c2f5289a80d8815"
      },
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Agreed.  I also ran into this problem in my implementation.",
          "createdAt": "2018-12-04T17:59:47Z",
          "updatedAt": "2018-12-04T17:59:47Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 79,
      "id": "MDExOlB1bGxSZXF1ZXN0MjM1OTEwNzgx",
      "title": "Add ciphersuites and signature schemes",
      "url": "https://github.com/mlswg/mls-protocol/pull/79",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "editorial",
        "recommendation"
      ],
      "body": "Need some actual values here for interop.  Signature scheme values are a subset of those in RFC 8446.\r\n\r\n@raphaelrobert - Do you think we should go ahead and define the higher-security-level ciphersuites as well as signature algorithms?",
      "createdAt": "2018-12-04T18:19:23Z",
      "updatedAt": "2019-12-17T09:35:07Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "1d6f0276cd0ec57e29205b084c2f5289a80d8815",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "ciphersuites",
      "headRefOid": "46b3dc1d8b9d22fe63f595543414e58355bd938b",
      "closedAt": "2018-12-04T18:36:21Z",
      "mergedAt": "2018-12-04T18:36:21Z",
      "mergedBy": "raphaelrobert",
      "mergeCommit": {
        "oid": "4353050b38578c43e65428e9e22527a6a640e2c4"
      },
      "comments": [
        {
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "body": "Looks good to me! We can always re-introduce Ed448 with X448 later.",
          "createdAt": "2018-12-04T18:36:07Z",
          "updatedAt": "2018-12-04T18:36:07Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 80,
      "id": "MDExOlB1bGxSZXF1ZXN0MjQwNjQ1NzQw",
      "title": "Welcome improvements",
      "url": "https://github.com/mlswg/mls-protocol/pull/80",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "bug",
        "editorial",
        "security",
        "privacy"
      ],
      "body": "This PR addresses two outstanding issues with Welcome messages:\r\n\r\n1. Welcome messages were not encrypted for the new member, so that the information in them (in particular, init secrets) were not appropriately protected.\r\n\r\n2. The protocol overview had not been updated to include the Welcome-based add flow.",
      "createdAt": "2018-12-22T17:32:51Z",
      "updatedAt": "2019-12-17T09:34:51Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "4353050b38578c43e65428e9e22527a6a640e2c4",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "welcome-crypt",
      "headRefOid": "8e5cd2acc2bb997345a58892b25e99513917c614",
      "closedAt": "2019-01-04T20:03:54Z",
      "mergedAt": "2019-01-04T20:03:54Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "95fe9d4169c03a7335e3be4d494729c46bd6d752"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTg3NTk4NTYy",
          "commit": {
            "abbreviatedOid": "8e5cd2a"
          },
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-12-22T17:39:36Z",
          "updatedAt": "2018-12-22T17:46:23Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "Note to self: there is no need to send it to the group, indeed. A nice thing might be for the group to have optional knowledge of who invited someone to the group.",
              "createdAt": "2018-12-22T17:39:36Z",
              "updatedAt": "2018-12-22T17:46:23Z"
            }
          ]
        }
      ]
    },
    {
      "number": 81,
      "id": "MDExOlB1bGxSZXF1ZXN0MjQyMzU5MDI0",
      "title": "Bugfixes for GroupState, Welcome and UserInitKeys",
      "url": "https://github.com/mlswg/mls-protocol/pull/81",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "bug",
        "editorial"
      ],
      "body": "This PR fixes several small issues I encountered while bringing my implementation more up to date. \r\n\r\n* When I changed `GroupState` to allow blanks in the tree, I failed to update `Welcome` accordingly\r\n* Credentials should dictate what signature scheme they will be used with, and once that's the case, we no longer need to indicate what algorithm is in use in cases where the signer's credential is known\r\n* `UserInitKeys` should come with a credential, not just a public key\r\n* The confirmation value is easier to parse as an opaque vector value than as an array whose size depends on the ciphersuite in use",
      "createdAt": "2019-01-04T20:03:00Z",
      "updatedAt": "2019-12-17T09:34:17Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "95fe9d4169c03a7335e3be4d494729c46bd6d752",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "bugfixes",
      "headRefOid": "d4ba9a453512d1d723efcf86f517c9bc041fe885",
      "closedAt": "2019-01-07T22:39:20Z",
      "mergedAt": "2019-01-07T22:39:20Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "e76abde308ed36d07907c3777245b187b4f95d17"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTg5NTkxNTM1",
          "commit": {
            "abbreviatedOid": "d4ba9a4"
          },
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-01-05T09:28:57Z",
          "updatedAt": "2019-01-05T09:31:37Z",
          "comments": [
            {
              "originalPosition": 21,
              "body": "Should that just be `Credential` ? Otherwise `BasicCredential` should probably be used in \"UserInitKey\".",
              "createdAt": "2019-01-05T09:28:57Z",
              "updatedAt": "2019-01-05T09:31:37Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTkwMDI0MzQ2",
          "commit": {
            "abbreviatedOid": "d4ba9a4"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-01-07T22:35:49Z",
          "updatedAt": "2019-01-07T22:35:49Z",
          "comments": [
            {
              "originalPosition": 21,
              "body": "`Credential` is the generic object (with a type selector).  `BasicCredential`is a specific type of credential that just lists the required info (without, say, a signature from a CA).",
              "createdAt": "2019-01-07T22:35:49Z",
              "updatedAt": "2019-01-07T22:35:49Z"
            }
          ]
        }
      ]
    },
    {
      "number": 82,
      "id": "MDExOlB1bGxSZXF1ZXN0MjQyMzY1MjI1",
      "title": "Simplify authentication calculations",
      "url": "https://github.com/mlswg/mls-protocol/pull/82",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "enhancement",
        "security"
      ],
      "body": "Looking at the signature and confirmation calculations in the current draft and comparing them to TLS, things seemed a bit complicated.  In TLS, we have the following:\r\n\r\n> CertificateVerify: A signature over the value Transcript-Hash(Handshake Context, Certificate)\r\n> Finished: A MAC over the value Transcript-Hash(Handshake Context, Certificate, CertificateVerify) using a MAC key derived from the base key.\r\n\r\nThis PR implements an analogous computation for MLS, where the signature in a message covers the transcript hash in the latest group state (which includes any changes to the roster ~ Certificate), and the confirmation MAC covers the transcript hash, plus the signature (i.e., the contents of CertificateVerify). ",
      "createdAt": "2019-01-04T20:32:31Z",
      "updatedAt": "2019-12-17T09:33:05Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "e76abde308ed36d07907c3777245b187b4f95d17",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "simplify-authn",
      "headRefOid": "b36ea7cbc0c573814d0762976addfa62e33c4c92",
      "closedAt": "2019-01-11T23:17:30Z",
      "mergedAt": "2019-01-11T23:17:30Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "c24590ebf8bf84e2cd738b45237b55da91861135"
      },
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Merging this despite CI failures because they seem to be spurious.",
          "createdAt": "2019-01-11T23:17:24Z",
          "updatedAt": "2019-01-11T23:17:24Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTg5NTkxMzk2",
          "commit": {
            "abbreviatedOid": "2a86c81"
          },
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-01-05T09:22:32Z",
          "updatedAt": "2019-01-05T09:31:52Z",
          "comments": [
            {
              "originalPosition": 18,
              "body": "Should that be `confirmation_data = signature_data || Handshake.signature` ?\r\n(otherwise `signature_data` seems unused)",
              "createdAt": "2019-01-05T09:22:32Z",
              "updatedAt": "2019-01-07T22:48:29Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTkwMDIzODYy",
          "commit": {
            "abbreviatedOid": "2a86c81"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-01-07T22:34:18Z",
          "updatedAt": "2019-01-07T22:34:18Z",
          "comments": [
            {
              "originalPosition": 18,
              "body": "My intent was that \"signature_data\" would be the input to the signature calculation.  I'll revise to clarify that.",
              "createdAt": "2019-01-07T22:34:18Z",
              "updatedAt": "2019-01-07T22:48:29Z"
            }
          ]
        }
      ]
    },
    {
      "number": 83,
      "id": "MDExOlB1bGxSZXF1ZXN0MjQyNDM1MDgz",
      "title": "Add dependencies for continuous build",
      "url": "https://github.com/mlswg/mls-protocol/pull/83",
      "state": "MERGED",
      "author": "katrielalex",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "weekly-digest"
      ],
      "body": "We need xml2rfc and kramdown-rfc2629 to build the HTML version of the rfc. This adds that information in Ruby (resp Python) syntax so that build tools can pick it up.",
      "createdAt": "2019-01-05T11:19:20Z",
      "updatedAt": "2019-12-17T09:32:38Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "95fe9d4169c03a7335e3be4d494729c46bd6d752",
      "headRepository": "katrielalex/mls-protocol",
      "headRefName": "dependencies-for-build",
      "headRefOid": "7088ab33f1728cf434636d56d498df2832947b1d",
      "closedAt": "2019-01-05T11:21:17Z",
      "mergedAt": "2019-01-05T11:21:17Z",
      "mergedBy": "katrielalex",
      "mergeCommit": {
        "oid": "f9fa240fbb7cf38ad4fca54810b213045046bb4f"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 84,
      "id": "MDExOlB1bGxSZXF1ZXN0MjQ0MTgxMDUy",
      "title": "Garbage collection",
      "url": "https://github.com/mlswg/mls-protocol/pull/84",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "enhancement",
        "performance"
      ],
      "body": "Right now, we blank out leaf nodes when we remove their holders, but we never reduce the size of hte tree or repopulate interior blanks with new members.  This PR adds those functions:\r\n\r\n* Reduce the size of the tree and the roster when you remove from the right edge\r\n* Add an `index` field to the `Add` message, to enable new members to be added to blank slots in the tree, not just at the right edge.\r\n\r\nIn addition to performing \"garbage collection\", this change should make it easier to do a state resync -- just remove the desync'ed endpoint and add them back in the same spot.\r\n\r\nFixes #86 ",
      "createdAt": "2019-01-11T23:51:41Z",
      "updatedAt": "2019-12-17T09:32:27Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "c24590ebf8bf84e2cd738b45237b55da91861135",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "add-in-place",
      "headRefOid": "04027ef3fa995a0f56eebe7ff1c500a0f4462af1",
      "closedAt": "2019-03-06T08:44:27Z",
      "mergedAt": "2019-03-06T08:44:27Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "645961291858d86f74a41b0d9e4f257db9fb96a0"
      },
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "@beurdouche Do you think this is ready to merge?  [Notes from the interim](https://github.com/mlswg/mls-protocol/issues/86#issuecomment-454579285) say it's OK as long as we can convince ourselves that truncation preserves the tree invariant. \r\n\r\nProof sketch: The tree invariant is a universal statement over nodes in the tree and members in the group:  \r\n\r\n![image](https://user-images.githubusercontent.com/75597/52915085-bb96fe80-329d-11e9-84c6-7cea21bd27b8.png)\r\n\r\nSince subtrees are just subsets of the set of nodes in the tree, if the tree invariant holds for a given tree, then it also holds for any subtree of that tree.  So since truncation just moves from a tree to a subtree, the invariant continues to hold.",
          "createdAt": "2019-02-17T15:24:15Z",
          "updatedAt": "2019-02-17T15:24:15Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjEwNTA2ODY5",
          "commit": {
            "abbreviatedOid": "04027ef"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-03-05T06:12:40Z",
          "updatedAt": "2019-03-05T06:12:40Z",
          "comments": []
        }
      ]
    },
    {
      "number": 85,
      "id": "MDExOlB1bGxSZXF1ZXN0MjQ0MTk4NTI3",
      "title": "Update changelong with entries for -03",
      "url": "https://github.com/mlswg/mls-protocol/pull/85",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "I forgot to update the changelog before I published -03.  We should add that to the review criteria.  This will at least fix it for -04.",
      "createdAt": "2019-01-12T03:59:33Z",
      "updatedAt": "2019-12-17T09:32:04Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "c24590ebf8bf84e2cd738b45237b55da91861135",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "changelog",
      "headRefOid": "08c2e06bd1cc59068cfba50c0fcd5f3addcd50f9",
      "closedAt": "2019-01-22T22:02:35Z",
      "mergedAt": "2019-01-22T22:02:35Z",
      "mergedBy": "beurdouche",
      "mergeCommit": {
        "oid": "2c724a84f61b1909f2eca97392a2e8c94e58d0f9"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTk0Mjg1MTU4",
          "commit": {
            "abbreviatedOid": "08c2e06"
          },
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-01-18T21:14:30Z",
          "updatedAt": "2019-01-18T21:14:30Z",
          "comments": []
        }
      ]
    },
    {
      "number": 94,
      "id": "MDExOlB1bGxSZXF1ZXN0MjQ0Mjg4Nzgw",
      "title": "Update of the client/participent/member terminology with Architecture draft",
      "url": "https://github.com/mlswg/mls-protocol/pull/94",
      "state": "MERGED",
      "author": "beurdouche",
      "authorAssociation": "MEMBER",
      "assignees": [
        "beurdouche"
      ],
      "labels": [
        "terminology"
      ],
      "body": "Aligning the terminology across the two documents after discussion.",
      "createdAt": "2019-01-13T16:19:32Z",
      "updatedAt": "2019-12-17T09:31:57Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "953ce6a405380611c148824dabdfb5a5c4b1f59e",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "language",
      "headRefOid": "5eb65332726fe3146c9cfc041e9690805e5dd05e",
      "closedAt": "2019-02-26T16:05:41Z",
      "mergedAt": "2019-02-26T16:05:41Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "2cc376d55fe8ac6fd805b413fc9bbb217fbe784b"
      },
      "comments": [
        {
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "body": "Ok, I think this is ready, please have a look.. I believe the changes are reasonably concise, the use of client seems better in some places than participant was and doesn't feel odd to me.",
          "createdAt": "2019-02-25T15:24:09Z",
          "updatedAt": "2019-02-25T15:24:09Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjA3NDU1Mjg5",
          "commit": {
            "abbreviatedOid": "5bbc64a"
          },
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-02-25T15:25:14Z",
          "updatedAt": "2019-02-25T15:25:15Z",
          "comments": [
            {
              "originalPosition": 154,
              "body": "I'll remove that line in a separate commit, since we currently don't have UserAdd",
              "createdAt": "2019-02-25T15:25:15Z",
              "updatedAt": "2019-02-26T09:13:27Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjA3NDkxNDA5",
          "commit": {
            "abbreviatedOid": "5bbc64a"
          },
          "author": "eomara",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "LGTM",
          "createdAt": "2019-02-25T16:21:49Z",
          "updatedAt": "2019-02-25T16:21:49Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjA3NjgxMDAx",
          "commit": {
            "abbreviatedOid": "5bbc64a"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2019-02-25T23:00:45Z",
          "updatedAt": "2019-02-25T23:08:51Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "Subject/verb agreement \"Users ... needs\".  Re-introducing \"A group of...\" would fix this.",
              "createdAt": "2019-02-25T23:00:45Z",
              "updatedAt": "2019-02-26T09:13:27Z"
            },
            {
              "originalPosition": 28,
              "body": "Let's not capitalize terms, just be consistent.",
              "createdAt": "2019-02-25T23:01:39Z",
              "updatedAt": "2019-02-26T09:13:27Z"
            },
            {
              "originalPosition": 52,
              "body": "This doesn't need a `(\\*)`, since it's not a breaking change.",
              "createdAt": "2019-02-25T23:02:09Z",
              "updatedAt": "2019-02-26T09:13:27Z"
            },
            {
              "originalPosition": 28,
              "body": "Likewise in a bunch of places below.",
              "createdAt": "2019-02-25T23:03:12Z",
              "updatedAt": "2019-02-26T09:13:27Z"
            },
            {
              "originalPosition": 124,
              "body": "This reads awkwardly.  Suggest deleting \", members of a group,\"",
              "createdAt": "2019-02-25T23:05:04Z",
              "updatedAt": "2019-02-26T09:13:27Z"
            },
            {
              "originalPosition": 347,
              "body": "I might rephrase this as \"The client joining the group...\"",
              "createdAt": "2019-02-25T23:07:41Z",
              "updatedAt": "2019-02-26T09:13:27Z"
            },
            {
              "originalPosition": 365,
              "body": "This would read better as singular, \"... the new member SHOULD...\"",
              "createdAt": "2019-02-25T23:08:12Z",
              "updatedAt": "2019-02-26T09:13:27Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjA3ODMxNjQ1",
          "commit": {
            "abbreviatedOid": "4629a73"
          },
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "Done, thanks for the review. I'll let you merge this.",
          "createdAt": "2019-02-26T09:04:06Z",
          "updatedAt": "2019-02-26T09:14:07Z",
          "comments": [
            {
              "originalPosition": 28,
              "body": "I just removed capitalization everywhere.",
              "createdAt": "2019-02-26T09:04:06Z",
              "updatedAt": "2019-02-26T09:14:07Z"
            },
            {
              "originalPosition": 14,
              "body": "Fixed.",
              "createdAt": "2019-02-26T09:04:14Z",
              "updatedAt": "2019-02-26T09:14:07Z"
            },
            {
              "originalPosition": 52,
              "body": "Fixed.",
              "createdAt": "2019-02-26T09:04:22Z",
              "updatedAt": "2019-02-26T09:14:07Z"
            },
            {
              "originalPosition": 124,
              "body": "Fixed.",
              "createdAt": "2019-02-26T09:06:14Z",
              "updatedAt": "2019-02-26T09:14:07Z"
            },
            {
              "originalPosition": 347,
              "body": "Fixed.",
              "createdAt": "2019-02-26T09:07:16Z",
              "updatedAt": "2019-02-26T09:14:07Z"
            },
            {
              "originalPosition": 365,
              "body": "Fixed",
              "createdAt": "2019-02-26T09:08:01Z",
              "updatedAt": "2019-02-26T09:14:07Z"
            },
            {
              "originalPosition": 154,
              "body": "I did that as well.",
              "createdAt": "2019-02-26T09:12:40Z",
              "updatedAt": "2019-02-26T09:14:07Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjA4MDQzODg3",
          "commit": {
            "abbreviatedOid": "5eb6533"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-02-26T15:58:48Z",
          "updatedAt": "2019-02-26T15:58:48Z",
          "comments": []
        }
      ]
    },
    {
      "number": 99,
      "id": "MDExOlB1bGxSZXF1ZXN0MjQ0NTU3MTU2",
      "title": "[ci] Add certified to the bundler dependencies",
      "url": "https://github.com/mlswg/mls-protocol/pull/99",
      "state": "MERGED",
      "author": "katrielalex",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "weekly-digest"
      ],
      "body": "I hypothesise that the CI is failing because I forgot a dependency.\r\n\r\nNot sure that's actually true, but in the spirit of \"move fast and break things\" I'm just merging it anyway and let's see if it fixes it.",
      "createdAt": "2019-01-14T19:20:56Z",
      "updatedAt": "2019-12-17T09:31:03Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "c24590ebf8bf84e2cd738b45237b55da91861135",
      "headRepository": "katrielalex/mls-protocol",
      "headRefName": "certified",
      "headRefOid": "cfeceda1553206ff8f3fc84952197e6b7d239899",
      "closedAt": "2019-01-14T19:24:31Z",
      "mergedAt": "2019-01-14T19:24:31Z",
      "mergedBy": "katrielalex",
      "mergeCommit": {
        "oid": "9723c82a5056576d7e0c7e789896e61404b0e454"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 106,
      "id": "MDExOlB1bGxSZXF1ZXN0MjQ1OTkwMTc2",
      "title": "Small edits: formatting, typos, and wording",
      "url": "https://github.com/mlswg/mls-protocol/pull/106",
      "state": "CLOSED",
      "author": "rozbb",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "beurdouche"
      ],
      "labels": [
        "editorial"
      ],
      "body": "I focused on 3 main things in this edit, which are reflected in the 3 commits:\r\n\r\n1. Looking at the HTML-rendered output, there were some structs that were already backtick-literal and some that were not. For the sake of consistency and readability, I literalized all structs and variable names that occur in prose. I also chose to leave function names alone, since it felt appropriate that they be written in the font of the rest of the paragraph.\r\n2. There were 3 obvious typos. The first one was \"it its\" where it meant \"its\", the second one was \"participants\" where it meant \"participant's\" (I'm sorry, this edit was actually in the formatting commit but it should've been in the typo commit), and the third was was listing \"P-256\" as the hashing algorithm for one of the ciphersuites.\r\n3. There was a lot of wording like \"direct path from the leaf to the root node\" but the wording set up in section 5.1 is \"direct path of the node\", so I changed all instances of the former to the latter for consistency's sake. There were also some uses of \"non-updated sibling\" where the term \"copath\" could be used. I'm least confident about this change, since it sounds a bit obtuse, but it's nice to stick to the terminology that has been used previously.\r\n\r\nOf course, I'm open to any and all disagreements. To whomever reads this: thank you for your time.",
      "createdAt": "2019-01-18T22:22:08Z",
      "updatedAt": "2019-12-17T09:30:31Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "9723c82a5056576d7e0c7e789896e61404b0e454",
      "headRepository": "rozbb/mls-protocol",
      "headRefName": "master",
      "headRefOid": "b02216dff9beb3656bd9b6dddfd833195e6f67c4",
      "closedAt": "2019-01-22T22:01:21Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "body": "Thank you for the review, we'll look into it ASAP.",
          "createdAt": "2019-01-18T22:45:31Z",
          "updatedAt": "2019-01-18T22:45:31Z"
        },
        {
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "body": "This is done, I cherry picked 3 out of 4 commits, made minor corrections and merged the changes via (PR #111) opened an issue for the consistency of using backticks that I will discuss with other editors later (Issue #110). Thanks you, this was helpful !",
          "createdAt": "2019-01-22T22:01:20Z",
          "updatedAt": "2019-01-22T22:01:20Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 109,
      "id": "MDExOlB1bGxSZXF1ZXN0MjQ2NzU5NjAy",
      "title": "Fix typos reported by @rozbb",
      "url": "https://github.com/mlswg/mls-protocol/pull/109",
      "state": "MERGED",
      "author": "beurdouche",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "",
      "createdAt": "2019-01-22T21:32:18Z",
      "updatedAt": "2019-12-17T09:30:23Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "9723c82a5056576d7e0c7e789896e61404b0e454",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "beurdouche_typos",
      "headRefOid": "4e79c4b30736d85f4e197f62af7802a98c9c9515",
      "closedAt": "2019-01-22T21:32:26Z",
      "mergedAt": "2019-01-22T21:32:26Z",
      "mergedBy": "beurdouche",
      "mergeCommit": {
        "oid": "2d24b27744808cf36c5d37453b96c6cb1d3b4608"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 111,
      "id": "MDExOlB1bGxSZXF1ZXN0MjQ2NzY2NTYw",
      "title": "Merging some commits from PR #106",
      "url": "https://github.com/mlswg/mls-protocol/pull/111",
      "state": "MERGED",
      "author": "beurdouche",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "The very first commit from PR #106 (6ba86ff561484a9eb96012e3b55b49f23cb8f9e9) was removed and a separate Issue #110 is filled for unifying the use of \"`\" and \"_\".",
      "createdAt": "2019-01-22T21:57:37Z",
      "updatedAt": "2019-01-22T22:20:16Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "2d24b27744808cf36c5d37453b96c6cb1d3b4608",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "beurdouche_merge_rozbb",
      "headRefOid": "582bf53bdf29d5c0fa2d15440c4547cb6fa81026",
      "closedAt": "2019-01-22T21:58:36Z",
      "mergedAt": "2019-01-22T21:58:36Z",
      "mergedBy": "beurdouche",
      "mergeCommit": {
        "oid": "c7881095922a9a790e0012b5916ccfa929426d93"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 113,
      "id": "MDExOlB1bGxSZXF1ZXN0MjQ2Nzg3Nzcz",
      "title": "Algorithm agility and ciphersuites (Issue #95)",
      "url": "https://github.com/mlswg/mls-protocol/pull/113",
      "state": "CLOSED",
      "author": "beurdouche",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "functionality",
        "? follow-up"
      ],
      "body": "DO NOT MERGE: Work in Progress\r\n\r\nDiscussion: Is this how we should define a ciphersuite -> (KEM,SYM,SIG,HASH) ?",
      "createdAt": "2019-01-22T23:26:03Z",
      "updatedAt": "2019-12-20T10:26:06Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "55183cc33ff09b3a4bc9dbc20e4323ca104661f8",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "beurdouche_ciphersuites",
      "headRefOid": "94c9f928d151cb8d85742932d8e7988cf9a68b4e",
      "closedAt": "2019-07-01T22:23:35Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "In addition to the two comments inline, note that there's an additional complication here due to `Derive-Key-Pair` -- if we do this decoupling, then we need to also have a requirement that the hash function in use produces enough entropy for the curve in use.  E.g., you wouldn't want to use Ed448 with SHA-256.",
          "createdAt": "2019-02-17T15:35:54Z",
          "updatedAt": "2019-02-17T15:35:54Z"
        },
        {
          "author": "katrielalex",
          "authorAssociation": "MEMBER",
          "body": "I am trying to fix up the CI and it looks like this PR is actually broken:\r\n\r\n```\r\n4:13:00 PM: Error: Unable to validate the XML document: draft-ietf-mls-protocol.xml\r\n4:13:00 PM:  <string>: Line 726: IDREF attribute target references an unknown ID \"SHS\"\r\n4:13:00 PM:  <string>: Line 736: IDREF attribute target references an unknown ID \"SHS\"\r\n4:13:00 PM:  <string>: Line 788: IDREF attribute target references an unknown ID \"SHS\"\r\n4:13:00 PM:  <string>: Line 730: IDREF attribute target references an unknown ID \"RFC8032\"\r\n4:13:00 PM:  <string>: Line 694: IDREF attribute target references an unknown ID \"RFC7919\"\r\n4:13:00 PM:  <string>: Line 733: IDREF attribute target references an unknown ID \"RFC8017\"\r\n4:13:00 PM:  <string>: Line 724: IDREF attribute target references an unknown ID \"ECDSA\"\r\n4:13:00 PM:  <string>: Line 691: IDREF attribute target references an unknown ID \"DSS\"\r\n4:13:00 PM:  <string>: Line 725: IDREF attribute target references an unknown ID \"DSS\"\r\n4:13:00 PM:  <string>: Line 727: IDREF attribute target references an unknown ID \"X690\"\r\n4:13:00 PM:  <string>: Line 788: IDREF attribute target references an unknown ID \"RFC7539\"\r\n4:13:00 PM: make: *** [draft-ietf-mls-protocol.htmltmp] Error 1\r\n```",
          "createdAt": "2019-02-17T16:21:07Z",
          "updatedAt": "2019-02-17T16:21:07Z"
        },
        {
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "body": "@bifurcation I'll try to work a bit more on this tomorrow. Anything controversial or missing ?",
          "createdAt": "2019-03-10T17:59:23Z",
          "updatedAt": "2019-03-10T17:59:23Z"
        },
        {
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "body": "Specifically, the next two subsections just before \"Credentials\" should probably be removed or merged.",
          "createdAt": "2019-03-10T18:06:00Z",
          "updatedAt": "2019-03-10T18:06:00Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "I think this one is well stale by now.  Still an issue that merits consideration, but needs a fresh PR.",
          "createdAt": "2019-07-01T22:23:35Z",
          "updatedAt": "2019-07-01T22:23:35Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjA0NTY2NTY3",
          "commit": {
            "abbreviatedOid": "d1f9f2f"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2019-02-17T15:32:31Z",
          "updatedAt": "2019-02-17T15:34:07Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "If we're going to decouple like this, then we should just incorporate the TLS algorithm identifiers by reference.",
              "createdAt": "2019-02-17T15:32:31Z",
              "updatedAt": "2019-02-25T17:55:27Z"
            },
            {
              "originalPosition": 71,
              "body": "Let's not do RSA-PSS.  I don't think anyone is asking for it.",
              "createdAt": "2019-02-17T15:32:59Z",
              "updatedAt": "2019-02-25T17:55:27Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjA3MzUxODY3",
          "commit": {
            "abbreviatedOid": "d1f9f2f"
          },
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-02-25T11:52:00Z",
          "updatedAt": "2019-02-25T11:52:01Z",
          "comments": [
            {
              "originalPosition": 71,
              "body": "I actually agree with this and will remove it. I liked the idea of aligning on TLS but randomness issues related to this are not something we want.",
              "createdAt": "2019-02-25T11:52:00Z",
              "updatedAt": "2019-02-25T17:55:27Z"
            }
          ]
        }
      ]
    },
    {
      "number": 114,
      "id": "MDExOlB1bGxSZXF1ZXN0MjUxNDY0ODAw",
      "title": "Use a KDF instead of a hash function to get keys for parent nodes",
      "url": "https://github.com/mlswg/mls-protocol/pull/114",
      "state": "MERGED",
      "author": "kkohbrok",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "enhancement",
        "security"
      ],
      "body": "For now, I've only touched the sections until the \"Cryptographic Objects\" section, which seems to be outdated anyway. Once those are updated at some point, I'm happy to help moving from hashing to KDF-derivation there as well.",
      "createdAt": "2019-02-08T13:28:48Z",
      "updatedAt": "2019-12-17T09:28:35Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "2c724a84f61b1909f2eca97392a2e8c94e58d0f9",
      "headRepository": "kkohbrok/mls-protocol",
      "headRefName": "master",
      "headRefOid": "6856b0d868c01965c753989545bb93de8728d9cd",
      "closedAt": "2019-02-08T13:43:20Z",
      "mergedAt": "2019-02-08T13:43:20Z",
      "mergedBy": "beurdouche",
      "mergeCommit": {
        "oid": "d43ff0ae3c0fb0c33429f505359ba72b96b00ab1"
      },
      "comments": [
        {
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "body": "Thanks Konrad ! : )",
          "createdAt": "2019-02-08T13:43:37Z",
          "updatedAt": "2019-02-08T13:43:37Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjAxNTgzMTky",
          "commit": {
            "abbreviatedOid": "6856b0d"
          },
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-02-08T13:43:14Z",
          "updatedAt": "2019-02-08T13:43:14Z",
          "comments": []
        }
      ]
    },
    {
      "number": 115,
      "id": "MDExOlB1bGxSZXF1ZXN0MjUxNDk3NzA4",
      "title": "Key Schedule uses the transcript_hash instead of the raw group_state",
      "url": "https://github.com/mlswg/mls-protocol/pull/115",
      "state": "CLOSED",
      "author": "beurdouche",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "enhancement",
        "security"
      ],
      "body": "This is an attempt to solve #90 and #107.",
      "createdAt": "2019-02-08T15:14:10Z",
      "updatedAt": "2019-12-17T09:28:04Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "d43ff0ae3c0fb0c33429f505359ba72b96b00ab1",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "beurdouche_ks",
      "headRefOid": "7fc6322db0407543712be1e7ae16cee321625ce3",
      "closedAt": "2019-02-21T11:27:51Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "body": "Note that there is a need to handle messages that are not exactly Group Operations such as the Welcome message. (I think it should be considered as a Group Operation and be added in the Group State transcript hash)",
          "createdAt": "2019-02-08T15:19:56Z",
          "updatedAt": "2019-02-08T15:19:56Z"
        },
        {
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "body": "Closing this in favor of #123 (which does not touch the way we pass the Group State to Derive Secret at all, we can do this in a different PR if need be.)",
          "createdAt": "2019-02-21T11:27:51Z",
          "updatedAt": "2019-02-21T11:27:51Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjA0NTY2MzY4",
          "commit": {
            "abbreviatedOid": "7fc6322"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2019-02-17T15:27:54Z",
          "updatedAt": "2019-02-17T15:31:21Z",
          "comments": [
            {
              "originalPosition": 60,
              "body": "If you're going to change `Derive-Secret` to `HKDF-Expand-Label`, then you need to chance these instances as well.  Alternatively, you could just define `Derive-Secret` in terms of `HKDF-Expand-Label`, basically as an abbreviation to make this diagram flow better.",
              "createdAt": "2019-02-17T15:27:55Z",
              "updatedAt": "2019-02-17T15:31:21Z"
            },
            {
              "originalPosition": 61,
              "body": "I would prefer that we not make this change, i.e., that we set the context to the serialized group state.  Changing from the group state to the transcript hash has bigger implications than just changing how the hashes are arranged.  That is, let's do #107 in this PR, and #90 later.  Note that this would also obviate the OPEN ISSUE below.",
              "createdAt": "2019-02-17T15:29:20Z",
              "updatedAt": "2019-02-17T15:31:21Z"
            },
            {
              "originalPosition": 106,
              "body": "Nit: Extra blank line.",
              "createdAt": "2019-02-17T15:30:31Z",
              "updatedAt": "2019-02-17T15:31:21Z"
            },
            {
              "originalPosition": 98,
              "body": "You could note here that this is the same as the TLS encoding of `sender` as a `uint32`.  Which is probably in fact how I would implement it.",
              "createdAt": "2019-02-17T15:31:11Z",
              "updatedAt": "2019-02-17T15:31:21Z"
            }
          ]
        }
      ]
    },
    {
      "number": 116,
      "id": "MDExOlB1bGxSZXF1ZXN0MjUxNTAyMTkx",
      "title": "Rename ECIES to HPKE",
      "url": "https://github.com/mlswg/mls-protocol/pull/116",
      "state": "MERGED",
      "author": "beurdouche",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "terminology"
      ],
      "body": "This does not handle the removal of DH uses instead of KEM which will be done as part of Issue #95 / PR #113 ...",
      "createdAt": "2019-02-08T15:27:18Z",
      "updatedAt": "2019-12-17T09:25:19Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "d43ff0ae3c0fb0c33429f505359ba72b96b00ab1",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "beurdouche_hpke",
      "headRefOid": "08c4f25a17656a85a7ab537da1160d9d769b201f",
      "closedAt": "2019-02-21T10:59:53Z",
      "mergedAt": "2019-02-21T10:59:53Z",
      "mergedBy": "beurdouche",
      "mergeCommit": {
        "oid": "07a1b0a3703a5930a1a2dece74d05aadbd1b15e7"
      },
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "I would be happier if this PR were moving the draft to use draft-barnes-cfrg-hpke, which is one of the changes I had in mind for -04.  Do you think that's premature?",
          "createdAt": "2019-02-17T15:14:18Z",
          "updatedAt": "2019-02-17T15:14:18Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjA0NTY1NDE5",
          "commit": {
            "abbreviatedOid": "6dff904"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2019-02-17T15:04:38Z",
          "updatedAt": "2019-02-17T15:12:25Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "Since we're moving to a more KEM-like framework, it might be good to also change this from `ephemeral_key` to something like `encapsulated_key`.\r\n\r\nAlso, while you're working here, please go ahead and increase the size of the `ciphertext` field.",
              "createdAt": "2019-02-17T15:04:38Z",
              "updatedAt": "2019-02-21T10:58:00Z"
            },
            {
              "originalPosition": 16,
              "body": "Also, the reason I had `DH` there was to distinguish from `SignaturePublicKey`.  Just having `PubilcKey` vs. `SignaturePublicKey` seems less clear.  What about `KEMPublicKey` or `HPKEPublicKey`?",
              "createdAt": "2019-02-17T15:06:08Z",
              "updatedAt": "2019-02-21T10:58:00Z"
            },
            {
              "originalPosition": 60,
              "body": "I'm inclined to go ahead and change this out for a reference to the CFRG HPKE draft.  If that doesn't get adopted by CFRG for some reason, we can always revert.",
              "createdAt": "2019-02-17T15:10:53Z",
              "updatedAt": "2019-02-21T10:58:00Z"
            },
            {
              "originalPosition": 89,
              "body": "This OPEN ISSUE can be deleted.  The Welcome Message is encrypted as of -03; I just neglected to remove this comment.",
              "createdAt": "2019-02-17T15:12:18Z",
              "updatedAt": "2019-02-21T10:58:00Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjA0NzE5MDIw",
          "commit": {
            "abbreviatedOid": "6dff904"
          },
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-02-18T10:35:17Z",
          "updatedAt": "2019-02-18T11:07:08Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "Using `encapsulated_key` and `KEMPublicKey` look ok, yes.",
              "createdAt": "2019-02-18T10:35:18Z",
              "updatedAt": "2019-02-21T10:58:00Z"
            },
            {
              "originalPosition": 89,
              "body": "Fixed.",
              "createdAt": "2019-02-18T10:44:12Z",
              "updatedAt": "2019-02-21T10:58:00Z"
            },
            {
              "originalPosition": 60,
              "body": "Ok, I removed the description and added an informative reference to HPKE.",
              "createdAt": "2019-02-18T11:01:42Z",
              "updatedAt": "2019-02-21T10:58:00Z"
            },
            {
              "originalPosition": 16,
              "body": "I removed this as we can point to the HPKE draft to get how the HPKECiphertext is internally organized.\r\nThere is still a sentence saying what the argument of HPKE Encrypt (node_secrets) are.",
              "createdAt": "2019-02-18T11:06:36Z",
              "updatedAt": "2019-02-21T10:58:00Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjA2MjQyMTkw",
          "commit": {
            "abbreviatedOid": "08c4f25"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-02-21T10:59:22Z",
          "updatedAt": "2019-02-21T10:59:22Z",
          "comments": []
        }
      ]
    },
    {
      "number": 120,
      "id": "MDExOlB1bGxSZXF1ZXN0MjUzNzIzNDE1",
      "title": "WIP: Introduce a common framing layer",
      "url": "https://github.com/mlswg/mls-protocol/pull/120",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "enhancement",
        "security"
      ],
      "body": "This PR introduces a common framing layer that is used to encapsulate both Handshake and Application messages, encrypted or unencrypted.  The most significant impact is that in order to make signing logic common to both of these cases, the signature now covers only the message in question, as opposed to also covering the transcript.    \r\n\r\nFixes #101 ",
      "createdAt": "2019-02-17T16:44:23Z",
      "updatedAt": "2019-12-17T09:25:09Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "2cc376d55fe8ac6fd805b413fc9bbb217fbe784b",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "common-framing",
      "headRefOid": "304fd874a0dffba54c1f2fc161b401fd9898cc3b",
      "closedAt": "2019-04-22T21:24:42Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "body": "As a general rule, I think we should not prefix structs with \"MLS\" as it adds no semantic value",
          "createdAt": "2019-02-27T09:34:02Z",
          "updatedAt": "2019-02-27T09:34:02Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "I added some prose in the latest round of commits that should clarify what's going on here.  I think that should address most of the comments. \r\n\r\n@raphaelrobert - regarding the \"MLS\" prefix, I'm inclined to keep it, because (1) it mirrors TLS, and (2) just having Plaintext and Ciphertext seems odd to me.",
          "createdAt": "2019-02-27T23:34:01Z",
          "updatedAt": "2019-02-27T23:34:01Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing in favor of #131 ",
          "createdAt": "2019-04-22T21:24:42Z",
          "updatedAt": "2019-04-22T21:24:42Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjA4NDAzMDMx",
          "commit": {
            "abbreviatedOid": "72c6fda"
          },
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "state": "CHANGES_REQUESTED",
          "body": "How to handle the application secret generation in this common framework is interesting, we can either always include it or having it only in the case of Application messages which will degrade the symmetry.",
          "createdAt": "2019-02-27T09:04:45Z",
          "updatedAt": "2019-02-27T09:27:38Z",
          "comments": [
            {
              "originalPosition": 20,
              "body": "The signature must cover everything including the content type",
              "createdAt": "2019-02-27T09:04:45Z",
              "updatedAt": "2019-02-27T23:31:35Z"
            },
            {
              "originalPosition": 18,
              "body": "`sig_len` is undefined.",
              "createdAt": "2019-02-27T09:06:23Z",
              "updatedAt": "2019-02-27T23:31:35Z"
            },
            {
              "originalPosition": 19,
              "body": "If we are gonna do this, I would prefer `opaque signature<0..2^16-1>`\r\notherwise if the ciphersuite* gives the length of the signature we don't need this.",
              "createdAt": "2019-02-27T09:07:30Z",
              "updatedAt": "2019-02-27T23:31:35Z"
            },
            {
              "originalPosition": 35,
              "body": "I am confused now, why is there a second signature here ?\r\nIn both cases there is a signature that covers the content of `group_id`, `epoch`, `sender` and `content type` no ?",
              "createdAt": "2019-02-27T09:09:06Z",
              "updatedAt": "2019-02-27T23:31:35Z"
            },
            {
              "originalPosition": 42,
              "body": "While this is weakly-authenticated via the AEAD it should be in the MLSPlaintext header as well and covered by the signature (especially in the case of an Application message) to avoid forgery from an adversarial member who is not the sender.",
              "createdAt": "2019-02-27T09:12:35Z",
              "updatedAt": "2019-02-27T23:31:35Z"
            },
            {
              "originalPosition": 153,
              "body": "I can do that when this PR is merged.",
              "createdAt": "2019-02-27T09:13:30Z",
              "updatedAt": "2019-02-27T23:31:35Z"
            },
            {
              "originalPosition": 42,
              "body": "It is also worth noting that this field even if not technically needed in the case of a Handshake message might be able to use this to advertise a counter for application messages previously sent by the sender, hence allowing recipients to know if they received all app messages from the sender. We could limit that to the previous epoch or not... Maybe there is something there or not...",
              "createdAt": "2019-02-27T09:18:44Z",
              "updatedAt": "2019-02-27T23:31:35Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjA4NDIwNjc3",
          "commit": {
            "abbreviatedOid": "72c6fda"
          },
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-02-27T09:42:07Z",
          "updatedAt": "2019-02-27T09:42:08Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "Why would content ever be labelled invalid?",
              "createdAt": "2019-02-27T09:42:07Z",
              "updatedAt": "2019-02-27T23:31:35Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjA4NDI2Mjc1",
          "commit": {
            "abbreviatedOid": "72c6fda"
          },
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-02-27T09:53:18Z",
          "updatedAt": "2019-02-27T10:08:51Z",
          "comments": [
            {
              "originalPosition": 36,
              "body": "Do we need another epoch field, as well as another group_id field? Both should be implicitly verified upon successful decryption with the group secret from the epoch contained in MLSCiphertext, right?",
              "createdAt": "2019-02-27T09:59:17Z",
              "updatedAt": "2019-02-27T23:31:35Z"
            },
            {
              "originalPosition": 44,
              "body": "What do we need the sender field for in MLSCiphertext? We might even get some sort of identity hiding if we leave it out :-)",
              "createdAt": "2019-02-27T10:02:36Z",
              "updatedAt": "2019-02-27T23:31:35Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjA4NDM0NDI5",
          "commit": {
            "abbreviatedOid": "72c6fda"
          },
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-02-27T10:09:49Z",
          "updatedAt": "2019-02-27T10:09:50Z",
          "comments": [
            {
              "originalPosition": 42,
              "body": "What is the generation field for exactly?",
              "createdAt": "2019-02-27T10:09:49Z",
              "updatedAt": "2019-02-27T23:31:35Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjA4NDM2ODk5",
          "commit": {
            "abbreviatedOid": "72c6fda"
          },
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-02-27T10:14:31Z",
          "updatedAt": "2019-02-27T10:14:32Z",
          "comments": [
            {
              "originalPosition": 35,
              "body": "On the contrary, the inner one is the one we use, you don't want to sign a large padding.\r\nWhat is important is that the inner one must cover those fields as done the message protection section.",
              "createdAt": "2019-02-27T10:14:31Z",
              "updatedAt": "2019-02-27T23:31:35Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjA4NDM4MjY1",
          "commit": {
            "abbreviatedOid": "72c6fda"
          },
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-02-27T10:17:03Z",
          "updatedAt": "2019-02-27T10:17:04Z",
          "comments": [
            {
              "originalPosition": 36,
              "body": "We do not need to actually copy them twice indeed, only the outer one in `Ciphertext` is needed, but they need to be covered by both the AEAD and the internal signature.",
              "createdAt": "2019-02-27T10:17:04Z",
              "updatedAt": "2019-02-27T23:31:35Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjA4NDQxOTc4",
          "commit": {
            "abbreviatedOid": "72c6fda"
          },
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-02-27T10:24:32Z",
          "updatedAt": "2019-02-27T10:24:32Z",
          "comments": [
            {
              "originalPosition": 35,
              "body": "Ok, then we're assuming that `group_id`, `sender` and `epoch` are still part of the `Handshake` struct? I was wondering if we could somehow avoid redundancy here.",
              "createdAt": "2019-02-27T10:24:32Z",
              "updatedAt": "2019-02-27T23:31:35Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjA4NDY1NzAx",
          "commit": {
            "abbreviatedOid": "72c6fda"
          },
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-02-27T11:15:13Z",
          "updatedAt": "2019-02-27T11:15:14Z",
          "comments": [
            {
              "originalPosition": 28,
              "body": "My initial interpretation was incorrect but, if I am correct now, above this should be removed.",
              "createdAt": "2019-02-27T11:15:13Z",
              "updatedAt": "2019-02-27T23:31:35Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjA4NDY4MDAz",
          "commit": {
            "abbreviatedOid": "72c6fda"
          },
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-02-27T11:20:01Z",
          "updatedAt": "2019-02-27T11:20:02Z",
          "comments": [
            {
              "originalPosition": 44,
              "body": "I was misunderstanding Richard's idea at first. I believe the idea is to encrypt the `Plaintext` with different keys depending if it is `Handshake` or `Application`. In that scenario, you need the `sender` and the `generation` in the clear to know which key to pick in the case of an Application message. Note that @raphaelrobert and I are thinking on suggesting to encrypt these under the the group key to hide them if necessary, we'll discuss this at some point. *Note that if this is the intent here, the ContentType must also be outside to know if this is an Application message or an Handshake message*.",
              "createdAt": "2019-02-27T11:20:01Z",
              "updatedAt": "2019-02-27T23:31:35Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjA4NDY4Njk2",
          "commit": {
            "abbreviatedOid": "72c6fda"
          },
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-02-27T11:21:46Z",
          "updatedAt": "2019-02-27T11:21:46Z",
          "comments": [
            {
              "originalPosition": 44,
              "body": "Why do you need the sender, though? Both handshake and application keys derived from the groupkey should be sender-independent.",
              "createdAt": "2019-02-27T11:21:46Z",
              "updatedAt": "2019-02-27T23:31:35Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjA4NDcyNTcx",
          "commit": {
            "abbreviatedOid": "72c6fda"
          },
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-02-27T11:30:59Z",
          "updatedAt": "2019-02-27T11:31:00Z",
          "comments": [
            {
              "originalPosition": 44,
              "body": "Which key do you pick when receiving an application message ? :) ",
              "createdAt": "2019-02-27T11:30:59Z",
              "updatedAt": "2019-02-27T23:31:35Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjA4NDgwMDk2",
          "commit": {
            "abbreviatedOid": "72c6fda"
          },
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-02-27T11:49:56Z",
          "updatedAt": "2019-02-27T11:49:56Z",
          "comments": [
            {
              "originalPosition": 44,
              "body": "I'm confused. The key for handshake encryption is derived from the `group_key`, right? So why do we need to know the sender? We only need the `group_id` and the `epoch` to derive the key if I understand correctly.",
              "createdAt": "2019-02-27T11:49:56Z",
              "updatedAt": "2019-02-27T23:31:35Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjA4NTI1NjMz",
          "commit": {
            "abbreviatedOid": "72c6fda"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-02-27T13:39:04Z",
          "updatedAt": "2019-02-27T13:39:04Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "The idea is that the ContentType is used to mark where the padding bytes (all zero) end, so it needs to be non-zero.",
              "createdAt": "2019-02-27T13:39:04Z",
              "updatedAt": "2019-02-27T23:31:35Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjA4OTEwOTY3",
          "commit": {
            "abbreviatedOid": "304fd87"
          },
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-02-28T06:43:48Z",
          "updatedAt": "2019-02-28T06:43:49Z",
          "comments": [
            {
              "originalPosition": 242,
              "body": "Do I understand correctly that the fields that represent information that is shared between the different structs are not actually part of the encoded data structure but rather are just meant to be pointers to the respective \"outer\" struct? If that is the case, I think we should stay true to the principle of having the structs represent what is actually part of the data structure that is encoded and not what is composed locally to compute signatures. Please do correct me if I'm wrong in my understanding of the spec here.",
              "createdAt": "2019-02-28T06:43:49Z",
              "updatedAt": "2019-02-28T06:43:49Z"
            }
          ]
        }
      ]
    },
    {
      "number": 121,
      "id": "MDExOlB1bGxSZXF1ZXN0MjUzNzI0MDQ5",
      "title": "cleanup netlify bundle cache before building",
      "url": "https://github.com/mlswg/mls-protocol/pull/121",
      "state": "MERGED",
      "author": "katrielalex",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "weekly-digest"
      ],
      "body": "",
      "createdAt": "2019-02-17T16:53:35Z",
      "updatedAt": "2019-12-17T09:24:52Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "d43ff0ae3c0fb0c33429f505359ba72b96b00ab1",
      "headRepository": "katrielalex/mls-protocol",
      "headRefName": "remove-insecure-content",
      "headRefOid": "661ff0adb31e403488f83cabea1c55278946381d",
      "closedAt": "2019-02-17T17:04:35Z",
      "mergedAt": "2019-02-17T17:04:35Z",
      "mergedBy": "katrielalex",
      "mergeCommit": {
        "oid": "f60def4a09159e073075d0f14c7545d3f77600d7"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 122,
      "id": "MDExOlB1bGxSZXF1ZXN0MjU0NjU0Mzcz",
      "title": "fix small typo in GroupState struct",
      "url": "https://github.com/mlswg/mls-protocol/pull/122",
      "state": "MERGED",
      "author": "kkohbrok",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": ":-)",
      "createdAt": "2019-02-20T14:17:14Z",
      "updatedAt": "2019-12-17T09:24:29Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "f60def4a09159e073075d0f14c7545d3f77600d7",
      "headRepository": "kkohbrok/mls-protocol",
      "headRefName": "master",
      "headRefOid": "439f4c5bd4fa3887d71e344acf70a96b7e0fd25c",
      "closedAt": "2019-02-20T20:41:43Z",
      "mergedAt": "2019-02-20T20:41:43Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "b78817cc5e7c2fc1c12ab85d5faa96b474941435"
      },
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks, @kkohbrok !",
          "createdAt": "2019-02-20T20:41:28Z",
          "updatedAt": "2019-02-20T20:41:28Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjA1OTg4MTg4",
          "commit": {
            "abbreviatedOid": "439f4c5"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-02-20T20:41:35Z",
          "updatedAt": "2019-02-20T20:41:35Z",
          "comments": []
        }
      ]
    },
    {
      "number": 123,
      "id": "MDExOlB1bGxSZXF1ZXN0MjU0OTg1ODAy",
      "title": "Fix for Application Key Schedule and define HKDF-Expand-Label",
      "url": "https://github.com/mlswg/mls-protocol/pull/123",
      "state": "MERGED",
      "author": "beurdouche",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "Fix for #107",
      "createdAt": "2019-02-21T11:26:37Z",
      "updatedAt": "2019-12-17T09:24:22Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "07a1b0a3703a5930a1a2dece74d05aadbd1b15e7",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "beurdouche_aks",
      "headRefOid": "f5c57dbbc4f3cd8b2e5cd80f933f4ba67362de9e",
      "closedAt": "2019-02-21T11:40:08Z",
      "mergedAt": "2019-02-21T11:40:08Z",
      "mergedBy": "beurdouche",
      "mergeCommit": {
        "oid": "bb233f54baa405d2097e1e8b29275ca2fb77b889"
      },
      "comments": [
        {
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "body": "@bifurcation This might not be completely ideal, because of the group state but it currently does not change the key schedule, I am merging this because we need it for correct interop but feel free to get back to discuss a better way to do this in details.",
          "createdAt": "2019-02-21T11:39:58Z",
          "updatedAt": "2019-02-21T11:39:58Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjA2MjU2Njg5",
          "commit": {
            "abbreviatedOid": "9bfc544"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-02-21T11:35:47Z",
          "updatedAt": "2019-02-21T11:35:47Z",
          "comments": []
        }
      ]
    },
    {
      "number": 124,
      "id": "MDExOlB1bGxSZXF1ZXN0MjU1MDMwMzAz",
      "title": "Message protection improvements",
      "url": "https://github.com/mlswg/mls-protocol/pull/124",
      "state": "MERGED",
      "author": "raphaelrobert",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "bug",
        "editorial"
      ],
      "body": " - Specify padding length\r\n - Rename struct Application to ApplicationMessage",
      "createdAt": "2019-02-21T13:50:21Z",
      "updatedAt": "2019-12-17T09:23:54Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "4803d5f85902e09dbcd01806191deaca1c7984c3",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "raphaelrobert-messageprotection",
      "headRefOid": "332cb79e143fd9773da1f46d52be641f9a845380",
      "closedAt": "2019-02-21T14:41:31Z",
      "mergedAt": "2019-02-21T14:41:31Z",
      "mergedBy": "beurdouche",
      "mergeCommit": {
        "oid": "43f92bfd13a4e4e1b7066d149ecb1d9e34c7ee79"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjA2MzQwMjMx",
          "commit": {
            "abbreviatedOid": "332cb79"
          },
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-02-21T14:41:22Z",
          "updatedAt": "2019-02-21T14:41:22Z",
          "comments": []
        }
      ]
    },
    {
      "number": 126,
      "id": "MDExOlB1bGxSZXF1ZXN0MjU1NjA2ODI2",
      "title": "Editorial: some fixes for #108",
      "url": "https://github.com/mlswg/mls-protocol/pull/126",
      "state": "MERGED",
      "author": "beurdouche",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "Fixes for points 1, 2, 4, 7 in #108.",
      "createdAt": "2019-02-23T10:52:48Z",
      "updatedAt": "2019-03-10T18:08:42Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "55183cc33ff09b3a4bc9dbc20e4323ca104661f8",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "beurdouche_108",
      "headRefOid": "f450134461bfe95504d0c6fdc83a60f8c804eff4",
      "closedAt": "2019-02-25T22:27:06Z",
      "mergedAt": "2019-02-25T22:27:06Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "759389f547817016f58a7de5af22e299fd4ba255"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjA3NjY4MzAw",
          "commit": {
            "abbreviatedOid": "f450134"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-02-25T22:26:57Z",
          "updatedAt": "2019-02-25T22:26:57Z",
          "comments": []
        }
      ]
    },
    {
      "number": 127,
      "id": "MDExOlB1bGxSZXF1ZXN0MjU1ODM0MTIx",
      "title": "Rephrased sentence in Add section.",
      "url": "https://github.com/mlswg/mls-protocol/pull/127",
      "state": "MERGED",
      "author": "kkohbrok",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "There is no \"leaf_secret\" field in GroupState. While there might be one in the group state struct that the implementation maintains locally, I think it's safe to recommend copying everything from the GroupState object as it's defined earlier in the document.",
      "createdAt": "2019-02-25T10:28:16Z",
      "updatedAt": "2019-12-17T09:22:27Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "55183cc33ff09b3a4bc9dbc20e4323ca104661f8",
      "headRepository": "kkohbrok/mls-protocol",
      "headRefName": "master",
      "headRefOid": "7a0b47676a5df8e54024e0ed0e0ea21d459c9061",
      "closedAt": "2019-02-25T22:30:24Z",
      "mergedAt": "2019-02-25T22:30:24Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "524fbec5d97fd7a6888bfcd26b7269711b6c95df"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjA3NjY5Mjk2",
          "commit": {
            "abbreviatedOid": "7a0b476"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-02-25T22:29:26Z",
          "updatedAt": "2019-02-25T22:29:26Z",
          "comments": []
        }
      ]
    },
    {
      "number": 128,
      "id": "MDExOlB1bGxSZXF1ZXN0MjU1OTkzOTU5",
      "title": "Multiple minor editorial fixes",
      "url": "https://github.com/mlswg/mls-protocol/pull/128",
      "state": "MERGED",
      "author": "beurdouche",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "",
      "createdAt": "2019-02-25T18:15:26Z",
      "updatedAt": "2019-03-10T18:08:40Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "55183cc33ff09b3a4bc9dbc20e4323ca104661f8",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "beurdouche_editorial",
      "headRefOid": "a380ef7b790cc92578906c29217fe2b0076c5e76",
      "closedAt": "2019-02-26T08:55:11Z",
      "mergedAt": "2019-02-26T08:55:11Z",
      "mergedBy": "beurdouche",
      "mergeCommit": {
        "oid": "953ce6a405380611c148824dabdfb5a5c4b1f59e"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjA3NjgwNTAy",
          "commit": {
            "abbreviatedOid": "07c2518"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "I'm approving these changes given the current state of the document, but I filed #129 because the KDF stuff is broken.\r\n\r\nPlease make HPKE a normative reference (since it's required to implement).  Since it's an Internet-Draft, you don't need to add it to the references section, you can just reference it directly as `{{!I-D.barnes-cfrg-hpke}}` and the Markdown processor will add the reference.  (Change the `!` to `?` for an informative reference.)",
          "createdAt": "2019-02-25T22:59:16Z",
          "updatedAt": "2019-02-25T22:59:16Z",
          "comments": []
        }
      ]
    },
    {
      "number": 131,
      "id": "MDExOlB1bGxSZXF1ZXN0MjU2NjQ1Nzky",
      "title": "Legacy - Common Framing serving as a base for PR  #153 and #155",
      "url": "https://github.com/mlswg/mls-protocol/pull/131",
      "state": "CLOSED",
      "author": "beurdouche",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "duplicate"
      ],
      "body": "Alternative to #120 to solve #101",
      "createdAt": "2019-02-27T11:39:35Z",
      "updatedAt": "2019-12-17T10:12:56Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "3b8b9350dc5f1d21cf52714208e3af4fbeab7998",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "beurdouche_101",
      "headRefOid": "be8f5a4a548b0e4c4f603e06de740c7def97918a",
      "closedAt": "2019-05-01T02:12:24Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "body": "Current todo before we can merge this: Proverif/Tamarin model. The intuition is that this is fine because the signature covers all the metadata, to be safe, the second AAD could take the ciphertext of the sender data + tag...",
          "createdAt": "2019-04-04T19:29:16Z",
          "updatedAt": "2019-04-04T19:29:16Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjIyOTk4MzU4",
          "commit": {
            "abbreviatedOid": "8980d61"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2019-04-04T20:56:40Z",
          "updatedAt": "2019-04-04T21:10:13Z",
          "comments": [
            {
              "originalPosition": 18,
              "body": "If you're going to use `Derive-Secret`, you need to derive an intermediate secret, not a key, since `Derive-Secret` produces an output of size Hash.length.  If you want to derive a key here, you want `HKDF-Expand-Label`. \r\n\r\nIt's an extra hash invocation, but it seems a bit more consistent to derive a handshake_secret and handshake_encryption_key",
              "createdAt": "2019-04-04T20:56:40Z",
              "updatedAt": "2019-04-05T08:27:37Z"
            },
            {
              "originalPosition": 32,
              "body": "`marker = 1`",
              "createdAt": "2019-04-04T20:57:09Z",
              "updatedAt": "2019-04-05T08:27:37Z"
            },
            {
              "originalPosition": 53,
              "body": "Nit: I would call this `sender_data_nonce`",
              "createdAt": "2019-04-04T21:02:35Z",
              "updatedAt": "2019-04-05T08:27:37Z"
            },
            {
              "originalPosition": 45,
              "body": "I would prefer if this struct had everything that was not necessary for encryption.  That way if you're not encrypting Handshake messages, you just send this struct instead.  So I would add back:\r\n\r\n* Group ID\r\n* Content type\r\n* Signature",
              "createdAt": "2019-04-04T21:03:33Z",
              "updatedAt": "2019-04-05T08:27:37Z"
            }
          ]
        }
      ]
    },
    {
      "number": 132,
      "id": "MDExOlB1bGxSZXF1ZXN0MjU3MDQ4NDU5",
      "title": "Some propositions for minor changes in structure and wording of the Handshake section.",
      "url": "https://github.com/mlswg/mls-protocol/pull/132",
      "state": "CLOSED",
      "author": "kkohbrok",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "The handshake section felt a bit \"flat\" to me, so I introduced some more structure. Also, every section describing the handling of the individual message types mentioned verifying the signature, which was already covered in the general description of how to handle Handshake messages. I realize this Section might change somewhat with the generic framing approach, so feel free to ignore this particular PR, if you want to tackle these points there.\r\n\r\nUpdate: I also found what I think is an small error in the instructions of how to process an Add message: The position of the newly added credential in the list of members has to match the position of the newly added leaf node in the tree. This necessitates that it happens _after_ the leaf node is added. The last commit updates the Add instructions accordingly.",
      "createdAt": "2019-02-28T12:21:52Z",
      "updatedAt": "2019-12-17T09:20:44Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "2cc376d55fe8ac6fd805b413fc9bbb217fbe784b",
      "headRepository": "kkohbrok/mls-protocol",
      "headRefName": "master",
      "headRefOid": "d64909c8875f7f953b4b472d7a03e014dd34267d",
      "closedAt": "2019-05-16T15:02:56Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The text has changed quite a bit in the meantime and I don't think my comments are very relevant anymore.\r\n\r\nClosing.",
          "createdAt": "2019-05-16T15:02:56Z",
          "updatedAt": "2019-05-16T15:02:56Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 133,
      "id": "MDExOlB1bGxSZXF1ZXN0MjU4MTkxOTI0",
      "title": "Add version negotiation fields",
      "url": "https://github.com/mlswg/mls-protocol/pull/133",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "functionality"
      ],
      "body": "This just adds some fields for devices to declare their version support in UserInitKey and for group members to declare what version the group is using in WelcomeInfo.  Obviously, more subtlety will be needed, but this seems like an OK shim for -04.\r\n\r\nCf. #105 ",
      "createdAt": "2019-03-05T05:44:49Z",
      "updatedAt": "2019-12-17T09:20:28Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "2cc376d55fe8ac6fd805b413fc9bbb217fbe784b",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "versioning",
      "headRefOid": "99750d3adcc907ac819238bd458bee2cfda51d41",
      "closedAt": "2019-03-11T04:45:45Z",
      "mergedAt": "2019-03-11T04:45:45Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "4cc5f56547952cae0d2a1530da7d7d3723178a68"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjExNDc2MTg1",
          "commit": {
            "abbreviatedOid": "99750d3"
          },
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-03-06T21:12:12Z",
          "updatedAt": "2019-03-06T21:12:12Z",
          "comments": []
        }
      ]
    },
    {
      "number": 134,
      "id": "MDExOlB1bGxSZXF1ZXN0MjU4NjM3MTYy",
      "title": "Tree Hash",
      "url": "https://github.com/mlswg/mls-protocol/pull/134",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "security",
        "functionality"
      ],
      "body": "As discussed on the list, this PR replaces the explicit tree and roster inputs to the key schedule with a \"tree hash\" construct.\r\n\r\n@beurdouche - Given this, do you think we need to keep the `transcript_hash` field around?  It seems like in TLS and similar, the transcript hash is there to ensure that the parties agree on things like identities, but we're encoding all that explicitly.\r\n\r\nFixes #90 ",
      "createdAt": "2019-03-06T09:20:45Z",
      "updatedAt": "2019-12-17T10:14:03Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "194aeef46bf6b12f90ffa489b50aae5a5fada3b3",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "tree-hash",
      "headRefOid": "36d619f71f6e551cdd2ce141c8b510788473f409",
      "closedAt": "2019-05-01T01:14:03Z",
      "mergedAt": "2019-05-01T01:14:03Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "3f14893110df64b367e0ae1f09410ddae45b4be5"
      },
      "comments": [
        {
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "body": "This is roughly what we do for the TreeKEM paper (I believe we don't re-mix the identities at each op. if I am correct). This seem to cover enough so it's good. I'll try to have a deeper look tomorrow, but this looks reasonable at first glance. It covers both the identities/roster and the group operations, (quid of the welcome message ?) so yes this makes the transcript hash redundant it seems :) I'll get back asap. \r\n\r\nEdit: as discussed before let's keep the transcript hash for now.",
          "createdAt": "2019-03-06T21:36:00Z",
          "updatedAt": "2019-05-01T10:36:02Z"
        },
        {
          "author": "rozbb",
          "authorAssociation": "CONTRIBUTOR",
          "body": "If the goal is to have a new data structure that combined and replaces the ratchet tree and roster, then parent and leaf nodes should be storing a lot more information. Namely, if this to be used as a ratchet tree, all nodes need to have associated public keys and private keys, and parent nodes should retain a hash of their children. No need to store node secrets, though. They're never used after private key derivation.",
          "createdAt": "2019-04-17T18:11:05Z",
          "updatedAt": "2019-04-17T18:11:05Z"
        },
        {
          "author": "rozbb",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think the definition of Resolution should be in the Tree Computation Terminology section, not the Ratchet Tree Contents section",
          "createdAt": "2019-04-19T17:39:50Z",
          "updatedAt": "2019-04-19T17:39:50Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjI3OTA3OTMx",
          "commit": {
            "abbreviatedOid": "47177af"
          },
          "author": "rozbb",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-04-17T17:55:04Z",
          "updatedAt": "2019-04-17T17:55:04Z",
          "comments": [
            {
              "originalPosition": 10,
              "body": "Typo: \"this section define a scheme\" should be \"this section defines a scheme\"",
              "createdAt": "2019-04-17T17:55:04Z",
              "updatedAt": "2019-05-01T01:12:12Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjI4NzY4Mjg2",
          "commit": {
            "abbreviatedOid": "cf40ebb"
          },
          "author": "rozbb",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-04-19T17:37:49Z",
          "updatedAt": "2019-04-19T17:37:49Z",
          "comments": [
            {
              "originalPosition": 102,
              "body": "Typo: `ot` -> `to`",
              "createdAt": "2019-04-19T17:37:49Z",
              "updatedAt": "2019-05-01T01:12:12Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjMwMzA2MTE5",
          "commit": {
            "abbreviatedOid": "16e4717"
          },
          "author": "rozbb",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-04-24T19:17:17Z",
          "updatedAt": "2019-04-24T19:17:17Z",
          "comments": [
            {
              "originalPosition": 86,
              "body": "Editorial: \"in that order\" seems redundant or meaningless here",
              "createdAt": "2019-04-24T19:17:17Z",
              "updatedAt": "2019-05-01T01:12:12Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjMwMzA3Mjc3",
          "commit": {
            "abbreviatedOid": "16e4717"
          },
          "author": "rozbb",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-04-24T19:20:00Z",
          "updatedAt": "2019-04-24T19:20:00Z",
          "comments": [
            {
              "originalPosition": 124,
              "body": "Remove \"the secret values\". The only secret a node holds is an optional private key",
              "createdAt": "2019-04-24T19:20:00Z",
              "updatedAt": "2019-05-01T01:12:12Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjMwMzA3OTk2",
          "commit": {
            "abbreviatedOid": "16e4717"
          },
          "author": "rozbb",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2019-04-24T19:21:36Z",
          "updatedAt": "2019-04-24T19:44:05Z",
          "comments": [
            {
              "originalPosition": 132,
              "body": "Ditto: remove \"secret value and\", replace \"are known\" -> \"is known\"",
              "createdAt": "2019-04-24T19:21:36Z",
              "updatedAt": "2019-05-01T01:12:12Z"
            },
            {
              "originalPosition": 134,
              "body": "Typo (unless you really mean it): \"descendent\" -> \"descendant\". The latter is how it's spelled everywhere else in the doc",
              "createdAt": "2019-04-24T19:23:56Z",
              "updatedAt": "2019-05-01T01:12:12Z"
            },
            {
              "originalPosition": 136,
              "body": "For specificity \"secrets\" -> \"private keys\"",
              "createdAt": "2019-04-24T19:24:24Z",
              "updatedAt": "2019-05-01T01:12:12Z"
            },
            {
              "originalPosition": 143,
              "body": "No need to quote \"direct path\" here. The term has already introduced and used non-quotatively in the previous section",
              "createdAt": "2019-04-24T19:26:12Z",
              "updatedAt": "2019-05-01T01:12:12Z"
            },
            {
              "originalPosition": 145,
              "body": "Auxiliary point: a path secret is made for the root node, but the root node does not appear in the direct path. Using saying that ps[n] is generated \"along the direct path\" may not be wrong, but it does seem a bit misleading. Thoughts?",
              "createdAt": "2019-04-24T19:28:25Z",
              "updatedAt": "2019-05-01T01:12:12Z"
            },
            {
              "originalPosition": 221,
              "body": "Double check this with me: If I am at the leaf, I am _my_ public key, and zero encrypted copies of _my_ path secret (this is `pk(ns[0])   |   [nothing]` in the diagram)\r\n\r\nIf I am a level up, I am encrypting _my_ public key, and 1 encrypted copy of _my_ path secret (this is `pk(ns[1])   |   E(pk(A), ps[1])` in the diagram).\r\n\r\nSo this should say:\r\n\r\n* The public key for the node\r\n* Zero or more copies of the node's path secret, encrypted for someone in the resolution of the node's sibling\r\n\r\nOr, since that last detail is mentioned below, just \"Zero or more encrypted copies of the node's path secret\"",
              "createdAt": "2019-04-24T19:39:47Z",
              "updatedAt": "2019-05-01T01:12:12Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjMwNTM5MDg2",
          "commit": {
            "abbreviatedOid": "16e4717"
          },
          "author": "psyoptix",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-04-25T09:25:12Z",
          "updatedAt": "2019-04-25T09:25:13Z",
          "comments": [
            {
              "originalPosition": 86,
              "body": "To me \"in that order\" somewhat clarifies that \"left.child || right.child\" is meant here and not \"right.child || left.child\". Clear yet though would be something like: \r\n\r\nThe resolution of a blank intermediate node is the result of concatenating the resolution of its right child to the end of the resolution of its left child.",
              "createdAt": "2019-04-25T09:25:12Z",
              "updatedAt": "2019-05-01T01:12:12Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjMwNTUxOTg2",
          "commit": {
            "abbreviatedOid": "16e4717"
          },
          "author": "psyoptix",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-04-25T09:51:12Z",
          "updatedAt": "2019-04-25T10:57:18Z",
          "comments": [
            {
              "originalPosition": 59,
              "body": "I think the first primitive to be fixed is a (CPA secure) KEM. ECDH is probably the most interesting class of KEMs but not the only ones worth considering. E.g. A post quantum KEM, say Kyber, (or maybe DH over modular integers) may also be valid choices here for some MLS users.",
              "createdAt": "2019-04-25T09:51:12Z",
              "updatedAt": "2019-05-01T01:12:12Z"
            },
            {
              "originalPosition": 348,
              "body": "The text description doesn't seem to match the structs. \r\n * The `public_key_hash` field is missing from the `ParentNodeHashInput` struct. To make it consistent with the text I think the `public_key` should be replaced with `opaque public_key_hash<0..255>;` or something like that. \r\n * Also, for completeness, we might want to add something like the following struct as it's mentioned in the text (e.g. to make the `hash_type` field precise) :\r\n\r\n`struct {\r\n  uint8 hash_type = 2;\r\n  optional <HPKEPublicKey> node_public_key;\r\n} ParentNodeInfo`\r\n\r\nMore generally though, I have some comments/questions about this section:\r\n* Why include `LeafNodeInfo` in `LeafNodeHashInput` directly but for parent nodes use *the hash of* `ParentNodeInfo` in `ParentNodeHashInput` instead (at least according to the text)? I don't see why the extra hash of NodeInfo makes sense for parents but not for leaves... Either both or neither no?\r\n* What is the purpose of `hash_type`? If domain separation why is that needed and why is hash_type sufficient?\r\n* On a related note, as defined now all blank leaves will have the same hash. Even internal nodes can have the same hash if they are both roots of identical sub-trees of blank nodes. I'm not sure its a problem... but if so one clean way to avoid this is to including `leaf_index` in the `LeafNodeHashInput` struct as a tie-breaker.",
              "createdAt": "2019-04-25T10:04:50Z",
              "updatedAt": "2019-05-01T01:12:12Z"
            },
            {
              "originalPosition": 533,
              "body": "Make clear if node or leaf index is meant here. E.g. \"represents the index of the member among the leaves of the ratchet tree\" --> \"represents the leaf index of the ratchet tree leaf assigned to the sender\"",
              "createdAt": "2019-04-25T10:56:23Z",
              "updatedAt": "2019-05-01T01:12:12Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjMwNjU2MDA2",
          "commit": {
            "abbreviatedOid": "16e4717"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-04-25T13:43:58Z",
          "updatedAt": "2019-04-25T13:43:59Z",
          "comments": [
            {
              "originalPosition": 145,
              "body": "I clarified in the next paragraph, \"for each node in the direct path of the leaf, as well as\r\nthe root\".  I wonder if we should just change the definition of dirpath to include the root?",
              "createdAt": "2019-04-25T13:43:58Z",
              "updatedAt": "2019-05-01T01:12:12Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjMwNjU4NjEy",
          "commit": {
            "abbreviatedOid": "16e4717"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-04-25T13:48:11Z",
          "updatedAt": "2019-04-25T13:48:11Z",
          "comments": [
            {
              "originalPosition": 221,
              "body": "Correct.  The encrypted copies are for the resolution of the non-updated child, and the leaf node has no children.  And yes, the \"parent\" in the second bullet shouldn't be there.",
              "createdAt": "2019-04-25T13:48:11Z",
              "updatedAt": "2019-05-01T01:12:12Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjMwNjYzNTg0",
          "commit": {
            "abbreviatedOid": "16e4717"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-04-25T13:56:02Z",
          "updatedAt": "2019-04-25T13:56:03Z",
          "comments": [
            {
              "originalPosition": 533,
              "body": "Done.",
              "createdAt": "2019-04-25T13:56:03Z",
              "updatedAt": "2019-05-01T01:12:12Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjMwNjY0MTAy",
          "commit": {
            "abbreviatedOid": "16e4717"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-04-25T13:56:48Z",
          "updatedAt": "2019-04-25T13:56:49Z",
          "comments": [
            {
              "originalPosition": 59,
              "body": "Good point.  Refactored to say we need:\r\n\r\n1. An HPKE ciphersuite (including KEM)\r\n2. A Derive-Key-Pair function that produces a key pair for that KEM from a secret",
              "createdAt": "2019-04-25T13:56:48Z",
              "updatedAt": "2019-05-01T01:12:12Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjMwNjk3MjUz",
          "commit": {
            "abbreviatedOid": "16e4717"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-04-25T14:48:36Z",
          "updatedAt": "2019-04-25T14:48:36Z",
          "comments": [
            {
              "originalPosition": 348,
              "body": "My thinking with the pre-hashing of the parent nodes values is that if someone were providing incomplete views of the tree together with proofs, then the proof could just include the hash instead of the value.  But on further reflection, I think this is a mistake since (a) the only contents of the node are an `optional<HPKEPublicKey>` and (b) that's not meaningfully different from its hash.  So I've just eliminated the `_hash` part.\r\n\r\nRe `hash_type` - TBH, I'm basically just copy/pasting from [Certificate Transparency](https://tools.ietf.org/html/rfc6962#section-2.1) here; open to arguments either way.  Maybe @beurdouche has some thoughts here?\r\n\r\nRe blank nodes - Even more, a blank subtree anywhere in the tree will have the same value.  I had considered just throwing the node index into all the hashes for diversity.  But I don't really see an issue here -- why do we need to distinguish between blanks in different places? Given that in the ultimate root hash they'll end up tied with non-blank stuff and locked into their position that way.\r\n",
              "createdAt": "2019-04-25T14:48:36Z",
              "updatedAt": "2019-05-01T01:12:12Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjMyMDc3NzA2",
          "commit": {
            "abbreviatedOid": "e9b283b"
          },
          "author": "psyoptix",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-04-30T09:41:57Z",
          "updatedAt": "2019-04-30T09:41:57Z",
          "comments": [
            {
              "originalPosition": 348,
              "body": "Thought a bit more about hash_type. For Merkle Trees (as in Certificate Transparency) the prefix to the hash inputs are definitely needed to separate leaf and internal node hashing domains. Otherwise MTs trivially aren't binding. E.g. given any target data set d={d(0),...,d(n)} it would be easy to make a new data point {d'} such that MT(d) = MT(d').\r\n\r\nFor MLS I'm suspect tree hashes may already be binding even without including hash_type. But justifying that would require subtle & messy reasoning including exactly how optional structs, HPKEPublicKey, SignaturesPK, Certificates, etc. are all serialized.\r\n\r\nBut that discussion can be entirely avoided by including hash_type as you have done. To see binding: hash_type ensures that for 2 tree's to have the same tree hash value they must have the same set of nodes and edges. (Otherwise two hash calls has differing hash_type inputs but results in the same output which is a collision on the underlying hash func). That in turn, means the trees must have the same set of labels for all nodes since otherwise we again have a collision somewhere. Ergo tree hash is binding.\r\n\r\nMuch cleaner. :-) So I've come round to the inclusion of hash_type even if I'm not convinced its strictly necessary.",
              "createdAt": "2019-04-30T09:41:57Z",
              "updatedAt": "2019-05-01T01:12:12Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjMyMzIwODY0",
          "commit": {
            "abbreviatedOid": "e9b283b"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-04-30T18:02:13Z",
          "updatedAt": "2019-04-30T18:02:14Z",
          "comments": [
            {
              "originalPosition": 348,
              "body": "Thanks!  Belt and suspenders!",
              "createdAt": "2019-04-30T18:02:14Z",
              "updatedAt": "2019-05-01T01:12:12Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjMxNTc3MDQ1",
          "commit": {
            "abbreviatedOid": "e9b283b"
          },
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-04-29T09:13:24Z",
          "updatedAt": "2019-04-30T19:09:03Z",
          "comments": [
            {
              "originalPosition": 132,
              "body": "This is not technically required for everyone but mostly for clients intending to add or remove, I would probably weaken this requirement, now or later.",
              "createdAt": "2019-04-29T09:18:53Z",
              "updatedAt": "2019-05-01T01:12:12Z"
            },
            {
              "originalPosition": 134,
              "body": "Indeed the public leaves are necessary",
              "createdAt": "2019-04-29T09:19:33Z",
              "updatedAt": "2019-05-01T01:12:12Z"
            },
            {
              "originalPosition": 139,
              "body": "It is interesting that you think of a \"secret state of the tree\". In my opinion, there is no such thing because TreeKEM will give you with agreement over the public tree but not the secret one except for the the node private kem key.\r\nThe best way to think about this, is that TreeKEM provides each sub-group (singleton or not) with a shared secret that you can recompute from a leaf secret and a public tree.",
              "createdAt": "2019-04-29T09:26:12Z",
              "updatedAt": "2019-05-01T01:12:12Z"
            },
            {
              "originalPosition": 145,
              "body": "s/MLS/TreeKEM",
              "createdAt": "2019-04-29T09:27:23Z",
              "updatedAt": "2019-05-01T01:12:12Z"
            },
            {
              "originalPosition": 226,
              "body": "a set of public values",
              "createdAt": "2019-04-29T09:31:19Z",
              "updatedAt": "2019-05-01T01:12:12Z"
            },
            {
              "originalPosition": 228,
              "body": "s/Other members/Each recipient\r\n\r\nThey use the values, or the content of the updated nodes, not the nodes",
              "createdAt": "2019-04-29T09:32:05Z",
              "updatedAt": "2019-05-01T01:12:12Z"
            },
            {
              "originalPosition": 234,
              "body": "You don't tell to whom you are sending.\r\nMaybe a notion of \"generalized\" (or whatever) sibling (all non-blank root of sub-trees of a direct sibling) is missing ?",
              "createdAt": "2019-04-29T09:37:16Z",
              "updatedAt": "2019-05-01T01:12:12Z"
            },
            {
              "originalPosition": 246,
              "body": "What happens for a blank node ?",
              "createdAt": "2019-04-29T09:39:28Z",
              "updatedAt": "2019-05-01T01:12:12Z"
            },
            {
              "originalPosition": 253,
              "body": "Convoluted",
              "createdAt": "2019-04-29T09:40:41Z",
              "updatedAt": "2019-05-01T01:12:12Z"
            },
            {
              "originalPosition": 303,
              "body": "I had trouble to understand the sentence for some reason... :)",
              "createdAt": "2019-04-30T19:08:02Z",
              "updatedAt": "2019-05-01T01:12:12Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjMyNDY5ODY5",
          "commit": {
            "abbreviatedOid": "e9b283b"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-01T01:03:02Z",
          "updatedAt": "2019-05-01T01:03:02Z",
          "comments": [
            {
              "originalPosition": 132,
              "body": "Softened to \"we generally assume\".",
              "createdAt": "2019-05-01T01:03:02Z",
              "updatedAt": "2019-05-01T01:12:12Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjMyNDcwNTcz",
          "commit": {
            "abbreviatedOid": "e9b283b"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-01T01:08:27Z",
          "updatedAt": "2019-05-01T01:08:28Z",
          "comments": [
            {
              "originalPosition": 234,
              "body": "That \"generalized sibling\" is the resolution of the sibling.",
              "createdAt": "2019-05-01T01:08:28Z",
              "updatedAt": "2019-05-01T01:12:12Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjMyNDcwNjAz",
          "commit": {
            "abbreviatedOid": "e9b283b"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-01T01:08:44Z",
          "updatedAt": "2019-05-01T01:08:44Z",
          "comments": [
            {
              "originalPosition": 246,
              "body": "The resolution stage accounts for blanks.",
              "createdAt": "2019-05-01T01:08:44Z",
              "updatedAt": "2019-05-01T01:12:12Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjMyNDcwODQ5",
          "commit": {
            "abbreviatedOid": "e9b283b"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-01T01:10:29Z",
          "updatedAt": "2019-05-01T01:10:30Z",
          "comments": [
            {
              "originalPosition": 253,
              "body": "Let's discuss in a follow-on.",
              "createdAt": "2019-05-01T01:10:29Z",
              "updatedAt": "2019-05-01T01:12:12Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjMyNDcxMDU5",
          "commit": {
            "abbreviatedOid": "e9b283b"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-01T01:12:03Z",
          "updatedAt": "2019-05-01T01:12:03Z",
          "comments": [
            {
              "originalPosition": 303,
              "body": "Probably because it's poorly written ;)  I rewrote it to hopefully be clearer.",
              "createdAt": "2019-05-01T01:12:03Z",
              "updatedAt": "2019-05-01T01:12:12Z"
            }
          ]
        }
      ]
    },
    {
      "number": 135,
      "id": "MDExOlB1bGxSZXF1ZXN0MjU4NzkxOTQ1",
      "title": " Address difference between roster and tree index ",
      "url": "https://github.com/mlswg/mls-protocol/pull/135",
      "state": "CLOSED",
      "author": "kkohbrok",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "Just stumbled across the difference again. I being a little more explicit about this a good way of preventing implementation error regarding mix-up of indices.",
      "createdAt": "2019-03-06T16:32:49Z",
      "updatedAt": "2019-12-17T09:19:11Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "645961291858d86f74a41b0d9e4f257db9fb96a0",
      "headRepository": "kkohbrok/mls-protocol",
      "headRefName": "patch-1",
      "headRefOid": "65624d827701373f9657c57b5942d82dfa78c645",
      "closedAt": "2019-03-11T05:08:21Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "I agree that this should not be merged.  There is a factor-of-2 issue here (which I have run into in my implementation), but I think the right answer is to remove the distinction between leaves and roster slots, as suggested in #134.",
          "createdAt": "2019-03-11T05:08:21Z",
          "updatedAt": "2019-03-11T05:08:21Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjExNDc2MDE0",
          "commit": {
            "abbreviatedOid": "65624d8"
          },
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "I believe this is just using Leaf numbering in that case instead of Node numbering. I am fine with keeping two numbering methods here as long as we make that more explicit. I would prefer avoiding these divisions even though this is correct.",
          "createdAt": "2019-03-06T21:11:52Z",
          "updatedAt": "2019-03-06T21:11:52Z",
          "comments": []
        }
      ]
    },
    {
      "number": 136,
      "id": "MDExOlB1bGxSZXF1ZXN0MjU4ODY4NTM0",
      "title": "Fixed example in 'Ratchet Tree Update' section",
      "url": "https://github.com/mlswg/mls-protocol/pull/136",
      "state": "CLOSED",
      "author": "kkohbrok",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "Previously, it was KEMing to the root key, which is not in the resolution of the coPath of B.",
      "createdAt": "2019-03-06T20:28:55Z",
      "updatedAt": "2019-12-17T09:18:27Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "645961291858d86f74a41b0d9e4f257db9fb96a0",
      "headRepository": "kkohbrok/mls-protocol",
      "headRefName": "patch-2",
      "headRefOid": "2dbeb47f15b72504d8c5a907c150c1514a7a2e6c",
      "closedAt": "2019-03-11T05:06:24Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "This PR now seems like a noop, so closing.  Feel free to reopen if there's actually something to do here.",
          "createdAt": "2019-03-11T05:06:24Z",
          "updatedAt": "2019-03-11T05:06:24Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjExNDc2NzQ0",
          "commit": {
            "abbreviatedOid": "0d1aa4f"
          },
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "state": "CHANGES_REQUESTED",
          "body": "This seems incorrect, the update is along B-E-G so the F node is not recovered, you do send pk(G) and G to both C and D.",
          "createdAt": "2019-03-06T21:13:22Z",
          "updatedAt": "2019-03-06T21:13:22Z",
          "comments": []
        }
      ]
    },
    {
      "number": 138,
      "id": "MDExOlB1bGxSZXF1ZXN0MjU5ODQ1NTcz",
      "title": "Include a hash of the WelcomeInfo in the Add message",
      "url": "https://github.com/mlswg/mls-protocol/pull/138",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "bug",
        "security"
      ],
      "body": "This addresses the authentication issue in -03 noted on the mailing list.",
      "createdAt": "2019-03-11T06:24:16Z",
      "updatedAt": "2019-12-17T09:18:13Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "4cc5f56547952cae0d2a1530da7d7d3723178a68",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "welcome-hash",
      "headRefOid": "cad1dc8451d32b4ca3bd185abef76c3a2f2e13b2",
      "closedAt": "2019-03-11T06:25:30Z",
      "mergedAt": "2019-03-11T06:25:30Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "703216af0327dca5c32e731e4a500f95826be97d"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjEyNjczNTQw",
          "commit": {
            "abbreviatedOid": "cad1dc8"
          },
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-03-11T06:25:01Z",
          "updatedAt": "2019-03-11T06:25:01Z",
          "comments": []
        }
      ]
    },
    {
      "number": 139,
      "id": "MDExOlB1bGxSZXF1ZXN0MjU5OTMwNjYx",
      "title": "Initial definition of the KDF and the Derive-Key-Pair function",
      "url": "https://github.com/mlswg/mls-protocol/pull/139",
      "state": "MERGED",
      "author": "beurdouche",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "security",
        "functionality"
      ],
      "body": "Initial attempt to solve #129. This defines the KDF as discussed in #129 and relocates the DH computation obligation and verification as part of the Derive-Key-Pair function definition.",
      "createdAt": "2019-03-11T11:33:02Z",
      "updatedAt": "2019-12-17T09:17:30Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "3b8b9350dc5f1d21cf52714208e3af4fbeab7998",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "beurdouche_129_kdf",
      "headRefOid": "de6832fbd453c4d5a5a3ace3c4ed7d0d9bcae5c5",
      "closedAt": "2019-03-15T14:46:01Z",
      "mergedAt": "2019-03-15T14:46:01Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "cda41739560803a05af8407a018f0db2bb85e948"
      },
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixing my own review comments here, since @beurdouche appears to be offline and we need to publish -04.",
          "createdAt": "2019-03-15T14:38:04Z",
          "updatedAt": "2019-03-15T14:38:04Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjE0MDExMjMy",
          "commit": {
            "abbreviatedOid": "c8b1b9c"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2019-03-13T15:03:11Z",
          "updatedAt": "2019-03-13T15:16:32Z",
          "comments": [
            {
              "originalPosition": 55,
              "body": "Everything from here down should be deleted, and replaced with the existing definitions that have been deleted in this PR.",
              "createdAt": "2019-03-13T15:04:31Z",
              "updatedAt": "2019-03-15T14:40:54Z"
            },
            {
              "originalPosition": 12,
              "body": "Nope, this is the node secret, which I don't think needs the extra word.",
              "createdAt": "2019-03-13T15:11:50Z",
              "updatedAt": "2019-03-15T14:40:54Z"
            },
            {
              "originalPosition": 16,
              "body": "There's no reason to delete this para.  It's still true that the key pair from the node derives from the node secret.  You just need to edit it to revert back to what it said before #114, namely that the key pair comes from the node secret via Derive-Key-Pair.",
              "createdAt": "2019-03-13T15:13:35Z",
              "updatedAt": "2019-03-15T14:40:54Z"
            },
            {
              "originalPosition": 36,
              "body": "I would move this back up to where you deleted a chunk. Instead of \"The contents of a parent node...\", you should say something like \"The tree is always updated along a direct path from a leaf to the root... [path secrets, node secrets]\"",
              "createdAt": "2019-03-13T15:15:43Z",
              "updatedAt": "2019-03-15T14:40:54Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjE1MDY4OTk1",
          "commit": {
            "abbreviatedOid": "c61c277"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-03-15T14:36:49Z",
          "updatedAt": "2019-03-15T14:36:49Z",
          "comments": []
        }
      ]
    },
    {
      "number": 141,
      "id": "MDExOlB1bGxSZXF1ZXN0MjY1MTE0MTg3",
      "title": "Added public_key_index to Add message",
      "url": "https://github.com/mlswg/mls-protocol/pull/141",
      "state": "CLOSED",
      "author": "rozbb",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "The original text says \"Set the leaf node in the tree at position index to a new node containing the public key from the UserInitKey in the Add corresponding to the ciphersuite in use\". Although it's never explicitly stated, the implication is that a UserInitKey can have at most 1 DhPublicKey per ciphersuite.\r\n\r\nI think a `public_key_index` could make errors somewhat nicer. I would rather have the issue be that the Adder picked incomensurate ciphersuite, as opposed to saying that the option to Add exists, but there's no consistent way to pick the public key index.\r\n\r\nIncluding an index could also open up the option of publishing large, long-lived UserInitKeys that can get downloaded and used over time (I'm not sure if this fits our model as-is, though).\r\n\r\nThoughts?",
      "createdAt": "2019-03-27T21:49:36Z",
      "updatedAt": "2019-12-17T09:16:46Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "cda41739560803a05af8407a018f0db2bb85e948",
      "headRepository": "rozbb/mls-protocol",
      "headRefName": "master",
      "headRefOid": "447ef431b68d99bee3a6d0c4ef1f7aa9cba482bd",
      "closedAt": "2019-04-17T16:49:05Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "rozbb",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Ah, ok. Nevermind that last point then. This is just a small semantic matter. I think the adder should explicitly pick a pubkey, rather than letting it be implicitly chosen, subject to an assumed constraint. \r\n\r\nOne concern here is also misuse. While writing my implementation, I was tempted to search for the first index of `cipher_suites` that matched the current ciphersuite, and then use that. But that would be a subtle bug, and the lack of a check there would put GroupStates out of sync. I think specifying an index and making sure the ciphersuite matches is less error-prone.\r\n\r\nAlso, the spec does not currently specify any constraints on `cipher_suites`, other than the one relating to its length. If this PR is rejected, I'll happily disambiguate this in a separate PR.",
          "createdAt": "2019-03-28T00:33:37Z",
          "updatedAt": "2019-03-28T00:33:37Z"
        },
        {
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "body": "The way you pick the ciphersuite is left to you and if you pick ciphersuite J in the list, you pick key J. Do you mean that the one-to-one key/ciphersuite mapping is not explicit enough in the sentence I pointed earlier ? ",
          "createdAt": "2019-03-28T00:48:19Z",
          "updatedAt": "2019-03-28T00:48:19Z"
        },
        {
          "author": "rozbb",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I thought there's no choice involved. The only `init_key` you _can_ pick is the one that corresponds to the current ciphersuite. I just think that that method, while perfectly well-defined and doable, is more prone to error than having the adder explicitly choose the `init_key` index and including it in the Add message.\r\n\r\nAnd yes, I believe that the one-to-one key/ciphersuite correspondence is not explicit enough. I didn't know that that was a condition until I read the Add subsection of the Handshake section in the spec.",
          "createdAt": "2019-03-28T19:12:21Z",
          "updatedAt": "2019-03-28T19:12:21Z"
        },
        {
          "author": "rozbb",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Closing because the `index -> tree_index` change is wrong and doesn't belong here. Also I shouldn't have based this on my `master`. I'll redo this change in a sec.",
          "createdAt": "2019-04-17T16:49:05Z",
          "updatedAt": "2019-04-17T16:49:05Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjE5NzcyNDg1",
          "commit": {
            "abbreviatedOid": "447ef43"
          },
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "state": "CHANGES_REQUESTED",
          "body": "The UserInitKey is one-time-use and contains a single ephemeral HPKE public key per algorithm. Reusing these keys across groups is just a very bad idea. Section 6 mandates:\r\n```\r\nThe init_keys array MUST have the same length as the cipher_suites\r\n   array, and each entry in the init_keys array MUST be a public key for\r\n   the asymmetric encryption scheme defined in the cipher_suites array\r\n   and used in the HPKE construction for TreeKEM.\r\n```",
          "createdAt": "2019-03-27T23:21:42Z",
          "updatedAt": "2019-03-27T23:21:42Z",
          "comments": []
        }
      ]
    },
    {
      "number": 143,
      "id": "MDExOlB1bGxSZXF1ZXN0MjY3MTI3MTM1",
      "title": "Fixes to tree manipulation in Remove",
      "url": "https://github.com/mlswg/mls-protocol/pull/143",
      "state": "MERGED",
      "author": "rozbb",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "This clears up the wording around how to prune the ratchet tree on a Remove operation. Previously, it could be interpreted as \"remove nodes from the tree until the rightmost node is not null\", but this is not what is intended by the authors, and it also has the ability to produce invalid trees (i.e., trees with an even number of elements).\r\n\r\nThe second change is to do the truncation _after_ doing the Blank propogation up the direct path of the removed leaf. Note that the order of these steps doesn't matter in that they produce the same resulting tree. However, if we blank after pruning, an implementor would have to take care to not to try to blank out previously-removed nodes. Prune-then-blank is a little easier to reason about.\r\n\r\nThe third change is a semantic fix. It is clear from the last paragraph in this section that the root node should be blanked, but the text only said to blank the direct path of the leaf, which does not include the root node. I just added that part in.",
      "createdAt": "2019-04-03T16:40:27Z",
      "updatedAt": "2019-12-17T09:16:40Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "cda41739560803a05af8407a018f0db2bb85e948",
      "headRepository": "rozbb/mls-protocol",
      "headRefName": "truncate-fix",
      "headRefOid": "0baffe3b5272d03eaf83c6c6b9413d5ae27a6ebf",
      "closedAt": "2019-05-02T14:36:36Z",
      "mergedAt": "2019-05-02T14:36:36Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "c56e7e9d8990a89cdf51ab31df681e4f8ba1cda6"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjI4NzE3MTQx",
          "commit": {
            "abbreviatedOid": "1afcbda"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2019-04-19T14:51:00Z",
          "updatedAt": "2019-04-19T14:55:53Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "This is redundant, given that the root path is on the direct path of every node.  Unless there's some definition that comes up one short?",
              "createdAt": "2019-04-19T14:51:00Z",
              "updatedAt": "2019-05-02T14:33:46Z"
            },
            {
              "originalPosition": 13,
              "body": "I would prefer not to have the \"(clearing...\" parts.  There's no such thing as a zero-member group, so it would be better to simply disallow Remove on a one-member group.",
              "createdAt": "2019-04-19T14:54:51Z",
              "updatedAt": "2019-05-02T14:33:46Z"
            },
            {
              "originalPosition": 13,
              "body": "Though now that I say that, I realize that requirement is not totally trivial to enforce, since the last remaining member could have any index.  But it still seems like the most semantically clear approach.",
              "createdAt": "2019-04-19T14:55:47Z",
              "updatedAt": "2019-05-02T14:33:46Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjI5MTY0NTQy",
          "commit": {
            "abbreviatedOid": "1afcbda"
          },
          "author": "rozbb",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-04-22T17:47:52Z",
          "updatedAt": "2019-04-22T17:47:53Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "What's the issue exactly with a zero-member group? You can't semantically do anything with it, so you just get a useless object at the end of the `Remove`, and you have no choice but to throw it out.",
              "createdAt": "2019-04-22T17:47:52Z",
              "updatedAt": "2019-05-02T14:33:46Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjI5MTY0ODA2",
          "commit": {
            "abbreviatedOid": "1afcbda"
          },
          "author": "rozbb",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-04-22T17:48:29Z",
          "updatedAt": "2019-04-22T17:48:29Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "From section 5.1: \"The direct path of a root is the empty list, and of any other node is the concatenation of that node with the direct path of its parent.\"\r\n\r\nDirect paths do not contain the root node.",
              "createdAt": "2019-04-22T17:48:29Z",
              "updatedAt": "2019-05-02T14:33:46Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjMyMzE4NzE4",
          "commit": {
            "abbreviatedOid": "1afcbda"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-04-30T17:57:52Z",
          "updatedAt": "2019-04-30T17:57:52Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "Well, that's the problem -- you can't do anything with it.  So it seems like it shouldn't be a valid state.",
              "createdAt": "2019-04-30T17:57:52Z",
              "updatedAt": "2019-05-02T14:33:46Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjMyMzI2MDE3",
          "commit": {
            "abbreviatedOid": "1afcbda"
          },
          "author": "rozbb",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-04-30T18:12:41Z",
          "updatedAt": "2019-04-30T18:12:41Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "Ah, I was going to say \"bad states are states that are semantically incorrect, and there's nothing incorrect about an empty group\" but I found a reason why it's not correct (at least for me): `signer_index` is not `optional` in my GroupState object. If the roster is empty, then there is no valid value for `signer_index`. Since this is necessarily an invalid state, I agree that zero-member groups should be disallowed. I'll make an update to reflect this prohibition for Removes.",
              "createdAt": "2019-04-30T18:12:41Z",
              "updatedAt": "2019-05-02T14:33:46Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjMyNzAyNTEy",
          "commit": {
            "abbreviatedOid": "5f670e3"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-01T18:49:47Z",
          "updatedAt": "2019-05-01T18:53:36Z",
          "comments": [
            {
              "originalPosition": 19,
              "body": "The receiver POV here seems more useful, i.e., \"If a member of a group receives a Remove message where the `removed` index is equal to the `sender` index, then the recipient MUST reject the message as malformed.\"  That's not to say we can't have both, though.\r\n\r\nMight tee this up better if you said \"remove one or more **other** members from the group\" (emphasis only for here, not for the doc).",
              "createdAt": "2019-05-01T18:49:47Z",
              "updatedAt": "2019-05-02T14:33:46Z"
            },
            {
              "originalPosition": 39,
              "body": "We're coming down to kind of a matter of taste here, since I don't really like discussing things that are impossible :)  How about we compromise with the following:\r\n\r\n* Leave these clarifications out of the instruction bullets\r\n* Add a para afterward of the form \"Note that there is always at least one non-blank...\"",
              "createdAt": "2019-05-01T18:53:28Z",
              "updatedAt": "2019-05-02T14:33:46Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjMyNzA1NjY0",
          "commit": {
            "abbreviatedOid": "3f25fb1"
          },
          "author": "rozbb",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-01T18:56:27Z",
          "updatedAt": "2019-05-01T18:56:27Z",
          "comments": [
            {
              "originalPosition": 39,
              "body": "agreed. That will also give room to mention that the same argument holds for tree truncation",
              "createdAt": "2019-05-01T18:56:27Z",
              "updatedAt": "2019-05-02T14:33:46Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjMyODIwMDIz",
          "commit": {
            "abbreviatedOid": "f358deb"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-02T01:31:11Z",
          "updatedAt": "2019-05-02T13:22:36Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "Could we delete this for now (also below) and handle it as a follow-on?  This seems non-trivial to resolve, and I want to ship draft-05 tomorrow.",
              "createdAt": "2019-05-02T01:31:12Z",
              "updatedAt": "2019-05-02T14:33:46Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjMzMDQ0ODQ0",
          "commit": {
            "abbreviatedOid": "0baffe3"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-05-02T14:34:58Z",
          "updatedAt": "2019-05-02T14:34:58Z",
          "comments": []
        }
      ]
    },
    {
      "number": 146,
      "id": "MDExOlB1bGxSZXF1ZXN0MjcwMDE5ODky",
      "title": "Tree based app keyschedule",
      "url": "https://github.com/mlswg/mls-protocol/pull/146",
      "state": "MERGED",
      "author": "psyoptix",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "security",
        "performance"
      ],
      "body": "Basic idea: \r\n - Application Key Schedule consists of a left balanced binary tree of secrets (the \"AS Tree\") and one symmetric ratchet per group member. The AS Tree has the same node/edge structure as the ratchet tree for that epoch. Members are assigned the same leaves.\r\n\r\n- Each node in the AS Tree is assigned a secret. The root's secret = application_secret. The secrets of children are derived from that of their parent.\r\n\r\n- The secret of a leaf is the initial secret of a symmetric hash ratchet. The ratchet generates the key/nonce sequence used by the leaf's group member to encrypt messages during that epoch.\r\n\r\n\r\n\r\nOther comments:\r\n- I included a \"Deletion Schedule\": keys, nonces are 'consumed' if they are used to encrypt or successfully decrypt a message. secrets are 'consumed' if value derived from it is consumed. Any consumed value must be immediately deleted for reasons of forward secrecy. \r\n\r\n- I was very generous with contexts for all calls to HKDF. E.g. I included Hash(GroupState_[n]) in the context of every call to HKDF. True, I dont think its neccesary to prove security against more coarse adversarial models (e.g. that only do all-or-nothing state leakage). Still, as a matter of the \"defense in depth\" principle I think including as much relevant context as possible during all key/secret derivation is a good idea. Albeit only as long as the price (in computation, complexity, etc) is not to high. To that end, I purposefully use Hash(GroupState_[n]) in the context as it is short, needs only to be computed once at the start of the epoch and can then be used to very cheaply to construct all contexts needed for the rest of the new application key schedule.\r\n\r\n- Disclaimer: I'm a bit of a noob when it comes to Markdown, RFCs and github so forgive me (and tell me!) if I've done something wrong here.\r\n\r\nCo-contributors: Benjamin Beurbouche, Sandro Coretti, Yevgeniy Dodis,",
      "createdAt": "2019-04-12T13:49:51Z",
      "updatedAt": "2019-12-17T09:16:22Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "74987e2b70e3bc5c2e02b0092d5bbb21cb7ae1eb",
      "headRepository": "psyoptix/mls-protocol",
      "headRefName": "tree-based-app-keysched",
      "headRefOid": "feb096db828cc1bdce2cf34e63832ebc023e4bf6",
      "closedAt": "2019-07-08T13:43:56Z",
      "mergedAt": "2019-07-08T13:43:56Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "811235cf469e5238f7f0a088d985d0afd0ff4c9d"
      },
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Merging this despite outstanding comments.  @beurdouche and I will handle our requested edits in a couple of follow-up PRs.",
          "createdAt": "2019-07-08T13:43:44Z",
          "updatedAt": "2019-07-08T13:43:44Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU2NTc1Njgx",
          "commit": {
            "abbreviatedOid": "82b931f"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2019-07-01T21:42:07Z",
          "updatedAt": "2019-07-01T22:08:51Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "Nit: tags of this form (lower-cased, spaces-to-dashes) are automatically generated by the tooling.  Same comment below.",
              "createdAt": "2019-07-01T21:42:07Z",
              "updatedAt": "2019-07-08T13:37:17Z"
            },
            {
              "originalPosition": 19,
              "body": "\"user\" -> \"client\"",
              "createdAt": "2019-07-01T21:42:38Z",
              "updatedAt": "2019-07-08T13:37:17Z"
            },
            {
              "originalPosition": 66,
              "body": "Might be helpful to expand \"AS\" on first use here.  I assume you mean \"application secret\"? ",
              "createdAt": "2019-07-01T21:43:10Z",
              "updatedAt": "2019-07-08T13:37:17Z"
            },
            {
              "originalPosition": 111,
              "body": "We have been using uint32s for indices elsewhere, to be conservative about size.",
              "createdAt": "2019-07-01T21:44:44Z",
              "updatedAt": "2019-07-08T13:37:17Z"
            },
            {
              "originalPosition": 149,
              "body": "What's the reasoning behind using the context you do here?  It seems like it would be simpler if you didn't have to keep around that context data.  For example, suppose you did something like the following:\r\n\r\n```\r\n           astree_node_[IndexOf(V)]_secret\r\n                     |\r\n                     +--> HKDF-Expand-Label(.,\"left\", \"\", Hash.length)\r\n                     |    = astree_node_[IndexOf(V.leftChild)]_secret\r\n                     |\r\n                     +--> HKDF-Expand-Label(.,\"right\", \"\", Hash.length)\r\n                          = astree_node_[IndexOf(V.rightChild)]_secret\r\n```\r\n\r\nThat would assure you have the diversity you need because every leaf in the tree would be derived via a different \"left\" / \"right\" path.",
              "createdAt": "2019-07-01T21:49:24Z",
              "updatedAt": "2019-07-08T13:37:17Z"
            },
            {
              "originalPosition": 149,
              "body": "Nit: Stylistically:\r\n* Slightly nicer to have both results on the right as above\r\n* I think we've been using more `snake_case`, so, e.g., `V.right_child`",
              "createdAt": "2019-07-01T21:51:03Z",
              "updatedAt": "2019-07-08T13:37:17Z"
            },
            {
              "originalPosition": 194,
              "body": "Same comment here about context.  Why can't we just use a fixed label [like TLS does](https://tools.ietf.org/html/rfc8446#section-7.2)?\r\n\r\n```\r\n       application_traffic_secret_N+1 =\r\n           HKDF-Expand-Label(application_traffic_secret_N,\r\n                             \"traffic upd\", \"\", Hash.length)\r\n```",
              "createdAt": "2019-07-01T21:53:54Z",
              "updatedAt": "2019-07-08T13:37:17Z"
            },
            {
              "originalPosition": 194,
              "body": "Also, a `leaf_index` should just be a `uint32`.  Did you mean for that to be an identity?",
              "createdAt": "2019-07-01T21:55:26Z",
              "updatedAt": "2019-07-08T13:37:17Z"
            },
            {
              "originalPosition": 196,
              "body": "BasicCredential is an instance of Credential, so just refer to the identity in the credential.  Or just eliminate all of this :)",
              "createdAt": "2019-07-01T21:55:53Z",
              "updatedAt": "2019-07-08T13:37:17Z"
            },
            {
              "originalPosition": 240,
              "body": "Nit: Unfortunate resonance between \"More precisely... More generally...\"",
              "createdAt": "2019-07-01T21:57:06Z",
              "updatedAt": "2019-07-08T13:37:17Z"
            },
            {
              "originalPosition": 240,
              "body": "Seems like you could express this by saying a secret is consumed if:\r\n\r\n* It is used to encrypt or decrypt a message\r\n* Any secret derived from it has been consumed",
              "createdAt": "2019-07-01T21:58:27Z",
              "updatedAt": "2019-07-08T13:37:17Z"
            },
            {
              "originalPosition": 261,
              "body": "A diagram might help here.  E.g., in the following scenario...\r\n\r\n```\r\n      G\r\n    /   \\\r\n   /     \\\r\n  E       F\r\n / \\     / \\\r\nA0  B0  C0  D0 -+- KD0\r\n            |   |\r\n            |   +- ND0\r\n            |\r\n            D1 -+- KD1\r\n            |   |\r\n            |   +- ND1\r\n            |\r\n            D2 -+- KD2\r\n                |\r\n                +- ND2\r\n```\r\n\r\nWhen KD1/ND1 are used to decrypt a message, the following are:\r\n* Consumed: G, F, D0, D1, KD1, ND1\r\n* Not necessarily consumed: E, A0, B0, C0, KD0, ND0, D2, KD2, ND2",
              "createdAt": "2019-07-01T22:07:13Z",
              "updatedAt": "2019-07-08T13:37:17Z"
            },
            {
              "originalPosition": 266,
              "body": "Here's the citation you want: https://tools.ietf.org/html/rfc8446#ref-AEAD-LIMITS",
              "createdAt": "2019-07-01T22:07:58Z",
              "updatedAt": "2019-07-08T13:37:17Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU4NjQxMjM2",
          "commit": {
            "abbreviatedOid": "82b931f"
          },
          "author": "psyoptix",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-07T20:11:54Z",
          "updatedAt": "2019-07-07T20:11:55Z",
          "comments": [
            {
              "originalPosition": 149,
              "body": "Here was my thought process which lead to the schedule in the PR.\r\n\r\nA property of left/right tree schedule i'm not a fan of: if nodes v and u end up with the same key then their children (and grandchildren, etc.) will have the same key too.\r\n\r\nSo add IndexOf(V.left_child) as context to Derive-Secret. However this still means if, in 2 different epochs a node in the AS Tree ends has the same key then so will its children. Thats why I added the Hash(GroupState_[n]).\r\n\r\nTo be clear, its not like I have a concrete attack. Its more of a \"best practice\" & \"defense in depth\" situation. IMO different pairs of keys having the same relation to each other make me nervous.\r\n\r\nI also hoped that since Hash(GroupState_[n]) only needs to computed once, is a short string (e.g. fits into even lower cache levels) and can be blindly plugged in to all Derive-Secret calls the price for this approach wasn't too great.\r\n\r\nSo for now I've not made any changes here. However, I dont fell all *that* strongly about it. So if you do, or there's push back from others as well then feel free to change it.",
              "createdAt": "2019-07-07T20:11:54Z",
              "updatedAt": "2019-07-08T13:37:17Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU4NjQxNTM5",
          "commit": {
            "abbreviatedOid": "82b931f"
          },
          "author": "psyoptix",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-07T20:20:40Z",
          "updatedAt": "2019-07-07T20:20:41Z",
          "comments": [
            {
              "originalPosition": 194,
              "body": "My reasoning here is the same as I explained above: no 2 keys should have the same relation -> defence in depth.\r\n\r\nIMO TLS is designed for greater packets per second than MLS (and probably aims to run on weaker devices like IoT stuff too) so it makes sense for TLS to care a lot about being efficient. MLS though is meant for lower packet rate (on at least a cellphone level device) so I think its worth spending a small number of extra cycles and memory access for reasons of best practice.\r\n\r\nJust as before, I'll leave it up to you which way to go though.",
              "createdAt": "2019-07-07T20:20:40Z",
              "updatedAt": "2019-07-08T13:37:17Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU4NjQxNjYx",
          "commit": {
            "abbreviatedOid": "82b931f"
          },
          "author": "psyoptix",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-07T20:24:33Z",
          "updatedAt": "2019-07-07T20:24:34Z",
          "comments": [
            {
              "originalPosition": 194,
              "body": "Oh. yeah, that wasn't too consistent. I mean leaf_index to denote the number of the leaf assigned to the owner of the ratchet, not their identity. \r\n\r\nAll I really care about for that the value is that its unique to a given ratchet and that its easy to determine the value for any client in the group. So using a full identity seems like an over kill. The index of the client's leaf should be enough.\r\n\r\nI edited things to (hopefully) make that clearer and more consistent.",
              "createdAt": "2019-07-07T20:24:33Z",
              "updatedAt": "2019-07-08T13:37:17Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU4NjQyMjgy",
          "commit": {
            "abbreviatedOid": "82b931f"
          },
          "author": "psyoptix",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-07T20:42:40Z",
          "updatedAt": "2019-07-07T20:42:40Z",
          "comments": [
            {
              "originalPosition": 196,
              "body": "Its gone. Full identity wasn't needed. Leaf Index will do.",
              "createdAt": "2019-07-07T20:42:40Z",
              "updatedAt": "2019-07-08T13:37:17Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU4NjQyNDQ5",
          "commit": {
            "abbreviatedOid": "82b931f"
          },
          "author": "psyoptix",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-07T20:46:11Z",
          "updatedAt": "2019-07-07T20:46:12Z",
          "comments": [
            {
              "originalPosition": 194,
              "body": "FYI I also removed the hashing of HashRatCont[i,j]. Now it just goes in the context as is instead of being hashed first.",
              "createdAt": "2019-07-07T20:46:11Z",
              "updatedAt": "2019-07-08T13:37:17Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU4NjQyODI5",
          "commit": {
            "abbreviatedOid": "82b931f"
          },
          "author": "psyoptix",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-07T20:56:10Z",
          "updatedAt": "2019-07-07T20:56:10Z",
          "comments": [
            {
              "originalPosition": 240,
              "body": "Agreed on compression encrypt/decrypt into one line.\r\n\r\nFor the second point I went with \"any key, secret or nonce\" instead of \"any secret\" just to be clear that nonce's are included here (as they're normally not thought of as secrets).",
              "createdAt": "2019-07-07T20:56:10Z",
              "updatedAt": "2019-07-08T13:37:17Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU4NjQ1Nzcy",
          "commit": {
            "abbreviatedOid": "822f18c"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-07T22:21:48Z",
          "updatedAt": "2019-07-07T22:22:00Z",
          "comments": [
            {
              "originalPosition": 149,
              "body": "I can see why it's appealing to have each derivation entail a different relation.  Maybe we can accommodate that a bit more elegantly by moving the GroupContext hash into the definition of Derive-Secret (since that's all that is used for context anyway), and defining a Derive-Application-Secret function that gives us the knobs we need to vary things as we go down the tree and the ratchets.  Here's a sketch that should be copy-paste-able into the text here:\r\n\r\n```\r\nHKDF-Expand-Label(Secret, Label, Context, Length) =\r\n    HKDF-Expand(Secret, HkdfLabel, Length)\r\n\r\nWhere HkdfLabel is specified as:\r\n\r\nstruct {\r\n    uint16 length = Length;\r\n    opaque label<7..255> = \"mls10 \" + Label;\r\n    opaque context<0..2^32-1> = Context;\r\n} HkdfLabel;\r\n\r\nDerive-Secret(Secret, Label) =\r\n    HKDF-Expand-Label(Secret, Label, Hash(GroupContext_[n]), Hash.length)\r\n\r\nstruct {\r\n  uint32 node;\r\n  uint32 generation;\r\n  opaque role<0..255>;\r\n} ApplicationContext;\r\n\r\nDerive-Application-Secret(secret, node, generation, role) =\r\n  DeriveSecret(secret, ApplicationContext(node, generation, role) \r\n\r\nastree_node_[IndexOf(V)]_secret\r\n        |\r\n        |\r\n        +--> Derive-Application-Secret(., V.left_child, 0, \"tree\")\r\n        |    = astree_node_[IndexOf(V.left_child)]_secret\r\n        |\r\n        +--> Derive-Application-Secret(., V.right_child, 0, \"tree\")\r\n             = astree_node_[IndexOf(V.right_child)]_secret\r\n\r\napplication_[i]_[j]_secret\r\n      |\r\n      +--> Derive-Application-Secret(., 2*i, j, \"key\")\r\n      |    = application_[i]_[j+1]_nonce\r\n      |\r\n      +--> Derive-Application-Secret(., 2*i, j, \"nonce\")\r\n      |    = application_[i]_[j+1]_key\r\n      |\r\n      V\r\nHKDF-Application-Secret(., 2*i, j, \"secret\")\r\n= application_[i]_[j+1]_secret\r\n```",
              "createdAt": "2019-07-07T22:21:48Z",
              "updatedAt": "2019-07-08T13:37:17Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU4ODQxNDE4",
          "commit": {
            "abbreviatedOid": "822f18c"
          },
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "state": "CHANGES_REQUESTED",
          "body": "Oki. I have some doubts about many complexities introduced in order to add redundant context in the key derivations which also diverge from the TLS style. I propose to merge this now, as we agreed on the main design at the interim, and do a run of cleanup-simplifications among editors before releasing the draft so that we restore simplicity. We'll then be able to debate over the details as part of our next round of reviews on the draft.",
          "createdAt": "2019-07-08T11:27:03Z",
          "updatedAt": "2019-07-08T13:30:59Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "It is either \"at most\" one symmetric ratchet per group member or you can say one for each sender in the epoch.",
              "createdAt": "2019-07-08T11:27:04Z",
              "updatedAt": "2019-07-08T13:37:17Z"
            },
            {
              "originalPosition": 16,
              "body": "It is not the \"Application Key Schedule\" which is the way to compute the keys but the \"Application Secret Tree\" which is the data structure that contains computed secrets and keys. Also, I don't think you can escape keeping the entire Application Secret Tree because as a receiver you have to be able to compute any Application Secret Chain.",
              "createdAt": "2019-07-08T11:31:13Z",
              "updatedAt": "2019-07-08T13:37:17Z"
            },
            {
              "originalPosition": 64,
              "body": "This block is not necessary, it adds no value as it is perfectly described in the text above.",
              "createdAt": "2019-07-08T11:43:12Z",
              "updatedAt": "2019-07-08T13:37:17Z"
            },
            {
              "originalPosition": 73,
              "body": "This is called the `GroupContext`",
              "createdAt": "2019-07-08T11:46:19Z",
              "updatedAt": "2019-07-08T13:37:17Z"
            },
            {
              "originalPosition": 122,
              "body": "s/`GroupState`/`GroupContext`",
              "createdAt": "2019-07-08T11:52:38Z",
              "updatedAt": "2019-07-08T13:37:17Z"
            },
            {
              "originalPosition": 72,
              "body": "Remove parenthesis",
              "createdAt": "2019-07-08T11:53:20Z",
              "updatedAt": "2019-07-08T13:37:17Z"
            },
            {
              "originalPosition": 138,
              "body": "The only information added for key-separation to the output of this secret is the `node_index` because the `GroupContext` is already in the root application secret. In TreeKEM we add the hash of the left subtree in the context because we build the tree derivations from leaves to the root which is convenient. As it is not the case here, I would either have more things in the `ASTreeContext` (but I don't have an immediate idea of what we could add) or remove this layer and pass the `node_index` directly instead.",
              "createdAt": "2019-07-08T12:09:22Z",
              "updatedAt": "2019-07-08T13:37:17Z"
            },
            {
              "originalPosition": 194,
              "body": "Once again, this is already in all previous derivations.\r\nI think I see why you would add it but in some sense if you have a collision on the KDF outputs, either this is pure coincidence and adding this information is irrelevant, or you have an attack on your KDF and adding context won't save you.",
              "createdAt": "2019-07-08T12:38:12Z",
              "updatedAt": "2019-07-08T13:37:17Z"
            },
            {
              "originalPosition": 194,
              "body": "In general I would prefer to stick to the TLS style instead of adding more complexity for debatable reasons :)",
              "createdAt": "2019-07-08T12:38:49Z",
              "updatedAt": "2019-07-08T13:37:17Z"
            },
            {
              "originalPosition": 214,
              "body": "Again here, what is the reason to add the gshash? There is basically no good reason to change what was previously on the spec except if it were for doing what Richard suggested and create a `Derive-Application-Secret` function.\r\nEven worse, the `HashRatCont[i,j+1]` is not gonna change anything about the probability of collisions for your KDF outputs between parallel chains...",
              "createdAt": "2019-07-08T12:44:50Z",
              "updatedAt": "2019-07-08T13:37:17Z"
            },
            {
              "originalPosition": 194,
              "body": "I agree with Richard here, this is introducing too much complexity for debatable reasons. Would we claim the probability of colliding KDF outputs is gonna be reduced by this ? I guess not. `astree_node_[i]_secret` already mixed in the index of the leaf of the ASTree.",
              "createdAt": "2019-07-08T12:49:46Z",
              "updatedAt": "2019-07-08T13:37:17Z"
            },
            {
              "originalPosition": 240,
              "body": "You need to introduce `S`",
              "createdAt": "2019-07-08T12:51:19Z",
              "updatedAt": "2019-07-08T13:37:17Z"
            },
            {
              "originalPosition": 261,
              "body": "D2 needs to be consumed because you already derived KD2 and ND2. D3 is missing.",
              "createdAt": "2019-07-08T12:54:04Z",
              "updatedAt": "2019-07-08T13:37:17Z"
            },
            {
              "originalPosition": 280,
              "body": "This will not render properly",
              "createdAt": "2019-07-08T12:54:58Z",
              "updatedAt": "2019-07-08T13:37:17Z"
            },
            {
              "originalPosition": 280,
              "body": "D3 is missing from the diagram",
              "createdAt": "2019-07-08T12:56:08Z",
              "updatedAt": "2019-07-08T13:37:17Z"
            },
            {
              "originalPosition": 286,
              "body": "Again, if KD2 and ND2 have been derived, D2 has been killed and D3 is missing",
              "createdAt": "2019-07-08T12:56:12Z",
              "updatedAt": "2019-07-08T13:37:17Z"
            },
            {
              "originalPosition": 266,
              "body": "It is not \"during each epoch\" it is for each encryption, and it is not a number of messages but an amount of data that counts. Since you derive a fresh key and nonce, your AEAD bound is fresh for each application message anyway, so it is for each application message.",
              "createdAt": "2019-07-08T13:01:36Z",
              "updatedAt": "2019-07-08T13:37:17Z"
            },
            {
              "originalPosition": 149,
              "body": "Here is an proposal for this which is an hybrid of your two suggestions:\r\n```\r\nHKDF-Expand-Label(Secret, Label, Context, Length) =\r\n    HKDF-Expand(Secret, HkdfLabel, Length)\r\n\r\nWhere HkdfLabel is specified as:\r\n\r\nstruct {\r\n    uint16 length = Length;\r\n    opaque label<7..255> = \"mls10 \" + Label;\r\n    opaque context<0..2^32-1> = Context;\r\n} HkdfLabel;\r\n\r\nDerive-Secret(Secret, Label) =\r\n    HKDF-Expand-Label(Secret, Label, Hash(GroupContext_[n]), Hash.length)\r\n\r\nstruct {\r\n  uint32 node;\r\n  uint32 generation;\r\n  opaque role<0..255>;\r\n} ApplicationContext;\r\n\r\nDerive-Application-Secret(secret, node, generation, role) =\r\n  DeriveSecret(secret, ApplicationContext(node, generation, role) \r\n\r\nastree_node_[IndexOf(V)]_secret\r\n        |\r\n        |\r\n        +--> Derive-Application-Secret(., V.left_child, 0, \"tree\")\r\n        |    = astree_node_[IndexOf(V.left_child)]_secret\r\n        |\r\n        +--> Derive-Application-Secret(., V.right_child, 0, \"tree\")\r\n             = astree_node_[IndexOf(V.right_child)]_secret\r\n\r\n\r\napplication_[i]_[j]_secret\r\n      |\r\n      +--> HKDF-Expand-Label(.,\"nonce\", \"\", nonce_length)\r\n      |    = write_nonce_[i]_[j]\r\n      |\r\n     +--> HKDF-Expand-Label(.,\"key\", \"\", key_length)\r\n     |    = write_key_[i]_[j] \r\n    V\r\nDerive-Application-Secret(., 2*i, 0, \"sender\")\r\n= application_[i]_[j+1]_secret\r\n\r\n```\r\nThis is slightly different in the sense that we have basically don't change our current way of deriving keys and nonces from an application secret.",
              "createdAt": "2019-07-08T13:17:32Z",
              "updatedAt": "2019-07-08T13:37:17Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU4OTM4ODY4",
          "commit": {
            "abbreviatedOid": "feb096d"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-08T14:25:07Z",
          "updatedAt": "2019-07-08T14:25:07Z",
          "comments": [
            {
              "originalPosition": 286,
              "body": "That's wrong.  D2 isn't consumed until KD2 or ND2 is consumed.",
              "createdAt": "2019-07-08T14:25:07Z",
              "updatedAt": "2019-07-08T14:25:07Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU4OTQwNDY3",
          "commit": {
            "abbreviatedOid": "feb096d"
          },
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-08T14:27:24Z",
          "updatedAt": "2019-07-08T14:27:24Z",
          "comments": [
            {
              "originalPosition": 286,
              "body": "Hmm, I disagree that breaks FS. D3, KD2 and ND2 are derived at the same time from D2 which is consumed at this occasion.",
              "createdAt": "2019-07-08T14:27:24Z",
              "updatedAt": "2019-07-08T14:27:24Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU5MTQ3NzE5",
          "commit": {
            "abbreviatedOid": "feb096d"
          },
          "author": "psyoptix",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-08T20:47:22Z",
          "updatedAt": "2019-07-08T20:47:23Z",
          "comments": [
            {
              "originalPosition": 261,
              "body": "Deriving a value doesnt mean the parent needs to be consumed. Only when the derived values are actually used/consumed does the parent need to be consumed. My understanding of this example is that only KD1/ND1 are used but not KD2/ND2. So D2 doesn't need to be consumed yet.",
              "createdAt": "2019-07-08T20:47:22Z",
              "updatedAt": "2019-07-08T20:47:23Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU5MTQ4NTIw",
          "commit": {
            "abbreviatedOid": "feb096d"
          },
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-08T20:49:03Z",
          "updatedAt": "2019-07-08T20:49:03Z",
          "comments": [
            {
              "originalPosition": 261,
              "body": "Again, if D2 gets leaked, it strictly worse than leaking D3 because you get KD2 and ND2 as well...",
              "createdAt": "2019-07-08T20:49:03Z",
              "updatedAt": "2019-07-08T20:49:03Z"
            }
          ]
        }
      ]
    },
    {
      "number": 147,
      "id": "MDExOlB1bGxSZXF1ZXN0MjcxNDAwODQz",
      "title": "Added public_key_index to Add message",
      "url": "https://github.com/mlswg/mls-protocol/pull/147",
      "state": "CLOSED",
      "author": "rozbb",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "This is a more correct version of #141. See there for prior conversation.",
      "createdAt": "2019-04-17T17:26:19Z",
      "updatedAt": "2019-12-17T09:16:07Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "cda41739560803a05af8407a018f0db2bb85e948",
      "headRepository": "rozbb/mls-protocol",
      "headRefName": "add-public-key-index",
      "headRefOid": "752d17bd3a7ac2f8ca592ff57d71d6f3f2e6d886",
      "closedAt": "2019-04-30T17:56:34Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "I would prefer that we not take this approach, but instead tighten up the requirements for uniqueness in the cipher_suites array, in which case there is no ambiguity in the current approach.\r\n\r\nIf we're going to go this explicit-index route, then you would at least need to require that the recipient verify that `cipher_suites[i] == group.cipher_suite`.  But that seems more fragile than indexing by cipher suite, since the recipient can omit this check and end up trying to re-use key shares across groups.",
          "createdAt": "2019-04-19T14:48:16Z",
          "updatedAt": "2019-04-19T14:48:16Z"
        },
        {
          "author": "rozbb",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I argue that `cipher_suites[i] == group.cipher_suite` is actually less fragile than indexing by ciphersuite. I have ciphersuite information encoded in all my DH and AEAD key types, so even if I were to forget that check, I would get a runtime error very quickly, which is a good thing.\r\n\r\nBut if I were to forget to check for uniqueness of ciphersuites, it could result in two members deriving disagreeing yet valid GroupStates. I think that this situation is harder to diagnose than the above.\r\n\r\nStill, I won't push too hard on this if everyone else is in agreement that it's not necessary.",
          "createdAt": "2019-04-19T17:57:02Z",
          "updatedAt": "2019-04-19T17:57:02Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "I am inclined to close this with no action.  @beurdouche @raphaelrobert wdyt?",
          "createdAt": "2019-04-25T15:10:34Z",
          "updatedAt": "2019-04-25T15:10:34Z"
        },
        {
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "body": "@bifurcation Yes, I agree with closing this.",
          "createdAt": "2019-04-29T08:52:52Z",
          "updatedAt": "2019-04-29T08:52:52Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 148,
      "id": "MDExOlB1bGxSZXF1ZXN0MjcxNDQ3ODIw",
      "title": "Added that users SHOULD verify pubkeys in an Update",
      "url": "https://github.com/mlswg/mls-protocol/pull/148",
      "state": "MERGED",
      "author": "rozbb",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "security",
        "recommendation"
      ],
      "body": "Adding this check would be the first step in recognizing that an Update operation may have maliciously excluded a person from the group.",
      "createdAt": "2019-04-17T19:57:16Z",
      "updatedAt": "2019-12-17T09:15:38Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "cda41739560803a05af8407a018f0db2bb85e948",
      "headRepository": "rozbb/mls-protocol",
      "headRefName": "verify-update-pubkeys",
      "headRefOid": "d75db3092eed43b52df71249c80680198ca07bcf",
      "closedAt": "2019-04-29T08:45:48Z",
      "mergedAt": "2019-04-29T08:45:48Z",
      "mergedBy": "beurdouche",
      "mergeCommit": {
        "oid": "242746778e96d2d865f916e36b3518104117a283"
      },
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "This would go better in the \"Ratchet Tree Updates\" section, right after \"Derive secret values for ancestors of that node using the KDF keyed with the decrypted secret\".  That would align better with where in the code you want the checks to be.  Other than that, LGTM.",
          "createdAt": "2019-04-19T14:39:25Z",
          "updatedAt": "2019-04-19T14:39:25Z"
        },
        {
          "author": "rozbb",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Fixed",
          "createdAt": "2019-04-19T18:02:04Z",
          "updatedAt": "2019-04-19T18:02:04Z"
        },
        {
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "body": "Thanks Michael !",
          "createdAt": "2019-04-29T08:46:55Z",
          "updatedAt": "2019-04-29T08:46:55Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjI5MjU1NzIx",
          "commit": {
            "abbreviatedOid": "3551fbb"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-04-22T21:20:43Z",
          "updatedAt": "2019-04-22T21:20:43Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjI5MjU2ODky",
          "commit": {
            "abbreviatedOid": "3551fbb"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-04-22T21:23:37Z",
          "updatedAt": "2019-04-22T21:23:37Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "Editorial: \"Members\" -> \"The recipient\"",
              "createdAt": "2019-04-22T21:23:37Z",
              "updatedAt": "2019-04-25T23:12:03Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjMwMjkyNTEw",
          "commit": {
            "abbreviatedOid": "866e4a4"
          },
          "author": "rozbb",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-04-24T18:47:33Z",
          "updatedAt": "2019-04-24T18:47:33Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "Done",
              "createdAt": "2019-04-24T18:47:33Z",
              "updatedAt": "2019-04-25T23:12:03Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjMxNTY1Njky",
          "commit": {
            "abbreviatedOid": "d75db30"
          },
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-04-29T08:44:17Z",
          "updatedAt": "2019-04-29T08:44:17Z",
          "comments": []
        }
      ]
    },
    {
      "number": 149,
      "id": "MDExOlB1bGxSZXF1ZXN0MjcxNDUwNjA0",
      "title": "Did a bunch of clarification around path secrets",
      "url": "https://github.com/mlswg/mls-protocol/pull/149",
      "state": "CLOSED",
      "author": "rozbb",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "A few things:\r\n\r\n1. Restructured the sections \"Ratchet Tree Nodes and Tree Updates\" and \"Ratchet Tree Updates\" into \"Ratchet Tree Nodes\" and \"Ratchet Tree Updates\". I also put them next to each other, whereas before the \"Blank Nodes and Resolution\" section came between them.\r\n2. Removed node secrets from the set of things that a node must contain. There is no need for this. The node secret is used precisely once\u2014to derive the node's keypair. It needn't be stored after that.\r\n3. Clarified things and made the terminology more consistent. For example, the diagram in the previous \"Ratchet Tree Updates\" section only referred to \"secrets\" without specification (because there used to only be node secrets). There were also statements that referred to node secrets when they meant path secrets. These should be fixed now.\r\n4. Renamed `RatchetNode::node_secrets` to `RatchetNode::path_secrets`",
      "createdAt": "2019-04-17T20:06:22Z",
      "updatedAt": "2019-12-17T09:15:19Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "cda41739560803a05af8407a018f0db2bb85e948",
      "headRepository": "rozbb/mls-protocol",
      "headRefName": "path-secret-cleanup",
      "headRefOid": "887f86762d2d962c47ac3fdc59802b788643e5ae",
      "closedAt": "2019-04-24T19:44:46Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "@rozbb Could you please verify that #134 has the required changes in it?  (And thus that this PR can be closed.)",
          "createdAt": "2019-04-22T21:25:34Z",
          "updatedAt": "2019-04-22T21:25:50Z"
        },
        {
          "author": "rozbb",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yup, looks like everything made it in. See #134 for further comments.",
          "createdAt": "2019-04-24T19:44:46Z",
          "updatedAt": "2019-04-24T19:44:46Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 151,
      "id": "MDExOlB1bGxSZXF1ZXN0MjcyMDA5MTU1",
      "title": "A couple of minor fixes",
      "url": "https://github.com/mlswg/mls-protocol/pull/151",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "* Clean up some OPEN ISSUES that aren't open any more\r\n* Make the welcome/add diagram clearer",
      "createdAt": "2019-04-19T14:22:21Z",
      "updatedAt": "2019-12-17T09:15:08Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "cda41739560803a05af8407a018f0db2bb85e948",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "minor-fixes",
      "headRefOid": "b42e702fdfec54197159a27bd29f0bfa5c84a3da",
      "closedAt": "2019-04-22T21:17:17Z",
      "mergedAt": "2019-04-22T21:17:17Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "24efba91dd3c679a27d9c96158707cfee3b09df3"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjI4NzA5MTIz",
          "commit": {
            "abbreviatedOid": "ee358ac"
          },
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-04-19T14:26:08Z",
          "updatedAt": "2019-04-19T14:26:08Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjI4NzY0MDQy",
          "commit": {
            "abbreviatedOid": "ee358ac"
          },
          "author": "rozbb",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-04-19T17:24:39Z",
          "updatedAt": "2019-04-19T17:24:40Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "This should be `Add(A->AB)`",
              "createdAt": "2019-04-19T17:24:39Z",
              "updatedAt": "2019-04-22T21:16:00Z"
            }
          ]
        }
      ]
    },
    {
      "number": 152,
      "id": "MDExOlB1bGxSZXF1ZXN0MjcyNzY5NjU3",
      "title": "Make epochs unpredictable",
      "url": "https://github.com/mlswg/mls-protocol/pull/152",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "privacy",
        "? follow-up"
      ],
      "body": "As discussed on the mailing list, further reduces the ability of the Delivery Service to infer what's going on in the group.",
      "createdAt": "2019-04-23T14:58:25Z",
      "updatedAt": "2019-12-20T10:11:51Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "24efba91dd3c679a27d9c96158707cfee3b09df3",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "random-epoch",
      "headRefOid": "d465e0110be01424eb06a37681d2693fa371c768",
      "closedAt": "2019-07-01T22:22:49Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "psyoptix",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I see we use HMAC to derive epoch_[n] which forces explicit truncation of HMACs output (to 4 bytes). Why not use HMAC-Expand instead? It's already used in another place by MLS so should already be available and it already takes the desired output length as a third parameter.",
          "createdAt": "2019-04-24T12:10:59Z",
          "updatedAt": "2019-04-24T12:10:59Z"
        },
        {
          "author": "psyoptix",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'm sure this is a silly question so please humor me... :-)\r\n\r\nIn the GroupOperation struct there is a select command which, I think, results in one of 4 struct types (e.g. \"Init\", \"Add\", etc) being chosen depending on the value of msg_type. But I dont see the actual *name* for that struct member being defined there (say, \"msg\"). Is it missing...  or am I just missing something? :-)\r\n\r\nIn case there's no bug here and I'm just not familiar with that syntax could someone point me to a resource where I can read up on it?",
          "createdAt": "2019-04-24T12:21:33Z",
          "updatedAt": "2019-04-24T12:21:33Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks for the comments, @psyoptix \r\n\r\nRe: `HKDF-Expand` -- Yeah, this is a good idea.  I'll refactor to use that.  It's still just one HKDF instantiation, after all.\r\n\r\nRe: `GroupOperation` -- According to [the syntax specification](https://tools.ietf.org/html/rfc8446#section-3.8), the field names are optional, but I would be fine including them.  Want to send a small PR for that?",
          "createdAt": "2019-04-24T12:59:53Z",
          "updatedAt": "2019-04-24T12:59:53Z"
        },
        {
          "author": "psyoptix",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yup, so as expected the issue lies with my knowledge of the correct syntax not with the doc so nevermind. :-) thanks for the reference by the way.\r\n\r\n(and as long as we're never referring to that member there's no need in giving it a name so the definition is fine as is.)",
          "createdAt": "2019-04-24T15:47:17Z",
          "updatedAt": "2019-04-24T15:47:17Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "@beurdouche based on your comments in #155 do you want to push this to draft-06?",
          "createdAt": "2019-05-01T02:13:06Z",
          "updatedAt": "2019-05-01T02:13:06Z"
        },
        {
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "body": "> @beurdouche based on your comments in #155 do you want to push this to draft-06?\r\n\r\nYes, that is not a difficult issue but I think handling unpredicatable epoch and unpredictable group_id makes sense. That might be a short discussion topic at the interim ?",
          "createdAt": "2019-05-01T10:32:44Z",
          "updatedAt": "2019-05-01T10:32:44Z"
        },
        {
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "body": "> > @beurdouche based on your comments in #155 do you want to push this to draft-06?\r\n> \r\n> Yes, that is not a difficult issue but I think handling unpredicatable epoch and unpredictable group_id makes sense. That might be a short discussion topic at the interim ?\r\n\r\nat the same time*",
          "createdAt": "2019-05-01T10:33:13Z",
          "updatedAt": "2019-05-01T10:33:13Z"
        },
        {
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "body": "I fully support the intention of this, but it is not clear to me how the DS can enforce total order on HS messages if the epochs are no longer comparable.",
          "createdAt": "2019-07-01T12:07:16Z",
          "updatedAt": "2019-07-01T12:07:16Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing this until we have a better theory for the overall environment (e.g., how server assist would work).",
          "createdAt": "2019-07-01T22:22:49Z",
          "updatedAt": "2019-07-01T22:22:49Z"
        },
        {
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "body": "This can be discussed as part of \"Server assist\".",
          "createdAt": "2019-12-20T10:11:51Z",
          "updatedAt": "2019-12-20T10:11:51Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 153,
      "id": "MDExOlB1bGxSZXF1ZXN0MjcyOTA5NzE0",
      "title": "Common framing, consolidated",
      "url": "https://github.com/mlswg/mls-protocol/pull/153",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "duplicate"
      ],
      "body": "I started off trying to just edit #131 to be landable, but as I looked at it, it seemed like we had accreted enough complexity that a refactor was in order.  So this PR mostly rewrites the sections related to encryption keys and message framing, hopefully in a way that's clearer to the reader.  For the most part, though, the technical bits are the same as in #131.  There are a couple of innovations here:\r\n\r\n* Using \"masking\" instead of AEAD for sender data encryption (cf. [QUIC header protection](https://tools.ietf.org/html/draft-ietf-quic-tls-17#section-5.4)). This saves 28 bytes of overhead, but there's no longer authentication except in the content AEAD.  This change could be done as a follow-on PR, but it seemed brief enough to include here.\r\n\r\n* I eliminated the `group_id` field in the messages, since it seems plausible that we could rely on applications to provide that.    The benefit of this is that the wire image that MLS itself presents (in `MLSCiphertext`) is entirely opaque to the delivery service (even if the DS might add some context that indicates the group ID).",
      "createdAt": "2019-04-23T22:07:28Z",
      "updatedAt": "2019-12-17T10:14:59Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "24efba91dd3c679a27d9c96158707cfee3b09df3",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "rlb-framing-v2",
      "headRefOid": "acfac1345e571fd9190279afb759088bd9cb94a5",
      "closedAt": "2019-05-01T02:12:24Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Draft implementation here: https://github.com/cisco/mlspp/pull/48",
          "createdAt": "2019-04-24T14:03:39Z",
          "updatedAt": "2019-04-24T14:03:39Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjMxNTk5MTAy",
          "commit": {
            "abbreviatedOid": "acfac13"
          },
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "state": "CHANGES_REQUESTED",
          "body": "Ok, globally I think this is quite good, but there are a few changes I think we should revert so I made the fixes on top of this PR in \r\nhttps://github.com/mlswg/mls-protocol/pull/155",
          "createdAt": "2019-04-29T10:09:15Z",
          "updatedAt": "2019-04-30T19:00:38Z",
          "comments": [
            {
              "originalPosition": 70,
              "body": "It is not only \"within the epoch\" but across the epochs as well.",
              "createdAt": "2019-04-29T10:11:06Z",
              "updatedAt": "2019-04-30T19:00:38Z"
            },
            {
              "originalPosition": 136,
              "body": "What can we say about Encryption here ?",
              "createdAt": "2019-04-29T10:14:33Z",
              "updatedAt": "2019-04-30T19:00:38Z"
            },
            {
              "originalPosition": 187,
              "body": "The `ContentType` should be somewhere here. It cannot be only inside, otherwise the DS cannot enforce total ordering of the HS messages. (It would force total ordering of application messages as well)",
              "createdAt": "2019-04-30T10:18:54Z",
              "updatedAt": "2019-04-30T19:00:38Z"
            },
            {
              "originalPosition": 186,
              "body": "Group ID is missing here. (See my point below)",
              "createdAt": "2019-04-30T10:21:06Z",
              "updatedAt": "2019-04-30T19:00:38Z"
            },
            {
              "originalPosition": 194,
              "body": "I don't think we should do this, this is quite a pain to add an unspecified requirement that the GID is somehow communicated out of band or via an ad-hoc way to the recipient.",
              "createdAt": "2019-04-30T10:22:10Z",
              "updatedAt": "2019-04-30T19:00:38Z"
            },
            {
              "originalPosition": 34,
              "body": "This seem like an unnecessary source of complexity, I would be fine with putting everything inside.",
              "createdAt": "2019-04-30T18:51:48Z",
              "updatedAt": "2019-04-30T19:00:38Z"
            },
            {
              "originalPosition": 49,
              "body": "I am not sure about \"sender\", as it is not sender specific. \"sender info\" ?",
              "createdAt": "2019-04-30T18:52:30Z",
              "updatedAt": "2019-04-30T19:00:38Z"
            },
            {
              "originalPosition": 69,
              "body": "There is no chain for the Handshake message. We are missing a definition to derive a key/nonce for handshake message. This should probably be sender specific as well to avoid two different sender to encrypt using the same key.",
              "createdAt": "2019-04-30T18:55:22Z",
              "updatedAt": "2019-04-30T19:00:38Z"
            },
            {
              "originalPosition": 245,
              "body": "This should probably be called `MLSCiphertextContent` then",
              "createdAt": "2019-04-30T18:57:13Z",
              "updatedAt": "2019-04-30T19:00:38Z"
            },
            {
              "originalPosition": 264,
              "body": "This should probably be called `MLSCiphertextAAD` and the AAD can now be the public prefix of the ciphertext on the wire.",
              "createdAt": "2019-04-30T18:58:07Z",
              "updatedAt": "2019-04-30T19:00:38Z"
            },
            {
              "originalPosition": 282,
              "body": "I think this should be removed.",
              "createdAt": "2019-04-30T18:58:27Z",
              "updatedAt": "2019-04-30T19:00:38Z"
            },
            {
              "originalPosition": 303,
              "body": "If we remove, this must be 8",
              "createdAt": "2019-04-30T18:58:41Z",
              "updatedAt": "2019-04-30T19:00:38Z"
            },
            {
              "originalPosition": 307,
              "body": "I really like this.",
              "createdAt": "2019-04-30T18:59:18Z",
              "updatedAt": "2019-04-30T19:00:38Z"
            }
          ]
        }
      ]
    },
    {
      "number": 155,
      "id": "MDExOlB1bGxSZXF1ZXN0Mjc0ODQ5MDcy",
      "title": "Common framing, consolidated with modifications",
      "url": "https://github.com/mlswg/mls-protocol/pull/155",
      "state": "MERGED",
      "author": "beurdouche",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "security",
        "privacy",
        "performance",
        "functionality"
      ],
      "body": "This PR is updates Richard's changes with a few adjustments:\r\n\r\n- Merge master;\r\n- Fix missing definition to derive key/nonce used for encryption of Handshake messages;\r\n- Delete the \"remove_confirmation\" function for simplicity. It has a very low cost anyway;\r\n- Revert to having the GID and the epoch in the clear, otherwise there is a need for a magic channel to communicate it to the recipient. We can eventually do it but this should be discussed seriously in Berlin;\r\n- Revert the masking of the content type, (keeps masking for sender and generation) otherwise it seem to force plaintext OR the Delivery Service to have access to the sender_data_secret. It seem impossible to only order Handshake messages otherwise.",
      "createdAt": "2019-04-30T18:59:46Z",
      "updatedAt": "2019-12-17T09:13:23Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "3f14893110df64b367e0ae1f09410ddae45b4be5",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "beurdouche_101bis",
      "headRefOid": "c13bd759241ef2bb6139e36bbcdaeccffc0977c7",
      "closedAt": "2019-05-02T15:31:25Z",
      "mergedAt": "2019-05-02T15:31:25Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "d7f01dba19742ee95735496fa4a14bfa0434c0b9"
      },
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "@raphaelrobert Last call on this one.  If I don't hear from you by the morning ET, I'm going to merge this.",
          "createdAt": "2019-05-02T01:29:39Z",
          "updatedAt": "2019-05-02T01:29:39Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Note that this PR will be pretty immediately updated by #156, which reverts the \"masking\" parts to use AEAD, in order to make analysis simpler for this revision.",
          "createdAt": "2019-05-02T15:31:08Z",
          "updatedAt": "2019-05-02T15:31:08Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjMyNDc2MTUy",
          "commit": {
            "abbreviatedOid": "02164b7"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "Overall, this looks pretty close.  OK to merge once we get these comments addressed.  I'm slightly sad to lose the extra masking, but we can handle that as a follow-on.",
          "createdAt": "2019-05-01T01:56:21Z",
          "updatedAt": "2019-05-01T02:11:29Z",
          "comments": [
            {
              "originalPosition": 106,
              "body": "s/\"[sender]\"/[sender]/",
              "createdAt": "2019-05-01T01:56:21Z",
              "updatedAt": "2019-05-02T15:21:43Z"
            },
            {
              "originalPosition": 109,
              "body": "Ditto here.",
              "createdAt": "2019-05-01T01:56:30Z",
              "updatedAt": "2019-05-02T15:21:43Z"
            },
            {
              "originalPosition": 102,
              "body": "This text assumes that there's only a need for one handshake message to be sent per epoch.  I realize that should be true in most cases, but I'm concerned about things like retries leading to nonce reuse.  This is why in #153, I had handshake keys follow the same path as application keys.  This also allows code reuse.\r\n",
              "createdAt": "2019-05-01T02:00:27Z",
              "updatedAt": "2019-05-02T15:21:43Z"
            },
            {
              "originalPosition": 125,
              "body": "s/sender/ap sender/ ?",
              "createdAt": "2019-05-01T02:00:53Z",
              "updatedAt": "2019-05-02T15:21:43Z"
            },
            {
              "originalPosition": 102,
              "body": "Oh, I see you have conveniently not deleted that text :)  So I would just delete the text you've added up here.",
              "createdAt": "2019-05-01T02:01:40Z",
              "updatedAt": "2019-05-02T15:21:43Z"
            },
            {
              "originalPosition": 52,
              "body": "In general, I've been using lower-case \"handshake message\", since we don't have a Handshake struct any more.",
              "createdAt": "2019-05-01T02:02:39Z",
              "updatedAt": "2019-05-02T15:21:43Z"
            },
            {
              "originalPosition": 222,
              "body": "s/type/content_type/",
              "createdAt": "2019-05-01T02:03:23Z",
              "updatedAt": "2019-05-02T15:21:43Z"
            },
            {
              "originalPosition": 246,
              "body": "\"Concatenating\" is not quite right, since it's a bit more complex than that.  Maybe \"Gather the required metadata:\"",
              "createdAt": "2019-05-01T02:04:44Z",
              "updatedAt": "2019-05-02T15:21:43Z"
            },
            {
              "originalPosition": 260,
              "body": "Also content_type now, right?",
              "createdAt": "2019-05-01T02:05:28Z",
              "updatedAt": "2019-05-02T15:21:43Z"
            },
            {
              "originalPosition": 285,
              "body": "It occurs to me that there's not actually a `length` field in `MLSPlaintext`.  Let's just use `length_of_content`, in parallel to `length_of_padding`.    ",
              "createdAt": "2019-05-01T02:08:01Z",
              "updatedAt": "2019-05-02T15:21:43Z"
            },
            {
              "originalPosition": 294,
              "body": "\"a handshake_key\".  But really you need to change this to say \"an unused generation from it's application or handshake key chain\"",
              "createdAt": "2019-05-01T02:08:47Z",
              "updatedAt": "2019-05-02T15:21:43Z"
            },
            {
              "originalPosition": 308,
              "body": "This is impossible.  The masking is based on the ciphertext, so you can't use the masked values as an input to the encryption.  Just use the plain values.",
              "createdAt": "2019-05-01T02:09:57Z",
              "updatedAt": "2019-05-02T15:21:43Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjMyNTM4Mjk3",
          "commit": {
            "abbreviatedOid": "fa15000"
          },
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "Ok, so I've merged master and made changes according to your comments.\r\nI think there is only one point remaining to be discussed but it is quite interesting... :)",
          "createdAt": "2019-05-01T10:50:50Z",
          "updatedAt": "2019-05-01T11:25:07Z",
          "comments": [
            {
              "originalPosition": 102,
              "body": "My way of thinking of this is that, since the Delivery Service has to provide total ordering of the handshake messages, each message will be processed after the other. In the case where two clients A, B emit HS messages in the same epoch [N], the Delivery Service will accept one (say mA) and reject the other (mB): B has to first process mA to get to the new epoch and group state [N+1], then it has to re-encrypt in the new epoch ([N+1]). I might be wrong but I think that this is necessary for everyone to end-up in the same state...\r\n\r\nIn the mechanism you describe, my understanding is that handshake_secret chain would live in the same epoch N. Because B needs to move to epoch [N+1] anyways, it would have to keep it's handshake_secret_[N]_[1] alive.\r\n\r\nI think this could be fine, but since we have to move to epoch [N+1] anyway, my proposal is just for B to use handshake_secret_[N+1]_[0] directly which allows everybody to kill all HS secrets from the previous epoch.\r\nIf I am correct, because of the fact that there is the [sender] in the derivation of the key/nonce, there cannot be a key/nonce reuse:\r\n- Even if two senders would send the same HS message, the keys would be different\r\n- Since you only encrypt at most one HS message per epoch, there is no more risk for reusing than what we have for application messages.\r\n\r\nIn some sense all the handshake secrets for the previous epoch are gone immediately and there is no need for book-keeping handshake_secrets from a previous epoch. Note that regarding code reuse, we can add the [sender] to the application key/nonce derivation so that these derivations only differ by the label... :)\r\n\r\nDoes that make sense and what do you think ? ;)\r\nB.\r\n\r\n",
              "createdAt": "2019-05-01T10:50:50Z",
              "updatedAt": "2019-05-02T15:21:43Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjMyNzA1NDg4",
          "commit": {
            "abbreviatedOid": "fa15000"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-01T18:56:01Z",
          "updatedAt": "2019-05-01T18:57:38Z",
          "comments": [
            {
              "originalPosition": 322,
              "body": "\"a handshake key\"",
              "createdAt": "2019-05-01T18:56:01Z",
              "updatedAt": "2019-05-02T15:21:43Z"
            },
            {
              "originalPosition": 323,
              "body": "\"a handshake message\"",
              "createdAt": "2019-05-01T18:56:16Z",
              "updatedAt": "2019-05-02T15:21:43Z"
            },
            {
              "originalPosition": 102,
              "body": "I can live with that for now.  Please remove the para starting \"The same rules are used to generate a sequence of keys and nonces for handshake encryption\"\r\n\r\nI see what you're saying, I don't feel 100% confident that we won't get wedged by this in practice.  And I dislike the extra code paths.  But we can merge with this flavor and ask the WG.\r\n",
              "createdAt": "2019-05-01T18:57:30Z",
              "updatedAt": "2019-05-02T15:21:43Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjMyNzIwMDkz",
          "commit": {
            "abbreviatedOid": "fa15000"
          },
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-01T19:34:11Z",
          "updatedAt": "2019-05-01T19:39:14Z",
          "comments": [
            {
              "originalPosition": 102,
              "body": "I agree, there might be a better solution but I don't immediately have it.\r\nShould I add an open issue or something ?",
              "createdAt": "2019-05-01T19:34:11Z",
              "updatedAt": "2019-05-02T15:21:43Z"
            },
            {
              "originalPosition": 322,
              "body": "Fixed, thanks !",
              "createdAt": "2019-05-01T19:34:31Z",
              "updatedAt": "2019-05-02T15:21:43Z"
            },
            {
              "originalPosition": 323,
              "body": "Fixed, thanks !",
              "createdAt": "2019-05-01T19:34:34Z",
              "updatedAt": "2019-05-02T15:21:43Z"
            }
          ]
        }
      ]
    },
    {
      "number": 156,
      "id": "MDExOlB1bGxSZXF1ZXN0Mjc1NDAyOTk0",
      "title": " Revert QUIC-like masking of sender_data in favor of AEAD ",
      "url": "https://github.com/mlswg/mls-protocol/pull/156",
      "state": "MERGED",
      "author": "beurdouche",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "security"
      ],
      "body": "",
      "createdAt": "2019-05-02T15:07:09Z",
      "updatedAt": "2019-12-17T09:12:36Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "d7f01dba19742ee95735496fa4a14bfa0434c0b9",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "beurdouche_revert_masking",
      "headRefOid": "acc56c5fd1d5691bc5b9a10a251de0a397c508ee",
      "closedAt": "2019-05-02T17:45:14Z",
      "mergedAt": "2019-05-02T17:45:13Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "8f938ed1188b0d6f4decbfd77b96a4a041557f7b"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjMzMDgwNjA5",
          "commit": {
            "abbreviatedOid": "05a5606"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-02T15:33:12Z",
          "updatedAt": "2019-05-02T15:34:13Z",
          "comments": [
            {
              "originalPosition": 266,
              "body": "Nit: This would be a little clearer as `sender_data_nonce`",
              "createdAt": "2019-05-02T15:33:12Z",
              "updatedAt": "2019-05-02T15:47:11Z"
            },
            {
              "originalPosition": 370,
              "body": "`sender_data_nonce`",
              "createdAt": "2019-05-02T15:33:35Z",
              "updatedAt": "2019-05-02T15:47:11Z"
            },
            {
              "originalPosition": 304,
              "body": "`sender_data_nonce`",
              "createdAt": "2019-05-02T15:34:10Z",
              "updatedAt": "2019-05-02T15:47:11Z"
            }
          ]
        }
      ]
    },
    {
      "number": 163,
      "id": "MDExOlB1bGxSZXF1ZXN0Mjc5NzkxNzE3",
      "title": "Reorder blanking and update in the Remove operation",
      "url": "https://github.com/mlswg/mls-protocol/pull/163",
      "state": "MERGED",
      "author": "beurdouche",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "security",
        "performance",
        "functionality"
      ],
      "body": "Fixes #162 ",
      "createdAt": "2019-05-17T08:07:38Z",
      "updatedAt": "2019-12-17T09:12:15Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "564ee2662e4eeac93a854edf3a6ab44eb46cb6d6",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "beurdouche_remove",
      "headRefOid": "50bc327f2e5d65832713c93e0c2ab7588be0a4d1",
      "closedAt": "2019-05-24T14:01:35Z",
      "mergedAt": "2019-05-24T14:01:35Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "46b8ece169e2bf0eb6771eac4396f144199032e4"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjQxNDc3MTkz",
          "commit": {
            "abbreviatedOid": "7c3f16c"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2019-05-23T22:16:11Z",
          "updatedAt": "2019-05-23T22:18:01Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "We should note here that the blanking should be temporary / undone after this computation.  The generation of messages should not change the sender's state.",
              "createdAt": "2019-05-23T22:16:11Z",
              "updatedAt": "2019-05-24T08:48:03Z"
            },
            {
              "originalPosition": 15,
              "body": "Also, you should go ahead and truncate here, which will save you unnecessary derivations.  So:\r\n\r\n* Before: Encrypt / blank\r\n* After: Blank / Truncate / Encrypt\r\n\r\nSame change in the processing logic below.\r\n\r\n",
              "createdAt": "2019-05-23T22:17:47Z",
              "updatedAt": "2019-05-24T08:48:03Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjQxNzU4MDc4",
          "commit": {
            "abbreviatedOid": "50bc327"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-05-24T14:01:23Z",
          "updatedAt": "2019-05-24T14:01:23Z",
          "comments": []
        }
      ]
    },
    {
      "number": 164,
      "id": "MDExOlB1bGxSZXF1ZXN0Mjc5NzkzMzcw",
      "title": "Rename UserInitKey to ClientInitKey",
      "url": "https://github.com/mlswg/mls-protocol/pull/164",
      "state": "MERGED",
      "author": "beurdouche",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "terminology"
      ],
      "body": "Fixes #137 ",
      "createdAt": "2019-05-17T08:13:37Z",
      "updatedAt": "2019-12-17T09:11:56Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "46b8ece169e2bf0eb6771eac4396f144199032e4",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "beurdouche_clientinitkey",
      "headRefOid": "72056b8116d31326a9f84855cde0ae08007715dd",
      "closedAt": "2019-05-24T14:04:36Z",
      "mergedAt": "2019-05-24T14:04:36Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "0d849622508cebd6d9c769dd0388fa17d15fd083"
      },
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Overall, this seems OK.  Just using \"InitKey\" would be clear and less wordy.",
          "createdAt": "2019-05-23T22:05:08Z",
          "updatedAt": "2019-05-23T22:05:08Z"
        },
        {
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "body": "I tried this and that led people to confuse `init key` and `init secret`",
          "createdAt": "2019-05-24T08:17:42Z",
          "updatedAt": "2019-05-24T08:17:42Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 165,
      "id": "MDExOlB1bGxSZXF1ZXN0Mjc5ODIzODc4",
      "title": "Fix typo after change in the MLSCiphertextContent struct",
      "url": "https://github.com/mlswg/mls-protocol/pull/165",
      "state": "MERGED",
      "author": "beurdouche",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "Fix for #158",
      "createdAt": "2019-05-17T09:47:39Z",
      "updatedAt": "2019-12-17T09:11:49Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "8f938ed1188b0d6f4decbfd77b96a4a041557f7b",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "beurdouche_158",
      "headRefOid": "f2fe8ec26565404ef0e6c4d79a61bea0dc50a84f",
      "closedAt": "2019-05-17T09:47:55Z",
      "mergedAt": "2019-05-17T09:47:55Z",
      "mergedBy": "beurdouche",
      "mergeCommit": {
        "oid": "99b311924a9b619fd1e03d4eecd21619bbada6be"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 166,
      "id": "MDExOlB1bGxSZXF1ZXN0Mjc5ODI2NjI3",
      "title": "GroupState is not a group state, renaming to GroupContext",
      "url": "https://github.com/mlswg/mls-protocol/pull/166",
      "state": "MERGED",
      "author": "beurdouche",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "terminology"
      ],
      "body": "Fix for #159",
      "createdAt": "2019-05-17T09:55:35Z",
      "updatedAt": "2019-12-17T09:11:37Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "99b311924a9b619fd1e03d4eecd21619bbada6be",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "beurdouche_159",
      "headRefOid": "66e4cbdbd11018983d9bca9dcf742aa42d92b57f",
      "closedAt": "2019-05-24T08:25:52Z",
      "mergedAt": "2019-05-24T08:25:52Z",
      "mergedBy": "beurdouche",
      "mergeCommit": {
        "oid": "564ee2662e4eeac93a854edf3a6ab44eb46cb6d6"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjQxNDc0MjI2",
          "commit": {
            "abbreviatedOid": "1e7c031"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Approved with the one comment fixed.",
          "createdAt": "2019-05-23T22:06:30Z",
          "updatedAt": "2019-05-23T22:07:06Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "It's not partial, it's a summary / commitment.\r\n\r\n\"Each member of the group maintains a GroupContext object that summarizes the state of the group:\"",
              "createdAt": "2019-05-23T22:06:30Z",
              "updatedAt": "2019-05-24T08:24:54Z"
            }
          ]
        }
      ]
    },
    {
      "number": 167,
      "id": "MDExOlB1bGxSZXF1ZXN0Mjc5OTA5NjY1",
      "title": "Fix incorrect definition of update_secret",
      "url": "https://github.com/mlswg/mls-protocol/pull/167",
      "state": "MERGED",
      "author": "beurdouche",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "bug",
        "editorial"
      ],
      "body": "\"The update secret resulting from this change is the path secret for the\r\nroot node of the ratchet tree.\" is suspicious because in the derivation, the index for both the `path_secret` and `node_secret` is the same as the level of the node. It should be the `path_secret[n+1]` \"above the root\" and not \"for the root\" (`path_secret[n]`which is the one used to derive the `node_secret[n]` of the root)...",
      "createdAt": "2019-05-17T14:14:52Z",
      "updatedAt": "2019-12-17T09:11:21Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "99b311924a9b619fd1e03d4eecd21619bbada6be",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "beurdouche_us",
      "headRefOid": "a2f0e8d905bdfa3a957ae956f65ddf0bb4d4f6bc",
      "closedAt": "2019-05-23T22:11:28Z",
      "mergedAt": "2019-05-23T22:11:28Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "6e672188c590c2dbd34fd1369b3b6e1d6da8fda8"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjQxNDc1NjM3",
          "commit": {
            "abbreviatedOid": "a2f0e8d"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-05-23T22:11:05Z",
          "updatedAt": "2019-05-23T22:11:05Z",
          "comments": []
        }
      ]
    },
    {
      "number": 169,
      "id": "MDExOlB1bGxSZXF1ZXN0MjgwODU0NzEz",
      "title": "Notion of virtual client when secrets are shared accross devices",
      "url": "https://github.com/mlswg/mls-protocol/pull/169",
      "state": "MERGED",
      "author": "beurdouche",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "terminology"
      ],
      "body": "",
      "createdAt": "2019-05-21T16:13:29Z",
      "updatedAt": "2019-12-17T09:10:38Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "99b311924a9b619fd1e03d4eecd21619bbada6be",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "beurdouche_145",
      "headRefOid": "98c9c8355975854ddfd5934a25d34b7ef1efe24b",
      "closedAt": "2019-05-23T22:12:06Z",
      "mergedAt": "2019-05-23T22:12:06Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "cefc48b64e3651fafeab56c6413fdd75bef4c4c5"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjQxNDc1OTA2",
          "commit": {
            "abbreviatedOid": "98c9c83"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-05-23T22:12:00Z",
          "updatedAt": "2019-05-23T22:12:00Z",
          "comments": []
        }
      ]
    },
    {
      "number": 170,
      "id": "MDExOlB1bGxSZXF1ZXN0MjgxODE3MDMz",
      "title": "Confirmation and transcript improvements",
      "url": "https://github.com/mlswg/mls-protocol/pull/170",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "bug",
        "security"
      ],
      "body": "This PR addresses two issues that were noted in draft-05, one that is definitely a bug, and one that should improve security analysis.\r\n\r\n* In draft-05, a circular dependency was introduced, wherein the confirmation MAC was calculated from the transcript, which includes the GroupOperation, which includes the confirmation MAC.  Here we move the confirmation MAC up to the MLSPlaintext object to avoid this circularity.\r\n\r\n* In all prior versions, the transcript covered only the GroupOperation objects, not the sender metadata or signatures.  Here we cover the whole MLSPlaintext object, but in \"staggered\" form -- the confirmation MAC and signature aren't entered into the transcript until the next epoch.\r\n\r\nFixes #157 ",
      "createdAt": "2019-05-23T23:21:53Z",
      "updatedAt": "2019-12-17T09:10:21Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "0d849622508cebd6d9c769dd0388fa17d15fd083",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "circular-confirmation",
      "headRefOid": "9132e357ce338c34d3fa95b93c1b5e5eb7598df4",
      "closedAt": "2019-05-30T15:29:57Z",
      "mergedAt": "2019-05-30T15:29:57Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "7602f683a6e9ba79cdb732814314a259d8738cb2"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjQzODQ1MDY1",
          "commit": {
            "abbreviatedOid": "dcf19f5"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2019-05-30T14:58:54Z",
          "updatedAt": "2019-05-30T15:03:09Z",
          "comments": [
            {
              "originalPosition": 29,
              "body": "Why do we need the `content_type` field? I think it will effectively always be set to `handshake`, since we go from one epoch to another.",
              "createdAt": "2019-05-30T14:58:54Z",
              "updatedAt": "2019-05-30T15:24:52Z"
            },
            {
              "originalPosition": 38,
              "body": "I'm not sure we have to introduce the notion of an intermediate hash, since it will never be used independently. We could just define the transcript hash as:\r\n\r\n```\r\ntranscript_hash_[n] = Hash(transcript_hash_[n-1] || MLSPlaintextOpAuthData_[n-1] || MLSPlaintextOpContent_[n]);\r\n```",
              "createdAt": "2019-05-30T15:01:35Z",
              "updatedAt": "2019-05-30T15:24:52Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjQzODU0NTY2",
          "commit": {
            "abbreviatedOid": "dcf19f5"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-30T15:15:35Z",
          "updatedAt": "2019-05-30T15:15:35Z",
          "comments": [
            {
              "originalPosition": 38,
              "body": "The idea of the intermediate hash is that an implementation could go ahead and update the transcript hash to this state and be done with MLSPlaintext_[n-1], so it wouldn't need to keep that around..  I'll add some text to clarify.",
              "createdAt": "2019-05-30T15:15:35Z",
              "updatedAt": "2019-05-30T15:24:52Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjQzODU4OTE4",
          "commit": {
            "abbreviatedOid": "dcf19f5"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-30T15:22:59Z",
          "updatedAt": "2019-05-30T15:23:00Z",
          "comments": [
            {
              "originalPosition": 29,
              "body": "I agree that in practice this field will be constant, but I like keeping the alignment with the MLSPlaintext struct.  I'll add an annotation to clarify.",
              "createdAt": "2019-05-30T15:23:00Z",
              "updatedAt": "2019-05-30T15:24:52Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjQzODYyMTgy",
          "commit": {
            "abbreviatedOid": "9132e35"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-30T15:28:31Z",
          "updatedAt": "2019-05-30T15:28:32Z",
          "comments": [
            {
              "originalPosition": 38,
              "body": "That makes sense",
              "createdAt": "2019-05-30T15:28:31Z",
              "updatedAt": "2019-05-30T15:28:32Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjQzODYyMjQz",
          "commit": {
            "abbreviatedOid": "9132e35"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-05-30T15:28:38Z",
          "updatedAt": "2019-05-30T15:28:38Z",
          "comments": []
        }
      ]
    },
    {
      "number": 171,
      "id": "MDExOlB1bGxSZXF1ZXN0MjgxODM1NTYx",
      "title": "Specify an Init message",
      "url": "https://github.com/mlswg/mls-protocol/pull/171",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "functionality"
      ],
      "body": "This is something we've been meaning to do for a while, and just haven't gotten around to.\r\n\r\nThe Init message directly creates a group with a specified member list.  The cost of group creation is O(N) DH operations for the sender, and O(1) for receivers.",
      "createdAt": "2019-05-24T01:19:33Z",
      "updatedAt": "2019-12-17T10:15:51Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "a3ac74a28e2417f9d08fe45375298db7bb7b3315",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "init",
      "headRefOid": "5eede135df0e4568fe3a63e02f5aeb78b86cc503",
      "closedAt": "2019-07-08T13:54:59Z",
      "mergedAt": "2019-07-08T13:54:59Z",
      "mergedBy": "beurdouche",
      "mergeCommit": {
        "oid": "a0f465ae7d3e692ec39ab7db7f7a52d70039f96d"
      },
      "comments": [
        {
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "body": "This now has an OPEN ISSUE regarding the fact that we'll need to add PKE encryption for that message, as agreed out of band, let's merge this and add encryption in the next iteration.",
          "createdAt": "2019-07-08T13:55:04Z",
          "updatedAt": "2019-07-08T13:55:04Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU4NjM2Njgy",
          "commit": {
            "abbreviatedOid": "7a83868"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-07T17:54:32Z",
          "updatedAt": "2019-07-07T18:01:26Z",
          "comments": [
            {
              "originalPosition": 19,
              "body": "Haven't we renamed `UserInitKey` to `ClientInitKey` recently?",
              "createdAt": "2019-07-07T17:54:33Z",
              "updatedAt": "2019-07-08T13:49:22Z"
            },
            {
              "originalPosition": 20,
              "body": "If we were to allow a warmed-up tree, we would have to replace `path` with a list of public keys, but I think we should do this in future version.",
              "createdAt": "2019-07-07T17:57:46Z",
              "updatedAt": "2019-07-08T13:49:22Z"
            },
            {
              "originalPosition": 45,
              "body": "It's not clear to me how the members learn about the path secrets. The creator would have to KEm secrets to each leaf node individually I suppose.",
              "createdAt": "2019-07-07T18:01:18Z",
              "updatedAt": "2019-07-08T13:49:22Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU4NjQ0MTIy",
          "commit": {
            "abbreviatedOid": "7a83868"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-07T21:33:49Z",
          "updatedAt": "2019-07-07T21:33:50Z",
          "comments": [
            {
              "originalPosition": 19,
              "body": "Yes, we have.  And in general, this needed a merge from master, which I have done.",
              "createdAt": "2019-07-07T21:33:50Z",
              "updatedAt": "2019-07-08T13:49:22Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU4NjQ0NTYw",
          "commit": {
            "abbreviatedOid": "7a83868"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-07T21:45:14Z",
          "updatedAt": "2019-07-07T21:45:15Z",
          "comments": [
            {
              "originalPosition": 20,
              "body": "You would actually want a giant vector of `DirectPathNode` values, where each private key was encrypted to the `2^level` receipients below it.  But I agree we should punt this to a future version.",
              "createdAt": "2019-07-07T21:45:14Z",
              "updatedAt": "2019-07-08T13:49:22Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU4NjQ0Nzgw",
          "commit": {
            "abbreviatedOid": "7a83868"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-07T21:51:43Z",
          "updatedAt": "2019-07-07T21:51:43Z",
          "comments": [
            {
              "originalPosition": 45,
              "body": "The members get path secrets from the DirectPath, just like in an Update.  Note that the DirectPath `path` attribute here has linear size: Each path secret is encrypted directly to the leaves under it.  I've added a clarification.",
              "createdAt": "2019-07-07T21:51:43Z",
              "updatedAt": "2019-07-08T13:49:22Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU4NzQ1NjQ1",
          "commit": {
            "abbreviatedOid": "8721907"
          },
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "state": "CHANGES_REQUESTED",
          "body": "Similarly to the `Add` for a new member, this is a PKE operation: the encryption of this message is missing from the description. This message needs to be encrypted to each client otherwise it leaks all public keys of the tree which would otherwise be protected under the common framing.\r\n\r\nA secondary question appears as a consequence. There is static key reuse for the leaves until they update, we designed HPKE so that it should be fine but I would still add an [OPEN ISSUE] for it.",
          "createdAt": "2019-07-08T08:09:55Z",
          "updatedAt": "2019-07-08T08:32:14Z",
          "comments": [
            {
              "originalPosition": 50,
              "body": "nit. s/working back to/derive secrets up-to/ ?",
              "createdAt": "2019-07-08T08:09:55Z",
              "updatedAt": "2019-07-08T13:49:22Z"
            },
            {
              "originalPosition": 44,
              "body": "nit. `adequate` seems inadequate; replace by `field` ?",
              "createdAt": "2019-07-08T08:11:35Z",
              "updatedAt": "2019-07-08T13:49:22Z"
            },
            {
              "originalPosition": 20,
              "body": "I think the current scenario looks fine. In the scenario were we would break the secrecy invariant and allow warmup and pre-populating nodes, there is an performance optimization: we can just send the public and the secret part of the tree independently to avoid large numbers of PKE of a large payload. In that scenario I would suggest encrypting the pre-warmed public tree encrypted under a fresh AEAD key/nonce and PKE encrypt the key and the nonce to the recipient along with the new path secret of its parent.",
              "createdAt": "2019-07-08T08:21:31Z",
              "updatedAt": "2019-07-08T13:49:22Z"
            }
          ]
        }
      ]
    },
    {
      "number": 172,
      "id": "MDExOlB1bGxSZXF1ZXN0MjgyMDgyNjQ3",
      "title": "DirectPathNode contains encrypted node secrets, not path secrets",
      "url": "https://github.com/mlswg/mls-protocol/pull/172",
      "state": "CLOSED",
      "author": "rozbb",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "The paragraph below the changed field refers to `node_secrets`, not `encrypted_path_secrets`.",
      "createdAt": "2019-05-24T16:30:36Z",
      "updatedAt": "2019-05-30T15:39:27Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "0d849622508cebd6d9c769dd0388fa17d15fd083",
      "headRepository": "rozbb/mls-protocol",
      "headRefName": "directpathnode-node-secrets",
      "headRefOid": "af21d6c81bf8f8ecd6ef61bcd6ae708e6d17f0be",
      "closedAt": "2019-05-30T15:39:27Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "This is incorrect.  The sender needs to transmit the path secret, so that the receivers can compute the hashes up the tree.  \r\n\r\nYou're correct that there's a mismatch between the struct definition and the prose below.  I've fixed this in #176.",
          "createdAt": "2019-05-30T15:39:27Z",
          "updatedAt": "2019-05-30T15:39:27Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 173,
      "id": "MDExOlB1bGxSZXF1ZXN0MjgyMDg0NDI2",
      "title": "Formatting: removed `\\_` where it was syntactically incorrect",
      "url": "https://github.com/mlswg/mls-protocol/pull/173",
      "state": "MERGED",
      "author": "rozbb",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "The underscore character does not have to be escaped in code environments. This applies to the inline (backticks) as well as block (tildes) variants.",
      "createdAt": "2019-05-24T16:36:59Z",
      "updatedAt": "2019-12-17T09:08:50Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "7602f683a6e9ba79cdb732814314a259d8738cb2",
      "headRepository": "rozbb/mls-protocol",
      "headRefName": "backslash-underscore",
      "headRefOid": "c12be2c8a3e2fe913f4a0e81854308aa86298852",
      "closedAt": "2019-05-30T15:32:14Z",
      "mergedAt": "2019-05-30T15:32:13Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "8c7cbca1e568b47394b1d89c73dbeaebe3f62afb"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 175,
      "id": "MDExOlB1bGxSZXF1ZXN0MjgzNzAxOTI5",
      "title": "Typo fix",
      "url": "https://github.com/mlswg/mls-protocol/pull/175",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "Race condition between #166 and #170 ",
      "createdAt": "2019-05-30T15:33:07Z",
      "updatedAt": "2019-12-17T09:08:03Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "8c7cbca1e568b47394b1d89c73dbeaebe3f62afb",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "circular-confirmation",
      "headRefOid": "779adb41d09c2fe99c55b61483bd3b26aa58d184",
      "closedAt": "2019-05-30T15:33:23Z",
      "mergedAt": "2019-05-30T15:33:23Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "b7498970e5dc1a8b4eb1a3db8db699e4dd1f5698"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 176,
      "id": "MDExOlB1bGxSZXF1ZXN0MjgzNzAzODg1",
      "title": "Use correct field names",
      "url": "https://github.com/mlswg/mls-protocol/pull/176",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "@rozbb pointed out this disconnect in #172, but the fix needs to be the other way around.",
      "createdAt": "2019-05-30T15:38:31Z",
      "updatedAt": "2019-12-17T09:07:56Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "b7498970e5dc1a8b4eb1a3db8db699e4dd1f5698",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "path-secret-typo",
      "headRefOid": "facd7a383ec8952072d0ead3c30daae16824a4fe",
      "closedAt": "2019-05-30T15:38:44Z",
      "mergedAt": "2019-05-30T15:38:44Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "112b535e77f1122e434c2a49492393d15bf19aa8"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 178,
      "id": "MDExOlB1bGxSZXF1ZXN0Mjg2MzQyNDM5",
      "title": "Fix transcript so that new members get the right information",
      "url": "https://github.com/mlswg/mls-protocol/pull/178",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "bug",
        "security"
      ],
      "body": "While trying to implement #170 [in mlspp](https://github.com/cisco/mlspp/pull/48), I noticed that the confirmation and transcript hash calculations in draft-06 do not actually allow a new participant to join the transcript hash.  Since the `transcript_hash` value is sent, and not the `intermediate_hash` value, the new joiner is missing the auth data necessary to compute the next `transcript_hash` value.  \r\n\r\nTo fix this and clarify terminology, this PR makes the following changes:\r\n\r\n* `transcript_hash` becomes `confirmed_transcript_hash`, since this is what goes into the confirmation MAC\r\n* `intermediate_hash` becomes `interim_transcript_hash`\r\n* `WelcomeInfo` is updated to refer to the `interim_transcript_hash`\r\n",
      "createdAt": "2019-06-07T21:44:10Z",
      "updatedAt": "2019-12-17T09:07:42Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "112b535e77f1122e434c2a49492393d15bf19aa8",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "transcript-fix",
      "headRefOid": "c77e0755b0fcdfc582d7ec58845032a39250ad96",
      "closedAt": "2019-07-08T14:20:28Z",
      "mergedAt": "2019-07-08T14:20:28Z",
      "mergedBy": "beurdouche",
      "mergeCommit": {
        "oid": "00b0b55a4c52953640ff13125c4e6f19fa4c5b79"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU4OTM1Mzk1",
          "commit": {
            "abbreviatedOid": "c77e075"
          },
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "This looks ok. If we want, merging `Welcome` and `Add` messages like in the TreeKEM paper would probably avoid some pain here. Merging.",
          "createdAt": "2019-07-08T14:20:14Z",
          "updatedAt": "2019-07-08T14:20:14Z",
          "comments": []
        }
      ]
    },
    {
      "number": 179,
      "id": "MDExOlB1bGxSZXF1ZXN0Mjg2MzQ0Mzcy",
      "title": "Add Beurdouche as a co-author",
      "url": "https://github.com/mlswg/mls-protocol/pull/179",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "@beurdouche has been doing a lot of work, and I just noticed he's not on the list of co-authors.  In addition to recognizing his contribution, this will enable him to push new Internet-Draft versions.",
      "createdAt": "2019-06-07T21:53:29Z",
      "updatedAt": "2019-12-17T09:06:43Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "112b535e77f1122e434c2a49492393d15bf19aa8",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "add-beurdouche",
      "headRefOid": "af877ca3eb8c50a1bbfe6095756d7186aa5e221c",
      "closedAt": "2019-06-07T23:24:34Z",
      "mergedAt": "2019-06-07T23:24:34Z",
      "mergedBy": "jmillican",
      "mergeCommit": {
        "oid": "a3ac74a28e2417f9d08fe45375298db7bb7b3315"
      },
      "comments": [
        {
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "body": "\ud83d\udc4d",
          "createdAt": "2019-06-07T23:14:31Z",
          "updatedAt": "2019-06-07T23:14:31Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjQ3MzM2NzI4",
          "commit": {
            "abbreviatedOid": "af877ca"
          },
          "author": "jmillican",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Absolutely, Beurdouche should definitely be in the co-authors list.",
          "createdAt": "2019-06-07T23:12:25Z",
          "updatedAt": "2019-06-07T23:12:25Z",
          "comments": []
        }
      ]
    },
    {
      "number": 183,
      "id": "MDExOlB1bGxSZXF1ZXN0MjkyMDY0ODQx",
      "title": "Multiple clarifications around Framing",
      "url": "https://github.com/mlswg/mls-protocol/pull/183",
      "state": "MERGED",
      "author": "rozbb",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "",
      "createdAt": "2019-06-26T16:18:07Z",
      "updatedAt": "2019-12-17T09:06:22Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "a3ac74a28e2417f9d08fe45375298db7bb7b3315",
      "headRepository": "rozbb/mls-protocol",
      "headRefName": "mlsplaintext-signature",
      "headRefOid": "edd48b4d01c2ca99c9f8cbc2c263699311ddb3f0",
      "closedAt": "2019-07-01T22:14:28Z",
      "mergedAt": "2019-07-01T22:14:28Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "74987e2b70e3bc5c2e02b0092d5bbb21cb7ae1eb"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU2NTcyODM1",
          "commit": {
            "abbreviatedOid": "3390169"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-07-01T21:34:17Z",
          "updatedAt": "2019-07-01T21:34:52Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "Nit: Spaces around the `-` characters",
              "createdAt": "2019-07-01T21:34:17Z",
              "updatedAt": "2019-07-01T21:53:13Z"
            }
          ]
        }
      ]
    },
    {
      "number": 184,
      "id": "MDExOlB1bGxSZXF1ZXN0MjkyMDcyMzQw",
      "title": "Clarify how HPKE ciphertexts are computed",
      "url": "https://github.com/mlswg/mls-protocol/pull/184",
      "state": "MERGED",
      "author": "rozbb",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "",
      "createdAt": "2019-06-26T16:39:53Z",
      "updatedAt": "2019-12-17T09:06:15Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "a3ac74a28e2417f9d08fe45375298db7bb7b3315",
      "headRepository": "rozbb/mls-protocol",
      "headRefName": "hpke-encrypt",
      "headRefOid": "f18d0d28f87af9998e74659172e4b658596e35ff",
      "closedAt": "2019-07-01T22:14:12Z",
      "mergedAt": "2019-07-01T22:14:12Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "12b572eb379a571ff7830337201e3549f7912989"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU2NTcxNDY1",
          "commit": {
            "abbreviatedOid": "a501c5f"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2019-07-01T21:30:31Z",
          "updatedAt": "2019-07-01T21:31:00Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "This should be `ephemeral_key, context`.  The lack of the `ephemeral_key` output is a bug in the current spec, and will be fixed in the [upcoming version](https://github.com/cfrg/draft-irtf-cfrg-hpke/blame/master/draft-irtf-cfrg-hpke.md#L323).",
              "createdAt": "2019-07-01T21:30:31Z",
              "updatedAt": "2019-07-01T21:55:39Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU2NTg2MTYy",
          "commit": {
            "abbreviatedOid": "f18d0d2"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-07-01T22:14:06Z",
          "updatedAt": "2019-07-01T22:14:06Z",
          "comments": []
        }
      ]
    },
    {
      "number": 186,
      "id": "MDExOlB1bGxSZXF1ZXN0Mjk1MzQ4NTg1",
      "title": "Enable new joiners to decrypt an encrypted Add message",
      "url": "https://github.com/mlswg/mls-protocol/pull/186",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "bug",
        "security",
        "functionality"
      ],
      "body": "Prior drafts enabled encryption of handshake messages, via the common framing structure.  This had the unfortunate effect of making it impossible to add new members!  If an Add is sent encrypted, then the new joiner had no way to get the key to decrypt it.\r\n\r\nThis PR adds the key and nonce for the Add encryption to the corresponding WelcomeInfo structure.  This maintains the confidentiality of the Add because the WelcomeInfo is encrypted to the new joiner, while providing the new joiner the key material it needs to decrypt the Add.",
      "createdAt": "2019-07-08T13:59:06Z",
      "updatedAt": "2019-12-17T09:06:07Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "a0f465ae7d3e692ec39ab7db7f7a52d70039f96d",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "add-decrypt-fix",
      "headRefOid": "60c7dcc4c1589cfc7627e1b9419b537cf67b0e68",
      "closedAt": "2019-07-08T14:03:35Z",
      "mergedAt": "2019-07-08T14:03:35Z",
      "mergedBy": "beurdouche",
      "mergeCommit": {
        "oid": "3ffeab09b5b78142c5093899e21571fc5c98a410"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU4OTIzNTI1",
          "commit": {
            "abbreviatedOid": "60c7dcc"
          },
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "I think we'll need to carefully study the impact of this one but this seems fine for now.\r\nIn the future aligning the way we do `Init` and `Add` (for the new member) which both are PKE operations will probably allow us to merge `Welcome` and `Add` and remove that issue all together.",
          "createdAt": "2019-07-08T14:03:06Z",
          "updatedAt": "2019-07-08T14:03:06Z",
          "comments": []
        }
      ]
    },
    {
      "number": 187,
      "id": "MDExOlB1bGxSZXF1ZXN0Mjk1MzYyMTUy",
      "title": "Simplify AS tree/ratchet computations",
      "url": "https://github.com/mlswg/mls-protocol/pull/187",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "editorial",
        "security"
      ],
      "body": "This PR implements a collection of comments on #146.  It aims to achieve the goal stated by @psyoptix of having every derivation have a different relationship, but with a simpler construction.",
      "createdAt": "2019-07-08T14:29:43Z",
      "updatedAt": "2019-12-17T09:05:41Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "00b0b55a4c52953640ff13125c4e6f19fa4c5b79",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "app-key-simplify",
      "headRefOid": "c3e5b8289a18175481905ce6025c2cdc7b74f83d",
      "closedAt": "2019-07-08T16:42:55Z",
      "mergedAt": "2019-07-08T16:42:55Z",
      "mergedBy": "beurdouche",
      "mergeCommit": {
        "oid": "6461f45e0db6a1d6719cfeebffce9005d6766200"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU4OTQ1NjAw",
          "commit": {
            "abbreviatedOid": "e546ea8"
          },
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2019-07-08T14:34:43Z",
          "updatedAt": "2019-07-08T14:40:57Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "This is undefined.",
              "createdAt": "2019-07-08T14:34:43Z",
              "updatedAt": "2019-07-08T16:28:37Z"
            },
            {
              "originalPosition": 27,
              "body": "`V` is just horrible, can you just call it `n`,`ni` or `i` for node, node index or index instead ?",
              "createdAt": "2019-07-08T14:36:44Z",
              "updatedAt": "2019-07-08T16:28:37Z"
            },
            {
              "originalPosition": 36,
              "body": "This is useless, it is described just above.",
              "createdAt": "2019-07-08T14:37:20Z",
              "updatedAt": "2019-07-08T16:28:37Z"
            },
            {
              "originalPosition": 113,
              "body": "Useless",
              "createdAt": "2019-07-08T14:37:54Z",
              "updatedAt": "2019-07-08T16:28:37Z"
            },
            {
              "originalPosition": 141,
              "body": "This is not an App-Secret derivation here, I would prefer to stick to a standard HKDF-Expand-Label for these.",
              "createdAt": "2019-07-08T14:38:56Z",
              "updatedAt": "2019-07-08T16:28:37Z"
            },
            {
              "originalPosition": 174,
              "body": "If KD2 and ND2 are on the diagram, I would prefer D3 to be there as well. The reader should see those as derived at the same time by consuming D2.",
              "createdAt": "2019-07-08T14:40:43Z",
              "updatedAt": "2019-07-08T16:28:37Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU4OTUwNjI0",
          "commit": {
            "abbreviatedOid": "e546ea8"
          },
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-08T14:42:04Z",
          "updatedAt": "2019-07-08T14:42:04Z",
          "comments": [
            {
              "originalPosition": 141,
              "body": "But I agree that it make sense for the app-secret to app-secret derivation below. ",
              "createdAt": "2019-07-08T14:42:04Z",
              "updatedAt": "2019-07-08T16:28:37Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU5MDA0OTA3",
          "commit": {
            "abbreviatedOid": "e546ea8"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-08T16:02:19Z",
          "updatedAt": "2019-07-08T16:02:19Z",
          "comments": [
            {
              "originalPosition": 36,
              "body": "Having it called out as an equation, in the notation used below, is useful.",
              "createdAt": "2019-07-08T16:02:19Z",
              "updatedAt": "2019-07-08T16:28:37Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU5MDA1MjI1",
          "commit": {
            "abbreviatedOid": "e546ea8"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-08T16:02:54Z",
          "updatedAt": "2019-07-08T16:02:55Z",
          "comments": [
            {
              "originalPosition": 113,
              "body": "As above, disagree :)",
              "createdAt": "2019-07-08T16:02:55Z",
              "updatedAt": "2019-07-08T16:28:37Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU5MDA1NzQ1",
          "commit": {
            "abbreviatedOid": "e546ea8"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-08T16:03:49Z",
          "updatedAt": "2019-07-08T16:03:49Z",
          "comments": [
            {
              "originalPosition": 141,
              "body": "Do you think this is harmful, or just un-aesthetic?  The goal here is to preserve Jo\u00ebl's invariant that every derivation has different context.  ",
              "createdAt": "2019-07-08T16:03:49Z",
              "updatedAt": "2019-07-08T16:28:37Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU5MDA2Njcz",
          "commit": {
            "abbreviatedOid": "e546ea8"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-08T16:05:19Z",
          "updatedAt": "2019-07-08T16:05:20Z",
          "comments": [
            {
              "originalPosition": 174,
              "body": "As I said in the discussion on #146, this doesn't follow.  Just because you've generated KD2 and ND2 doesn't mean you have to derive forward to D3.  That's only required when you consume one of KD2/ND2.",
              "createdAt": "2019-07-08T16:05:19Z",
              "updatedAt": "2019-07-08T16:28:37Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU5MDIwNTY2",
          "commit": {
            "abbreviatedOid": "c3e5b82"
          },
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "Ok, I think this is good enough : )",
          "createdAt": "2019-07-08T16:30:53Z",
          "updatedAt": "2019-07-08T16:30:53Z",
          "comments": []
        }
      ]
    },
    {
      "number": 188,
      "id": "MDExOlB1bGxSZXF1ZXN0Mjk1MzcwMzMz",
      "title": "Add Jo\u00ebl Alwen as a contributor",
      "url": "https://github.com/mlswg/mls-protocol/pull/188",
      "state": "MERGED",
      "author": "beurdouche",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "",
      "createdAt": "2019-07-08T14:47:41Z",
      "updatedAt": "2019-12-17T09:04:20Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "00b0b55a4c52953640ff13125c4e6f19fa4c5b79",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "beurdouche_contributors_joel",
      "headRefOid": "ed59ca2ee6069d86b1fc9d593c9d684f73850b8c",
      "closedAt": "2019-07-08T14:47:48Z",
      "mergedAt": "2019-07-08T14:47:47Z",
      "mergedBy": "beurdouche",
      "mergeCommit": {
        "oid": "f391dd3cab275d6ef27b0650ae51fff9e84eba56"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 189,
      "id": "MDExOlB1bGxSZXF1ZXN0Mjk1NDMyMjU5",
      "title": "Minor editorial updates",
      "url": "https://github.com/mlswg/mls-protocol/pull/189",
      "state": "MERGED",
      "author": "beurdouche",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "Update change log for draft-07\r\nNo conflicting PRs so I did break many lines that were too long.\r\nFix a few minor editorial issues after merging the tree-based application key schedule.",
      "createdAt": "2019-07-08T17:38:33Z",
      "updatedAt": "2019-12-17T09:04:03Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "6461f45e0db6a1d6719cfeebffce9005d6766200",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "beurdouche_app_tree_editorial",
      "headRefOid": "41da6e386aa26175beda20893d48e6acbe18b2e3",
      "closedAt": "2019-07-08T18:40:09Z",
      "mergedAt": "2019-07-08T18:40:09Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "b5053f283705da4dd22d134d8e9eb78893160540"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU5MDU3MzYz",
          "commit": {
            "abbreviatedOid": "97c90d2"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-08T17:41:52Z",
          "updatedAt": "2019-07-08T17:52:53Z",
          "comments": [
            {
              "originalPosition": 142,
              "body": "Nit: You could probably move this up to the previous line.   Since there's not a blank line, it's not a new paragraph.",
              "createdAt": "2019-07-08T17:43:07Z",
              "updatedAt": "2019-07-08T18:39:35Z"
            },
            {
              "originalPosition": 201,
              "body": "It seems like this OPEN ISSUE is obsoleted by the new key schedule.",
              "createdAt": "2019-07-08T17:43:43Z",
              "updatedAt": "2019-07-08T18:39:35Z"
            },
            {
              "originalPosition": 201,
              "body": "Actually, I would just replace the whole discussion of application keys here with a forward reference to the application key schedule section.  All you need here is the stuff that's required to underestand the message framing, namely the idea of \"generations\".  So maybe just put a short summary, e.g.:\r\n\r\n> For application messages, a chain of keys is derived for each sender in a similar fashion. This allows forward secrecy at the level of application messages within and out of an epoch.  A step in this chain (the second subscript) is called a \"generation\". The details of application key derivation are described in {{message-protection}}.\r\n\r\nAnd delete the remainder of this section.",
              "createdAt": "2019-07-08T17:46:51Z",
              "updatedAt": "2019-07-08T18:39:35Z"
            },
            {
              "originalPosition": 556,
              "body": "Nit: `).` -> `.)`",
              "createdAt": "2019-07-08T17:51:09Z",
              "updatedAt": "2019-07-08T18:39:35Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU5MDgxMDc0",
          "commit": {
            "abbreviatedOid": "97c90d2"
          },
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-08T18:27:37Z",
          "updatedAt": "2019-07-08T18:27:38Z",
          "comments": [
            {
              "originalPosition": 142,
              "body": "Done",
              "createdAt": "2019-07-08T18:27:37Z",
              "updatedAt": "2019-07-08T18:39:35Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU5MDg3NDY0",
          "commit": {
            "abbreviatedOid": "41da6e3"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-07-08T18:40:03Z",
          "updatedAt": "2019-07-08T18:40:03Z",
          "comments": []
        }
      ]
    },
    {
      "number": 190,
      "id": "MDExOlB1bGxSZXF1ZXN0Mjk1NDY1MDc4",
      "title": "Add Michael Rosenberg to contributors",
      "url": "https://github.com/mlswg/mls-protocol/pull/190",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "",
      "createdAt": "2019-07-08T19:24:40Z",
      "updatedAt": "2019-12-17T09:03:55Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "b5053f283705da4dd22d134d8e9eb78893160540",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "rozbb",
      "headRefOid": "f7d0e28fd2e527c856316c3f989d47268153a492",
      "closedAt": "2019-07-08T20:04:32Z",
      "mergedAt": "2019-07-08T20:04:32Z",
      "mergedBy": "beurdouche",
      "mergeCommit": {
        "oid": "1ada0d00ef3cc112406c6d5b1d5f9d24ca645670"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 191,
      "id": "MDExOlB1bGxSZXF1ZXN0Mjk1NDcyMDUz",
      "title": "Be clear about what HPKE algorithms to use",
      "url": "https://github.com/mlswg/mls-protocol/pull/191",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "",
      "createdAt": "2019-07-08T19:48:04Z",
      "updatedAt": "2019-12-17T09:03:49Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "b5053f283705da4dd22d134d8e9eb78893160540",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "hpke-suites",
      "headRefOid": "9c77668541388ac11e48f0c62ea6989465eefd8b",
      "closedAt": "2019-07-08T20:05:18Z",
      "mergedAt": "2019-07-08T20:05:18Z",
      "mergedBy": "beurdouche",
      "mergeCommit": {
        "oid": "3fead6a16cc806916b2518c4190ef66cc2d25d69"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 192,
      "id": "MDExOlB1bGxSZXF1ZXN0Mjk5NDc3ODcy",
      "title": "Made it clear that Init messages MUST be sent unencrypted",
      "url": "https://github.com/mlswg/mls-protocol/pull/192",
      "state": "CLOSED",
      "author": "rozbb",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "It took me a few reads to gather that that was the purpose of Init messages. The OPEN ISSUE actually cleared it up for me.",
      "createdAt": "2019-07-19T20:33:58Z",
      "updatedAt": "2019-12-17T09:03:40Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "3fead6a16cc806916b2518c4190ef66cc2d25d69",
      "headRepository": "rozbb/mls-protocol",
      "headRefName": "init-necessity",
      "headRefOid": "e0e622ea86de27a5c2f3c94203c9d3313acf96d3",
      "closedAt": "2019-11-14T17:59:52Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Obsoleted by #239 ",
          "createdAt": "2019-11-14T17:59:52Z",
          "updatedAt": "2019-11-14T17:59:52Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mjc2NjQyMTk0",
          "commit": {
            "abbreviatedOid": "099ca26"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-08-19T15:34:11Z",
          "updatedAt": "2019-08-19T15:34:35Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "Nit: \"When shared\" is unnecessary.  ",
              "createdAt": "2019-08-19T15:34:11Z",
              "updatedAt": "2019-08-19T16:37:54Z"
            }
          ]
        }
      ]
    },
    {
      "number": 193,
      "id": "MDExOlB1bGxSZXF1ZXN0MzAzOTQ1MDQ3",
      "title": "Fix formatting issues.",
      "url": "https://github.com/mlswg/mls-protocol/pull/193",
      "state": "MERGED",
      "author": "Bren2010",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "",
      "createdAt": "2019-08-02T22:13:54Z",
      "updatedAt": "2019-12-17T09:08:36Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "3fead6a16cc806916b2518c4190ef66cc2d25d69",
      "headRepository": "Bren2010/mls-protocol",
      "headRefName": "brendan/2019.7.0",
      "headRefOid": "679d0ccdcf214a44ac8690fc5ae71ac7c0a73a1d",
      "closedAt": "2019-08-19T15:30:50Z",
      "mergedAt": "2019-08-19T15:30:50Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "996280ee06a12ce7d51975bf929284cb59de7c3f"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mjc2NjM5MzYw",
          "commit": {
            "abbreviatedOid": "679d0cc"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-08-19T15:29:35Z",
          "updatedAt": "2019-08-19T15:29:35Z",
          "comments": []
        }
      ]
    },
    {
      "number": 194,
      "id": "MDExOlB1bGxSZXF1ZXN0MzA1Mjg1ODQz",
      "title": "Clarified and Changed WelcomeInfo Secrets",
      "url": "https://github.com/mlswg/mls-protocol/pull/194",
      "state": "CLOSED",
      "author": "rozbb",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2019-08-07T19:21:00Z",
      "updatedAt": "2019-11-14T17:59:34Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "3fead6a16cc806916b2518c4190ef66cc2d25d69",
      "headRepository": "rozbb/mls-protocol",
      "headRefName": "fresh-handshake-encryption",
      "headRefOid": "fc2379f180b1ee46f8159bee10b498ffcfc64d29",
      "closedAt": "2019-11-14T17:59:34Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "rozbb",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The last commit above implements my proposal for using `handshake_secret` & `sender_key_secret` instead of `handshake_key` & `handshake_nonce` for the `WelcomeInfo`s preceding an encrypted `Add`.\r\n\r\nI implemented it on top of the wording changes because I think those are important regardless.\r\n\r\nFeel free to reject the last commit and just take the first two.",
          "createdAt": "2019-08-16T16:51:06Z",
          "updatedAt": "2019-08-16T16:51:06Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Obsoleted by #239 ",
          "createdAt": "2019-11-14T17:59:28Z",
          "updatedAt": "2019-11-14T17:59:28Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mjc2NjUyNjU5",
          "commit": {
            "abbreviatedOid": "09d6335"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2019-08-19T15:50:33Z",
          "updatedAt": "2019-08-19T16:00:58Z",
          "comments": [
            {
              "originalPosition": 67,
              "body": "I don't think the \"after\" here is right.  The `init_secret`, `handshake_secret`, and `sender_data_secret` are all derived before the Add/Welcome are constructed.  Then in the update to the next epoch, the Add message is included in the transcript (with the all-zero update secret), and now the new joiner is included.",
              "createdAt": "2019-08-19T15:50:34Z",
              "updatedAt": "2019-08-19T17:29:22Z"
            },
            {
              "originalPosition": 67,
              "body": "In ASCII art:\r\n\r\n```\r\n                 init_secret_[n-1]\r\n                       |\r\n                       V\r\nupdate_secret -> epoch_secret_[n]\r\n                       |\r\n                       +--> sender_data_secret <~~ provided in WelcomeInfo\r\n                       |\r\n                       +--> handshake_secret   <~~ provided in WelcomeInfo\r\n                       |\r\n                       +--> application_secret <~~ secret from new joiner\r\n                       |\r\n                       +--> confirmation_key   <~~ secret from new joiner\r\n                       |\r\n                       V\r\n                 init_secret_[n]               <~~ provided in WelcomeInfo\r\n                       |\r\n                       V\r\n            0 -> epoch_secret_[n]              <~~ new joiner can compute this\r\n```",
              "createdAt": "2019-08-19T15:59:17Z",
              "updatedAt": "2019-08-19T17:29:22Z"
            },
            {
              "originalPosition": 40,
              "body": "`sender_data_secret`",
              "createdAt": "2019-08-19T15:59:55Z",
              "updatedAt": "2019-08-19T17:29:22Z"
            },
            {
              "originalPosition": 41,
              "body": "\"Unframing\" isn't used elsewhere.  Maybe \"HandshakeEncryptionSecrets\"?",
              "createdAt": "2019-08-19T16:00:34Z",
              "updatedAt": "2019-08-19T17:29:22Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mjc2NjY4MzE4",
          "commit": {
            "abbreviatedOid": "09d6335"
          },
          "author": "rozbb",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-08-19T16:17:45Z",
          "updatedAt": "2019-08-19T16:17:45Z",
          "comments": [
            {
              "originalPosition": 67,
              "body": "Agreed, I think I worded this very poorly. If I changed _after_ to _before_ would that resolve this?",
              "createdAt": "2019-08-19T16:17:45Z",
              "updatedAt": "2019-08-19T17:29:22Z"
            }
          ]
        }
      ]
    },
    {
      "number": 195,
      "id": "MDExOlB1bGxSZXF1ZXN0MzA1MzY1MjEy",
      "title": "Tightened up wording in AS tree deletion sched",
      "url": "https://github.com/mlswg/mls-protocol/pull/195",
      "state": "MERGED",
      "author": "rozbb",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "",
      "createdAt": "2019-08-08T00:25:49Z",
      "updatedAt": "2019-12-17T09:02:24Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "3fead6a16cc806916b2518c4190ef66cc2d25d69",
      "headRepository": "rozbb/mls-protocol",
      "headRefName": "astree-style-fixes",
      "headRefOid": "f5ce6498803fcb88322707decfe838bc17618bbe",
      "closedAt": "2019-08-19T16:10:34Z",
      "mergedAt": "2019-08-19T16:10:34Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "4e60ddcd16df6ed524f64bf701fc4126594e4157"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mjc2NjY0MTQ1",
          "commit": {
            "abbreviatedOid": "f5ce649"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-08-19T16:10:09Z",
          "updatedAt": "2019-08-19T16:10:09Z",
          "comments": []
        }
      ]
    },
    {
      "number": 196,
      "id": "MDExOlB1bGxSZXF1ZXN0MzA1NjYzMTA4",
      "title": "Cleaned up beginning of Cryptographic Objects section",
      "url": "https://github.com/mlswg/mls-protocol/pull/196",
      "state": "MERGED",
      "author": "rozbb",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "One of the issues was that the ciphersuites were subsubsections in a section, so it got rendered as\r\n```\r\n6.1) Curve25519, SHA-256, and AES-128-GCM\r\n  6.1.1) P-256, SHA-256, and AES-128-GCM\r\n```\r\nwhich is odd.\r\n\r\nAlso, previously, the beginning of the Cryptographic Objects section talked about ciphersuites and public keys. I moved their descriptions to where they are more relevant.\r\n\r\nFinally, I replaced \"cipher suite\" with \"ciphersuite\", since the latter had 25 occurrences while the former had 2.",
      "createdAt": "2019-08-08T16:48:26Z",
      "updatedAt": "2019-12-17T09:02:03Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "f7142b7c206fca6217ac87aeae76c9ea2db67c06",
      "headRepository": "rozbb/mls-protocol",
      "headRefName": "cleanup-crypto-objects",
      "headRefOid": "cf5b19766eaf75678010de52dac80b5d1ddcb0e8",
      "closedAt": "2019-09-19T14:05:41Z",
      "mergedAt": "2019-09-19T14:05:41Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "1a201118d76925dcc1e9b31138299798d71cc90f"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mjc2NjY2NzYy",
          "commit": {
            "abbreviatedOid": "6ef4669"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2019-08-19T16:14:50Z",
          "updatedAt": "2019-08-19T16:50:23Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "We still need this definition. Maybe put it under the `CipherSuite` enum, as with `SignaturePublicKey` and the `SignatureScheme` enum.",
              "createdAt": "2019-08-19T16:14:50Z",
              "updatedAt": "2019-09-19T14:04:25Z"
            },
            {
              "originalPosition": 17,
              "body": "Also, some descriptive text like you added for `SignaturePublicKey` would be helpful.",
              "createdAt": "2019-08-19T16:15:22Z",
              "updatedAt": "2019-09-19T14:04:25Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjkwNTkwOTQ2",
          "commit": {
            "abbreviatedOid": "2af5a2a"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-09-19T14:03:44Z",
          "updatedAt": "2019-09-19T14:03:44Z",
          "comments": []
        }
      ]
    },
    {
      "number": 197,
      "id": "MDExOlB1bGxSZXF1ZXN0MzA2MjY0Mjk2",
      "title": "Minor edit",
      "url": "https://github.com/mlswg/mls-protocol/pull/197",
      "state": "MERGED",
      "author": "seanieb",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "The operations in the lifecycle of a group has been reduced to three.",
      "createdAt": "2019-08-11T08:08:39Z",
      "updatedAt": "2019-12-17T09:01:47Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "3fead6a16cc806916b2518c4190ef66cc2d25d69",
      "headRepository": null,
      "headRefName": "patch-1",
      "headRefOid": "9743c0e671eb1c18894703f18aff1e44d9ce5b94",
      "closedAt": "2019-08-13T13:10:54Z",
      "mergedAt": "2019-08-13T13:10:54Z",
      "mergedBy": "beurdouche",
      "mergeCommit": {
        "oid": "483c2b2d87c4e2911a7428ea38d04bae938258dc"
      },
      "comments": [
        {
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "body": "Thank you !",
          "createdAt": "2019-08-13T13:10:48Z",
          "updatedAt": "2019-08-13T13:10:48Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 198,
      "id": "MDExOlB1bGxSZXF1ZXN0MzA2ODk5NDc1",
      "title": "Initial design for the key schedule Exporter",
      "url": "https://github.com/mlswg/mls-protocol/pull/198",
      "state": "MERGED",
      "author": "beurdouche",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "security",
        "functionality"
      ],
      "body": "",
      "createdAt": "2019-08-13T13:10:05Z",
      "updatedAt": "2019-12-20T21:58:45Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "3eee58aa2ba2896a0f28fb9e1c6df16245b6fee7",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "beurdouche_exporter",
      "headRefOid": "d7e67c208d70a846b3aa32bd70596bec3c990049",
      "closedAt": "2019-12-10T20:50:14Z",
      "mergedAt": "2019-12-10T20:50:14Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "d1c8986d3ef932ae4a7cc05b4172d2762428fcd0"
      },
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Note: There's a consistency issue around Derive-Secret, for which I filed #264 for follow-up.",
          "createdAt": "2019-12-10T20:49:52Z",
          "updatedAt": "2019-12-10T20:49:52Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mjc2Njg4MDIx",
          "commit": {
            "abbreviatedOid": "6b4e77a"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-08-19T16:55:02Z",
          "updatedAt": "2019-08-19T17:02:29Z",
          "comments": [
            {
              "originalPosition": 37,
              "body": "It seems like if the application wants to get the full FS / PCS benefits, they need to refresh every time the epoch changes.  Is there a reason you're limiting things here?\r\n\r\nAlso, a nit: \"Add\" and \"Remove\" have only one capital letter.",
              "createdAt": "2019-08-19T16:55:02Z",
              "updatedAt": "2019-12-10T16:58:38Z"
            },
            {
              "originalPosition": 22,
              "body": "This is different from the [TLS construction](https://tools.ietf.org/html/rfc8446#section-7.5)\r\n\r\n```\r\n   TLS-Exporter(label, context_value, key_length) =\r\n       HKDF-Expand-Label(Derive-Secret(Secret, label, \"\"),\r\n                         \"exporter\", Hash(context_value), key_length)\r\n```\r\n\r\nNotice that the \"Derive-Secret\" is missing from the construction in the PR.  What's the reasoning here?",
              "createdAt": "2019-08-19T17:00:12Z",
              "updatedAt": "2019-12-10T16:58:38Z"
            },
            {
              "originalPosition": 22,
              "body": "In a similar vein, it might be useful to say something about labels, as the [TLS exporter RFC does](https://tools.ietf.org/html/rfc5705#section-4).  For example, do we want to have a registry?",
              "createdAt": "2019-08-19T17:02:00Z",
              "updatedAt": "2019-12-10T16:58:38Z"
            },
            {
              "originalPosition": 39,
              "body": "Nit: Extra blank line.",
              "createdAt": "2019-08-19T17:02:14Z",
              "updatedAt": "2019-12-10T16:58:38Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzE4NTY1NDYw",
          "commit": {
            "abbreviatedOid": "f01c1cd"
          },
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-18T19:14:08Z",
          "updatedAt": "2019-11-18T19:14:08Z",
          "comments": [
            {
              "originalPosition": 37,
              "body": "Fixed",
              "createdAt": "2019-11-18T19:14:08Z",
              "updatedAt": "2019-12-10T16:58:38Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzE4NTY1NzA1",
          "commit": {
            "abbreviatedOid": "f01c1cd"
          },
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-18T19:14:28Z",
          "updatedAt": "2019-11-18T19:14:28Z",
          "comments": [
            {
              "originalPosition": 39,
              "body": "Fixed",
              "createdAt": "2019-11-18T19:14:28Z",
              "updatedAt": "2019-12-10T16:58:38Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzE4NTY3MTE5",
          "commit": {
            "abbreviatedOid": "f01c1cd"
          },
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-18T19:16:47Z",
          "updatedAt": "2019-11-18T19:16:47Z",
          "comments": [
            {
              "originalPosition": 22,
              "body": "Fix pending... Any intuition about the registry story ?",
              "createdAt": "2019-11-18T19:16:47Z",
              "updatedAt": "2019-12-10T16:58:38Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzI5OTgzMTY1",
          "commit": {
            "abbreviatedOid": "d06d021"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-12-10T16:43:41Z",
          "updatedAt": "2019-12-10T16:43:42Z",
          "comments": [
            {
              "originalPosition": 30,
              "body": "Nit: \"functionalities\"",
              "createdAt": "2019-12-10T16:43:42Z",
              "updatedAt": "2019-12-10T16:58:38Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzMwMTM1MjI1",
          "commit": {
            "abbreviatedOid": "d7e67c2"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-12-10T20:50:08Z",
          "updatedAt": "2019-12-10T20:50:08Z",
          "comments": []
        }
      ]
    },
    {
      "number": 200,
      "id": "MDExOlB1bGxSZXF1ZXN0MzA4NzQwODQ0",
      "title": "Non-destructive add",
      "url": "https://github.com/mlswg/mls-protocol/pull/200",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "security",
        "performance",
        "functionality"
      ],
      "body": "This PR attempts to implement the \"non-destructive add\" proposal discussed at IETF 105.  Instead of blanking nodes on add, we keep track of \"unmerged leaves\" below each intermediate node.  This involves a bit more complexity in the tree state that is passed around, but avoids unnecessary blank nodes.",
      "createdAt": "2019-08-19T19:01:28Z",
      "updatedAt": "2019-12-17T09:00:41Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "41a2389abf922fe0c3dbcc1ec67e2ddbd7416ec2",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "non-destructive-add",
      "headRefOid": "064353ecff9d84b719a1333d53e785c2593642c5",
      "closedAt": "2019-11-14T17:22:49Z",
      "mergedAt": "2019-11-14T17:22:49Z",
      "mergedBy": "beurdouche",
      "mergeCommit": {
        "oid": "d7ca4817c58cf48fd1ddc23dea5be4b5e89595fa"
      },
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "As discussed in the interim: Remove processing should be updated such that for each node in the removed node's direct path:\r\n\r\n* If the removed leaf is in `unmerged_leaves` for the node, then just remove it from that list\r\n* Otherwise, blank the node",
          "createdAt": "2019-10-01T21:55:22Z",
          "updatedAt": "2019-10-01T21:55:22Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzE2NjgxNzI2",
          "commit": {
            "abbreviatedOid": "e6585cf"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2019-11-14T02:36:01Z",
          "updatedAt": "2019-11-14T03:00:37Z",
          "comments": [
            {
              "originalPosition": 135,
              "body": "\"if a node\"",
              "createdAt": "2019-11-14T02:36:01Z",
              "updatedAt": "2019-11-14T16:17:11Z"
            },
            {
              "originalPosition": 140,
              "body": "Less confusing: \"A member may not know the private keys of all the intermediate nodes that they're below. Such a member has an _unmerged_ leaf. Encrypting to an intermediate node requires encrypting to the node's public key, as well as the public keys of all the unmerged leaves below it. A leaf is unmerged when...\"",
              "createdAt": "2019-11-14T02:54:06Z",
              "updatedAt": "2019-11-14T16:17:11Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzE3MTI4MjQ1",
          "commit": {
            "abbreviatedOid": "064353e"
          },
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-11-14T17:22:43Z",
          "updatedAt": "2019-11-14T17:22:43Z",
          "comments": []
        }
      ]
    },
    {
      "number": 201,
      "id": "MDExOlB1bGxSZXF1ZXN0MzEwNTQ1MjA5",
      "title": "Define enum values for ProtocolVersion.",
      "url": "https://github.com/mlswg/mls-protocol/pull/201",
      "state": "MERGED",
      "author": "Bren2010",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "",
      "createdAt": "2019-08-23T21:51:50Z",
      "updatedAt": "2019-12-17T09:00:21Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "4e60ddcd16df6ed524f64bf701fc4126594e4157",
      "headRepository": "Bren2010/mls-protocol",
      "headRefName": "brendan/2019.8.0",
      "headRefOid": "cbcaf629136d5a5f5b0a36735cbf9c278621e6ef",
      "closedAt": "2019-09-09T21:40:27Z",
      "mergedAt": "2019-09-09T21:40:27Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "b8eed965739bae912b971e6156a377656f1884c0"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mjg1ODAwNDIw",
          "commit": {
            "abbreviatedOid": "cbcaf62"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-09-09T21:40:09Z",
          "updatedAt": "2019-09-09T21:40:09Z",
          "comments": []
        }
      ]
    },
    {
      "number": 203,
      "id": "MDExOlB1bGxSZXF1ZXN0MzEyODA4Nzk5",
      "title": "HPKECiphertext takes generic KEM output, not a public key.",
      "url": "https://github.com/mlswg/mls-protocol/pull/203",
      "state": "MERGED",
      "author": "Bren2010",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "Currently you assume that the KEM's output is an ephemeral public key, but that's only true for Diffie-Hellman-type constructions.",
      "createdAt": "2019-08-30T16:31:33Z",
      "updatedAt": "2019-12-17T08:59:49Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "b8eed965739bae912b971e6156a377656f1884c0",
      "headRepository": "Bren2010/mls-protocol",
      "headRefName": "brendan/2019.8.1",
      "headRefOid": "f7814c1c8673c75028c2465658a53d7227813f3d",
      "closedAt": "2019-09-19T13:57:41Z",
      "mergedAt": "2019-09-19T13:57:40Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "e3c6e466c17ea3ca41e2be3551ad432775b3b23e"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjkwNTg2MTk5",
          "commit": {
            "abbreviatedOid": "f7814c1"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-09-19T13:57:29Z",
          "updatedAt": "2019-09-19T13:57:29Z",
          "comments": []
        }
      ]
    },
    {
      "number": 204,
      "id": "MDExOlB1bGxSZXF1ZXN0MzEyODE2MTg2",
      "title": "Update ClientInitKey to contain only one ciphersuite.",
      "url": "https://github.com/mlswg/mls-protocol/pull/204",
      "state": "MERGED",
      "author": "Bren2010",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "enhancement"
      ],
      "body": "",
      "createdAt": "2019-08-30T16:57:33Z",
      "updatedAt": "2019-12-17T08:55:47Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "b8eed965739bae912b971e6156a377656f1884c0",
      "headRepository": "Bren2010/mls-protocol",
      "headRefName": "brendan/2019.8.2",
      "headRefOid": "a8dc485abcf7cd5b9b8ac2da5d36e097bea1d56e",
      "closedAt": "2019-09-19T13:59:26Z",
      "mergedAt": "2019-09-19T13:59:26Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "f7142b7c206fca6217ac87aeae76c9ea2db67c06"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mjg1Nzk3NDQ5",
          "commit": {
            "abbreviatedOid": "43c21b7"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Thanks for this proposal, @Bren2010.  I agree it's a useful simplification.  I've suggested a couple of minor changes.",
          "createdAt": "2019-09-09T21:33:23Z",
          "updatedAt": "2019-09-09T21:39:15Z",
          "comments": [
            {
              "originalPosition": 32,
              "body": "Please don't re-wrap text that hasn't been modified.  It makes the history unnecessarily complicated.",
              "createdAt": "2019-09-09T21:33:23Z",
              "updatedAt": "2019-09-11T16:59:55Z"
            },
            {
              "originalPosition": 59,
              "body": "Please move this to the first slot in the struct.  That way we can have a very simple protocol invariant -- the first two octets of the InitKey tell you the format of the rest.  (We should write down these invariants, but that's for a different PR.)",
              "createdAt": "2019-09-09T21:37:22Z",
              "updatedAt": "2019-09-11T16:59:55Z"
            },
            {
              "originalPosition": 70,
              "body": "Maybe say \"one or more ClientInitKeys\"",
              "createdAt": "2019-09-09T21:38:03Z",
              "updatedAt": "2019-09-11T16:59:55Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mjg2OTMzMTMx",
          "commit": {
            "abbreviatedOid": "43c21b7"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-09-11T16:54:21Z",
          "updatedAt": "2019-09-11T16:54:21Z",
          "comments": [
            {
              "originalPosition": 59,
              "body": "Protocol version is only one octet, is there something else you want here?",
              "createdAt": "2019-09-11T16:54:21Z",
              "updatedAt": "2019-09-11T16:59:55Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjkwNTg3MTQz",
          "commit": {
            "abbreviatedOid": "a8dc485"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-09-19T13:58:44Z",
          "updatedAt": "2019-09-19T13:59:19Z",
          "comments": [
            {
              "originalPosition": 59,
              "body": "Misstatement on my part, sorry.",
              "createdAt": "2019-09-19T13:58:44Z",
              "updatedAt": "2019-09-19T13:59:19Z"
            }
          ]
        }
      ]
    },
    {
      "number": 208,
      "id": "MDExOlB1bGxSZXF1ZXN0MzE3ODk5MjM4",
      "title": "Add authenticated_data to the mls message.",
      "url": "https://github.com/mlswg/mls-protocol/pull/208",
      "state": "MERGED",
      "author": "psla",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "privacy",
        "functionality"
      ],
      "body": "[As previously discussed](https://mailarchive.ietf.org/arch/msg/mls/jB5ygAJs3P8TLkduj6Q9vFWmSJI), this is a proposal to add AAD to the application messages.\r\n\r\nThere are many motivations to do this:\r\n\u2022 It's a 'cheap' feature to add (although it could potentially be misused)\r\n\u2022 It avoids duplicate content: if there is a content that needs to be authenticated, but also needs to be visible to the server, the only solution today is to repeat it in the header (to the server) and then in the encrypted body.\r\n\u2022 Modern ciphers already provide support for AAD, and MLS takes advantage of this. In fact most(all?) of the fields in the header are authenticated already.\r\n\u2022 This field is optional(as in: can be empty), which means that it doesn't have to be used in the implementation.\r\n\r\nThe primary benefit is for the server to have access to the fields that are otherwise authenticated, but are not part of MLS message. Typically, the server has another encryption mechanism with the client (e.g. TLS) and as such client-server communication is already secure. As a matter of fact, handshake messages can already be transported in plaintext (in case server needs to examine their content), but application messages are not allowed to have any plaintext content, even though server may need to examine some metadata as well.\r\n\r\nA couple of thoughts that may be worth discussing: \r\n* what should be the max size of authenticated_data (I assumed 32KB, just like application message)\r\n* whether *authenticated data* should be offered only as part of *application*, or both *handshake message* and *application message*. It is fair to consider it only for an *application message*, though for simplicity I added it to both message types. Happy to change it based on general preferences.",
      "createdAt": "2019-09-16T14:08:37Z",
      "updatedAt": "2019-12-17T08:57:09Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "d8672cf6e78d781a5ff6f9e238ee6b0db3b3f026",
      "headRepository": "psla/mls-protocol",
      "headRefName": "aead",
      "headRefOid": "06c0317832918f15e7ccab3a9e0b5c8a992441fb",
      "closedAt": "2019-10-11T22:49:04Z",
      "mergedAt": "2019-10-11T22:49:04Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "968cdceceb7fa389e092c111ebd29d5600b0b68c"
      },
      "comments": [
        {
          "author": "eomara",
          "authorAssociation": "COLLABORATOR",
          "body": "@bifurcation per our discussion in London, we agreed to accept this change. you mentioned other places need to be updated,  which one? ",
          "createdAt": "2019-10-09T03:24:22Z",
          "updatedAt": "2019-10-09T03:24:22Z"
        },
        {
          "author": "psla",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> this AAD field is AEAD authenticated but does not seem covered by the signature, while probably should.\r\nI don't quite understand how to address this comment. I believe I added it to the signature, maybe I missed something\r\n\r\n> ** Sign the plaintext metadata -- the group ID, epoch, sender index, and  content type **as well as the authenticated data** and message content\r\n\r\nCan you clarify which part is missing the AAD?",
          "createdAt": "2019-10-09T15:42:28Z",
          "updatedAt": "2019-10-09T15:42:28Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "@beurdouche i think you're wrong here.  In {{content-signing-and-encryption}}, we have the following:\r\n\r\n>  The signature covers the plaintext metadata and message content, i.e., all fields of MLSPlaintext except for the signature field.\r\n\r\nI think this is ready to go as soon as @psla fixes the two minor comments we have (order of fields and `[]` vs `<>` notation).",
          "createdAt": "2019-10-10T13:55:35Z",
          "updatedAt": "2019-10-10T13:55:35Z"
        },
        {
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "body": "Note that in general, the `MLSCiphertextSenderDataAAD` and `MLSCiphertextContentAAD` are the prefix of their ciphertext which means you have to put the new `authenticated_data` field you added at the correct position in both of those too... : )",
          "createdAt": "2019-10-11T15:40:07Z",
          "updatedAt": "2019-10-11T15:40:39Z"
        },
        {
          "author": "psla",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Are you saying that `MLSCiphertextSenderDataAAD` needs it as well? That would lead to two AAD blobs, right? One of which would be encrypted? (I am a bit fuzzy about the relation between `MLSCiphertextContentAAD` and encrypted_sender_data (which is encrypted `MLSCiphertextSenderDataAAD`, right?)\r\n\r\nI added it there, but I don't fully understand it. Please take another look.",
          "createdAt": "2019-10-11T18:22:53Z",
          "updatedAt": "2019-10-11T18:22:53Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "@beurdouche  - I agree with @psla that it doesn't seem necessary to include the `authenticated_data` in the `MLSCiphertextSenderDataAAD`.  Do you have a specific issue in mind?",
          "createdAt": "2019-10-11T19:19:43Z",
          "updatedAt": "2019-10-11T19:19:43Z"
        },
        {
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "body": "Ok, I am quite exhausted this week, so my clarity is low sorry\u2026\r\nI think I confused the positionning of the new field in the MLSPlaintext vs the MLSCiphertext\r\n\r\nIt all depends where you place the new field in the MLSCiphertext, right ?!\r\nIn the current design for the AEADs is that the thing you authenticate is the prefix of\r\nthe ciphertext you are decrypting...\r\n\r\nSo if the new field is just after the content type in the MLSCiphertext\r\nit is part of the prefix of the encrypted sender data and has to be included in the SenderDataAAD but it is also in the prefix of the content so it has to also be in the ContentAAD.\r\n\r\nIf the new field is placed between the encrypted SenderData and the encrypted Content\r\nit is just a prefix of the second one and should appear only in the ContentAAD.\r\n\r\nDo I make sense ? :)\r\nB.",
          "createdAt": "2019-10-11T19:49:13Z",
          "updatedAt": "2019-10-11T19:50:46Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "If we espouse that theory (not clear that it necessarily holds, but let's go with it for now), the question is where you draw the line between metadata and content.  Compare the current state with two cases (a) and (b):\r\n\r\n```\r\nNOW              A.               B.\r\n\r\ngroup_id         group_id         group_id\r\nepoch            epoch            epoch\r\nsender           sender           sender\r\ncontent_type     content_type     content_type\r\n============     ============     aad\r\ncontent          aad              ============\r\nsignature        content          content\r\n                 signature        signature\r\n```\r\n\r\nBasically, the `=====` turns into the sender_data in the MLSCiphertext.  In case (B), you would want the AAD in the `SenderDataAAD`; in case (A) you would not.  I don't really see a reason why we need to assume case (B), so since case (A) is a bit simpler, I'm inclined to go that way.  Simpler in the sense that the AAD is used as AAD exactly once, together with the protected content.",
          "createdAt": "2019-10-11T20:13:04Z",
          "updatedAt": "2019-10-11T20:13:04Z"
        },
        {
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "body": "Those were my proposals\u2026\r\nMy preference goes to Fig 8 but I don\u2019t have a strong opinion.\r\n<img width=\"640\" alt=\"New field\" src=\"https://user-images.githubusercontent.com/1193431/66683688-5eaae700-ec78-11e9-8af4-ff7f59a761d5.png\">\r\n\r\n",
          "createdAt": "2019-10-11T20:41:30Z",
          "updatedAt": "2019-10-11T20:42:17Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Ah, even better illustration than mine!  OK, when you put it that way, I can see the appeal of including the AAD in the sender data.  Though I admit this is mostly an aesthetic point, not one that I have any security analysis to back up.\r\n\r\n@psla would you mind moving the AAD to above the `sender_data_nonce` in all cases?  Then I think this is ready to merge.",
          "createdAt": "2019-10-11T20:57:53Z",
          "updatedAt": "2019-10-11T20:57:53Z"
        },
        {
          "author": "psla",
          "authorAssociation": "CONTRIBUTOR",
          "body": "It makes sense to me too now. Thanks. I think I addressed it.",
          "createdAt": "2019-10-11T22:05:49Z",
          "updatedAt": "2019-10-11T22:05:49Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mjk0ODM2MDAx",
          "commit": {
            "abbreviatedOid": "eda3fb3"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-09-30T09:00:12Z",
          "updatedAt": "2019-09-30T09:00:17Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "Nit: I would put this just below the content_type field, just to preserve parallelism (`MLSCiphertext.ciphertext -> MLSPlaintext.operation/application_data`)",
              "createdAt": "2019-09-30T09:00:13Z",
              "updatedAt": "2019-10-11T22:05:27Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mjk5MjE4Nzk0",
          "commit": {
            "abbreviatedOid": "eda3fb3"
          },
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "state": "CHANGES_REQUESTED",
          "body": "Two big caveats:\r\n- this AAD field is AEAD authenticated but does not seem covered by the signature, while probably should.\r\n- we agreed to this change under the condition of a big flashing warning that the `send/receive_group_operation_with_aad` functions in the API MUST be separate from the normal ones at the api level. This is missing here.",
          "createdAt": "2019-10-09T07:35:38Z",
          "updatedAt": "2019-10-09T07:56:07Z",
          "comments": [
            {
              "originalPosition": 40,
              "body": "`opaque` already encompass the length, I believe.",
              "createdAt": "2019-10-09T07:35:38Z",
              "updatedAt": "2019-10-11T22:05:27Z"
            },
            {
              "originalPosition": 4,
              "body": "Also it would avoid interleaving plaintexts and ciphertexts...",
              "createdAt": "2019-10-09T07:39:46Z",
              "updatedAt": "2019-10-11T22:05:27Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mjk5NTA3Mzg1",
          "commit": {
            "abbreviatedOid": "eda3fb3"
          },
          "author": "psla",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-10-09T15:37:07Z",
          "updatedAt": "2019-10-09T15:42:35Z",
          "comments": [
            {
              "originalPosition": 40,
              "body": "I was inspired by\r\n```\r\n    opaque content[length_of_content];\r\n```\r\nabove (in MLSCiphertextContent). Is that one also incorrect?",
              "createdAt": "2019-10-09T15:37:07Z",
              "updatedAt": "2019-10-11T22:05:27Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzAwMDgyMzA0",
          "commit": {
            "abbreviatedOid": "eda3fb3"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-10-10T13:50:36Z",
          "updatedAt": "2019-10-10T13:52:37Z",
          "comments": [
            {
              "originalPosition": 40,
              "body": "This can just be the same definition as in the `MLSCiphertext` object.  The only reason for the `[]` notation w.r.t. content is the weird encoding of `MLSCiphertextContent`, which IIRC is about to get reverted.",
              "createdAt": "2019-10-10T13:50:36Z",
              "updatedAt": "2019-10-11T22:05:27Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzAwMjIwNDEw",
          "commit": {
            "abbreviatedOid": "eda3fb3"
          },
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "I missed that indeed, feel free to fix the `<>` `[]` and we'll merge the PR, I'll put the API recommendation in the architecture document. For the record, even though people at the interim kind of agree this mechanism was ok, I am still very skeptical about it because I am certain people will misuse it...\r\n",
          "createdAt": "2019-10-10T17:07:29Z",
          "updatedAt": "2019-10-10T17:07:29Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzAwNzQ4Mjcw",
          "commit": {
            "abbreviatedOid": "eda3fb3"
          },
          "author": "psla",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-10-11T15:04:32Z",
          "updatedAt": "2019-10-11T15:19:14Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "I agree. Done!",
              "createdAt": "2019-10-11T15:04:32Z",
              "updatedAt": "2019-10-11T22:05:27Z"
            },
            {
              "originalPosition": 40,
              "body": "Done.\r\nI also renamed it to authenticated_data instead of authenticated_content, in order to keep the naming the same. (I was in the pickle here, since the data struct is called 'MLSCiphertextConterntAAD' and then the field inside is called authenticated_data. I initially thought that calling it authenticated_content will be better, but I believe it's better to keep the same name all over the place).",
              "createdAt": "2019-10-11T15:06:32Z",
              "updatedAt": "2019-10-11T22:05:27Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzAwOTU4MjAy",
          "commit": {
            "abbreviatedOid": "06c0317"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-10-11T22:48:54Z",
          "updatedAt": "2019-10-11T22:48:54Z",
          "comments": []
        }
      ]
    },
    {
      "number": 209,
      "id": "MDExOlB1bGxSZXF1ZXN0MzE5MDE5MjIx",
      "title": "Proposals and Commits",
      "url": "https://github.com/mlswg/mls-protocol/pull/209",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "security",
        "functionality"
      ],
      "body": "This PR implements the proposal discussed in Prague and on the mailing list, to separate GroupOperations into Proposals and Commits.  This change leaves the underlying ratchet tree operations untouched, but changes how these operations are folded into the overall key schedule.\r\n\r\nThis is also a fairly initial effort, with several OPEN ISSUEs noted.  The most important IMO is that we should allow a single MLSPlaintext to pack one or more Proposals along with a Commit, which makes it simpler to emulate the current behavior, and might allow us to get rid of the Init message.",
      "createdAt": "2019-09-18T22:07:05Z",
      "updatedAt": "2019-12-17T08:56:54Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "69739df60d07ee53c245ff9bbee7d391f1ce5b9d",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "proposals",
      "headRefOid": "1af815682b86f1bb659302553b72c57517e6c48d",
      "closedAt": "2019-11-14T15:37:05Z",
      "mergedAt": "2019-11-14T15:37:05Z",
      "mergedBy": "beurdouche",
      "mergeCommit": {
        "oid": "41a2389abf922fe0c3dbcc1ec67e2ddbd7416ec2"
      },
      "comments": [
        {
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "body": "Note: Need to stop truncating hash of proposal",
          "createdAt": "2019-10-01T13:24:04Z",
          "updatedAt": "2019-10-01T13:24:04Z"
        },
        {
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "body": "This is good. Thanks Richard !",
          "createdAt": "2019-11-14T15:37:00Z",
          "updatedAt": "2019-11-14T15:37:00Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjkwMjUwMDc1",
          "commit": {
            "abbreviatedOid": "8b57a97"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-09-18T23:11:46Z",
          "updatedAt": "2019-09-19T00:04:55Z",
          "comments": [
            {
              "originalPosition": 18,
              "body": "more advanced",
              "createdAt": "2019-09-18T23:11:46Z",
              "updatedAt": "2019-11-14T15:33:44Z"
            },
            {
              "originalPosition": 132,
              "body": "hash over the whole transcript",
              "createdAt": "2019-09-18T23:15:15Z",
              "updatedAt": "2019-11-14T15:33:44Z"
            },
            {
              "originalPosition": 137,
              "body": "MLSPlaintext -> MLSPlaintextCommitAuthData?",
              "createdAt": "2019-09-18T23:43:00Z",
              "updatedAt": "2019-11-14T15:33:44Z"
            },
            {
              "originalPosition": 160,
              "body": "It's confusing to me why it's done the way that it is now. Can't you use the one ASTree to generate keys for everything?",
              "createdAt": "2019-09-18T23:44:28Z",
              "updatedAt": "2019-11-14T15:33:44Z"
            },
            {
              "originalPosition": 449,
              "body": "Maybe off-topic, but can we make it so that Adds always add to the first empty index?",
              "createdAt": "2019-09-18T23:52:16Z",
              "updatedAt": "2019-11-14T15:33:44Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjkwNTk4OTAw",
          "commit": {
            "abbreviatedOid": "8b57a97"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-09-19T14:14:19Z",
          "updatedAt": "2019-09-19T14:14:20Z",
          "comments": [
            {
              "originalPosition": 449,
              "body": "That is the desire, but it runs into the problem that \"first\" isn't well-defined in a context where members might see two Add messages in different orders.  So the idea here is that the Committer acts as the arbiter and decides the order.",
              "createdAt": "2019-09-19T14:14:19Z",
              "updatedAt": "2019-11-14T15:33:44Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjkwNzEzNzY0",
          "commit": {
            "abbreviatedOid": "8b57a97"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-09-19T17:07:26Z",
          "updatedAt": "2019-09-19T17:07:27Z",
          "comments": [
            {
              "originalPosition": 449,
              "body": "Doesn't the Commit message define an order over the Adds? You could\r\n```diff\r\n- AddCommit adds<0..2^16-1>;\r\n+ ProposalID adds<0..2^16-1>;\r\n```\r\nbecause the index is implicit",
              "createdAt": "2019-09-19T17:07:27Z",
              "updatedAt": "2019-11-14T15:33:44Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjkwNzgzMjA2",
          "commit": {
            "abbreviatedOid": "8b57a97"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-09-19T19:09:10Z",
          "updatedAt": "2019-09-19T19:09:11Z",
          "comments": [
            {
              "originalPosition": 449,
              "body": "Oh, I see. Good point.  If I try hard, I can imagine scenarios where you would not want that (\"Each user gets 8 devices, so we're going to assign each user a slice of the tree\"), but for this first cut, I'm happy to have it simpler.  We can add the flexibility back if people ask for it.",
              "createdAt": "2019-09-19T19:09:10Z",
              "updatedAt": "2019-11-14T15:33:44Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjkwODYzOTgz",
          "commit": {
            "abbreviatedOid": "9148b31"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-09-19T21:53:49Z",
          "updatedAt": "2019-09-19T21:53:50Z",
          "comments": [
            {
              "originalPosition": 160,
              "body": "It's a question of where you separate the handshake keys from the application keys.  You want them to be separate to simplify the analysis, so that the implication always goes Handshake => Application and not vice versa.\r\n\r\nIn the current draft, the nearest common ancestor is the epoch secret.  I think you're on the right track here, and a better design would be to use the AStree to fan out secrets per participant, then split out different keys for different uses at the leaves.\r\n\r\n@beurdouche should probably opine here, but in any case, it seems like a follow-on PR, not something to address here.",
              "createdAt": "2019-09-19T21:53:49Z",
              "updatedAt": "2019-11-14T15:33:44Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjkwODY4NTAy",
          "commit": {
            "abbreviatedOid": "9148b31"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-09-19T22:05:54Z",
          "updatedAt": "2019-09-19T23:15:10Z",
          "comments": [
            {
              "originalPosition": 81,
              "body": "This needs to be there or else the sectioning gets messed up",
              "createdAt": "2019-09-19T22:05:54Z",
              "updatedAt": "2019-11-14T15:33:44Z"
            },
            {
              "originalPosition": 398,
              "body": "and are uniquely",
              "createdAt": "2019-09-19T22:26:59Z",
              "updatedAt": "2019-11-14T15:33:45Z"
            },
            {
              "originalPosition": 457,
              "body": "an MLSPlaintext",
              "createdAt": "2019-09-19T22:28:31Z",
              "updatedAt": "2019-11-14T15:33:45Z"
            },
            {
              "originalPosition": 505,
              "body": "This needs to be updated to be in line with new Add behavior",
              "createdAt": "2019-09-19T22:30:42Z",
              "updatedAt": "2019-11-14T15:33:45Z"
            },
            {
              "originalPosition": 599,
              "body": "Should implementations be required to incorporate all valid proposals that they know of? If not, meaning proposals have a chance of being dropped, how are they meant to be communicated to an end-user?",
              "createdAt": "2019-09-19T23:08:38Z",
              "updatedAt": "2019-11-14T15:33:45Z"
            },
            {
              "originalPosition": 601,
              "body": "Because proposals can't build on top of each other, you have weird cases like:\r\n\r\n1. Alice adds Bob to the group (without committing).\r\n2. Carol removes Bob from the group.\r\n\r\nIt implicitly requires Carol to Commit->Remove because she can't form her Remove proposal without first committing. Whatever API you expose to an application would have to understand this",
              "createdAt": "2019-09-19T23:09:16Z",
              "updatedAt": "2019-11-14T15:33:45Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjkxMTE5MjQy",
          "commit": {
            "abbreviatedOid": "9148b31"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-09-20T12:03:00Z",
          "updatedAt": "2019-09-20T12:03:00Z",
          "comments": [
            {
              "originalPosition": 81,
              "body": "It's still there, it just got moved up in #196.  ",
              "createdAt": "2019-09-20T12:03:00Z",
              "updatedAt": "2019-11-14T15:33:45Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjkxMTIwNjAw",
          "commit": {
            "abbreviatedOid": "9148b31"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-09-20T12:06:11Z",
          "updatedAt": "2019-09-20T12:19:38Z",
          "comments": [
            {
              "originalPosition": 505,
              "body": "Could you say more?  I already updated this to remove the reference to multiple ciphersuites in the CIK.",
              "createdAt": "2019-09-20T12:06:11Z",
              "updatedAt": "2019-11-14T15:33:45Z"
            },
            {
              "originalPosition": 599,
              "body": "This being a distributed system, there's always a risk of proposals being dropped.  One of the drawbacks of this proposal is that it increases the complexity of the retry logic.  Nonetheless, we can require that the Commit contain all proposals **known to the committer**. ",
              "createdAt": "2019-09-20T12:09:45Z",
              "updatedAt": "2019-11-14T15:33:45Z"
            },
            {
              "originalPosition": 601,
              "body": "This seems workable to me.  I would expect that the API just wouldn't mark Bob as added until the Add was committed, so Carol wouldn't even be able to form the Remove message until then.  ",
              "createdAt": "2019-09-20T12:19:23Z",
              "updatedAt": "2019-11-14T15:33:45Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjkyNTkzMzA1",
          "commit": {
            "abbreviatedOid": "2fffe2b"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Lgtm besides last few comments\r\n\r\nEdit: Obviously you need to fix the key schedule as well before this is complete, but yeah.",
          "createdAt": "2019-09-24T17:39:54Z",
          "updatedAt": "2019-09-24T20:34:40Z",
          "comments": [
            {
              "originalPosition": 505,
              "body": "- \"Instead, the sender of the Commit message chooses a location for each added member and states it in the Commit message.\"\r\n- \"A member of the group applies an Add message at leaf index `index` specified in the Commit message by taking the following steps:\"\r\n\r\nYou're referencing an index which is now implicit",
              "createdAt": "2019-09-24T17:39:54Z",
              "updatedAt": "2019-11-14T15:33:45Z"
            },
            {
              "originalPosition": 776,
              "body": "There's a section below here, \"Merging Updates\", that I think you can remove. Merging multiple Commits doesn't make sense",
              "createdAt": "2019-09-24T20:29:59Z",
              "updatedAt": "2019-11-14T15:33:45Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjkyODQ1NzM4",
          "commit": {
            "abbreviatedOid": "2fffe2b"
          },
          "author": "rozbb",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-09-25T06:09:27Z",
          "updatedAt": "2019-09-25T06:09:27Z",
          "comments": [
            {
              "originalPosition": 662,
              "body": "Typo: `path`\r\n\r\nAlso, if there's only a single DirectPath per epoch, won't this lead to trees becoming sparser (i.e., having fewer filled nodes) over time? It's fine as long as the root node is filled, but DirectPath messages might have to get bigger to accommodate the sparseness.",
              "createdAt": "2019-09-25T06:09:27Z",
              "updatedAt": "2019-11-14T15:33:45Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mjk0ODkyNTY2",
          "commit": {
            "abbreviatedOid": "2fffe2b"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-09-30T10:51:22Z",
          "updatedAt": "2019-09-30T10:51:22Z",
          "comments": [
            {
              "originalPosition": 662,
              "body": "The sparseness of the tree depends on how often all the members Commit. For example, if you have a group where only one person ever Commits, then the direct path above that person is the only one that will ever be populated, and MLS will degrade to \"encrypt every message to every person individually\" scheme.\r\n\r\nIf you have an application-level understanding of who needs to Commit and who's allowed to be lazy, it could be fine(?). It gives you a performance trade-off.",
              "createdAt": "2019-09-30T10:51:22Z",
              "updatedAt": "2019-11-14T15:33:45Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzE2OTU5NTg3",
          "commit": {
            "abbreviatedOid": "8f506ec"
          },
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "A few changes needed, but I would be fine with fixing in subsequent PRs.",
          "createdAt": "2019-11-14T13:43:09Z",
          "updatedAt": "2019-11-14T14:56:11Z",
          "comments": [
            {
              "originalPosition": 114,
              "body": "I suppose ContentType should be defined above correct ? or is this a forward reference ?\r\n(It is not in the diff..)",
              "createdAt": "2019-11-14T13:44:51Z",
              "updatedAt": "2019-11-14T15:33:45Z"
            },
            {
              "originalPosition": 160,
              "body": "Mixing derivations of different uses of the keys is quite bad practice and difficult to mechanically prove in an unbounded setting. We might get back to a tree later: Joel has a nice idea in to make it usable in the mechanized context and he will be visiting us to discuss it. For functionality I don't think we actually have to do a Tree, we can include a sender's counter when calling the KDF to derive separate keys and advertise it on the wire in the new outer AAD field of the common framing.\r\n\r\n",
              "createdAt": "2019-11-14T13:50:27Z",
              "updatedAt": "2019-11-14T15:33:45Z"
            },
            {
              "originalPosition": 215,
              "body": "Yes, we probably should, we don't want the delivery service to process the Commit first and discard the associated proposal because it is from the previous epoch",
              "createdAt": "2019-11-14T13:57:30Z",
              "updatedAt": "2019-11-14T15:33:45Z"
            },
            {
              "originalPosition": 217,
              "body": "I think Update+Commit should be atomic",
              "createdAt": "2019-11-14T13:57:57Z",
              "updatedAt": "2019-11-14T15:33:45Z"
            },
            {
              "originalPosition": 340,
              "body": "s/protocol/protocol version",
              "createdAt": "2019-11-14T13:59:13Z",
              "updatedAt": "2019-11-14T15:33:45Z"
            },
            {
              "originalPosition": 342,
              "body": "?? s/Note/Record ??",
              "createdAt": "2019-11-14T13:59:52Z",
              "updatedAt": "2019-11-14T15:33:45Z"
            },
            {
              "originalPosition": 392,
              "body": "s/broadcast/broadcasted",
              "createdAt": "2019-11-14T14:01:26Z",
              "updatedAt": "2019-11-14T15:33:45Z"
            },
            {
              "originalPosition": 599,
              "body": "Yes. As we need to indicate all the proposal accepted and rejected by the committer so that other members know what proposals have been considered.",
              "createdAt": "2019-11-14T14:35:00Z",
              "updatedAt": "2019-11-14T15:33:45Z"
            },
            {
              "originalPosition": 601,
              "body": "Richard is correct here.",
              "createdAt": "2019-11-14T14:40:17Z",
              "updatedAt": "2019-11-14T15:33:45Z"
            }
          ]
        }
      ]
    },
    {
      "number": 210,
      "id": "MDExOlB1bGxSZXF1ZXN0MzE5Mjk3MDc2",
      "title": "Update changelog for recent PRs",
      "url": "https://github.com/mlswg/mls-protocol/pull/210",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "",
      "createdAt": "2019-09-19T14:08:17Z",
      "updatedAt": "2019-12-17T08:56:16Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "1a201118d76925dcc1e9b31138299798d71cc90f",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "changelog-08",
      "headRefOid": "5d738bd4c395d1bf18597018d77dd06c50f381cb",
      "closedAt": "2019-09-19T14:08:39Z",
      "mergedAt": "2019-09-19T14:08:39Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "46e586329b16d9703ec321a83f79c70d6ed72c17"
      },
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Merging myself because this is trivial.",
          "createdAt": "2019-09-19T14:08:34Z",
          "updatedAt": "2019-09-19T14:08:34Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 213,
      "id": "MDExOlB1bGxSZXF1ZXN0MzIyNzg3Mzkz",
      "title": "Change ciphertext content to be standard TLS format.",
      "url": "https://github.com/mlswg/mls-protocol/pull/213",
      "state": "MERGED",
      "author": "Bren2010",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "enhancement"
      ],
      "body": "I don't like the pattern of having a marker byte followed by zero-padding. It has to be parsed manually, backwards, unlike every other object in the protocol which all follow a common format.",
      "createdAt": "2019-09-30T13:38:21Z",
      "updatedAt": "2019-12-17T08:54:09Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "46e586329b16d9703ec321a83f79c70d6ed72c17",
      "headRepository": "Bren2010/mls-protocol",
      "headRefName": "brendan/2019.9.0",
      "headRefOid": "1c3a2a6757ba447965ea90e2e1942d9e930d42fb",
      "closedAt": "2019-10-01T10:48:09Z",
      "mergedAt": "2019-10-01T10:48:09Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "30c31565ce57843e10e36c69c8573da54d505a56"
      },
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Agreement at the interim was that people don't care about the overhead (for now), so we're going to go with the simpler, TLS-syntax-based structure.",
          "createdAt": "2019-10-01T10:47:36Z",
          "updatedAt": "2019-10-01T10:47:36Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mjk1MDUyNzA0",
          "commit": {
            "abbreviatedOid": "1c3a2a6"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-09-30T15:16:19Z",
          "updatedAt": "2019-09-30T22:02:57Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "In general, I would prefer that editorial changes be in separate PRs from substantive changes.  But this one is small enough that I'll let it slide.",
              "createdAt": "2019-09-30T15:16:19Z",
              "updatedAt": "2019-09-30T22:02:57Z"
            },
            {
              "originalPosition": 55,
              "body": "The current design is carried over from TLS's minimal-overhead, unlimited-length design.  Relative to the left-hand side of the diff, you've added an octet here and imposed a 2^16 length limit.  I would counter-offer the following proposal:\r\n\r\n```\r\nstruct {\r\n  uint8 zero_padding[length_of_padding];\r\n  ContentType content_type;\r\n  select(content_type) {...}\r\n  opaque signature<0..2^16-1>;\r\n} MLSCiphertextContent;\r\n```\r\n\r\nThat is, move the `content_type` inside the encrypted portion, use it as the marker byte (as in TLS), and put the padding at the front.  @raphaelrobert had made noises about the server not knowing which messages to queue if the `content_type` was opaque, but it seems like the clients do know and if the server offers scheduled and unscheduled service, can choose the appropriate type.",
              "createdAt": "2019-09-30T15:22:47Z",
              "updatedAt": "2019-09-30T22:02:57Z"
            }
          ]
        }
      ]
    },
    {
      "number": 218,
      "id": "MDExOlB1bGxSZXF1ZXN0MzIzMDk2ODMy",
      "title": "Favor not reusing ClientInitKey (SHOULD)",
      "url": "https://github.com/mlswg/mls-protocol/pull/218",
      "state": "MERGED",
      "author": "beurdouche",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "security",
        "recommendation"
      ],
      "body": "This has been reported unclear multiple times. I strongly prefer forbidding reuse altogether.\r\nA validation mechanism is needed for the formal security proof, it can be implemented according to an expiration mechanism (see Architecture - 4.2.  Delivery Service Compromise)",
      "createdAt": "2019-10-01T05:52:10Z",
      "updatedAt": "2019-12-17T08:53:11Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "46e586329b16d9703ec321a83f79c70d6ed72c17",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "beurdouche_noreuse",
      "headRefOid": "5d3a24275f5822f9f2c2d08886502d9120b42cee",
      "closedAt": "2019-11-14T17:26:19Z",
      "mergedAt": "2019-11-14T17:26:19Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "39006cae700c2acdd769046911b6983c7d566c66"
      },
      "comments": [
        {
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "body": "We need to allow Last Resort keys. Not sure what you mean by \"replay attacks\"",
          "createdAt": "2019-10-04T18:08:48Z",
          "updatedAt": "2019-10-04T18:08:48Z"
        },
        {
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "body": "> We need to allow Last Resort keys. Not sure what you mean by \"replay attacks\"\r\n\r\nI rewrote it in favor of using \"SHOULD NOT reuse\", which is true, except in case of last resort to avoid DOS, which we are willing to allow.\r\n\r\nNormal meaning... If I remember correctly, there is a cross channel forwarding attack (replay) possible on the first message in Signal when reusing prekeys (the last resort key) because it lacks some channel binding but I would have to check. I am working to make sure we don't suffer the same defect but I am documenting it in the mean time.",
          "createdAt": "2019-10-04T19:28:11Z",
          "updatedAt": "2019-10-04T19:28:11Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "I can live with this for now; we can refine later.",
          "createdAt": "2019-11-14T17:26:10Z",
          "updatedAt": "2019-11-14T17:26:10Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzExODY0NjI1",
          "commit": {
            "abbreviatedOid": "5d3a242"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-05T16:32:07Z",
          "updatedAt": "2019-11-05T16:35:21Z",
          "comments": [
            {
              "originalPosition": 21,
              "body": "This needs more elaboration.  InitKeys are used in Welcome/Init messages, so those messages could be replayed.  The result of that depends on how applications treat group IDs, since the group ID will be the same between the original and the replay.  If the client rejects Init/Welcome messages for group IDs where it is already a member, then there's no problem.  If the client allows duplicate group IDs, and thus accepts such Init/Welcome messages, then it will consider the replay a new session and accept the replayed messages within that session.  That session can be replayed up until the first time the new member updates, so there's even more reason to update on join.\r\n\r\nIf we're going to say something here, I would propose we focus the guidance on those considerations, instead of trying to prevent reuse (which isn't feasible anyway).\r\n\r\n* Applications SHOULD reject Init/Welcome with duplicate group IDs\r\n* Clients SHOULD update on join",
              "createdAt": "2019-11-05T16:32:07Z",
              "updatedAt": "2019-11-05T16:35:21Z"
            },
            {
              "originalPosition": 11,
              "body": "Multiple versions as well.",
              "createdAt": "2019-11-05T16:32:28Z",
              "updatedAt": "2019-11-05T16:35:22Z"
            },
            {
              "originalPosition": 9,
              "body": "I'm not sure I agree with this.  If you have a last resort key, an attacker can always force you to use it.  And as discussed below, there are alternative mitigations to the replay risks.",
              "createdAt": "2019-11-05T16:35:18Z",
              "updatedAt": "2019-11-05T16:35:22Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzE3MTMwMTg2",
          "commit": {
            "abbreviatedOid": "5d3a242"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-11-14T17:25:54Z",
          "updatedAt": "2019-11-14T17:25:54Z",
          "comments": []
        }
      ]
    },
    {
      "number": 219,
      "id": "MDExOlB1bGxSZXF1ZXN0MzIzMTA0MjEz",
      "title": "Fix application message truncation attack",
      "url": "https://github.com/mlswg/mls-protocol/pull/219",
      "state": "CLOSED",
      "author": "beurdouche",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "security",
        "work in progress",
        "functionality"
      ],
      "body": "2020/03/04 - Will be resolved by the next interim",
      "createdAt": "2019-10-01T06:17:00Z",
      "updatedAt": "2020-07-24T21:16:47Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "46e586329b16d9703ec321a83f79c70d6ed72c17",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "beurdouche_fix_truncation_attack",
      "headRefOid": "84a6d7b93fc914157066f41854489bb22f5adfc9",
      "closedAt": "2020-07-24T21:16:47Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "body": "I don't agree with this change. It's not MLS's job to enforce an order on messages, or enforce that messages don't get lost. If you want to ensure things, you can build your own mechanism and store it in the AAD of the messages. This also lets people build their own thing that's as strong/weak as they need:\r\n\r\n- Ensure per-peer message order, no messages lost: Each peer puts a counter in their AAD, \"This is my 7th message.\" and others can complain if they haven't seen message 6.\r\n- Ensure total message order: Each message has the hash of the last message in its AAD.\r\n- Maybe you have no mechanism because you're fine with messages getting lost.",
          "createdAt": "2019-10-01T12:53:15Z",
          "updatedAt": "2019-10-01T12:53:15Z"
        },
        {
          "author": "katrielalex",
          "authorAssociation": "MEMBER",
          "body": "I'd be happy to include in the AAD the length of the previous chain (\"PN\" in Signal's language), but I don't have strong feelings.",
          "createdAt": "2019-10-01T13:02:14Z",
          "updatedAt": "2019-10-01T13:02:14Z"
        },
        {
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "body": "> I don't agree with this change. It's not MLS's job to enforce an order on messages,\r\n> \r\nNobody is talking about this...\r\n> or enforce that messages don't get lost.\r\n> \r\nModern protocols gives you this property. I believe Signal does give you that, minimally, you should know if I drop all your messages.\r\n> If you want to ensure things, you can build your own mechanism and store it in the AAD of the messages. This also lets people build their own thing that's as strong/weak as they need:\r\n> \r\n> Ensure per-peer message order, no messages lost: Each peer puts a counter in their AAD, \"This is my 7th message.\" and others can complain if they haven't seen message 6.\r\n> Ensure total message order: Each message has the hash of the last message in its AAD.\r\n> Maybe you have no mechanism because you're fine with messages getting lost\r\nThis reasonning is completly the reverse of the MLS goals, we actually want to enforce as much\r\nas possible in the protocol and relax at the application level but definitely not let people design complex\r\nthings at the application level without any information callback from the protocol layer\r\n\r\n",
          "createdAt": "2019-10-01T13:17:29Z",
          "updatedAt": "2019-10-04T09:20:16Z"
        },
        {
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "body": "> This reasonning is completly the reverse of the MLS goals, we actually want to enforce as much\r\nas possible in the protocol\r\n\r\nWe leave a lot of things out of the protocol that are better handled at another layer, or where there are multiple acceptable solutions. \"Application message truncation attack\" is not an attack, it's just another way to say \"packet loss\" which is better handled at the TCP / application layer, because those are the layers that know how things are going to get lost.\r\n\r\nTLS, for example, doesn't know how to recover lost packets -- that's TCP's job. TLS also doesn't know how to do application-level retries -- that's the application's job.",
          "createdAt": "2019-10-04T17:56:36Z",
          "updatedAt": "2019-10-04T17:56:36Z"
        },
        {
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "body": "I think that including the counter is a meaningful mechanism to ensure the DS behaves correctly. If possible at all, this should not be solved at the application layer. Naturally applications can ignore lost/suppressed messages if they so wish.\r\nTranscript consistency was one the properties discussed early on and this goes in the right direction at a very low cost.",
          "createdAt": "2019-10-04T18:54:06Z",
          "updatedAt": "2019-10-04T18:54:06Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "This PR has gotten quite stale and out of sync with the draft.  Closing for now.  @beurdouche holds the token to propose an alternate resolution to #160.",
          "createdAt": "2020-07-24T21:16:47Z",
          "updatedAt": "2020-07-24T21:16:47Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 220,
      "id": "MDExOlB1bGxSZXF1ZXN0MzIzMTA5MTE5",
      "title": "More requirements regarding state loss",
      "url": "https://github.com/mlswg/mls-protocol/pull/220",
      "state": "CLOSED",
      "author": "beurdouche",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "security"
      ],
      "body": "",
      "createdAt": "2019-10-01T06:33:16Z",
      "updatedAt": "2019-12-17T08:52:00Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "46e586329b16d9703ec321a83f79c70d6ed72c17",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "beurdouche_state_loss",
      "headRefOid": "332fb1dca48460d29ebbc4bb3302066c5b9aedc5",
      "closedAt": "2019-11-05T16:09:46Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "body": "I mixed state loss and device loss by mistake, thank you. I removed the second part and put it in a separate place. Regarding the partial state loss, I am sure that Jon, Katriel or Raphael can give you good examples. ",
          "createdAt": "2019-10-04T18:59:13Z",
          "updatedAt": "2019-10-04T18:59:13Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing this pending #93 \r\n",
          "createdAt": "2019-11-05T16:09:38Z",
          "updatedAt": "2019-11-05T16:09:38Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mjk3MzU0NDUy",
          "commit": {
            "abbreviatedOid": "9978983"
          },
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-10-04T09:17:59Z",
          "updatedAt": "2019-10-04T09:18:00Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "Note that this will be definitely needed to recover PCS if we do the signature key rotation.",
              "createdAt": "2019-10-04T09:18:00Z",
              "updatedAt": "2019-10-04T18:51:45Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mjk3NjI3MzU5",
          "commit": {
            "abbreviatedOid": "9978983"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "This section doesn't make sense to me. In what situation would you only lose part of the group state? Why does losing the state for a group mean you have to expire all of your ClientInitKeys?",
          "createdAt": "2019-10-04T17:52:55Z",
          "updatedAt": "2019-10-04T17:52:55Z",
          "comments": []
        }
      ]
    },
    {
      "number": 221,
      "id": "MDExOlB1bGxSZXF1ZXN0MzIzMTM4Mjky",
      "title": "Precisions on authentication and IdentityKeys",
      "url": "https://github.com/mlswg/mls-protocol/pull/221",
      "state": "MERGED",
      "author": "beurdouche",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "security",
        "recommendation"
      ],
      "body": "I couldn't find this written anywhere else and this is also related to a discussion about PCS with Cas and al.",
      "createdAt": "2019-10-01T08:03:35Z",
      "updatedAt": "2019-12-17T08:51:10Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "46e586329b16d9703ec321a83f79c70d6ed72c17",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "beurdouche_auth_control",
      "headRefOid": "d3048eacf93cf5c2d5645b72622d847ebdf87ce0",
      "closedAt": "2019-11-05T16:07:24Z",
      "mergedAt": "2019-11-05T16:07:24Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "69739df60d07ee53c245ff9bbee7d391f1ce5b9d"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mjk3NjMzODYz",
          "commit": {
            "abbreviatedOid": "d3048ea"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-10-04T18:05:16Z",
          "updatedAt": "2019-10-04T18:05:21Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "maybe just \"MUST be validated.\"",
              "createdAt": "2019-10-04T18:05:16Z",
              "updatedAt": "2019-10-04T18:05:21Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzExODQ1Njk0",
          "commit": {
            "abbreviatedOid": "d3048ea"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-11-05T16:07:10Z",
          "updatedAt": "2019-11-05T16:07:15Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "I don't think you can make this a MUST.  You can imagine applications that don't really care about authentication, but want all the other properties.  Also, there is no comparable requirement in TLS.",
              "createdAt": "2019-11-05T16:07:10Z",
              "updatedAt": "2019-11-05T16:07:15Z"
            }
          ]
        }
      ]
    },
    {
      "number": 229,
      "id": "MDExOlB1bGxSZXF1ZXN0MzI0NjgzODYy",
      "title": "Correction of three minor typos",
      "url": "https://github.com/mlswg/mls-protocol/pull/229",
      "state": "MERGED",
      "author": "pjunodsc",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "This PR corrects three minor typos.",
      "createdAt": "2019-10-04T13:35:34Z",
      "updatedAt": "2019-12-17T08:50:49Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "30c31565ce57843e10e36c69c8573da54d505a56",
      "headRepository": "pjunodsc/mls-protocol",
      "headRefName": "20191004_minor-typos",
      "headRefOid": "328effac7452a831836ebe43391d3d2caa30cbf7",
      "closedAt": "2019-10-04T13:36:22Z",
      "mergedAt": "2019-10-04T13:36:22Z",
      "mergedBy": "beurdouche",
      "mergeCommit": {
        "oid": "d8672cf6e78d781a5ff6f9e238ee6b0db3b3f026"
      },
      "comments": [
        {
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "body": "Thank you Pascal !",
          "createdAt": "2019-10-04T13:36:24Z",
          "updatedAt": "2019-10-04T13:36:24Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mjk3NDc4MjY0",
          "commit": {
            "abbreviatedOid": "328effa"
          },
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-10-04T13:35:58Z",
          "updatedAt": "2019-10-04T13:35:58Z",
          "comments": []
        }
      ]
    },
    {
      "number": 230,
      "id": "MDExOlB1bGxSZXF1ZXN0MzI0ODA3ODQ1",
      "title": "Device loss and sig key compromise",
      "url": "https://github.com/mlswg/mls-protocol/pull/230",
      "state": "MERGED",
      "author": "beurdouche",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "security",
        "recommendation"
      ],
      "body": "",
      "createdAt": "2019-10-04T18:55:21Z",
      "updatedAt": "2019-12-17T08:50:35Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "d8672cf6e78d781a5ff6f9e238ee6b0db3b3f026",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "beurdouche_sig_pcs",
      "headRefOid": "0cb0617030c1082a105b1af2b33654dffa9a7fe4",
      "closedAt": "2019-11-05T16:03:27Z",
      "mergedAt": "2019-11-05T16:03:27Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "d4362b8075dd5e42e1a45c721874409a82a7438f"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzExODQyNzM1",
          "commit": {
            "abbreviatedOid": "0cb0617"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-11-05T16:03:15Z",
          "updatedAt": "2019-11-05T16:03:15Z",
          "comments": []
        }
      ]
    },
    {
      "number": 232,
      "id": "MDExOlB1bGxSZXF1ZXN0MzI1NjM4Njk3",
      "title": "Fix resolution-related issue in ratchet tree update example",
      "url": "https://github.com/mlswg/mls-protocol/pull/232",
      "state": "CLOSED",
      "author": "pjunodsc",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "",
      "createdAt": "2019-10-08T07:31:06Z",
      "updatedAt": "2019-12-17T10:17:38Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "d8672cf6e78d781a5ff6f9e238ee6b0db3b3f026",
      "headRepository": "pjunodsc/mls-protocol",
      "headRefName": "20191007_fix-copath",
      "headRefOid": "3feef3c8467ec01b781a03d7ff75dbdee621bd9e",
      "closedAt": "2019-11-14T18:20:46Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Obsoleted by #244 ",
          "createdAt": "2019-11-14T18:20:46Z",
          "updatedAt": "2019-11-14T18:20:46Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzE2NjkwNjQ0",
          "commit": {
            "abbreviatedOid": "3feef3c"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-11-14T03:12:57Z",
          "updatedAt": "2019-11-14T03:12:57Z",
          "comments": []
        }
      ]
    },
    {
      "number": 233,
      "id": "MDExOlB1bGxSZXF1ZXN0MzI2NDQ3OTEx",
      "title": "Initialize new members directly into the current epoch",
      "url": "https://github.com/mlswg/mls-protocol/pull/233",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "security",
        "functionality"
      ],
      "body": "Fixes #223 \r\n\r\nDiscussion of security analysis in the issue.",
      "createdAt": "2019-10-09T21:04:28Z",
      "updatedAt": "2019-12-17T10:17:21Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "d8672cf6e78d781a5ff6f9e238ee6b0db3b3f026",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "welcome-current-epoch",
      "headRefOid": "e1e26b8f40ca5ebfa47c42f92cb8994957555846",
      "closedAt": "2019-11-11T19:29:58Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "body": "Shouldn't we rebase this on the Proposals proposal? Otherwise we might just throw away a good part of this PR soon.",
          "createdAt": "2019-10-11T13:46:06Z",
          "updatedAt": "2019-10-11T13:46:06Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "@raphaelrobert - Since there wasn't clear agreement on the Proposals PR, I went ahead and pulled this out.  If we are going to do Proposals, it won't be a bad rebase.  And in any case, doing this on its own made it a bit easier to do the supporting analysis.",
          "createdAt": "2019-10-11T22:50:12Z",
          "updatedAt": "2019-10-11T22:50:12Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing this, as it looks like #209 is going to land soon.",
          "createdAt": "2019-11-11T19:29:08Z",
          "updatedAt": "2019-11-11T19:29:08Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 234,
      "id": "MDExOlB1bGxSZXF1ZXN0MzI2NDUzNDA2",
      "title": "Add downgrade protection to ClientInitKeys",
      "url": "https://github.com/mlswg/mls-protocol/pull/234",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "security",
        "functionality"
      ],
      "body": "Fixes #224 ",
      "createdAt": "2019-10-09T21:19:51Z",
      "updatedAt": "2019-12-17T08:49:01Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "517c83b3b83ae73d5bd58cff763245c771567d2e",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "cik-extensions",
      "headRefOid": "5f9c2ff63e822ff7a51832778834be942e03f8b6",
      "closedAt": "2019-11-14T17:58:54Z",
      "mergedAt": "2019-11-14T17:58:54Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "1ba65c11aee17962c22c85e1b2eb2250e3584a9c"
      },
      "comments": [
        {
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "body": "I think @bifurcation added what we discussed at the interim, but I agree with @beurdouche that we shouldn't label it as \"protection\" because of the lack of guarantees.\r\nIt is indeed just an information mechanism, but a number of questions are left open:\r\n - what should the client creating a group do if better ciphersuites /higher versions are advertised but the DS doesn't deliver the corresponding keys?\r\n - what should an added client do when it realises it was added with a sub-optimal ClientInitKey?\r\n - ...",
          "createdAt": "2019-10-11T09:28:30Z",
          "updatedAt": "2019-10-11T09:28:30Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "This now has a MUST for using the extensions to prevent downgrade.\r\n",
          "createdAt": "2019-11-14T17:09:23Z",
          "updatedAt": "2019-11-14T17:09:23Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzAwMTk0MzAy",
          "commit": {
            "abbreviatedOid": "4d16799"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-10-10T16:21:41Z",
          "updatedAt": "2019-10-10T16:21:41Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzAwMTk1NzE0",
          "commit": {
            "abbreviatedOid": "4d16799"
          },
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "state": "CHANGES_REQUESTED",
          "body": "This is not a downgrade protection mechanism. This is an information mechanism.\r\nThere is no rule here telling client receiving a `create` that they should refuse the state and how they should refuse it.",
          "createdAt": "2019-10-10T16:24:05Z",
          "updatedAt": "2019-10-10T16:24:05Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzE3MTE5NDM4",
          "commit": {
            "abbreviatedOid": "afc4965"
          },
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-11-14T17:09:02Z",
          "updatedAt": "2019-11-14T17:09:02Z",
          "comments": []
        }
      ]
    },
    {
      "number": 239,
      "id": "MDExOlB1bGxSZXF1ZXN0MzM5NjY0MDkw",
      "title": "Welcome* == Init",
      "url": "https://github.com/mlswg/mls-protocol/pull/239",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "security",
        "functionality"
      ],
      "body": "This PR makes two major changes that are enabled by Proposals:\r\n\r\n* Multiple participants added in the same epoch receive the same Welcome message\r\n* Init is always a special case of Add\r\n\r\nPrior to Proposals, treating Init as a special case of Add led to a performance degradation (`n -> n log n`).  With Proposals, any number of Adds can be done with a single Commit (at `O(n)` cost), so there is no more degradation.  The result seems (IMO) much more elegant than before.\r\n\r\nThe main cost is that encryption of Welcome messages is now in two stages (three if you include the internal HPKE stage!), even if there is only one new member.\r\n\r\nDepends on #209 \r\nObsoletes #192 and #194 ",
      "createdAt": "2019-11-11T23:45:26Z",
      "updatedAt": "2019-12-17T08:47:53Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "39006cae700c2acdd769046911b6983c7d566c66",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "welcome-equals-init",
      "headRefOid": "292a51be8f9ebcc921349f2a2fa469873bb29583",
      "closedAt": "2019-11-14T17:56:48Z",
      "mergedAt": "2019-11-14T17:56:48Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "517c83b3b83ae73d5bd58cff763245c771567d2e"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzE3MDk0MDM2",
          "commit": {
            "abbreviatedOid": "93de1be"
          },
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "state": "CHANGES_REQUESTED",
          "body": "I don't think that's far... Should we put CIK in leaves prior to this ?",
          "createdAt": "2019-11-14T16:33:45Z",
          "updatedAt": "2019-11-14T16:45:25Z",
          "comments": [
            {
              "originalPosition": 116,
              "body": "The creator chooses all CIKs and all secrets from its leaf to the root.",
              "createdAt": "2019-11-14T16:33:45Z",
              "updatedAt": "2019-11-14T17:56:40Z"
            },
            {
              "originalPosition": 121,
              "body": "I would prefer avoiding the requirement that the creator is at index 0 because it breaks privacy of its identity.\r\nWhen newcomers are included later on, it might be nice to not know immediately who is the creator.",
              "createdAt": "2019-11-14T16:35:29Z",
              "updatedAt": "2019-11-14T17:56:40Z"
            },
            {
              "originalPosition": 149,
              "body": "randomly chosen key and nonce",
              "createdAt": "2019-11-14T16:37:06Z",
              "updatedAt": "2019-11-14T17:56:40Z"
            },
            {
              "originalPosition": 186,
              "body": "MemberInfo is a bad name, welcome keypackage or something ?",
              "createdAt": "2019-11-14T16:39:08Z",
              "updatedAt": "2019-11-14T17:56:40Z"
            },
            {
              "originalPosition": 196,
              "body": "Same thing, for the name: `KeyPackage packages` or something ?",
              "createdAt": "2019-11-14T16:42:35Z",
              "updatedAt": "2019-11-14T17:56:40Z"
            },
            {
              "originalPosition": 212,
              "body": "What kind of error ?",
              "createdAt": "2019-11-14T16:43:31Z",
              "updatedAt": "2019-11-14T17:56:40Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzE3MTIzMzc3",
          "commit": {
            "abbreviatedOid": "93de1be"
          },
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "Modulo fixes discussed with Richard",
          "createdAt": "2019-11-14T17:15:06Z",
          "updatedAt": "2019-11-14T17:15:06Z",
          "comments": []
        }
      ]
    },
    {
      "number": 240,
      "id": "MDExOlB1bGxSZXF1ZXN0MzM5Njc1MjA1",
      "title": "External proposals",
      "url": "https://github.com/mlswg/mls-protocol/pull/240",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "security",
        "functionality"
      ],
      "body": "Depends on #209 \r\nFixes #104 ",
      "createdAt": "2019-11-12T00:38:48Z",
      "updatedAt": "2019-12-17T08:47:14Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "41a2389abf922fe0c3dbcc1ec67e2ddbd7416ec2",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "external-proposals",
      "headRefOid": "e543c19029d839ffe95e8ebd0a6c8597a0802290",
      "closedAt": "2019-11-14T17:16:11Z",
      "mergedAt": "2019-11-14T17:16:10Z",
      "mergedBy": "beurdouche",
      "mergeCommit": {
        "oid": "2eb798398763655082d43c22fab5e52d563ecd4b"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzE3MDg3MjU3",
          "commit": {
            "abbreviatedOid": "e543c19"
          },
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "The signing key of external actors will be contained in the leaf in the case it is a CIK.",
          "createdAt": "2019-11-14T16:25:14Z",
          "updatedAt": "2019-11-14T16:25:14Z",
          "comments": []
        }
      ]
    },
    {
      "number": 241,
      "id": "MDExOlB1bGxSZXF1ZXN0MzQwMDk4Mjc0",
      "title": "IANA Considerations and Ciphersuites",
      "url": "https://github.com/mlswg/mls-protocol/pull/241",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "editorial",
        "functionality"
      ],
      "body": "This PR begins filling in the IANA Considerations section, starting with a Ciphersuites registry.  This addresses the concerns in #95 as discussed at the interim (2019-10), namely by reserving for vendor use chunk of the code points space large enough to be selected at random without huge risk of collision (2^12 values).\r\n\r\nDepends on #209 \r\nFixes #95 ",
      "createdAt": "2019-11-12T20:30:57Z",
      "updatedAt": "2019-12-17T08:46:40Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "41a2389abf922fe0c3dbcc1ec67e2ddbd7416ec2",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "iana",
      "headRefOid": "96599f8b82016f8ffd43941cb4d810e3f5362df2",
      "closedAt": "2019-11-14T17:17:24Z",
      "mergedAt": "2019-11-14T17:17:23Z",
      "mergedBy": "beurdouche",
      "mergeCommit": {
        "oid": "e03e5d74e59ba2aca912b6f454141a6d204bad3d"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzE3MTI0NzU3",
          "commit": {
            "abbreviatedOid": "96599f8"
          },
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-11-14T17:17:17Z",
          "updatedAt": "2019-11-14T17:17:17Z",
          "comments": []
        }
      ]
    },
    {
      "number": 242,
      "id": "MDExOlB1bGxSZXF1ZXN0MzQwMTYxMzUw",
      "title": "Pack multiple Proposals and a Commit together",
      "url": "https://github.com/mlswg/mls-protocol/pull/242",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This is a light optimization over #209, removing the overhead of extra encryptions/signatures in the case where proposal(s) and a commit are sent at the same time.\r\n\r\nDepends on #209 ",
      "createdAt": "2019-11-12T23:25:11Z",
      "updatedAt": "2019-11-14T19:10:30Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "1ba65c11aee17962c22c85e1b2eb2250e3584a9c",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "multi",
      "headRefOid": "f8e5827a8d1c8a2b181cb8d6d9540fa4bc316f3c",
      "closedAt": "2019-11-14T18:08:49Z",
      "mergedAt": "2019-11-14T18:08:49Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "b3f7fe7c836cfd951fc638966ebd95f478324f7d"
      },
      "comments": [
        {
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "body": "Unfortunately, using a single content type enforces the DS to order everything while there is no reason to force ordering of proposals made for the same epoch.",
          "createdAt": "2019-11-14T16:16:53Z",
          "updatedAt": "2019-11-14T16:16:53Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "On conversation with @beurdouche - Will keep content types separate, but allow Commit to have proposals.",
          "createdAt": "2019-11-14T17:07:15Z",
          "updatedAt": "2019-11-14T17:07:15Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzE3MTUxMDI0",
          "commit": {
            "abbreviatedOid": "c9a0977"
          },
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "Good to go modulo fix.",
          "createdAt": "2019-11-14T18:00:34Z",
          "updatedAt": "2019-11-14T18:00:34Z",
          "comments": []
        }
      ]
    },
    {
      "number": 243,
      "id": "MDExOlB1bGxSZXF1ZXN0MzQwNzYzNDU2",
      "title": "Add GroupContext to signatures and AAD",
      "url": "https://github.com/mlswg/mls-protocol/pull/243",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "bug",
        "security"
      ],
      "body": "This makes MLSPlaintext signatures and DirectPath encryptions specific to a given group and epoch, to avoid copy/paste attacks.\r\n\r\n@Bren2010 - Note that this fixes #214 since DirectPath HPKE encryptions will have non-empty AAD, while Welcome messages will have none.\r\n\r\nDepends on #209 \r\nFixes #214 \r\nFixes #217 ",
      "createdAt": "2019-11-14T02:58:16Z",
      "updatedAt": "2019-12-17T08:43:17Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "41a2389abf922fe0c3dbcc1ec67e2ddbd7416ec2",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "inputs",
      "headRefOid": "34b3022a9ba40cb96114734915e7bb82af3c171c",
      "closedAt": "2019-11-14T17:18:25Z",
      "mergedAt": "2019-11-14T17:18:25Z",
      "mergedBy": "beurdouche",
      "mergeCommit": {
        "oid": "3bc25daa05026562a7221ca228498451ded9ceb4"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzE3MTI1NDQy",
          "commit": {
            "abbreviatedOid": "34b3022"
          },
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-11-14T17:18:18Z",
          "updatedAt": "2019-11-14T17:18:18Z",
          "comments": []
        }
      ]
    },
    {
      "number": 244,
      "id": "MDExOlB1bGxSZXF1ZXN0MzQxMTExNTYx",
      "title": "Some editorial fixes",
      "url": "https://github.com/mlswg/mls-protocol/pull/244",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "Picking up some comments from @Bren2010 that I missed earlier, and fixing examples.\r\n\r\nObsoletes #232 ",
      "createdAt": "2019-11-14T18:19:38Z",
      "updatedAt": "2019-12-17T08:42:34Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "b3f7fe7c836cfd951fc638966ebd95f478324f7d",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "editorial",
      "headRefOid": "6961d3ec6915ecec9d7e8397cd6c4e7e7cb8d71a",
      "closedAt": "2019-11-14T18:20:18Z",
      "mergedAt": "2019-11-14T18:20:17Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "09110a985ad173c546c37707e90614ae54f7468a"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 245,
      "id": "MDExOlB1bGxSZXF1ZXN0MzQxMTMxMzIz",
      "title": "Unpredictable epochs",
      "url": "https://github.com/mlswg/mls-protocol/pull/245",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "work in progress",
        "privacy"
      ],
      "body": "This allows for forks in the group history.",
      "createdAt": "2019-11-14T19:12:28Z",
      "updatedAt": "2020-01-28T23:35:24Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "09110a985ad173c546c37707e90614ae54f7468a",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "random-epoch",
      "headRefOid": "9eaa62caf6cfabdbc4ca6af64a73eb82e39e50ad",
      "closedAt": "2020-01-28T23:35:23Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "body": "I'm not sure I understand how the DS can do its job with this. To re-iterate what that is:\r\n\r\n - The DS needs to be the arbitrator in a race condition when two clients send a HS message based on the same previous epoch\r\n - In order to do so, it needs to be able to compare the new with the old epoch\r\n - It should additionally be able to detect when a HS message is not based on the previous and reject it\r\n\r\nThe above obviously works nicely with an incremental counter for epochs. I'd be happy if we can further obfuscate the epoch number, I'm just not sure what options we have that satisfy the above requirements.",
          "createdAt": "2019-11-14T20:10:13Z",
          "updatedAt": "2019-11-14T20:10:13Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Obsoleted by #281 ",
          "createdAt": "2020-01-28T23:35:23Z",
          "updatedAt": "2020-01-28T23:35:23Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzE3MjE0NzU2",
          "commit": {
            "abbreviatedOid": "9eaa62c"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2019-11-14T19:44:06Z",
          "updatedAt": "2019-11-14T19:44:19Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "- Stop truncating hashes!\r\n- What about the first epoch?",
              "createdAt": "2019-11-14T19:44:07Z",
              "updatedAt": "2019-11-14T19:44:20Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzE3MjE2NjA1",
          "commit": {
            "abbreviatedOid": "9eaa62c"
          },
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-14T19:47:16Z",
          "updatedAt": "2019-11-14T19:47:17Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "I am more concerned* about loosing lexicographic ordering here. The DS wouldn't know how to reorder.",
              "createdAt": "2019-11-14T19:47:17Z",
              "updatedAt": "2019-11-14T19:47:53Z"
            }
          ]
        }
      ]
    },
    {
      "number": 246,
      "id": "MDExOlB1bGxSZXF1ZXN0MzQxNzkwMzE0",
      "title": "Bugfixes in ClientInitKey, Commit, and Welcome",
      "url": "https://github.com/mlswg/mls-protocol/pull/246",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "bug",
        "editorial"
      ],
      "body": "1. The `client_init_key_id` is no longer needed, since CIKs are referenced by hash.\r\n2. ProposalIDs were no longer usable to refer to proposals since we enabled multiple proposals per MLSPlaintext\r\n3. The syntax description for Welcome was invalid",
      "createdAt": "2019-11-16T20:42:57Z",
      "updatedAt": "2020-01-30T10:57:33Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "26a327ca9c07381c3a8b9d717ff2641749195824",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "sg-bugfixes",
      "headRefOid": "13a4e3c8b0ee3e8b0145fb7c5bd8d6261f4b8520",
      "closedAt": "2020-01-29T22:06:29Z",
      "mergedAt": "2020-01-29T22:06:29Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "f52047aa4efc1e089c5bcd4c81c6eee6a90cefa5"
      },
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Merge with master obsoleted some changes.  I re-implemented the \"supported_version\"->\"version\" change, and added a \"key_id\" extension to address Benjamin's comment.",
          "createdAt": "2020-01-29T22:06:23Z",
          "updatedAt": "2020-01-29T22:06:23Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzE3OTg4MzY5",
          "commit": {
            "abbreviatedOid": "cef2419"
          },
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-16T20:47:36Z",
          "updatedAt": "2019-11-16T20:52:37Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "I am quite sure that it is needed for lookup, the emitter should have the ability to validate it and you want to include it in the signature.",
              "createdAt": "2019-11-16T20:47:36Z",
              "updatedAt": "2020-01-29T22:04:57Z"
            },
            {
              "originalPosition": 9,
              "body": "I prefer `init_key` which conveys the fact that it is the very first KEM public key",
              "createdAt": "2019-11-16T20:48:23Z",
              "updatedAt": "2020-01-29T22:04:57Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzE3OTg4NjA3",
          "commit": {
            "abbreviatedOid": "cef2419"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-16T20:54:59Z",
          "updatedAt": "2019-11-16T20:54:59Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "Why do you need it for lookup?  The only place it's referenced is Welcome, which references it by hash.",
              "createdAt": "2019-11-16T20:54:59Z",
              "updatedAt": "2020-01-29T22:04:57Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzE3OTg4NjE2",
          "commit": {
            "abbreviatedOid": "cef2419"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-16T20:55:19Z",
          "updatedAt": "2019-11-16T20:55:19Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "OK, sure, whatever :)",
              "createdAt": "2019-11-16T20:55:19Z",
              "updatedAt": "2020-01-29T22:04:57Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzE3OTg5MTU0",
          "commit": {
            "abbreviatedOid": "cef2419"
          },
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-16T21:10:34Z",
          "updatedAt": "2019-11-16T21:10:34Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "It might be fine to use the hash as an implicit identifier for outside the protocol for now but I suspect that in some applications we'll want the application to pick the identifier.",
              "createdAt": "2019-11-16T21:10:34Z",
              "updatedAt": "2020-01-29T22:04:57Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzE3OTg5NzQx",
          "commit": {
            "abbreviatedOid": "cef2419"
          },
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-11-16T21:27:47Z",
          "updatedAt": "2019-11-16T21:27:47Z",
          "comments": []
        }
      ]
    },
    {
      "number": 247,
      "id": "MDExOlB1bGxSZXF1ZXN0MzQxNzkxMDc3",
      "title": "Welcome confirmation and key derivation",
      "url": "https://github.com/mlswg/mls-protocol/pull/247",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "enhancement",
        "security"
      ],
      "body": "1. Once a new member instantiates the group state, they can verify the confirmation MAC that was sent in the Commit that created the state.  This lets new members verify that they've joined correctly.  (It does not assure that they're seeing the same confirmation as anyone else.)\r\n\r\n2. Instead of generating a fresh key, we can simply provide the epoch key in the key package and derive the GroupInfo encryption key from it.  This avoids relying on fresh entropy, and makes it more difficult for the sender to provide different keys that will all decrypt and authenticate the GroupInfo.",
      "createdAt": "2019-11-16T20:52:47Z",
      "updatedAt": "2020-01-31T15:09:13Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "f52047aa4efc1e089c5bcd4c81c6eee6a90cefa5",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "welcome-confirmation",
      "headRefOid": "d460925cac306275e529a6c657e74eed653cf11b",
      "closedAt": "2020-01-31T15:09:13Z",
      "mergedAt": "2020-01-31T15:09:13Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "f5f308ddc3cbe8eae68867231e1d79242e6a512f"
      },
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "This appears to have been rendered obsolete by #265 ",
          "createdAt": "2020-01-29T21:47:50Z",
          "updatedAt": "2020-01-29T21:47:50Z"
        },
        {
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "body": "Actually this is the nice one providing the nice properties, unlike #265 which breaks the cryptographic properties we expect from the secrecy invariant (see #277)",
          "createdAt": "2020-01-30T10:48:56Z",
          "updatedAt": "2020-01-30T10:48:56Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Ah, thank you for reminding me of #277! I will rebase this and merge.  ",
          "createdAt": "2020-01-30T14:23:37Z",
          "updatedAt": "2020-01-30T14:23:37Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzE3OTg5NzEw",
          "commit": {
            "abbreviatedOid": "e54b510"
          },
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-11-16T21:27:03Z",
          "updatedAt": "2019-11-16T21:27:09Z",
          "comments": []
        }
      ]
    },
    {
      "number": 251,
      "id": "MDExOlB1bGxSZXF1ZXN0MzQyMzEwOTI3",
      "title": "Initial proposal for PSK inputs",
      "url": "https://github.com/mlswg/mls-protocol/pull/251",
      "state": "MERGED",
      "author": "beurdouche",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "security",
        "functionality"
      ],
      "body": "This is for injection of out-of-band shared entropy.",
      "createdAt": "2019-11-18T19:06:32Z",
      "updatedAt": "2019-12-20T21:58:46Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "c99d7c11318d78545a15973776b6bb1cf62833ea",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "beurdouche_psk",
      "headRefOid": "8fddd9af921b76f9b88bc41b9a65b4626c027b47",
      "closedAt": "2019-12-10T16:53:55Z",
      "mergedAt": "2019-12-10T16:53:55Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "3eee58aa2ba2896a0f28fb9e1c6df16245b6fee7"
      },
      "comments": [
        {
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "body": "Note that an alternative to this is to make PSK a proposal containing a PSK identifier.",
          "createdAt": "2019-11-19T10:42:07Z",
          "updatedAt": "2019-11-19T10:42:23Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzI5OTkwNzQy",
          "commit": {
            "abbreviatedOid": "8fddd9a"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-12-10T16:53:45Z",
          "updatedAt": "2019-12-10T16:53:45Z",
          "comments": []
        }
      ]
    },
    {
      "number": 252,
      "id": "MDExOlB1bGxSZXF1ZXN0MzQyMzg2NjMy",
      "title": "Bugfixes: fix a few typos in text and structs",
      "url": "https://github.com/mlswg/mls-protocol/pull/252",
      "state": "MERGED",
      "author": "beurdouche",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "",
      "createdAt": "2019-11-18T22:11:01Z",
      "updatedAt": "2019-12-20T21:58:51Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "09110a985ad173c546c37707e90614ae54f7468a",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "beurdouche_bugfixes",
      "headRefOid": "f45e0d7f4d3399c24b7c348629e2c5afd50fa1ca",
      "closedAt": "2019-12-10T16:34:35Z",
      "mergedAt": "2019-12-10T16:34:35Z",
      "mergedBy": "raphaelrobert",
      "mergeCommit": {
        "oid": "c99d7c11318d78545a15973776b6bb1cf62833ea"
      },
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Yeah, I noticed that too as I was implementing. I will fix it in a\n\u201creconciliation with implementation\u201d PR I\u2019m working on.\n\nOn Tue, Dec 10, 2019 at 17:17 Brendan McMillion <notifications@github.com>\nwrote:\n\n> *@Bren2010* commented on this pull request.\n> ------------------------------\n>\n> In draft-ietf-mls-protocol.md\n> <https://github.com/mlswg/mls-protocol/pull/252#discussion_r356308100>:\n>\n> > @@ -1007,7 +1007,7 @@ of a `ParentNodeHashInput` struct:\n>  ~~~~~\n>  struct {\n>      HPKEPublicKey public_key;\n> -    uint32_t unmerged_leaves<0..2^32-1>;\n> +    opaque unmerged_leaves<0..2^32-1>;\n>\n> I don't think this is meant to be opaque. It's an array of leave indices\n>\n> \u2014\n> You are receiving this because you are subscribed to this thread.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/mlswg/mls-protocol/pull/252?email_source=notifications&email_token=AAASOTLZJ2TOMGNUCJASGPDQYAIONA5CNFSM4JO22YFKYY3PNVWWK3TUL52HS4DFWFIHK3DMKJSXC5LFON2FEZLWNFSXPKTDN5WW2ZLOORPWSZGOCOXDH2A#pullrequestreview-330183656>,\n> or unsubscribe\n> <https://github.com/notifications/unsubscribe-auth/AAASOTL43RIIDNHMYAWLOUDQYAIONANCNFSM4JO22YFA>\n> .\n>\n",
          "createdAt": "2019-12-11T01:02:45Z",
          "updatedAt": "2019-12-11T01:02:45Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzMwMTgzNjU2",
          "commit": {
            "abbreviatedOid": "f45e0d7"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-12-10T22:17:08Z",
          "updatedAt": "2019-12-10T22:17:09Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "I don't think this is meant to be opaque. It's an array of leave indices",
              "createdAt": "2019-12-10T22:17:09Z",
              "updatedAt": "2019-12-10T22:17:09Z"
            }
          ]
        }
      ]
    },
    {
      "number": 253,
      "id": "MDExOlB1bGxSZXF1ZXN0MzQyMzg3MDUw",
      "title": "Initial version of the Tree of Signature",
      "url": "https://github.com/mlswg/mls-protocol/pull/253",
      "state": "MERGED",
      "author": "beurdouche",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "security"
      ],
      "body": "",
      "createdAt": "2019-11-18T22:12:13Z",
      "updatedAt": "2020-01-06T07:39:31Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "a72f07db7bfbbc1294754149cc9354b01322f846",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "beurdouche_sigtree",
      "headRefOid": "9a1664a2f1575378df5860f3672c3463db39e3db",
      "closedAt": "2019-12-20T21:13:50Z",
      "mergedAt": "2019-12-20T21:13:50Z",
      "mergedBy": "raphaelrobert",
      "mergeCommit": {
        "oid": "6555b94c457b22c3bf623c0f6ee29e6e14a1ca3f"
      },
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "It seems like there's a major thing missing here, namely how the sender of a Commit transmits the new node signatures to the other members of the group.  We need something like that before this lands.\r\n\r\nThe most obvious approach would be to add a `signature` field to DirectPathNode, as you have with RatchetNode.",
          "createdAt": "2019-12-10T21:14:45Z",
          "updatedAt": "2019-12-10T21:14:45Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "It would also be handy to include in the intermediate node an indication of which leaf signed it.  Otherwise you have to do \"trial verifications\" (cf. trial decryption), which is expensive.",
          "createdAt": "2019-12-10T21:19:36Z",
          "updatedAt": "2019-12-10T21:19:36Z"
        },
        {
          "author": "kelrit",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> It seems like there's a major thing missing here, namely how the sender of a Commit transmits the new node signatures to the other members of the group. We need something like that before this lands.\r\n> \r\n> The most obvious approach would be to add a `signature` field to DirectPathNode, as you have with RatchetNode.\r\n\r\nWas this addressed? it's mentioned that the signature should be transmitted in \"Synchronizing Views of the Tree\" but there's no signature in the transmitted DirectPathNode",
          "createdAt": "2020-01-03T22:16:27Z",
          "updatedAt": "2020-01-03T22:16:27Z"
        },
        {
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "body": "@kelrit #287 changes the strategy for signing the tree, everything should be sorted out there.",
          "createdAt": "2020-01-06T07:39:31Z",
          "updatedAt": "2020-01-06T07:39:31Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzM1NDkwMDc1",
          "commit": {
            "abbreviatedOid": "a670098"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-12-20T19:55:20Z",
          "updatedAt": "2019-12-20T19:57:21Z",
          "comments": [
            {
              "originalPosition": 135,
              "body": "This is a good starting point, we should see if we need something fancier in the future, like a Merkle tree (or reuse the node hashes).",
              "createdAt": "2019-12-20T19:55:21Z",
              "updatedAt": "2019-12-20T20:51:26Z"
            },
            {
              "originalPosition": 92,
              "body": "Isn't this where we discussed that the signer's index is missing?",
              "createdAt": "2019-12-20T19:57:01Z",
              "updatedAt": "2019-12-20T20:51:26Z"
            }
          ]
        }
      ]
    },
    {
      "number": 254,
      "id": "MDExOlB1bGxSZXF1ZXN0MzQyMzkyNjM4",
      "title": "Initial work to use CIK in leaves and CIK rotation",
      "url": "https://github.com/mlswg/mls-protocol/pull/254",
      "state": "MERGED",
      "author": "beurdouche",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "security",
        "functionality"
      ],
      "body": "",
      "createdAt": "2019-11-18T22:27:04Z",
      "updatedAt": "2019-12-20T21:58:36Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "d1c8986d3ef932ae4a7cc05b4172d2762428fcd0",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "beurdouche_leafcik",
      "headRefOid": "02fefcc1fecfc0e834d2b4e4a4724a4763e97264",
      "closedAt": "2019-12-20T10:08:53Z",
      "mergedAt": "2019-12-20T10:08:53Z",
      "mergedBy": "raphaelrobert",
      "mergeCommit": {
        "oid": "a72f07db7bfbbc1294754149cc9354b01322f846"
      },
      "comments": [
        {
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "body": "I went back and watched the recording of the last interim to get some context for this PR, and the motivation given there isn't entirely clear to me. The reasoning given then was:\r\n- We want to allow rotation of identity key.\r\n- This helps authenticate the leaf key by signing it.\r\n\r\nBut if we want to allow rotating the identity key, what we need is an operation that changes the `credential` field of the leaf. Putting the entire CIK in the leaf doesn't help that. And I imagine that the leaf key would already be signed by the changes required for #253.",
          "createdAt": "2019-12-09T18:37:22Z",
          "updatedAt": "2019-12-09T18:37:22Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Note that this PR will need to change Commit as well -- the DirectPath in the commit sets the HPKEPublicKey in the sender's leaf node.  Suggested fix:\r\n\r\n1. Update DirectPath so that the first node in the path is the one above the leaf (not the leaf itself)\r\n2. Add a new ClientInitKey field to Commit that replaces the leaf\r\n\r\nThat's also forward-compatible with hash-based solutions to tree signing (cf. #253), since we can just define a ClientInitKey extension that contains the hash to be signed.",
          "createdAt": "2019-12-10T21:18:51Z",
          "updatedAt": "2019-12-10T21:18:51Z"
        },
        {
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "body": "To answer my own question, putting the entire CIK in the leaf (instead of just, say, a single signature) means the ratchet tree will contain information about node capabilities. This makes it possible for members being added to a group to detect downgrade attacks.",
          "createdAt": "2019-12-16T22:17:27Z",
          "updatedAt": "2019-12-16T22:17:27Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzMyOTE5MTg0",
          "commit": {
            "abbreviatedOid": "68a533c"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2019-12-16T22:47:38Z",
          "updatedAt": "2019-12-16T23:19:15Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "Would be better to stick with \"generating\"",
              "createdAt": "2019-12-16T22:47:39Z",
              "updatedAt": "2019-12-20T10:07:28Z"
            },
            {
              "originalPosition": 26,
              "body": "- we've never abbreviated this before, CIK -> ClientInitKey\r\n- lowercase, See -> see\r\n- remove \"the\" in front of \"path_secret[0]\"",
              "createdAt": "2019-12-16T23:03:43Z",
              "updatedAt": "2019-12-20T10:07:28Z"
            },
            {
              "originalPosition": 25,
              "body": "associated to -> associated with",
              "createdAt": "2019-12-16T23:05:48Z",
              "updatedAt": "2019-12-20T10:07:28Z"
            },
            {
              "originalPosition": 27,
              "body": "- remove \"value\"\r\n- generates -> generate",
              "createdAt": "2019-12-16T23:06:25Z",
              "updatedAt": "2019-12-20T10:07:28Z"
            },
            {
              "originalPosition": 28,
              "body": "\"intermediate nodes between the leaf and the root\" -> \"ancestor of its leaf\"",
              "createdAt": "2019-12-16T23:07:40Z",
              "updatedAt": "2019-12-20T10:07:28Z"
            },
            {
              "originalPosition": 230,
              "body": "I would leave this sentence how it was, \"Likewise, ...\"",
              "createdAt": "2019-12-16T23:18:39Z",
              "updatedAt": "2019-12-20T10:07:28Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzMzMDkxNTMx",
          "commit": {
            "abbreviatedOid": "68a533c"
          },
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-12-17T08:12:36Z",
          "updatedAt": "2019-12-17T08:12:37Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "Work in progress... There is an editorial discussion going on between the editors to see what we should keep in the PR. That's likely gonna be discussed at the interim.",
              "createdAt": "2019-12-17T08:12:36Z",
              "updatedAt": "2019-12-20T10:07:28Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzMzMDkxNjY0",
          "commit": {
            "abbreviatedOid": "68a533c"
          },
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-12-17T08:12:53Z",
          "updatedAt": "2019-12-17T08:12:53Z",
          "comments": [
            {
              "originalPosition": 26,
              "body": "Thanks !",
              "createdAt": "2019-12-17T08:12:53Z",
              "updatedAt": "2019-12-20T10:07:28Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzM1MTY5MDU5",
          "commit": {
            "abbreviatedOid": "02fefcc"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-12-20T10:08:38Z",
          "updatedAt": "2019-12-20T10:08:38Z",
          "comments": []
        }
      ]
    },
    {
      "number": 255,
      "id": "MDExOlB1bGxSZXF1ZXN0MzQyMzk1ODA5",
      "title": "Move epoch numbers to UInt64",
      "url": "https://github.com/mlswg/mls-protocol/pull/255",
      "state": "MERGED",
      "author": "beurdouche",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "enhancement"
      ],
      "body": "",
      "createdAt": "2019-11-18T22:35:40Z",
      "updatedAt": "2019-12-20T21:58:50Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "09110a985ad173c546c37707e90614ae54f7468a",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "beurdouche_epoch",
      "headRefOid": "898e8629646f6976186edffa471c21e564347a0e",
      "closedAt": "2019-12-10T15:56:01Z",
      "mergedAt": "2019-12-10T15:56:00Z",
      "mergedBy": "raphaelrobert",
      "mergeCommit": {
        "oid": "6fc93429ad31553ca34f657f457da54272a962b0"
      },
      "comments": [
        {
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "body": "#245 might invalidate this, but in the meantime we should go ahead with this!",
          "createdAt": "2019-11-28T14:07:33Z",
          "updatedAt": "2019-11-28T14:07:33Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzI0MzA5MDc3",
          "commit": {
            "abbreviatedOid": "898e862"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-11-28T14:08:13Z",
          "updatedAt": "2019-11-28T14:08:13Z",
          "comments": []
        }
      ]
    },
    {
      "number": 256,
      "id": "MDExOlB1bGxSZXF1ZXN0MzQyMzk3MjE5",
      "title": "Remove OPEN ISSUE: the entire group context is now in the signature",
      "url": "https://github.com/mlswg/mls-protocol/pull/256",
      "state": "MERGED",
      "author": "beurdouche",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "",
      "createdAt": "2019-11-18T22:39:57Z",
      "updatedAt": "2019-12-20T21:58:49Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "09110a985ad173c546c37707e90614ae54f7468a",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "beurdouche_rem_openissue",
      "headRefOid": "ca67895547bb4e9615fc51045e38a058949bd0ad",
      "closedAt": "2019-12-10T15:54:41Z",
      "mergedAt": "2019-12-10T15:54:41Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "c6bbdcd315d2201fb85681a3dc12d3d201135acf"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzI5OTQzNjA5",
          "commit": {
            "abbreviatedOid": "ca67895"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-12-10T15:54:32Z",
          "updatedAt": "2019-12-10T15:54:32Z",
          "comments": []
        }
      ]
    },
    {
      "number": 257,
      "id": "MDExOlB1bGxSZXF1ZXN0MzQyNDA5NzI3",
      "title": "Make clear that Commits are responsible for FS and PCS",
      "url": "https://github.com/mlswg/mls-protocol/pull/257",
      "state": "MERGED",
      "author": "beurdouche",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "",
      "createdAt": "2019-11-18T23:19:50Z",
      "updatedAt": "2019-12-20T21:58:47Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "09110a985ad173c546c37707e90614ae54f7468a",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "beurdouche_us_to_cs",
      "headRefOid": "6d6074ee4504ad7452353704479cd499035dd964",
      "closedAt": "2019-12-10T15:54:05Z",
      "mergedAt": "2019-12-10T15:54:05Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "5140d9417f022f9313ac4ae4eb7355f18a12d517"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzI5OTQzMTM4",
          "commit": {
            "abbreviatedOid": "6d6074e"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-12-10T15:53:58Z",
          "updatedAt": "2019-12-10T15:53:58Z",
          "comments": []
        }
      ]
    },
    {
      "number": 259,
      "id": "MDExOlB1bGxSZXF1ZXN0MzQzODYwNDM0",
      "title": "Remove blanking of nodes on Add, clarify language",
      "url": "https://github.com/mlswg/mls-protocol/pull/259",
      "state": "MERGED",
      "author": "kelrit",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "- Blanking on add (I think) was obsoleted by unmerged leaves\r\n- Add leaf to unmerged list for *non-blank* nodes on add\r\n- There are now four elements in each node",
      "createdAt": "2019-11-21T06:08:10Z",
      "updatedAt": "2019-12-17T08:36:57Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "09110a985ad173c546c37707e90614ae54f7468a",
      "headRepository": "kelrit/mls-protocol",
      "headRefName": "master",
      "headRefOid": "f9d003b76c69b80c429396ef90db54c847968300",
      "closedAt": "2019-11-21T08:55:01Z",
      "mergedAt": "2019-11-21T08:55:01Z",
      "mergedBy": "beurdouche",
      "mergeCommit": {
        "oid": "bff920cf70b0de0ae5e2a71ae85ddf66615fe443"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzIwNzIwODc5",
          "commit": {
            "abbreviatedOid": "f9d003b"
          },
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "Nice catch, Thank you !",
          "createdAt": "2019-11-21T08:54:54Z",
          "updatedAt": "2019-11-21T08:54:54Z",
          "comments": []
        }
      ]
    },
    {
      "number": 263,
      "id": "MDExOlB1bGxSZXF1ZXN0MzUxMTU2OTIx",
      "title": "Change special values to structed types for external senders",
      "url": "https://github.com/mlswg/mls-protocol/pull/263",
      "state": "MERGED",
      "author": "kelrit",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "discussion"
      ],
      "body": "Action item from Singapore: it seems better to specify directly in the message if we have an external sender instead of using reserved ranges.",
      "createdAt": "2019-12-10T01:40:21Z",
      "updatedAt": "2020-01-03T15:20:10Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "9426b880dace5a105405196b347e7e493f3677ac",
      "headRepository": "kelrit/mls-protocol",
      "headRefName": "master",
      "headRefOid": "d8bbe3d4e0692669d58a132ddab5d3d33d3d081b",
      "closedAt": "2020-01-03T15:20:09Z",
      "mergedAt": "2020-01-03T15:20:09Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "02bf13ebad9a8efd675f6c30c3261dcf6191f179"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzMwMTQxMzg3",
          "commit": {
            "abbreviatedOid": "de1672b"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "@kelrit - Overall I think this is on the right track.  A few comments that should be easy to address.",
          "createdAt": "2019-12-10T21:00:54Z",
          "updatedAt": "2019-12-10T21:10:12Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "I'm not sure \"authority\" is quite the semantic here.  Maybe just \"external\" or \"preconfigured\"?",
              "createdAt": "2019-12-10T21:00:54Z",
              "updatedAt": "2020-01-03T01:49:57Z"
            },
            {
              "originalPosition": 17,
              "body": "I think something like `new_member` might be clearer here.",
              "createdAt": "2019-12-10T21:01:46Z",
              "updatedAt": "2020-01-03T01:49:57Z"
            },
            {
              "originalPosition": 30,
              "body": "There's no need to use the full `Sender` struct here, since you have to be a member to send an `MLSCiphertext`; just use uint32.  In other words, encrypting an MLSPlaintext with `Sender.sender_type != member` is an error, and an MLSPlaintext decrypted from an MLSCiphertext always has `Sender.sender_type != member`.",
              "createdAt": "2019-12-10T21:06:14Z",
              "updatedAt": "2020-01-03T01:49:57Z"
            },
            {
              "originalPosition": 30,
              "body": "As a bonus, this makes it syntactically impossible for an external sender to send an MLSCiphertext.",
              "createdAt": "2019-12-10T21:06:47Z",
              "updatedAt": "2020-01-03T01:49:57Z"
            },
            {
              "originalPosition": 54,
              "body": "Don't need the tag; it's auto-generated from the title itself.",
              "createdAt": "2019-12-10T21:07:18Z",
              "updatedAt": "2020-01-03T01:49:57Z"
            },
            {
              "originalPosition": 76,
              "body": "Rather than ignoring, I would suggest that it MUST be zero.",
              "createdAt": "2019-12-10T21:07:56Z",
              "updatedAt": "2020-01-03T01:49:57Z"
            },
            {
              "originalPosition": 72,
              "body": "Note that `external` is not defined above, but probably should be :)\r\n\r\nAlso, this should be \"`external` or `new_member`\" (or whatever words we decide on).",
              "createdAt": "2019-12-10T21:08:56Z",
              "updatedAt": "2020-01-03T01:49:57Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzMwMjc2NTUx",
          "commit": {
            "abbreviatedOid": "de1672b"
          },
          "author": "kelrit",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-12-11T03:11:35Z",
          "updatedAt": "2019-12-11T03:11:36Z",
          "comments": [
            {
              "originalPosition": 30,
              "body": "iiuc - the proposal is to treat all MLSPlaintexts as `member` sender types? That would mean external senders would need some other mechanism for sender? How can we differentiate between self add and a preconfigured sender?\r\n\r\nI'm confused by this comment - were you thinking this was in MLSSenderData?",
              "createdAt": "2019-12-11T03:11:35Z",
              "updatedAt": "2020-01-03T01:49:57Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzM3ODYwMjcz",
          "commit": {
            "abbreviatedOid": "3efbcb1"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-01-02T21:10:48Z",
          "updatedAt": "2020-01-02T21:13:56Z",
          "comments": [
            {
              "originalPosition": 30,
              "body": "There's a difference between MLSPlaintext and MLSCiphertext here.  An MLSPlaintext can be constructed and sent by anyone; all you need is a signing key that is known to the group.  In order to construct an MLSCiphertext, you have to be a member of the group, since otherwise you won't have the right symmetric keys.  In other words, external senders can only send *unencrypted* messages to the group right now.  (I think Raphael is working on a PR to enable encryption to the group from outside.)",
              "createdAt": "2020-01-02T21:10:48Z",
              "updatedAt": "2020-01-03T01:49:57Z"
            },
            {
              "originalPosition": 45,
              "body": "In light of the above discussion, I would suggest adding a step to the encryption where the sender verifies that the `MLSPlaintext.sender.type == member`, then copies `MLSPlaintext.sender.sender` to `MLSCiphertext.sender`. ",
              "createdAt": "2020-01-02T21:12:50Z",
              "updatedAt": "2020-01-03T01:49:57Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzM3OTI4Mzg0",
          "commit": {
            "abbreviatedOid": "3efbcb1"
          },
          "author": "kelrit",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-01-03T01:48:16Z",
          "updatedAt": "2020-01-03T01:48:17Z",
          "comments": [
            {
              "originalPosition": 30,
              "body": "Yea - I think we are on the same page. MLSPlaintext can be sent by anyone (in or outside the group) so it needs a full Sender object to disambiguate. However MLSCiphertext needs only the sender index, which is done by keeping MLSSenderData as is.",
              "createdAt": "2020-01-03T01:48:16Z",
              "updatedAt": "2020-01-03T01:49:57Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzM3OTI4NzI1",
          "commit": {
            "abbreviatedOid": "d8bbe3d"
          },
          "author": "kelrit",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-01-03T01:51:12Z",
          "updatedAt": "2020-01-03T01:51:12Z",
          "comments": [
            {
              "originalPosition": 45,
              "body": "It wasn't quite clear where that'd go; I re-organized the steps to be a little more clear and put in a check when constructing MLSSenderData objects (which is the only place in MLSCiphertext where the sender is identified)",
              "createdAt": "2020-01-03T01:51:12Z",
              "updatedAt": "2020-01-03T01:51:33Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzM3OTQ3MzQw",
          "commit": {
            "abbreviatedOid": "d8bbe3d"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-01-03T04:38:06Z",
          "updatedAt": "2020-01-03T04:38:11Z",
          "comments": [
            {
              "originalPosition": 30,
              "body": "Oh I see.  I was mistaken about what line we were looking at.  LGTM.",
              "createdAt": "2020-01-03T04:38:06Z",
              "updatedAt": "2020-01-03T04:38:11Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzM3OTQ3Mzcz",
          "commit": {
            "abbreviatedOid": "d8bbe3d"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-01-03T04:38:23Z",
          "updatedAt": "2020-01-03T04:38:23Z",
          "comments": []
        }
      ]
    },
    {
      "number": 265,
      "id": "MDExOlB1bGxSZXF1ZXN0MzUxOTY2OTM1",
      "title": "Align spec text with implementation",
      "url": "https://github.com/mlswg/mls-protocol/pull/265",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "bug",
        "? follow-up"
      ],
      "body": "I have managed to implement Proposal / Commit in mlspp, but it required some modifications to the Welcome and Commit structs and processes.  Two major things to point out:\r\n\r\n* This PR proposes to send the same DirectPath to both new members and current members.  This avoids the need to have two code paths and special tree math to implant path secrets, at the cost of some bloat in the Welcome and Commit messages.\r\n\r\n* As a result, the sequencing of GroupContexts is a bit tricky.  The GroupContext used for encrypting/decrypting DirectPaths is an intermediate context -- the new group context, but *before the transcript is updated*.  \r\n\r\nAll that said, this version is [verified implementable](https://github.com/cisco/mlspp/pull/64).  The implementation exercise highlighted that the net effect of Proposal/Commit was to isolate basically all of the state management complexity to three methods in the client stack:\r\n\r\n* Processing of Welcome messages\r\n* Generation of Commit+Welcome messages\r\n* Processing of Commit messages\r\n\r\nThis PR reflects the algorithms for those three things.",
      "createdAt": "2019-12-11T15:16:43Z",
      "updatedAt": "2019-12-22T11:55:47Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "6555b94c457b22c3bf623c0f6ee29e6e14a1ca3f",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "impl",
      "headRefOid": "ac784c5acfc4415a5a42145f5a8fd7281ec02d65",
      "closedAt": "2019-12-22T11:46:01Z",
      "mergedAt": "2019-12-22T11:46:01Z",
      "mergedBy": "beurdouche",
      "mergeCommit": {
        "oid": "9426b880dace5a105405196b347e7e493f3677ac"
      },
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "@beurdouche I added one minor change (order of fields) and rebased.  I think this is ready to merge.  I'm also about to drop offline for a bit, so please pull the trigger if it looks good to you.",
          "createdAt": "2019-12-21T20:15:47Z",
          "updatedAt": "2019-12-21T20:16:10Z"
        },
        {
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "body": "Ack, I\u2019ll take a look in tonight or tomorrow morning and merge it.",
          "createdAt": "2019-12-21T20:26:00Z",
          "updatedAt": "2019-12-22T11:55:47Z"
        },
        {
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "body": "I am merging this now because it includes fixes we definitely need even though I note that I have one philosophical concern and one security concern...\r\n\r\n1. Multiplying the numbers of transcript hashes in the state is an implementation concern and not a protocol concern, I would much prefer keep only the real (confirmed) transcript hash. (The implementation should keep the current state and one provisional updated state but the struct shouldn't have to keep both)\r\n2. Sending the init_secret and the update_secret at once *seem* equivalent to sending the epoch secret but I don't think it is actually the case since it could be rejected by the DS, breaking the encryption key of that message would hence still have consequences even if the message is rejected. I'll open an issue for that.",
          "createdAt": "2019-12-22T11:45:54Z",
          "updatedAt": "2019-12-22T11:45:54Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzMxMjc0MDI4",
          "commit": {
            "abbreviatedOid": "d589270"
          },
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "Ok, this looks good to me. I think we don't have to derive that many keys in the main KS but that's ok for now, we can optimize later.",
          "createdAt": "2019-12-12T14:36:45Z",
          "updatedAt": "2019-12-12T15:20:01Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "I actually forgot about the fact we had typed vectors in the syntax, sorry about that... : )",
              "createdAt": "2019-12-12T14:36:46Z",
              "updatedAt": "2019-12-21T20:14:02Z"
            },
            {
              "originalPosition": 77,
              "body": "I guess we don't have to generate a Welcome message if there is no `add` proposals in the Commit.\r\nShould we clarify that here ?",
              "createdAt": "2019-12-12T14:41:11Z",
              "updatedAt": "2019-12-21T20:14:02Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzMyODk5OTkw",
          "commit": {
            "abbreviatedOid": "d589270"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2019-12-16T22:08:00Z",
          "updatedAt": "2019-12-16T22:45:25Z",
          "comments": [
            {
              "originalPosition": 53,
              "body": "`Proposal proposal` (singular)",
              "createdAt": "2019-12-16T22:08:00Z",
              "updatedAt": "2019-12-21T20:14:02Z"
            },
            {
              "originalPosition": 68,
              "body": "Update line 1849 to reflect this change",
              "createdAt": "2019-12-16T22:39:16Z",
              "updatedAt": "2019-12-21T20:14:02Z"
            },
            {
              "originalPosition": 91,
              "body": "Nit: one space between sentences",
              "createdAt": "2019-12-16T22:42:16Z",
              "updatedAt": "2019-12-21T20:14:02Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzMzNDc5NTgz",
          "commit": {
            "abbreviatedOid": "d589270"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-12-17T18:15:59Z",
          "updatedAt": "2019-12-17T18:15:59Z",
          "comments": [
            {
              "originalPosition": 53,
              "body": "Please also update MLSPlaintextSignatureInput",
              "createdAt": "2019-12-17T18:15:59Z",
              "updatedAt": "2019-12-21T20:14:02Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzMzNDgwMTA5",
          "commit": {
            "abbreviatedOid": "d589270"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-12-17T18:16:50Z",
          "updatedAt": "2019-12-17T18:16:50Z",
          "comments": [
            {
              "originalPosition": 53,
              "body": "Please also change to the singular in MLSPlaintext",
              "createdAt": "2019-12-17T18:16:50Z",
              "updatedAt": "2019-12-21T20:14:02Z"
            }
          ]
        }
      ]
    },
    {
      "number": 274,
      "id": "MDExOlB1bGxSZXF1ZXN0MzU1ODA0ODQ5",
      "title": "Fix contexts and simplify key schedule",
      "url": "https://github.com/mlswg/mls-protocol/pull/274",
      "state": "CLOSED",
      "author": "beurdouche",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "enhancement",
        "security",
        "work in progress",
        "? follow-up"
      ],
      "body": "This is a fix for #264 as well as for missing context that was previously partially added in the messages but not in the Tree intermediate derivations.\r\n\r\nThe changes are centered around putting back the `transcript_hash` (aka the full history) to be what should be included as default context.",
      "createdAt": "2019-12-20T16:31:13Z",
      "updatedAt": "2020-03-04T18:20:44Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "a72f07db7bfbbc1294754149cc9354b01322f846",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "beurdouche_txh",
      "headRefOid": "072d87ecc57d5c7ee28f13e6aede6d00889c5927",
      "closedAt": "2020-03-04T18:20:43Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "body": "@bifurcation Yes, this is still a \"Work in Progress\" and is labeled as such... :) \r\nIt will probably not be updated it before RWC... I'll ping when it is in a reasonable state.",
          "createdAt": "2019-12-28T16:07:55Z",
          "updatedAt": "2019-12-28T16:07:55Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing for now.  Happy to reconsider on refresh/rebase.",
          "createdAt": "2020-03-04T18:20:43Z",
          "updatedAt": "2020-03-04T18:20:43Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzM2OTE5MTUy",
          "commit": {
            "abbreviatedOid": "072d87e"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2019-12-28T15:09:18Z",
          "updatedAt": "2019-12-28T15:17:35Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "I would prefer to spell this out, if we have horizontal space",
              "createdAt": "2019-12-28T15:09:19Z",
              "updatedAt": "2019-12-28T15:17:35Z"
            },
            {
              "originalPosition": 54,
              "body": "I don't understand your proposal here.  The transcript hash you define has an odd structure -- it only covers the CommitContent, not the AuthData.  So the confirmation hashes and signatures are not covered.  It's as if the TLS transcript hash didn't include CertificateVerify or Finished.  Is that your intent?",
              "createdAt": "2019-12-28T15:12:58Z",
              "updatedAt": "2019-12-28T15:17:35Z"
            },
            {
              "originalPosition": 54,
              "body": "In any case, if you're going to remove the interim transcript hash, you need to do more radical surgery.   For example, MLSPlaintextCommitAuthData is no longer needed; likewise much of the prose below.",
              "createdAt": "2019-12-28T15:13:56Z",
              "updatedAt": "2019-12-28T15:17:35Z"
            },
            {
              "originalPosition": 16,
              "body": "Here and below, I would prefer if we expanded this.",
              "createdAt": "2019-12-28T15:15:15Z",
              "updatedAt": "2019-12-28T15:17:35Z"
            },
            {
              "originalPosition": 140,
              "body": "Nit: Extra blank line.",
              "createdAt": "2019-12-28T15:15:52Z",
              "updatedAt": "2019-12-28T15:17:35Z"
            }
          ]
        }
      ]
    },
    {
      "number": 275,
      "id": "MDExOlB1bGxSZXF1ZXN0MzU1ODExMDkx",
      "title": "Mandate expiration of ClientInitKeys and presence of some extensions",
      "url": "https://github.com/mlswg/mls-protocol/pull/275",
      "state": "MERGED",
      "author": "beurdouche",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "enhancement",
        "security",
        "ready to merge"
      ],
      "body": "",
      "createdAt": "2019-12-20T16:48:44Z",
      "updatedAt": "2020-03-05T23:05:19Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "a72f07db7bfbbc1294754149cc9354b01322f846",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "beurdouche_expiration",
      "headRefOid": "35d2aa847080c2f24e44dd4fee0965495430276f",
      "closedAt": "2020-03-05T23:05:18Z",
      "mergedAt": "2020-03-05T23:05:18Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "3dc9603bfdc4ac4ef56391927988cb32654dd9cd"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzM3ODU4MTUz",
          "commit": {
            "abbreviatedOid": "026f92f"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2020-01-02T21:05:26Z",
          "updatedAt": "2020-01-02T21:06:43Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "There are two extensions here.  So if you mean both of them, you should say so.",
              "createdAt": "2020-01-02T21:05:26Z",
              "updatedAt": "2020-03-05T23:03:40Z"
            },
            {
              "originalPosition": 24,
              "body": "The need for this is not clear to me.  Let's discuss this at the interim before merging this PR.",
              "createdAt": "2020-01-02T21:06:28Z",
              "updatedAt": "2020-03-05T23:03:40Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY5MDA5NTg3",
          "commit": {
            "abbreviatedOid": "a1daf63"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-04T18:16:06Z",
          "updatedAt": "2020-03-04T18:16:07Z",
          "comments": [
            {
              "originalPosition": 24,
              "body": "This was discussed at the interim, and people were comfortable with this requirement.",
              "createdAt": "2020-03-04T18:16:06Z",
              "updatedAt": "2020-03-05T23:03:40Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY5MDA5NjE4",
          "commit": {
            "abbreviatedOid": "a1daf63"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-03-04T18:16:09Z",
          "updatedAt": "2020-03-04T18:16:09Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY5MDUzMDIz",
          "commit": {
            "abbreviatedOid": "a1daf63"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2020-03-04T19:19:20Z",
          "updatedAt": "2020-03-04T19:34:52Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "```suggestion\r\nThese extensions MUST be always present in a ClientInitKey.\r\n```",
              "createdAt": "2020-03-04T19:19:20Z",
              "updatedAt": "2020-03-05T23:03:40Z"
            },
            {
              "originalPosition": 24,
              "body": "```suggestion\r\nThis extension MUST always be present in a ClientInitKey.\r\n```",
              "createdAt": "2020-03-04T19:20:44Z",
              "updatedAt": "2020-03-05T23:03:40Z"
            },
            {
              "originalPosition": 22,
              "body": "The expiration of ClientInitKeys is important for PCS, so setting to the maximum value shouldn't be encouraged. If you have keys that never expire and you're compromised, those keys can be used at any time in the future to \"add\" you to a group when they're actually giving the adversary access.\r\n\r\nLast Resort keys are a defense against DoS, when somebody sends you a lot of messages in a short period of time. As such, any ClientInitKey can be a Last Resort key, regardless of how long it's valid for, because nobody is checking how many times a specific key gets used.\r\n\r\nLast Resort keys are not a suitable defense against the user being offline for an arbitrary amount of time. Handling this securely probably requires more consideration.\r\n\r\nWe should recommend an application-specified maximum duration, and switch to a `(notBefore, notAfter)` system so that everyone know's the key's lifetime.",
              "createdAt": "2020-03-04T19:34:46Z",
              "updatedAt": "2020-03-05T23:03:40Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY5OTc2ODAy",
          "commit": {
            "abbreviatedOid": "35d2aa8"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-05T23:05:11Z",
          "updatedAt": "2020-03-05T23:05:12Z",
          "comments": [
            {
              "originalPosition": 22,
              "body": "This would take things in a bit of a different direction, and needs more discussion.  I'm going to go ahead and merge this now, but feel free to file an issue.",
              "createdAt": "2020-03-05T23:05:11Z",
              "updatedAt": "2020-03-05T23:05:12Z"
            }
          ]
        }
      ]
    },
    {
      "number": 278,
      "id": "MDExOlB1bGxSZXF1ZXN0MzU3Mzg4MjQx",
      "title": "Review of sections 1-6.",
      "url": "https://github.com/mlswg/mls-protocol/pull/278",
      "state": "CLOSED",
      "author": "Bren2010",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "editorial",
        "ready for review (by editors)"
      ],
      "body": "- Rewrite some outdated sections related to proposals\r\n- Prefer \"forward secrecy\" and \"post-compromise security\" over variants\r\n- Prefer \"AES-GCM-128\" over variants\r\n- Prefer not to use \"i.e.\" and \"e.g.\"",
      "createdAt": "2019-12-28T04:28:26Z",
      "updatedAt": "2020-01-15T11:53:10Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "02bf13ebad9a8efd675f6c30c3261dcf6191f179",
      "headRepository": "Bren2010/mls-protocol",
      "headRefName": "brendan/2019.12.0",
      "headRefOid": "3c21673317fd2fad85a0201ad5002385ebbb57c4",
      "closedAt": "2020-01-15T11:53:10Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "body": "@raphaelrobert @beurdouche Any objections to this being merged?",
          "createdAt": "2020-01-13T18:10:27Z",
          "updatedAt": "2020-01-13T18:10:27Z"
        },
        {
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "body": "I think it's generally fine, but I'll let @beurdouche have the final say in this",
          "createdAt": "2020-01-14T17:13:13Z",
          "updatedAt": "2020-01-14T17:13:13Z"
        },
        {
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "body": "Yes, it is globally fine, I will merge that soon enough as part of an editorial pass I will do.\n\n> On Jan 14, 2020, at 6:13 PM, raphaelrobert <notifications@github.com> wrote:\n> \n> \ufeff\n> I think it's generally fine, but I'll let @beurdouche have the final say in this\n> \n> \u2014\n> You are receiving this because you were mentioned.\n> Reply to this email directly, view it on GitHub, or unsubscribe.\n",
          "createdAt": "2020-01-14T17:57:41Z",
          "updatedAt": "2020-01-14T17:57:41Z"
        },
        {
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "body": "I would like this merged sooner rather than later please",
          "createdAt": "2020-01-14T20:59:00Z",
          "updatedAt": "2020-01-14T20:59:00Z"
        },
        {
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "body": "Ack\n\n> On Jan 14, 2020, at 9:59 PM, Brendan McMillion <notifications@github.com> wrote:\n> \n> \ufeff\n> I would like this merged sooner rather than later please\n> \n> \u2014\n> You are receiving this because you were mentioned.\n> Reply to this email directly, view it on GitHub, or unsubscribe.\n",
          "createdAt": "2020-01-14T21:05:01Z",
          "updatedAt": "2020-01-14T21:05:01Z"
        },
        {
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "body": "Merged+Editorial in #292 \r\nChanges in 5b2651d60babab8fd43d53d421e9db89e742d083",
          "createdAt": "2020-01-15T11:53:10Z",
          "updatedAt": "2020-01-15T11:53:10Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzM2OTAwNzI5",
          "commit": {
            "abbreviatedOid": "3801af9"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-12-28T04:29:14Z",
          "updatedAt": "2019-12-28T04:29:15Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": ".editorconfig files are not a very common thing, but I'm curious if others think it would be helpful",
              "createdAt": "2019-12-28T04:29:14Z",
              "updatedAt": "2020-01-06T01:14:49Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzM2OTExNzkx",
          "commit": {
            "abbreviatedOid": "3801af9"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-12-28T11:10:36Z",
          "updatedAt": "2019-12-28T11:10:36Z",
          "comments": [
            {
              "originalPosition": 270,
              "body": "FYI, this section is currently being rewritten in #279.",
              "createdAt": "2019-12-28T11:10:36Z",
              "updatedAt": "2020-01-06T01:14:49Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzM3MTE3MjY0",
          "commit": {
            "abbreviatedOid": "0d0937e"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "Two minor things, otherwise LGTM",
          "createdAt": "2019-12-30T14:12:07Z",
          "updatedAt": "2020-01-02T20:57:46Z",
          "comments": [
            {
              "originalPosition": 21,
              "body": "I don't agree with this.  The leaf key (pair) is the asymmetric key pair at the leaf, not the secret, and I like the explanation.  How about:\r\n\r\n> An HPKE key pair that can be used to encrypt to a specific client, so called because members' leaf keys are the leaves in the group's ratchet tree.",
              "createdAt": "2019-12-30T14:12:07Z",
              "updatedAt": "2020-01-06T01:14:49Z"
            },
            {
              "originalPosition": 46,
              "body": "Thanks, this description is better.  It seems like this is missing a step, though: the new members initialize from a `Welcome` message corresponding to the Commit.",
              "createdAt": "2019-12-30T14:13:58Z",
              "updatedAt": "2020-01-06T01:14:49Z"
            },
            {
              "originalPosition": 7,
              "body": "I don't have an opinion here.  @beurdouche @raphaelrobert ?",
              "createdAt": "2020-01-02T20:56:34Z",
              "updatedAt": "2020-01-06T01:14:49Z"
            }
          ]
        }
      ]
    },
    {
      "number": 279,
      "id": "MDExOlB1bGxSZXF1ZXN0MzU3NDQwOTky",
      "title": "Bring back more ciphersuites",
      "url": "https://github.com/mlswg/mls-protocol/pull/279",
      "state": "MERGED",
      "author": "raphaelrobert",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "enhancement",
        "ready to merge"
      ],
      "body": "",
      "createdAt": "2019-12-28T11:06:55Z",
      "updatedAt": "2020-03-25T00:07:59Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "9426b880dace5a105405196b347e7e493f3677ac",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "raphael_ciphersuites",
      "headRefOid": "0606ce7c64730b54d569aef11c137142942a0927",
      "closedAt": "2020-03-05T22:57:09Z",
      "mergedAt": "2020-03-05T22:57:09Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "74380c5a193277e696d39a0d7554fd9243cd3d9b"
      },
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "It seems like we have a few separable issues here:\r\n1. Whether we require a single signature scheme for the whole group\r\n2. Whether signature schemes are included in the ciphersuite\r\n3. Whether we have an MTI ciphersuite / signature algorithm\r\n4. What new ciphersuites should be defined, and what algorithms should go in them\r\n\r\nLet's discuss this at the interim and maybe break this PR into a few bits",
          "createdAt": "2020-01-03T16:00:47Z",
          "updatedAt": "2020-01-03T16:00:47Z"
        },
        {
          "author": "seanturner",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Note that specification required registries imply that there is a designated expert pool. I will add some text to create one. The text is very similar to the TLS DE pool text from [RFC8447](https://datatracker.ietf.org/doc/rfc8447/) with some tweaks that, hopefully, address the misunderstandings uncovered during non-standards track registry requests.\r\n\r\nNote the process is: (assuming that the IESG eventually approves this draft) When the IESG approves this draft, the responsible AD assigns some DEs (like 2-3 suggested by the WG chairs). These DEs are in charge of all registrations regardless of whether the draft comes from the WG or elsewhere as all requests go to the MLS DEs mailing list.",
          "createdAt": "2020-02-13T02:37:17Z",
          "updatedAt": "2020-02-13T02:37:17Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzM2OTIxNTU1",
          "commit": {
            "abbreviatedOid": "7ac6156"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "The file no longer compiles, not sure why",
          "createdAt": "2019-12-28T16:20:10Z",
          "updatedAt": "2019-12-28T16:28:13Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "Now the CipherSuite type is never defined",
              "createdAt": "2019-12-28T16:20:11Z",
              "updatedAt": "2020-03-05T22:56:24Z"
            },
            {
              "originalPosition": 112,
              "body": "Please update line 810 to say that ciphersuites are defined by: KEM, AEAD, HASH, SIG.",
              "createdAt": "2019-12-28T16:22:58Z",
              "updatedAt": "2020-03-05T22:56:24Z"
            },
            {
              "originalPosition": 131,
              "body": "Shouldn't the mandatory suite be P-256? X25519 has never been mandatory",
              "createdAt": "2019-12-28T16:25:36Z",
              "updatedAt": "2020-03-05T22:56:24Z"
            },
            {
              "originalPosition": 27,
              "body": "I would make this section at the same level as \"Ciphersuites\" (so \"## Diffie-Hellman Groups\") and add explainer text that DH groups are used to build KEMs with HPKE",
              "createdAt": "2019-12-28T16:25:45Z",
              "updatedAt": "2020-03-05T22:56:24Z"
            },
            {
              "originalPosition": 84,
              "body": "A ciphersuite is a combination of a protocol version and the set of cryptographic algorithms that should be used.",
              "createdAt": "2019-12-28T16:27:35Z",
              "updatedAt": "2020-03-05T22:56:24Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzM2OTIyMjI4",
          "commit": {
            "abbreviatedOid": "7ac6156"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-12-28T16:40:06Z",
          "updatedAt": "2019-12-28T16:40:06Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "It is defined in section \"MLS Ciphersuites\" as a two byte value now.",
              "createdAt": "2019-12-28T16:40:06Z",
              "updatedAt": "2020-03-05T22:56:24Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzM2OTIyMzIw",
          "commit": {
            "abbreviatedOid": "7ac6156"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-12-28T16:43:31Z",
          "updatedAt": "2019-12-28T16:43:32Z",
          "comments": [
            {
              "originalPosition": 112,
              "body": "The missing part would be the signature, but the context here is \"primitives to be used in group key computations\".\r\nI guess we could reference HPKE here.",
              "createdAt": "2019-12-28T16:43:32Z",
              "updatedAt": "2020-03-05T22:56:24Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzM2OTIyMzcw",
          "commit": {
            "abbreviatedOid": "7ac6156"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-12-28T16:45:02Z",
          "updatedAt": "2019-12-28T16:45:03Z",
          "comments": [
            {
              "originalPosition": 131,
              "body": "> Shouldn't the mandatory suite be P-256?\r\n\r\nWhy?\r\n\r\n> X25519 has never been mandatory\r\n\r\nIt has always been so far",
              "createdAt": "2019-12-28T16:45:02Z",
              "updatedAt": "2020-03-05T22:56:24Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzM2OTIyNDQx",
          "commit": {
            "abbreviatedOid": "7ac6156"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-12-28T16:47:51Z",
          "updatedAt": "2019-12-28T16:47:52Z",
          "comments": [
            {
              "originalPosition": 84,
              "body": "Thanks, will address this in another commit.",
              "createdAt": "2019-12-28T16:47:51Z",
              "updatedAt": "2020-03-05T22:56:24Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzM2OTIyNTc3",
          "commit": {
            "abbreviatedOid": "7ac6156"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-12-28T16:52:00Z",
          "updatedAt": "2019-12-28T16:52:00Z",
          "comments": [
            {
              "originalPosition": 27,
              "body": "I'll add the explainer, but I think it makes sense to keep it at this level, since it is about ciphersuites after all.",
              "createdAt": "2019-12-28T16:52:00Z",
              "updatedAt": "2020-03-05T22:56:24Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzM2OTIyNjk2",
          "commit": {
            "abbreviatedOid": "5f69d5f"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-12-28T16:55:59Z",
          "updatedAt": "2019-12-28T16:55:59Z",
          "comments": [
            {
              "originalPosition": 27,
              "body": "(added)",
              "createdAt": "2019-12-28T16:55:59Z",
              "updatedAt": "2020-03-05T22:56:24Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzM3NDYwODA0",
          "commit": {
            "abbreviatedOid": "7ac6156"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2019-12-31T22:54:22Z",
          "updatedAt": "2019-12-31T23:14:26Z",
          "comments": [
            {
              "originalPosition": 112,
              "body": "Signature algorithms are not part of the ciphersuite, they're specified in the credentials.",
              "createdAt": "2019-12-31T22:54:23Z",
              "updatedAt": "2020-03-05T22:56:24Z"
            },
            {
              "originalPosition": 107,
              "body": "I would drop the versions; ciphers should be able to be used across versions.",
              "createdAt": "2019-12-31T22:55:04Z",
              "updatedAt": "2020-03-05T22:56:24Z"
            },
            {
              "originalPosition": 108,
              "body": "This doesn't seem all that useful, I would drop it.",
              "createdAt": "2019-12-31T22:56:02Z",
              "updatedAt": "2020-03-05T22:56:24Z"
            },
            {
              "originalPosition": 118,
              "body": "Instead of \"HPKE\", these should say \"DHKEM\".  Or we could just say that when a curve group is listed here, it indicates that DHKEM is in use.  I would prefer the latter, since it's more succinct.  Together with the above, that would get you back to something of similar size to what we have now, e.g., `MLS_X25519_AES128GCM_SHA256`",
              "createdAt": "2019-12-31T22:59:04Z",
              "updatedAt": "2020-03-05T22:56:24Z"
            },
            {
              "originalPosition": 130,
              "body": "Adding an MTI should be a separate PR.",
              "createdAt": "2019-12-31T22:59:27Z",
              "updatedAt": "2020-03-05T22:56:24Z"
            },
            {
              "originalPosition": 23,
              "body": "I think you need a bit more description here, just to say what a ciphersuite indicates, namely:\r\n\r\n* Parameters for an instance of HPKE\r\n* A KDF to be used \r\n* As a consequence, a Derive-Key-Pair function, as defined below.",
              "createdAt": "2019-12-31T23:07:20Z",
              "updatedAt": "2020-03-05T22:56:24Z"
            },
            {
              "originalPosition": 23,
              "body": "Also, does `{{MLS Ciphersuites}}` actually work?  Might need to be `{{mls-ciphersuites}}`.",
              "createdAt": "2019-12-31T23:09:16Z",
              "updatedAt": "2020-03-05T22:56:24Z"
            },
            {
              "originalPosition": 27,
              "body": "This extra section heading doesn't seem necessary.",
              "createdAt": "2019-12-31T23:10:08Z",
              "updatedAt": "2020-03-05T22:56:24Z"
            },
            {
              "originalPosition": 54,
              "body": "Should we use HKDF instead of SHA directly?  In other words, make node secrets variable-length, where the length is determined by the KEM in use.\r\n\r\n* P256, X25519: 32 bytes\r\n* X448: 56 bytes\r\n* P521: 66 bytes\r\n\r\nAs a bonus, that would save a couple of hash invocations.",
              "createdAt": "2019-12-31T23:13:52Z",
              "updatedAt": "2020-03-05T22:56:24Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzM3NjY3MzA1",
          "commit": {
            "abbreviatedOid": "5f69d5f"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-01-02T13:55:42Z",
          "updatedAt": "2020-01-02T13:55:43Z",
          "comments": [
            {
              "originalPosition": 112,
              "body": "Have we decided on that? In theory there could be different signature algorithms for credentials and message signing. Since credentials are completely defined by the AS, it might be tricky to get consensus when picking the CIKs.",
              "createdAt": "2020-01-02T13:55:43Z",
              "updatedAt": "2020-03-05T22:56:24Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzM3NjY3NzE1",
          "commit": {
            "abbreviatedOid": "5f69d5f"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-01-02T13:56:50Z",
          "updatedAt": "2020-01-02T13:56:50Z",
          "comments": [
            {
              "originalPosition": 107,
              "body": "I wanted to avoid exactly that scenario, it could be dangerous to re-use ciphersuites between versions is the primitives are used for a different purpose in the new version. Being more explicit might be the safer choice here.",
              "createdAt": "2020-01-02T13:56:50Z",
              "updatedAt": "2020-03-05T22:56:24Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzM3NjY4MDI4",
          "commit": {
            "abbreviatedOid": "5f69d5f"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-01-02T13:57:39Z",
          "updatedAt": "2020-01-02T13:57:39Z",
          "comments": [
            {
              "originalPosition": 108,
              "body": "The idea is to give you a rough idea of the overall security level for informational purposes. Maybe @beurdouche can elaborate more on that.",
              "createdAt": "2020-01-02T13:57:39Z",
              "updatedAt": "2020-03-05T22:56:24Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzM3NjY4NzM5",
          "commit": {
            "abbreviatedOid": "5f69d5f"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-01-02T13:59:21Z",
          "updatedAt": "2020-01-02T13:59:21Z",
          "comments": [
            {
              "originalPosition": 118,
              "body": "The idea was to explicitly base this on what HPKE defines. This is just to emphasize that we want to use HPKE rather than some other KEM mechanism.",
              "createdAt": "2020-01-02T13:59:21Z",
              "updatedAt": "2020-03-05T22:56:24Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzM3NjY4ODcw",
          "commit": {
            "abbreviatedOid": "5f69d5f"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-01-02T13:59:42Z",
          "updatedAt": "2020-01-02T13:59:42Z",
          "comments": [
            {
              "originalPosition": 130,
              "body": "Why?",
              "createdAt": "2020-01-02T13:59:42Z",
              "updatedAt": "2020-03-05T22:56:24Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzM3NjcwNjIx",
          "commit": {
            "abbreviatedOid": "5f69d5f"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-01-02T14:04:05Z",
          "updatedAt": "2020-01-02T14:04:06Z",
          "comments": [
            {
              "originalPosition": 23,
              "body": "1) That's why I wanted to leave \"HPKE\" in the name of the ciphersuite\r\n2) I guess that should then go in line 809\r\n3) That's what we have in the \"Diffie-Hellmann groups section\"\r\n\r\nRegarding the notation for hyperlinks, I'll take your word for it",
              "createdAt": "2020-01-02T14:04:06Z",
              "updatedAt": "2020-03-05T22:56:24Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzM3NjcxNDcz",
          "commit": {
            "abbreviatedOid": "5f69d5f"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-01-02T14:06:12Z",
          "updatedAt": "2020-01-02T14:06:12Z",
          "comments": [
            {
              "originalPosition": 54,
              "body": "Unless there is a specific reasons not to do it (cc @beurdouche), I think it would be great to harmonise this. Having different hash algorithms in here makes no sense to me if it can be avoided.\r\n\r\n",
              "createdAt": "2020-01-02T14:06:12Z",
              "updatedAt": "2020-03-05T22:56:24Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ1NDgxMzE5",
          "commit": {
            "abbreviatedOid": "5f69d5f"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-01-20T18:39:06Z",
          "updatedAt": "2020-01-20T18:39:07Z",
          "comments": [
            {
              "originalPosition": 112,
              "body": "In the discussion at the last interim the consensus was to keep the signature algorithms as part of the ciphersuite.",
              "createdAt": "2020-01-20T18:39:06Z",
              "updatedAt": "2020-03-05T22:56:24Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUyMTUxMTE3",
          "commit": {
            "abbreviatedOid": "bb89ab8"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-03T10:24:44Z",
          "updatedAt": "2020-02-03T10:24:45Z",
          "comments": [
            {
              "originalPosition": 107,
              "body": "As discussed at the last interim, we want ciphersuites to be specific for a certain MLS protocol version.",
              "createdAt": "2020-02-03T10:24:45Z",
              "updatedAt": "2020-03-05T22:56:24Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUyMTUxNTM3",
          "commit": {
            "abbreviatedOid": "bb89ab8"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-03T10:25:27Z",
          "updatedAt": "2020-02-03T10:25:28Z",
          "comments": [
            {
              "originalPosition": 130,
              "body": "As discussed at the interim, we want to include the MTI.",
              "createdAt": "2020-02-03T10:25:27Z",
              "updatedAt": "2020-03-05T22:56:24Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUyMTUyMTA2",
          "commit": {
            "abbreviatedOid": "bb89ab8"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-03T10:26:24Z",
          "updatedAt": "2020-02-03T10:26:24Z",
          "comments": [
            {
              "originalPosition": 131,
              "body": "As  discussed at the last interim, we keep this MTI.",
              "createdAt": "2020-02-03T10:26:24Z",
              "updatedAt": "2020-03-05T22:56:24Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUyMTU0ODk1",
          "commit": {
            "abbreviatedOid": "1d59c9c"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-03T10:30:57Z",
          "updatedAt": "2020-02-03T10:30:57Z",
          "comments": [
            {
              "originalPosition": 118,
              "body": "HPKE changed to DHKEM",
              "createdAt": "2020-02-03T10:30:57Z",
              "updatedAt": "2020-03-05T22:56:24Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUyMTU1NzEz",
          "commit": {
            "abbreviatedOid": "1d59c9c"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-03T10:32:14Z",
          "updatedAt": "2020-02-03T10:32:15Z",
          "comments": [
            {
              "originalPosition": 112,
              "body": "done",
              "createdAt": "2020-02-03T10:32:14Z",
              "updatedAt": "2020-03-05T22:56:24Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUzMzA2NDYz",
          "commit": {
            "abbreviatedOid": "8f27146"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "This seems to accurately reflect the consensus we had at the last interim, and there's nothing I can't live with otherwise.\r\n\r\nI will probably file a follow-up to convert the Derive-Key-Pair operations to use HKDF directly, as discussed, avoiding the need for intermediate `node_secret` values or truncation of SHA-512.",
          "createdAt": "2020-02-04T21:15:35Z",
          "updatedAt": "2020-02-04T21:15:35Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUzNzI2NTg4",
          "commit": {
            "abbreviatedOid": "8f27146"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "There are some items missing that I believe we agreed on at the last in-person interim:\r\n- It's not clear from reading the PR that the signature scheme is now fixed per-group.\r\n  - Need to verify that CIKs correspond to current suite and express support for all algorithms currently used.\r\n- Recommendation that we be conservative when adding new suites in the future.\r\n- Justification for why the current suites are minimal.",
          "createdAt": "2020-02-05T13:48:58Z",
          "updatedAt": "2020-02-05T13:48:58Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU3OTQyNjcx",
          "commit": {
            "abbreviatedOid": "6387082"
          },
          "author": "seanturner",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-13T04:04:18Z",
          "updatedAt": "2020-02-13T04:04:19Z",
          "comments": [
            {
              "originalPosition": 23,
              "body": "I fixed this in mine. The anchor is {#anchor} and then you link in text with {{anchor}}.",
              "createdAt": "2020-02-13T04:04:18Z",
              "updatedAt": "2020-03-05T22:56:24Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU3OTQyNzE4",
          "commit": {
            "abbreviatedOid": "6387082"
          },
          "author": "seanturner",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-13T04:04:32Z",
          "updatedAt": "2020-02-13T04:04:32Z",
          "comments": [
            {
              "originalPosition": 27,
              "body": "I blew it away in mine.",
              "createdAt": "2020-02-13T04:04:32Z",
              "updatedAt": "2020-03-05T22:56:24Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYwNjg1MzE5",
          "commit": {
            "abbreviatedOid": "6387082"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-18T21:28:05Z",
          "updatedAt": "2020-02-18T21:38:20Z",
          "comments": [
            {
              "originalPosition": 21,
              "body": "- Please wrap this at 80-ish chars\r\n- \"field\"\r\n- Can it really be different?",
              "createdAt": "2020-02-18T21:28:05Z",
              "updatedAt": "2020-03-05T22:56:24Z"
            },
            {
              "originalPosition": 49,
              "body": "The punctuation was correct before\r\nAlternatively, lower-case r in \"Recall\"",
              "createdAt": "2020-02-18T21:29:44Z",
              "updatedAt": "2020-03-05T22:56:24Z"
            },
            {
              "originalPosition": 102,
              "body": "VALUE is represented\r\n8-bit",
              "createdAt": "2020-02-18T21:32:39Z",
              "updatedAt": "2020-03-05T22:56:24Z"
            },
            {
              "originalPosition": 113,
              "body": "lower-case s in \"Signature\"",
              "createdAt": "2020-02-18T21:34:15Z",
              "updatedAt": "2020-03-05T22:56:24Z"
            },
            {
              "originalPosition": 141,
              "body": "HKDF over SHA-256, AES-128-GCM for HPKE,",
              "createdAt": "2020-02-18T21:36:36Z",
              "updatedAt": "2020-03-05T22:56:24Z"
            },
            {
              "originalPosition": 143,
              "body": "\"message encryption and authentication\"",
              "createdAt": "2020-02-18T21:37:44Z",
              "updatedAt": "2020-03-05T22:56:24Z"
            }
          ]
        }
      ]
    },
    {
      "number": 281,
      "id": "MDExOlB1bGxSZXF1ZXN0MzU5MDUzODg5",
      "title": "Extend the epoch with a commit hash",
      "url": "https://github.com/mlswg/mls-protocol/pull/281",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "discussion",
        "functionality"
      ],
      "body": "As discussed on the mailing list, this allows for fork detection.",
      "createdAt": "2020-01-03T16:54:55Z",
      "updatedAt": "2020-01-29T22:45:21Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "02bf13ebad9a8efd675f6c30c3261dcf6191f179",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "extended-epoch",
      "headRefOid": "35e927ac86a1b717095fb0cf80e049c3de7c1743",
      "closedAt": "2020-01-29T22:45:21Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "I am withdrawing this proposal.  Discussion at the interim indicated that consideration of fork/merge cases is more complex than it might have seemed, and it's not clear that this extension is needed outside of those cases.\r\n\r\nAnd in any case, if something like this is needed, it seems like it can be done in an extension.",
          "createdAt": "2020-01-29T22:45:21Z",
          "updatedAt": "2020-01-29T22:45:21Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 282,
      "id": "MDExOlB1bGxSZXF1ZXN0MzU5MDYzNDE1",
      "title": "Specify an Ack message",
      "url": "https://github.com/mlswg/mls-protocol/pull/282",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "security",
        "discussion",
        "functionality"
      ],
      "body": "",
      "createdAt": "2020-01-03T17:27:54Z",
      "updatedAt": "2020-01-12T17:06:01Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "02bf13ebad9a8efd675f6c30c3261dcf6191f179",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "ack",
      "headRefOid": "d2f5141521fee3592fa4aca0a3c0ae59138eeca3",
      "closedAt": "2020-01-12T17:04:57Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "After discussion at Jan 2020 interim, the current feeling is that Acks are not necessary at the moment.  We may re-add them later, once we have some more thorough analysis of recovery scenarios.",
          "createdAt": "2020-01-12T17:06:01Z",
          "updatedAt": "2020-01-12T17:06:01Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 283,
      "id": "MDExOlB1bGxSZXF1ZXN0MzU5MDcxNDQ1",
      "title": "Use the same ratchet for Handshake and Application keys",
      "url": "https://github.com/mlswg/mls-protocol/pull/283",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "security",
        "privacy",
        "discussion",
        "ready to merge"
      ],
      "body": "The current draft uses a hash ratchet to derive single-use keys for application messages, but for handshake messages, re-uses the same key with a sequence of different nonces.  This results in a lot of unnecessary extra code.\r\n\r\nThis PR uses the same hash ratchet for handshake and application messages.  The only difference is in the base key for the hash ratchet.  In the application case, we use the AStree.  In the HS case, we derive the base keys directly from the handshake secret.  The lack of a tree in the HS case means that either the client will do a linear number of derivations on the first send/receive, or it will keep the handshake secret around and not get FS for handshake messages within the epoch.",
      "createdAt": "2020-01-03T17:57:34Z",
      "updatedAt": "2020-03-04T04:46:16Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "02bf13ebad9a8efd675f6c30c3261dcf6191f179",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "hs-key-chain",
      "headRefOid": "b1f18f441451aa7d16db3cbf9e0f5fbb66d86492",
      "closedAt": "2020-03-04T04:46:16Z",
      "mergedAt": "2020-03-04T04:46:15Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "081c42111a3b937c1f81ee611d24ae5cdba6b0b9"
      },
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "@psyoptix - would appreciate your thoughts here\r\n",
          "createdAt": "2020-01-03T17:58:06Z",
          "updatedAt": "2020-01-03T17:58:06Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "As discussed on the PR call:\r\n* There's no point to FS for Proposals because clients have to cache the plaintext anyway\r\n* Given that, the \"flat derivation\" approach should be fine\r\n* We should have separate keys per sender to it easier to avoid nonce collisions\r\n* Unclear whether we should derive nonces on a hash ratchet or use a counter",
          "createdAt": "2020-01-29T14:33:04Z",
          "updatedAt": "2020-01-29T15:02:07Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU3NDQzMTY4",
          "commit": {
            "abbreviatedOid": "b1f18f4"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-12T13:19:36Z",
          "updatedAt": "2020-02-12T13:19:37Z",
          "comments": [
            {
              "originalPosition": 56,
              "body": "There is a fundamental difference between application message sender ratchets and handshake message ratchets: the requirement for forward secrecy.\r\nFor application messages clients MUST delete old key material in order to obtain FS.\r\nFor handshake messages FS is not required. Moreover since there is no ordering requirement for Proposals clients should keep older key material around in order to be able to decrypt out-of-order handshake messages within one epoch.\r\nI think it's important to make that more clear.",
              "createdAt": "2020-02-12T13:19:36Z",
              "updatedAt": "2020-02-12T13:19:37Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY3MjgwNjA0",
          "commit": {
            "abbreviatedOid": "b1f18f4"
          },
          "author": "seanturner",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Please merge when you have chance.",
          "createdAt": "2020-03-02T15:19:14Z",
          "updatedAt": "2020-03-02T15:19:14Z",
          "comments": []
        }
      ]
    },
    {
      "number": 285,
      "id": "MDExOlB1bGxSZXF1ZXN0MzU5MzYzODgz",
      "title": "Get rid of ignored proposals.",
      "url": "https://github.com/mlswg/mls-protocol/pull/285",
      "state": "MERGED",
      "author": "Bren2010",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "security",
        "today! (?)"
      ],
      "body": "Ignored proposals don't make sense to me. How can they possibly add value? Also, re-structured section on Commits some.\r\n\r\n![mls-ignored-proposals](https://user-images.githubusercontent.com/416022/71790700-9ced4380-2fe6-11ea-843b-12b3609e9079.png)",
      "createdAt": "2020-01-06T02:12:37Z",
      "updatedAt": "2020-02-06T16:59:54Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "f5f308ddc3cbe8eae68867231e1d79242e6a512f",
      "headRepository": "Bren2010/mls-protocol",
      "headRefName": "brendan/2020.1.0",
      "headRefOid": "61a5623887240b7d99be71875eadc2758073664a",
      "closedAt": "2020-02-06T16:59:54Z",
      "mergedAt": "2020-02-06T16:59:54Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "6bca62edac0b77a530a0130101be1fa4c1c4105b"
      },
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "I'm afraid the flow chart might not quite be that simple.  It is possible for there to be proposals that (1) don't appear in the Commit and (2) don't need to be re-sent.  The simplest case is when a member sends two Update messages within an epoch.  On the one hand, there's no practical need for them both to be included in the Commit, since one will overwrite the other.  On the other hand, at the same time, the new member shouldn't re-send the stale Update.   The idea of the `ignored` array was to provide a slot for these to be included in the Commit, but without the need for recipients to act on them.\r\n\r\n\r\n",
          "createdAt": "2020-01-07T00:12:23Z",
          "updatedAt": "2020-01-07T00:12:23Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "On a separate note, it would be helpful if you could base your different PRs on master, to make the specific changes clearer.",
          "createdAt": "2020-01-07T00:13:37Z",
          "updatedAt": "2020-01-07T00:13:37Z"
        },
        {
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "body": "In that specific example, the member is aware of all the Updates they've sent and can know to only expect one to be included.\r\n\r\nIn fact, the member can try to enforce a lot of things:\r\n- Re-send if no Update was included.\r\n- Re-send if the included Update isn't \"recent enough.\"\r\n- Re-send if the included Update isn't the most recent.\r\n\r\nThe member's own sense of what should/shouldn't be included is what matters here, not the comitter's.",
          "createdAt": "2020-01-09T03:36:41Z",
          "updatedAt": "2020-01-09T03:36:41Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "I can agree that the difference between \"Proposal got dropped somewhere in the ether\" and \"Proposal was consciously ignored by the Committer\" is not really salient.  I'll post to the list to see if anyone else objects.",
          "createdAt": "2020-01-29T23:27:24Z",
          "updatedAt": "2020-01-29T23:27:24Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "@beurdouche raised some concerns with this on the mailing list.  I proposed a compromise there, of the form:\r\n\r\n1. Specify that if a Committer receives two Updates proposals for the same leaf in the same epoch, then it MUST commit the latest one it received.\r\n2. State explicitly that the only Proposals that may be omitted from a Commit are:\r\n  - Invalid proposals (e.g., because of a bad signature, parsing error, reference to a non-existent leaf)\r\n  - Proposals whose effect on the tree is overwritten by another proposal, which at this point includes only:\r\n    - Updates for a leaf prior to the latest Update received by the committer\r\n    - Updates for a leaf for which there is a Remove in the epoch\r\n\r\n",
          "createdAt": "2020-02-04T21:18:46Z",
          "updatedAt": "2020-02-04T21:18:46Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "@Bren2010 - How does that strike you?",
          "createdAt": "2020-02-04T21:18:57Z",
          "updatedAt": "2020-02-04T21:18:57Z"
        },
        {
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "body": "Isn't that what's currently in the PR? The only difference is \"SHOULD prefer the most recent Update\" because it's not enforceable anyway",
          "createdAt": "2020-02-04T21:22:53Z",
          "updatedAt": "2020-02-04T21:22:53Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUwNDk0NDg4",
          "commit": {
            "abbreviatedOid": "dee01e5"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-01-29T23:23:41Z",
          "updatedAt": "2020-01-29T23:23:41Z",
          "comments": []
        }
      ]
    },
    {
      "number": 286,
      "id": "MDExOlB1bGxSZXF1ZXN0MzU5MzY1ODk4",
      "title": "Editorial: Unclear that Commits always include an Update/refreshes the CIK for the committer.",
      "url": "https://github.com/mlswg/mls-protocol/pull/286",
      "state": "MERGED",
      "author": "Bren2010",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "editorial",
        "today! (?)"
      ],
      "body": "",
      "createdAt": "2020-01-06T02:25:41Z",
      "updatedAt": "2020-02-06T17:00:35Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "f5f308ddc3cbe8eae68867231e1d79242e6a512f",
      "headRepository": "Bren2010/mls-protocol",
      "headRefName": "brendan/2020.1.1",
      "headRefOid": "8f172730fc889091b1ff6ef89bd52db8d764ad64",
      "closedAt": "2020-02-06T17:00:34Z",
      "mergedAt": "2020-02-06T17:00:34Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "8260491cf8cfb50479ca120b37851264982f6efa"
      },
      "comments": [
        {
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "body": "You can now rebase this on master for clarity.",
          "createdAt": "2020-01-15T11:56:04Z",
          "updatedAt": "2020-01-15T11:56:04Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUwNDk3NTk0",
          "commit": {
            "abbreviatedOid": "3ae19ac"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "This looks good, just one minor clarification",
          "createdAt": "2020-01-29T23:32:18Z",
          "updatedAt": "2020-01-29T23:32:41Z",
          "comments": [
            {
              "originalPosition": 89,
              "body": "It would be good to make clear that the Update in question is the `committer_update`.  Also, could you please check to make sure that DirectPath no longer touches the leaf?  Since we have split out Update and `committer_update`, DirectPath should start at the parent of the Committer.",
              "createdAt": "2020-01-29T23:32:18Z",
              "updatedAt": "2020-02-05T16:00:04Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUxMDgyOTQw",
          "commit": {
            "abbreviatedOid": "3ae19ac"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-01-30T19:27:21Z",
          "updatedAt": "2020-01-30T19:27:21Z",
          "comments": [
            {
              "originalPosition": 89,
              "body": "https://github.com/mlswg/mls-protocol/pull/294",
              "createdAt": "2020-01-30T19:27:21Z",
              "updatedAt": "2020-02-05T16:00:04Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUzNzYxMjE3",
          "commit": {
            "abbreviatedOid": "8ff6c00"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-05T14:33:48Z",
          "updatedAt": "2020-02-05T14:33:49Z",
          "comments": [
            {
              "originalPosition": 38,
              "body": "Since an Update only contains a CIK, we should use the CIK right away here.",
              "createdAt": "2020-02-05T14:33:48Z",
              "updatedAt": "2020-02-05T16:00:04Z"
            }
          ]
        }
      ]
    },
    {
      "number": 287,
      "id": "MDExOlB1bGxSZXF1ZXN0MzU5NDI4ODc5",
      "title": "Switch to signing strategy using one signature per leaf.",
      "url": "https://github.com/mlswg/mls-protocol/pull/287",
      "state": "MERGED",
      "author": "Bren2010",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "enhancement",
        "security",
        "performance",
        "discussion",
        "ready to merge"
      ],
      "body": "",
      "createdAt": "2020-01-06T07:38:36Z",
      "updatedAt": "2020-02-06T17:01:00Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "f5f308ddc3cbe8eae68867231e1d79242e6a512f",
      "headRepository": "Bren2010/mls-protocol",
      "headRefName": "brendan/2020.1.2",
      "headRefOid": "cd67f82e44c74d98c420de3244660ca60c3e40b5",
      "closedAt": "2020-02-06T17:01:00Z",
      "mergedAt": "2020-02-06T17:01:00Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "2c478519074be70049fe4e028b4853e1c942864b"
      },
      "comments": [
        {
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "body": "After the discussion at the interim I took a look again and I would like to bring up the following points:\r\n\r\n - The PR contains functional changes as well as editorial changes. I think it makes no sense to combine the two and the two kind of changes should be split in at least two PRs.\r\n - We discussed that enforcing the tree invariant is the minimum we need, there is still an ongoing discussion on what we want to guarantee regarding group agreement.\r\n - This PR covers more than just the direct path needed for the tree invariant, because the fields `left_hash` and `right_hash` are present in `ParentNodeHashInput`. Is this on done on purpose? If so, why?\r\n - I think it is not actually possible to verify the hash chain in a direct path other than in the direct path of the last Commit. The reason is that the hash chain breaks on all other direct paths because at some level the direct path gets overwritten by the direct path of the committer and the hashes are therefore no longer correct. The way forward would be to use a Merckle tree instead of a hash in the CIK extension (I think @bifurcation proposed that at some point).",
          "createdAt": "2020-01-14T17:07:54Z",
          "updatedAt": "2020-01-14T17:07:54Z"
        },
        {
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "body": "You can now rebase this on master for clarity.\r\nPlease avoid unrelated editorial as much as possible.",
          "createdAt": "2020-01-15T11:55:22Z",
          "updatedAt": "2020-01-15T11:55:22Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "As discussed on PR call:\r\n* People are generally OK going with this approach for now, pending further proofs\r\n* We should get #285 and #286 merged first",
          "createdAt": "2020-01-29T15:01:26Z",
          "updatedAt": "2020-01-29T15:01:26Z"
        },
        {
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "body": "I think the last commits address my concerns.",
          "createdAt": "2020-01-29T15:56:01Z",
          "updatedAt": "2020-01-29T15:56:01Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "One more note here: It might be good to add an OPEN ISSUE to acknowledge the still-outstanding concerns about group agreement vs. deniability, , something like:\r\n\r\n> [[ OPEN ISSUE: This scheme, in which the tree hash covers the parent hash, is designed to allow for more deniable deployments, since a signature by a member covers only its direct path.  The other possible scheme, in which the parent hash covers the tree hash, provides better group agreement properties, since a member's signature covers the entire membership of the trees it is in.  Further discussion is needed to determine whether the benefits to deniability justify the harm to group agreement properties, or whether there are alternative approaches to deniability that could be compatible with the other approach. ]]",
          "createdAt": "2020-02-05T02:09:43Z",
          "updatedAt": "2020-02-05T02:09:43Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 288,
      "id": "MDExOlB1bGxSZXF1ZXN0MzU5Njc2ODY2",
      "title": "Typos",
      "url": "https://github.com/mlswg/mls-protocol/pull/288",
      "state": "MERGED",
      "author": "raphaelrobert",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "",
      "createdAt": "2020-01-06T19:23:09Z",
      "updatedAt": "2020-03-04T18:22:36Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "02bf13ebad9a8efd675f6c30c3261dcf6191f179",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "raphaelrobert-typos",
      "headRefOid": "6b535809d07db778e7dfeb6ec8442f056abb3f07",
      "closedAt": "2020-01-07T00:19:50Z",
      "mergedAt": "2020-01-07T00:19:50Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "62bd560673d8e795e8b124e717d122e459e08611"
      },
      "comments": [
        {
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "body": "These are resolved in #287.",
          "createdAt": "2020-01-06T19:30:39Z",
          "updatedAt": "2020-01-06T19:30:39Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzM4OTcxNDkz",
          "commit": {
            "abbreviatedOid": "6b53580"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-01-07T00:19:43Z",
          "updatedAt": "2020-01-07T00:19:43Z",
          "comments": []
        }
      ]
    },
    {
      "number": 292,
      "id": "MDExOlB1bGxSZXF1ZXN0MzYzMDk3ODQ2",
      "title": "Editorial on top of PR #278",
      "url": "https://github.com/mlswg/mls-protocol/pull/292",
      "state": "MERGED",
      "author": "beurdouche",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "",
      "createdAt": "2020-01-15T11:48:12Z",
      "updatedAt": "2020-01-20T18:43:38Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "62bd560673d8e795e8b124e717d122e459e08611",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "beurdouche_278",
      "headRefOid": "543a78105eb1b029315e8342ea73bf5a4434fd26",
      "closedAt": "2020-01-15T11:51:05Z",
      "mergedAt": "2020-01-15T11:51:05Z",
      "mergedBy": "beurdouche",
      "mergeCommit": {
        "oid": "26a327ca9c07381c3a8b9d717ff2641749195824"
      },
      "comments": [
        {
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "body": "Merge+Squash #278 from Brendan and apply editorial fixes",
          "createdAt": "2020-01-15T11:51:10Z",
          "updatedAt": "2020-01-15T11:51:10Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 294,
      "id": "MDExOlB1bGxSZXF1ZXN0MzY5MjQ1MTE1",
      "title": "Re-define direct path to not include the leaf.",
      "url": "https://github.com/mlswg/mls-protocol/pull/294",
      "state": "MERGED",
      "author": "Bren2010",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "today! (?)"
      ],
      "body": "",
      "createdAt": "2020-01-30T19:27:11Z",
      "updatedAt": "2020-02-06T17:03:16Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "f5f308ddc3cbe8eae68867231e1d79242e6a512f",
      "headRepository": "Bren2010/mls-protocol",
      "headRefName": "brendan/2020.1.3",
      "headRefOid": "bd4fec65fd4bbf7d5de164504ab13f7ea9b58421",
      "closedAt": "2020-02-06T17:03:15Z",
      "mergedAt": "2020-02-06T17:03:15Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "57a0a34096a5cd4a0583dbd748a4a462d42b6686"
      },
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "You can also strike this sentence further down: \" In particular, for the leaf node, there are no encrypted secrets, since a leaf node has no children.\"",
          "createdAt": "2020-02-05T14:32:15Z",
          "updatedAt": "2020-02-05T14:32:15Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Note that this severs the connection between the HPKE key in the leaf and the parent of the leaf.  Whereas before, the leaf HPKE key was derived from a path secret, and the parent HPKE key was derived from the next path secret.  Now the parent path secret is set directly, and the leaf HPKE key is set completely independently, with no dependency on a path secret.\r\n\r\nSo we're losing a bit of internal structure in the tree.  But this seems OK because that structure was never observable to the group -- only the holder of the leaf knows the leaf path secret, so nobody else could verify that the leaf was related to its parent.",
          "createdAt": "2020-02-05T14:36:51Z",
          "updatedAt": "2020-02-05T14:36:51Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUzNzU5NTcy",
          "commit": {
            "abbreviatedOid": "bd5525e"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-05T14:31:50Z",
          "updatedAt": "2020-02-05T14:31:50Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "Add root here, so it lines up with the copath",
              "createdAt": "2020-02-05T14:31:50Z",
              "updatedAt": "2020-02-05T16:15:33Z"
            }
          ]
        }
      ]
    },
    {
      "number": 295,
      "id": "MDExOlB1bGxSZXF1ZXN0MzY5OTEwOTc1",
      "title": "Use path secret instead of full DirectPath",
      "url": "https://github.com/mlswg/mls-protocol/pull/295",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "today! (?)"
      ],
      "body": "This PR adapts the Welcome logic so that the new joiners get their path secrets directly, rather than from a DirectPath.  This cleans things up in a few ways.  The new joiners no longer have to have the context for the previous epoch (which was used to encrypt the DirectPath).  And we can get away with one HPKE operation per new joiner instead of two (one for the EncryptedKeyPackage and one for the DirectPath).\r\n\r\nThe major cost is that there's a bit more complexity in the TreeKEM.  Instead of just producing and consuming DirectPaths, you now need to know which path secrets go with which nodes.  You also need tree math to identify the common ancestor of two leaves, but there's a simple closed-form formula for that, expressed in the Python code here.\r\n\r\n[Corresponding PR on the Go implementation.](https://github.com/bifurcation/mls/pull/37)",
      "createdAt": "2020-02-01T15:47:37Z",
      "updatedAt": "2020-02-07T08:40:50Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "57a0a34096a5cd4a0583dbd748a4a462d42b6686",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "path-secret",
      "headRefOid": "e20bcecda309d3ee140644107ff98716fbb76c0e",
      "closedAt": "2020-02-06T17:08:21Z",
      "mergedAt": "2020-02-06T17:08:21Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "db9ab6a206e9b9cca6d1c2e0c3b9c3db0088c644"
      },
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "@raphaelrobert - Curious if this seems implementable to you.  Clearly it's possible, since I did it in Go :)  But it also needs to make sense to other people.",
          "createdAt": "2020-02-01T15:48:31Z",
          "updatedAt": "2020-02-01T15:48:31Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUxODkxMDIz",
          "commit": {
            "abbreviatedOid": "6324601"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-01T16:05:27Z",
          "updatedAt": "2020-02-01T16:07:38Z",
          "comments": [
            {
              "originalPosition": 41,
              "body": "I think there might be more math involved here. Unless it's a group of two, the direct path of the new member should be blank until it intersects with the direct path of the adder (who populated their path with the Commit). In other words, the common ancestor node has to be resolved, leading to an array of resolved nodes. The new member should be one of these resolved nodes.\r\nTo me this looks like you end up KEMing to the new member's leaf node directly.",
              "createdAt": "2020-02-01T16:05:27Z",
              "updatedAt": "2020-02-06T17:07:49Z"
            },
            {
              "originalPosition": 145,
              "body": "For simplicity I would just iterate over `parent()` until the value is equal.",
              "createdAt": "2020-02-01T16:07:30Z",
              "updatedAt": "2020-02-06T17:07:49Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUxODkxMzY5",
          "commit": {
            "abbreviatedOid": "6324601"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-01T16:13:03Z",
          "updatedAt": "2020-02-01T16:13:03Z",
          "comments": [
            {
              "originalPosition": 145,
              "body": "That actually doesn't work, because the distance to the parent might not be equal.  Consider, for example, the three-member tree:\r\n\r\n```\r\n    ABC\r\n   /   \\\r\n AB     |\r\n / \\    |\r\nA   B   C\r\n```\r\n\r\nThe common ancestor of A and B is `ABC = parent(parent(A)) = parent(C)`.\r\n\r\nYou would have to first compute the direct path of one node, then iterate `parent()` on the other until you end up in the direct path.  The formula here is a little bit of index magic, but I think it can be proven correct, and it's simpler/faster.",
              "createdAt": "2020-02-01T16:13:03Z",
              "updatedAt": "2020-02-06T17:07:49Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUxODkxNTg5",
          "commit": {
            "abbreviatedOid": "6324601"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-01T16:17:43Z",
          "updatedAt": "2020-02-01T16:17:43Z",
          "comments": [
            {
              "originalPosition": 41,
              "body": "You're kind of making a point I should have made, namely that sending the path secret of the common ancestor as we are here is equivalent to sending the direct path -- in the direct path encryption, you would encrypt the path secret to the corresponding copath node, which would ultimately resolve to the leaf node (and possibly some others).\r\n\r\nWhat this PR is doing is taking the KEMing to the new member's leaf and taking it out of the context of the DirectPath.  Where before you were doing an HPKE to the new member once for EncryptedKeyPackage and again in the DirectPath, now you just do it for the EncryptedKeyPackage.",
              "createdAt": "2020-02-01T16:17:43Z",
              "updatedAt": "2020-02-06T17:07:49Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUxODkyNTMz",
          "commit": {
            "abbreviatedOid": "6324601"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-01T16:39:19Z",
          "updatedAt": "2020-02-01T16:39:19Z",
          "comments": [
            {
              "originalPosition": 41,
              "body": "Sure, I think that makes sense. \r\n\r\nBut there might be another issue: I forgot that we don't blank the direct path of new members anymore and instead use `unmerged_leaves`. This list should now be shorter and only include nodes from leaf to common ancestor. This is however something every member in the group processing the `Add` has to calculate as it is non explicit.",
              "createdAt": "2020-02-01T16:39:19Z",
              "updatedAt": "2020-02-06T17:07:49Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUxODkyNjIx",
          "commit": {
            "abbreviatedOid": "6324601"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-01T16:41:07Z",
          "updatedAt": "2020-02-01T16:41:08Z",
          "comments": [
            {
              "originalPosition": 145,
              "body": "True, my idea only works reliably on the left part of the tree. On the right part you'd have to also use `level()` to skip some nodes. If you're confident your math works, it might just be simpler to use that.",
              "createdAt": "2020-02-01T16:41:08Z",
              "updatedAt": "2020-02-06T17:07:49Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUyNDg0NDQz",
          "commit": {
            "abbreviatedOid": "6324601"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-03T18:57:26Z",
          "updatedAt": "2020-02-03T18:57:27Z",
          "comments": [
            {
              "originalPosition": 145,
              "body": "The algorithm passes tests on a non-trivial tree, so I have pretty good confidence that it works.  Proof sketch:\r\n\r\n* Each subtree of the tree is identified by a common prefix\r\n    * The root of the subtree is `<prefix>0<1 * level>`\r\n    * The nodes within the subtree are `<prefix>0...0` to <prefix>1...10\r\n* Therefore every common ancestor of A and B will have a prefix that is common to A and B, since a common ancestor is the root of a subtree containing both nodes\r\n* This algorithm finds the longest prefix shared by A and B, then computes the root of the corresponding subtree\r\n\r\nOf course, all of this is just a recommended implementation.  Implementations are free to use a more explicit algorithm like yours if they prefer.",
              "createdAt": "2020-02-03T18:57:26Z",
              "updatedAt": "2020-02-06T17:07:49Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUyOTY2Mjk0",
          "commit": {
            "abbreviatedOid": "6324601"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-04T13:19:03Z",
          "updatedAt": "2020-02-04T13:19:04Z",
          "comments": [
            {
              "originalPosition": 41,
              "body": "> This list should now be shorter and only include nodes from leaf to common ancestor\r\n\r\nThis is already true.  Even before this PR, the DirectPath processing would reset the `unnmerged_leaves` arrays to `[]` for nodes in the direct path of the committer.",
              "createdAt": "2020-02-04T13:19:03Z",
              "updatedAt": "2020-02-06T17:07:49Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUyOTY2ODIz",
          "commit": {
            "abbreviatedOid": "6324601"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-04T13:19:56Z",
          "updatedAt": "2020-02-04T13:19:57Z",
          "comments": [
            {
              "originalPosition": 41,
              "body": "In any case, we should be clear that you reset `unmerged_leaves` whenever you write to a node.  I don't think that needs to be blocking on this PR.",
              "createdAt": "2020-02-04T13:19:56Z",
              "updatedAt": "2020-02-06T17:07:49Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUzNzc3ODkw",
          "commit": {
            "abbreviatedOid": "6324601"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-02-05T14:53:59Z",
          "updatedAt": "2020-02-05T14:53:59Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU1MDAwNDc5",
          "commit": {
            "abbreviatedOid": "e20bcec"
          },
          "author": "ericcornelissen",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-07T08:40:49Z",
          "updatedAt": "2020-02-07T08:40:50Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "This change leaves a reference to a GroupInfo object that is not mentioned before. If I'm not mistaken, I think this can be rewritten as:\r\n\r\n> Create a DirectPath using the new tree (which includes any new members). The GroupContext for this operation uses the `group_id`, `epoch`, and `tree` in the provisional GroupContext and the `confirmed_transcript_hash` for the current state of the group (not the provisional state).\r\n\r\nOn this note, I'm not entirely sure I understand why an entire GroupContext (specifically the `group_id`, `epoch`, and `confirmed_transcript_hash`) is needed to compute a DirectPath...",
              "createdAt": "2020-02-07T08:40:49Z",
              "updatedAt": "2020-02-07T08:40:50Z"
            }
          ]
        }
      ]
    },
    {
      "number": 296,
      "id": "MDExOlB1bGxSZXF1ZXN0MzcxMTQ2Njcx",
      "title": "Flesh out the extensions story",
      "url": "https://github.com/mlswg/mls-protocol/pull/296",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "editorial",
        "security",
        "functionality"
      ],
      "body": "Extensions in the CIK were only half of the story.  To do things like RTreeKEM or fork/merge as extensions, we need the ability to (1) tell new members that the group is doing something different, and (2) confirm that all group members have the same view of the rules of the road.  This PR adds extensions to the GroupInfo object for the first case, and to the Welcome object for the second, and a bunch of explanatory text to make it all work.\r\n\r\nOne thing this PR does *not* do is define a way to change extensions in a running group.  You could in principle do this by sending new extensions in Commit that could overwrite or add to extensions.  But that entails some messy questions (how do you delete an extension in use?), so it is currently left to an extension (heh), or to a group restart.\r\n\r\nDepends on #295 to avoid conflicts in GroupInfo changes.",
      "createdAt": "2020-02-05T01:59:30Z",
      "updatedAt": "2020-03-05T23:05:58Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "10e75b3e9e722f6fda9a48b332407b80e51e87dd",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "more-extensions",
      "headRefOid": "dfd3caba595e855eed63eaa8d565f44fef55093f",
      "closedAt": "2020-03-05T23:05:58Z",
      "mergedAt": "2020-03-05T23:05:58Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "ba7a182cdd541c80087ea21a0d61a5024ab3d105"
      },
      "comments": [
        {
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "body": "I think this could also be useful for deniability.",
          "createdAt": "2020-02-05T10:22:01Z",
          "updatedAt": "2020-02-05T10:22:01Z"
        },
        {
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "body": "I imagine we also need to define an IANA registry of extensions, designated experts, a private space?",
          "createdAt": "2020-03-03T18:59:35Z",
          "updatedAt": "2020-03-03T18:59:35Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Filed #312 for the IANA stuff",
          "createdAt": "2020-03-04T05:10:30Z",
          "updatedAt": "2020-03-04T05:10:30Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU3NTA2NjIx",
          "commit": {
            "abbreviatedOid": "b300624"
          },
          "author": "seanturner",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-12T14:43:04Z",
          "updatedAt": "2020-02-12T14:43:05Z",
          "comments": [
            {
              "originalPosition": 119,
              "body": "This means we need some more text in the IANA considerations about setting up the space.",
              "createdAt": "2020-02-12T14:43:04Z",
              "updatedAt": "2020-03-05T23:05:48Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY0OTA5MTEy",
          "commit": {
            "abbreviatedOid": "b300624"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "You've essentially just added extension fields without defining /how/ they'll interact with the protocol. Which tells me they're probably meant to be able to change /anything/ about the protocol. In that case, it needs to be clear that all extensions (outside of CIKs) are effectively mandatory, and that we can't have non-mandatory extensions.",
          "createdAt": "2020-02-26T13:47:27Z",
          "updatedAt": "2020-02-26T13:58:11Z",
          "comments": [
            {
              "originalPosition": 123,
              "body": "expresses",
              "createdAt": "2020-02-26T13:47:27Z",
              "updatedAt": "2020-03-05T23:05:48Z"
            },
            {
              "originalPosition": 122,
              "body": "\"to the one\"\r\n\"one-to-one: the\"",
              "createdAt": "2020-02-26T13:48:00Z",
              "updatedAt": "2020-03-05T23:05:48Z"
            },
            {
              "originalPosition": 129,
              "body": "participation",
              "createdAt": "2020-02-26T13:48:37Z",
              "updatedAt": "2020-03-05T23:05:48Z"
            },
            {
              "originalPosition": 106,
              "body": "corresponds",
              "createdAt": "2020-02-26T13:54:17Z",
              "updatedAt": "2020-03-05T23:05:48Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY5MDA1MzI5",
          "commit": {
            "abbreviatedOid": "5417dae"
          },
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-03-04T18:09:58Z",
          "updatedAt": "2020-03-04T18:09:58Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY5MTE3OTM1",
          "commit": {
            "abbreviatedOid": "5417dae"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2020-03-04T20:59:22Z",
          "updatedAt": "2020-03-04T21:05:43Z",
          "comments": [
            {
              "originalPosition": 56,
              "body": "```suggestion\r\n  have an extension of the same type, and the contents of the extension MUST be\r\n```",
              "createdAt": "2020-03-04T20:59:23Z",
              "updatedAt": "2020-03-05T23:05:48Z"
            },
            {
              "originalPosition": 75,
              "body": "I think this would be good. Making sure the CIK format doesn't change is all I think you need for backwards-compatibility.",
              "createdAt": "2020-03-04T21:05:31Z",
              "updatedAt": "2020-03-05T23:05:48Z"
            }
          ]
        }
      ]
    },
    {
      "number": 303,
      "id": "MDExOlB1bGxSZXF1ZXN0MzcyMTU0OTUx",
      "title": "Add some per-message entropy",
      "url": "https://github.com/mlswg/mls-protocol/pull/303",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #216 ",
      "createdAt": "2020-02-06T23:03:01Z",
      "updatedAt": "2020-03-04T18:23:49Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "db9ab6a206e9b9cca6d1c2e0c3b9c3db0088c644",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "per-message-entropy",
      "headRefOid": "a7bd50001dd2a55c92f1e01dfae848ab4874c4b3",
      "closedAt": "2020-02-17T17:57:43Z",
      "mergedAt": "2020-02-17T17:57:43Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "8045e66dbbac361202ac8ab90d3d27d33771ad28"
      },
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "cc @Bren2010 ",
          "createdAt": "2020-02-06T23:03:09Z",
          "updatedAt": "2020-02-06T23:03:09Z"
        },
        {
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "body": "Quick question without reading much, but why can't we reuse the sender data nonce which is always fresh to do this?",
          "createdAt": "2020-02-07T19:05:37Z",
          "updatedAt": "2020-02-07T19:05:37Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "You could do that; in fact you could just use that nonce for the content encryption as well as the sender data encryption, and forget about the key-schedule derived nonces as well.\r\n\r\nThe reason I didn't go down that path is that I'm generally leery of requiring fresh randomness in the protocol.  In particular, for the sender data, I think we should be moving toward masking instead of GCM (cf #302).  If we do masking, then we won't need to change this, and we'll have basically the minimum amount of fresh entropy needed.",
          "createdAt": "2020-02-07T19:20:46Z",
          "updatedAt": "2020-02-07T19:20:46Z"
        },
        {
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "body": "Nope you can't really do that. The xoring of the two is strictly stronger, even if your PRNG is bad, you'll benefit from the entropy of the deterministic nonce because of the current epoch secret to which many people have contributed to.\r\n\r\nUntil we do that move to masking, I think I would prefer to have the xor use the sender data nonce.",
          "createdAt": "2020-02-07T19:25:24Z",
          "updatedAt": "2020-02-07T19:25:24Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "I'm confused about what you're talking about.  In the current proposal:\r\n\r\n```\r\naead_nonce = key_sched_nonce XOR (reuse_guard || 0)\r\n```\r\n\r\nI agree that that's better than just using the `sender_data_nonce` for the reasons you say.  But I thought what you were proposing was :\r\n\r\n```\r\naead_nonce = key_sched_nonce XOR sender_data_nonce\r\n```\r\n\r\nEither way, we're incorporating the key schedule nonce.  \r\n\r\nHow about the following proposal?\r\n* For now: `aead_nonce = key_sched_nonce XOR sender_data_nonce`\r\n* If we do masking later, we do something like what's in this PR",
          "createdAt": "2020-02-07T19:29:42Z",
          "updatedAt": "2020-02-07T19:29:42Z"
        },
        {
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "body": "> How about the following proposal?\r\n> \r\n>     * For now: `aead_nonce = key_sched_nonce XOR sender_data_nonce` \r\n>     * If we do masking later, we do something like what's in this PR\r\n\r\nWorks for me !\r\n",
          "createdAt": "2020-02-07T20:27:10Z",
          "updatedAt": "2020-02-07T20:27:10Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "@Bren2010 if the revised scheme looks ok to you, I'll consider this ready to merge",
          "createdAt": "2020-02-07T21:02:33Z",
          "updatedAt": "2020-02-07T21:02:33Z"
        },
        {
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "body": "If I had a concern with the new scheme, it's that it's no longer resistant to nonce misuse. For example, consider somebody setting `sender_data_nonce = key_sched_nonce`.",
          "createdAt": "2020-02-07T21:09:04Z",
          "updatedAt": "2020-02-07T21:09:04Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "That would violate the requirement that the `sender_data_nonce` be fresh.  I've clarified that requirement in the latest commit.",
          "createdAt": "2020-02-07T21:14:57Z",
          "updatedAt": "2020-02-07T21:14:57Z"
        },
        {
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "body": "Putting a requirement in the spec is good. But that won't stop a nonce-misusing implementation from running, which was the point of deterministically generating the nonce in the first place.",
          "createdAt": "2020-02-07T21:18:51Z",
          "updatedAt": "2020-02-07T21:18:51Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "I'm not sure why you think a freshness requirement is less plausible for the `sender_data_nonce` than for the `reuse_guard`.  Neither is enforceable in the protocol.\r\n\r\n![image](https://user-images.githubusercontent.com/75597/74067871-3209a080-49c8-11ea-991a-69fe1cbbfc9a.png)\r\n",
          "createdAt": "2020-02-07T21:38:46Z",
          "updatedAt": "2020-02-07T21:38:46Z"
        },
        {
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "body": "The value of `reuse_guard` is that it's only 4 bytes, so it doesn't mask the whole thing. Worst case, `reuse_guard` can reliably fix 32 bits, leaving only 64 bits of actual randomness in the nonce. Not good, but better than 0, and better than invoking a hash `H(key_sched_nonce | sender_data_nonce)` to actually mix things.",
          "createdAt": "2020-02-07T21:50:46Z",
          "updatedAt": "2020-02-07T21:50:46Z"
        },
        {
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "body": "The fact that `reuse_guard` is not called a nonce and is a different size also makes me feel better about it not being misused",
          "createdAt": "2020-02-07T21:52:22Z",
          "updatedAt": "2020-02-07T21:52:38Z"
        },
        {
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "body": "@bifurcation @Bren2010 I don't have a strong opinion here, I was just pointing that we already has a fresh value. I can see why Brendan prefers the smaller guard using a fresh distinct value, so I'll support this or any variant for which you both agree ; )",
          "createdAt": "2020-02-16T11:19:19Z",
          "updatedAt": "2020-02-16T11:19:19Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Reverted to the `reuse_guard` approach, which it seems everyone is OK with.",
          "createdAt": "2020-02-17T17:57:36Z",
          "updatedAt": "2020-02-17T17:57:36Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU1MzYyOTM5",
          "commit": {
            "abbreviatedOid": "20f59e3"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "This is perfect! Thanks!",
          "createdAt": "2020-02-07T18:50:30Z",
          "updatedAt": "2020-02-07T18:50:30Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY5MDE0ODI4",
          "commit": {
            "abbreviatedOid": "a7bd500"
          },
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "Approved.",
          "createdAt": "2020-03-04T18:23:49Z",
          "updatedAt": "2020-03-04T18:23:49Z",
          "comments": []
        }
      ]
    },
    {
      "number": 304,
      "id": "MDExOlB1bGxSZXF1ZXN0MzcyMTY3OTY2",
      "title": "Use HKDF to derive key pairs",
      "url": "https://github.com/mlswg/mls-protocol/pull/304",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "ready to merge"
      ],
      "body": "This deals cleanly with groups where the private key size doesn't align neatly with a hash function output size (e.g., X448), and saves a few hash invocations by removing intermediate `node_secret` values.\r\n\r\nA few editorial changes are included here as well.\r\n\r\nDepends on #279.",
      "createdAt": "2020-02-06T23:48:31Z",
      "updatedAt": "2020-03-05T23:01:10Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "74380c5a193277e696d39a0d7554fd9243cd3d9b",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "hkdf-derive-key-pair",
      "headRefOid": "38f1dbf406220f3b484204e229cf5f166ac452a8",
      "closedAt": "2020-03-05T23:01:10Z",
      "mergedAt": "2020-03-05T23:01:10Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "680a2a7858684d6a8d3c7d8fe6b9f273a5d366bf"
      },
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "As discussed on call, folks are comfortable with this.  Ready to merge, pending #279 ",
          "createdAt": "2020-02-12T14:35:28Z",
          "updatedAt": "2020-02-12T14:35:28Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYwNjk5Mjc1",
          "commit": {
            "abbreviatedOid": "f1b5764"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-18T21:50:49Z",
          "updatedAt": "2020-02-18T21:50:49Z",
          "comments": [
            {
              "originalPosition": 183,
              "body": "66 octets",
              "createdAt": "2020-02-18T21:50:49Z",
              "updatedAt": "2020-03-05T23:00:54Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY3MjgxMjA0",
          "commit": {
            "abbreviatedOid": "f1b5764"
          },
          "author": "seanturner",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Please merge when get a chance.",
          "createdAt": "2020-03-02T15:19:58Z",
          "updatedAt": "2020-03-02T15:19:58Z",
          "comments": []
        }
      ]
    },
    {
      "number": 305,
      "id": "MDExOlB1bGxSZXF1ZXN0MzczMDU4Mjk3",
      "title": "Update HKDFLabel variable to match naming conventions",
      "url": "https://github.com/mlswg/mls-protocol/pull/305",
      "state": "MERGED",
      "author": "GaPhil",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "editorial",
        "? invalid"
      ],
      "body": "This PR changes the variable name `HkdfLabel` to `HKDFLabel` in order to match the previously used naming conventions.",
      "createdAt": "2020-02-10T10:35:34Z",
      "updatedAt": "2020-02-12T14:10:20Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "9128dc8dc88730467cb42f83643901099f71082c",
      "headRepository": null,
      "headRefName": "master",
      "headRefOid": "904439875c9aec7342cc722b8e49de88d25c6bb1",
      "closedAt": "2020-02-12T14:01:12Z",
      "mergedAt": "2020-02-12T14:01:12Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "ac53a7dc0984241661d53cf722e0979b18aebda3"
      },
      "comments": [
        {
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "body": "Hi Philip @GaPhil  !\r\nThis is following the conventions we used in RFC 8446 so I think we should just keep that... I'll let Richard @bifurcation close this if he agrees with me but anyway, thank you for having a look! : )\r\nB.",
          "createdAt": "2020-02-10T10:40:48Z",
          "updatedAt": "2020-02-10T10:40:48Z"
        },
        {
          "author": "GaPhil",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Sure, noted.\r\n\r\nHowever, one might consider whether one wishes to maintain the same conventions for acronyms in this document. See `HPKECiphertext` and `MLSPlaintextCommitAuthData` as opposed to `HpkeCiphertext` and `MlsPlaintextCommitAuthData`.",
          "createdAt": "2020-02-10T11:51:05Z",
          "updatedAt": "2020-02-10T11:51:05Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "I actually agree with @GaPhil here.  It's also more like Go than Java, so let's go with the more modern language :)",
          "createdAt": "2020-02-12T14:01:07Z",
          "updatedAt": "2020-02-12T14:01:07Z"
        },
        {
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "body": "Well Phillip's point was certainly valid. The one about programming language is completely irrelevant.",
          "createdAt": "2020-02-12T14:09:29Z",
          "updatedAt": "2020-02-12T14:09:29Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "I agree that it's irrelevant.  Just kidding.",
          "createdAt": "2020-02-12T14:10:20Z",
          "updatedAt": "2020-02-12T14:10:20Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 306,
      "id": "MDExOlB1bGxSZXF1ZXN0MzczMTIwMzQw",
      "title": "Typos",
      "url": "https://github.com/mlswg/mls-protocol/pull/306",
      "state": "MERGED",
      "author": "GaPhil",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "This PR aims to fix some odd formulations, whilst maintaining the intended meaning of the sentences.",
      "createdAt": "2020-02-10T12:58:35Z",
      "updatedAt": "2020-02-10T14:12:58Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "db9ab6a206e9b9cca6d1c2e0c3b9c3db0088c644",
      "headRepository": null,
      "headRefName": "typos",
      "headRefOid": "dec27f1e8dab422bfc9adfbec2472fa22d2dc2a4",
      "closedAt": "2020-02-10T13:00:12Z",
      "mergedAt": "2020-02-10T13:00:12Z",
      "mergedBy": "beurdouche",
      "mergeCommit": {
        "oid": "9128dc8dc88730467cb42f83643901099f71082c"
      },
      "comments": [
        {
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "body": "Thank you!",
          "createdAt": "2020-02-10T13:00:21Z",
          "updatedAt": "2020-02-10T13:00:21Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 307,
      "id": "MDExOlB1bGxSZXF1ZXN0Mzc0NjU0MzY1",
      "title": "DE-related text",
      "url": "https://github.com/mlswg/mls-protocol/pull/307",
      "state": "MERGED",
      "author": "seanturner",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "Here's to hoping I did this merge properly.",
      "createdAt": "2020-02-13T03:47:01Z",
      "updatedAt": "2020-03-05T22:56:22Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "raphael_ciphersuites",
      "baseRefOid": "6387082ad4c34637940bfc1e1e2b54d4ae17f353",
      "headRepository": "seanturner/mls-protocol",
      "headRefName": "raphael_ciphersuites",
      "headRefOid": "5a5862ab50f2fab54c5af1391da23977e53a3e6a",
      "closedAt": "2020-03-05T22:56:22Z",
      "mergedAt": "2020-03-05T22:56:22Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "0606ce7c64730b54d569aef11c137142942a0927"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU5OTAwODIw",
          "commit": {
            "abbreviatedOid": "6161f17"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2020-02-17T17:58:34Z",
          "updatedAt": "2020-02-17T18:02:10Z",
          "comments": [
            {
              "originalPosition": 66,
              "body": "\"Designated\"",
              "createdAt": "2020-02-17T17:58:34Z",
              "updatedAt": "2020-02-19T14:25:17Z"
            },
            {
              "originalPosition": 9,
              "body": "I think this will render as \"MLS Ciphersuites Section X.Y.Z\".  Maybe add parens around `{{ciphersuites}}`",
              "createdAt": "2020-02-17T17:59:15Z",
              "updatedAt": "2020-02-19T14:25:17Z"
            },
            {
              "originalPosition": 5,
              "body": "You don't need to define this, the \"lowercase plus dashes\" tags are auto-generated.",
              "createdAt": "2020-02-17T17:59:46Z",
              "updatedAt": "2020-02-19T14:25:17Z"
            },
            {
              "originalPosition": 9,
              "body": "As above, just use `{{mls-ciphersuites}}` and there's no need for an explicit tag.",
              "createdAt": "2020-02-17T18:00:08Z",
              "updatedAt": "2020-02-19T14:25:17Z"
            },
            {
              "originalPosition": 35,
              "body": "This needs to be guarded with `~~~`",
              "createdAt": "2020-02-17T18:00:38Z",
              "updatedAt": "2020-02-19T14:25:17Z"
            },
            {
              "originalPosition": 69,
              "body": "Suggest `mls-ciphersuites@`",
              "createdAt": "2020-02-17T18:01:11Z",
              "updatedAt": "2020-02-19T14:25:17Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYxMTQ1OTc0",
          "commit": {
            "abbreviatedOid": "6161f17"
          },
          "author": "seanturner",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-19T14:19:04Z",
          "updatedAt": "2020-02-19T14:19:05Z",
          "comments": [
            {
              "originalPosition": 69,
              "body": "But, we're going to end up with more than one registry (e.g., extensions) so I was going for the more general name.",
              "createdAt": "2020-02-19T14:19:05Z",
              "updatedAt": "2020-02-19T14:25:17Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY4OTgzMzQz",
          "commit": {
            "abbreviatedOid": "5a5862a"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-03-04T17:37:45Z",
          "updatedAt": "2020-03-04T17:37:45Z",
          "comments": []
        }
      ]
    },
    {
      "number": 308,
      "id": "MDExOlB1bGxSZXF1ZXN0MzgxMDkxMDY0",
      "title": "Remove nonce from SenderData AAD.",
      "url": "https://github.com/mlswg/mls-protocol/pull/308",
      "state": "MERGED",
      "author": "Bren2010",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "performance",
        "discussion"
      ],
      "body": "With any AEAD, the nonce is necessarily already authenticated. Also, the name of the struct was changed to be more clear.",
      "createdAt": "2020-02-27T21:50:24Z",
      "updatedAt": "2020-07-13T06:37:37Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "1f9f90578eecd61103cc02f98b8a0d058d265e65",
      "headRepository": "Bren2010/mls-protocol",
      "headRefName": "brendan/2020.2.0",
      "headRefOid": "215386655cf85ff6354355848948d05feaf8fd4a",
      "closedAt": "2020-07-12T20:45:15Z",
      "mergedAt": "2020-07-12T20:45:15Z",
      "mergedBy": "Bren2010",
      "mergeCommit": {
        "oid": "7d7b07325f618acd7d254be3bf5ea45615a1445e"
      },
      "comments": [
        {
          "author": "br-hale",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Does this force use of an implicit nonce such as in TLS, vice an explicit nonce such as in DTLS?",
          "createdAt": "2020-03-02T21:22:12Z",
          "updatedAt": "2020-03-02T21:22:12Z"
        },
        {
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "body": "Sender data has always been encrypted with an explicit nonce, and the explicit nonce is still sent in MLSCiphertext. This just removes the explicit nonce from the AAD.",
          "createdAt": "2020-03-02T21:27:51Z",
          "updatedAt": "2020-03-02T21:28:04Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "I think @beurdouche proposed this originally, with the idea that the AAD at each point would include everything above it.  But I agree that it doesn't seem very useful.  I'm OK to merge if other folks are.",
          "createdAt": "2020-03-04T04:47:51Z",
          "updatedAt": "2020-03-04T04:47:51Z"
        },
        {
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "body": "The thing is designed so that the entire prefix of the AEAD ciphertext is authenticated.\r\n<img width=\"718\" alt=\"Screenshot 2020-03-04 at 19 01 50\" src=\"https://user-images.githubusercontent.com/1193431/75908571-af4ef680-5e4a-11ea-8379-4a3e051f25e1.png\">\r\nI would prefer to keep it that way...",
          "createdAt": "2020-03-04T18:02:41Z",
          "updatedAt": "2020-03-04T18:02:41Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "@Bren2010 unless you think this is really important, I'm inclined to just close this PR.",
          "createdAt": "2020-03-04T18:04:05Z",
          "updatedAt": "2020-03-04T18:04:05Z"
        },
        {
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "body": "@beurdouche Put \"sender nonce\" under \"Encrypted Sender Data\" because the nonce is part of the ciphertext. Then there's no gap in your picture, and \"Encrypted Sender Data\" will fit within the bounds of the arrow.",
          "createdAt": "2020-03-04T19:38:11Z",
          "updatedAt": "2020-03-04T19:38:11Z"
        },
        {
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "body": "That was not meant to be merged, that was meant for raphael and I to review. So, I\u2019ll revert that until we can do this.\n\n> On Jul 12, 2020, at 10:45 PM, Brendan McMillion <notifications@github.com> wrote:\n> \n> \ufeff\n> Merged #308 into master.\n> \n> \u2014\n> You are receiving this because you were mentioned.\n> Reply to this email directly, view it on GitHub, or unsubscribe.\n",
          "createdAt": "2020-07-13T06:37:36Z",
          "updatedAt": "2020-07-13T06:37:36Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY4NTAyMzQ4",
          "commit": {
            "abbreviatedOid": "327590a"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-03-04T04:47:58Z",
          "updatedAt": "2020-03-04T04:47:58Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ2OTA4MzY1",
          "commit": {
            "abbreviatedOid": "2153866"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-07-12T20:42:04Z",
          "updatedAt": "2020-07-12T20:42:04Z",
          "comments": []
        }
      ]
    },
    {
      "number": 309,
      "id": "MDExOlB1bGxSZXF1ZXN0MzgxMTAwMTMw",
      "title": "Update MLSPlaintextTBS struct to match MLSPlaintext.",
      "url": "https://github.com/mlswg/mls-protocol/pull/309",
      "state": "MERGED",
      "author": "Bren2010",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-02-27T22:13:50Z",
      "updatedAt": "2020-03-04T04:51:02Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "8045e66dbbac361202ac8ab90d3d27d33771ad28",
      "headRepository": "Bren2010/mls-protocol",
      "headRefName": "brendan/2020.2.1",
      "headRefOid": "78cdd3be31a53b5f2a7ffe8f5ca9c618f6852d8e",
      "closedAt": "2020-03-04T04:51:02Z",
      "mergedAt": "2020-03-04T04:51:02Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "10e75b3e9e722f6fda9a48b332407b80e51e87dd"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY4NTAzMDQ3",
          "commit": {
            "abbreviatedOid": "78cdd3b"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Thanks for fixing this bug.",
          "createdAt": "2020-03-04T04:50:55Z",
          "updatedAt": "2020-03-04T04:50:55Z",
          "comments": []
        }
      ]
    },
    {
      "number": 310,
      "id": "MDExOlB1bGxSZXF1ZXN0MzgyNjMyNjQ0",
      "title": "Fix identation and remove some vestigial stuff from the key schedule.",
      "url": "https://github.com/mlswg/mls-protocol/pull/310",
      "state": "MERGED",
      "author": "Bren2010",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "",
      "createdAt": "2020-03-02T22:05:54Z",
      "updatedAt": "2020-03-03T14:08:51Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "8045e66dbbac361202ac8ab90d3d27d33771ad28",
      "headRepository": "Bren2010/mls-protocol",
      "headRefName": "brendan/2020.2.2",
      "headRefOid": "afdfda8ef7eba543097b3af839e357a4ee6e3b49",
      "closedAt": "2020-03-03T14:08:51Z",
      "mergedAt": "2020-03-03T14:08:51Z",
      "mergedBy": "beurdouche",
      "mergeCommit": {
        "oid": "b9b68fb1ad3eae9789b14f98216296e1c9415d4a"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY3NTc2MjQ0",
          "commit": {
            "abbreviatedOid": "15e687e"
          },
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "Could you please just restore the PSK part of the KeySchedule, I\u2019ll handle that separately.\r\nPs: we wouldn\u2019t have forgot you... :) we intended to go back to the list later, but I\u2019ll merge it now...",
          "createdAt": "2020-03-02T22:27:52Z",
          "updatedAt": "2020-03-02T22:27:52Z",
          "comments": []
        }
      ]
    },
    {
      "number": 311,
      "id": "MDExOlB1bGxSZXF1ZXN0MzgzMTM0MTg0",
      "title": "Review of section 7.",
      "url": "https://github.com/mlswg/mls-protocol/pull/311",
      "state": "MERGED",
      "author": "Bren2010",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "",
      "createdAt": "2020-03-03T19:32:22Z",
      "updatedAt": "2020-03-05T23:02:25Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "680a2a7858684d6a8d3c7d8fe6b9f273a5d366bf",
      "headRepository": "Bren2010/mls-protocol",
      "headRefName": "brendan/2020.2.3",
      "headRefOid": "7ab79af6dded2b255617a531303458b339a58514",
      "closedAt": "2020-03-05T23:02:24Z",
      "mergedAt": "2020-03-05T23:02:24Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "f227d0c5c0f142d7dc421dfe12c22bdff6ce639a"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY4NTAyNjcw",
          "commit": {
            "abbreviatedOid": "2e6f31c"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "One small change, otherwise LGTM.",
          "createdAt": "2020-03-04T04:49:21Z",
          "updatedAt": "2020-03-04T04:50:12Z",
          "comments": [
            {
              "originalPosition": 28,
              "body": "This is just an example, so it doesn't cost any generality just to say \"a member\".  And I think it reads more clearly.",
              "createdAt": "2020-03-04T04:49:21Z",
              "updatedAt": "2020-03-05T23:02:16Z"
            }
          ]
        }
      ]
    },
    {
      "number": 313,
      "id": "MDExOlB1bGxSZXF1ZXN0Mzg0NTQ5ODA1",
      "title": "Clarify signature algorithm requirements",
      "url": "https://github.com/mlswg/mls-protocol/pull/313",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "#279 required a common signature algorithm, but allowed credentials to deviate.  This PR adds the requirement that credentials be consistent.",
      "createdAt": "2020-03-05T23:22:32Z",
      "updatedAt": "2020-03-06T16:41:23Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "ba7a182cdd541c80087ea21a0d61a5024ab3d105",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "sig-fix",
      "headRefOid": "e663318ca9846cc79e6e4cb629ca496896b980f8",
      "closedAt": "2020-03-06T16:41:23Z",
      "mergedAt": "2020-03-06T16:41:22Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "1d79b5110a3cc31c86bd29e5af059285c1bf9cb0"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 314,
      "id": "MDExOlB1bGxSZXF1ZXN0Mzg0ODk3MTEx",
      "title": "Fix build and update changelog",
      "url": "https://github.com/mlswg/mls-protocol/pull/314",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Since draft-08, we have neglected to update the changelog, despite a bunch of significant changes.  Also, because our CI is busted, some build failures crept in.",
      "createdAt": "2020-03-06T15:59:56Z",
      "updatedAt": "2020-03-06T16:43:06Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "1d79b5110a3cc31c86bd29e5af059285c1bf9cb0",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "fix-build",
      "headRefOid": "ae16ebef6b49bae920e196dc43b3ef70fa7875c9",
      "closedAt": "2020-03-06T16:43:06Z",
      "mergedAt": "2020-03-06T16:43:06Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "99745ec6a2babbd12515cd19ae8f4ade7804d452"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 315,
      "id": "MDExOlB1bGxSZXF1ZXN0Mzg0ODk5MjAx",
      "title": "ClientInitKey -> KeyPackage",
      "url": "https://github.com/mlswg/mls-protocol/pull/315",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This is just a terminology change.  ClientInitKey was feeling increasingly awkward, because (1) ClientInitKey structs are now used in leaves in addition to being used for initialization, and (2) there are some emerging cases where the \"client\" in an MLS sense might be a \"server\" (or some other role) in another application.  \"KeyPackage\" is a more neutral term.\r\n\r\nOther than `s/ClientInitKey/KeyPackage/g`, the most invasive change was in Welcome, where we already had `KeyPackage` and `EncryptedKeyPackage`.  I just changed those to `GroupSecrets` and `EncryptedGroupSecrets`, which seem more descriptive anyway.\r\n\r\nDepends on #314 ",
      "createdAt": "2020-03-06T16:04:31Z",
      "updatedAt": "2020-03-06T17:11:13Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "99745ec6a2babbd12515cd19ae8f4ade7804d452",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "key-package",
      "headRefOid": "1a6b2f1f964e3f64757316607445a9edda421e08",
      "closedAt": "2020-03-06T17:11:12Z",
      "mergedAt": "2020-03-06T17:11:12Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "3e30491de42dbb5443559cca4ece45339cea4721"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 316,
      "id": "MDExOlB1bGxSZXF1ZXN0Mzg0OTMxODY2",
      "title": "Update changelog for KeyPackage",
      "url": "https://github.com/mlswg/mls-protocol/pull/316",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-03-06T17:12:46Z",
      "updatedAt": "2020-03-06T17:12:52Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "3e30491de42dbb5443559cca4ece45339cea4721",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "key-package",
      "headRefOid": "b2e52d5229133798f766814db856fe044b0c532e",
      "closedAt": "2020-03-06T17:12:52Z",
      "mergedAt": "2020-03-06T17:12:52Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "35a68735c06c7d6cfa497cb63d6e7fa90e0aa82e"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 317,
      "id": "MDExOlB1bGxSZXF1ZXN0Mzg1MDA1MTUz",
      "title": "Change expiration extension to lifetime extension.",
      "url": "https://github.com/mlswg/mls-protocol/pull/317",
      "state": "MERGED",
      "author": "Bren2010",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-03-06T20:21:39Z",
      "updatedAt": "2020-04-21T19:08:18Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "35a68735c06c7d6cfa497cb63d6e7fa90e0aa82e",
      "headRepository": "Bren2010/mls-protocol",
      "headRefName": "brendan/2020.3.0",
      "headRefOid": "cd94ebcf1272456a8e77389c532fef539e5618ff",
      "closedAt": "2020-04-21T19:08:18Z",
      "mergedAt": "2020-04-21T19:08:18Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "50b276b3d6b07c60e69ee54c62e0bede2ee7c527"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzcwNzM0OTU4",
          "commit": {
            "abbreviatedOid": "cd94ebc"
          },
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-03-07T09:51:18Z",
          "updatedAt": "2020-03-07T09:51:18Z",
          "comments": []
        }
      ]
    },
    {
      "number": 318,
      "id": "MDExOlB1bGxSZXF1ZXN0Mzg1NDQ1MzI1",
      "title": "Fix markdown formatting issue for Ciphersuite section",
      "url": "https://github.com/mlswg/mls-protocol/pull/318",
      "state": "MERGED",
      "author": "arianvp",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-03-09T08:25:37Z",
      "updatedAt": "2020-04-21T14:12:26Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "35a68735c06c7d6cfa497cb63d6e7fa90e0aa82e",
      "headRepository": "arianvp/mls-protocol",
      "headRefName": "patch-2",
      "headRefOid": "663ab30b1f09b238d1051853055c926096571f78",
      "closedAt": "2020-04-21T14:12:26Z",
      "mergedAt": "2020-04-21T14:12:26Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "2e9584b5e4e678c9c94baf820b80100b7c96b3fb"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk3MzcxMTU1",
          "commit": {
            "abbreviatedOid": "663ab30"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-04-21T14:12:20Z",
          "updatedAt": "2020-04-21T14:12:20Z",
          "comments": []
        }
      ]
    },
    {
      "number": 319,
      "id": "MDExOlB1bGxSZXF1ZXN0Mzg2NDA4MTE1",
      "title": "Use correct type for uint32.",
      "url": "https://github.com/mlswg/mls-protocol/pull/319",
      "state": "MERGED",
      "author": "Bren2010",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-03-10T23:15:18Z",
      "updatedAt": "2020-04-21T14:13:39Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "35a68735c06c7d6cfa497cb63d6e7fa90e0aa82e",
      "headRepository": "Bren2010/mls-protocol",
      "headRefName": "brendan/2020.3.1",
      "headRefOid": "7acb2cd43e81915cb67b985a8019c750a03a06fd",
      "closedAt": "2020-04-21T14:13:39Z",
      "mergedAt": "2020-04-21T14:13:38Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "4de0095356658d1486c6d34260e71659e36fa495"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk3MzcyMzQw",
          "commit": {
            "abbreviatedOid": "7acb2cd"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-04-21T14:13:30Z",
          "updatedAt": "2020-04-21T14:13:30Z",
          "comments": []
        }
      ]
    },
    {
      "number": 320,
      "id": "MDExOlB1bGxSZXF1ZXN0Mzg2NDA4OTE0",
      "title": "Use node type instead of leaf index in tree hashes.",
      "url": "https://github.com/mlswg/mls-protocol/pull/320",
      "state": "CLOSED",
      "author": "Bren2010",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "discussion",
        "analysis"
      ],
      "body": "This is more friendly with recursive implementations of Ratchet Trees and is more similar to the construction used in similar places, like RFC 6962.",
      "createdAt": "2020-03-10T23:18:09Z",
      "updatedAt": "2020-05-19T17:51:56Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "35a68735c06c7d6cfa497cb63d6e7fa90e0aa82e",
      "headRepository": "Bren2010/mls-protocol",
      "headRefName": "brendan/2020.3.2",
      "headRefOid": "06d579bf8d3957ecfd0b417f64a61f9725bb5f81",
      "closedAt": "2020-05-19T17:51:56Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "We had something like that before, and I think some folks liked having the index better because, for example, blank leaves at different positions have different hashes.",
          "createdAt": "2020-03-31T01:00:15Z",
          "updatedAt": "2020-03-31T01:00:15Z"
        },
        {
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "body": "The change was made in #254 with no apparent discussion. Not sure what you mean wrt to blank nodes -- I don't believe this is any more or less malleable than the current scheme.",
          "createdAt": "2020-03-31T23:57:41Z",
          "updatedAt": "2020-03-31T23:57:41Z"
        },
        {
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "body": "There was discussion. The security proofs rely on being able to disambiguate between different empty leaves or intermediate nodes when you don't balance the levels, and the type is not enough to do that.",
          "createdAt": "2020-04-01T11:45:07Z",
          "updatedAt": "2020-04-01T11:45:07Z"
        },
        {
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "body": "Sorry, I still don't see where the ambiguity is? The scheme captures whether or not a node is blank, if it's a leaf or not, where it is in the tree.",
          "createdAt": "2020-04-01T14:54:57Z",
          "updatedAt": "2020-04-01T14:55:40Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "@Bren2010  You said in one of the issue discussions that this is to be friendlier to recursive implementations.  But it seems like as long as your recursive function knows (1) how big the tree is and (2) where it is in the tree, then you can include the node index with no problem.  This is in fact [how the Go implementation does it](https://github.com/bifurcation/mls/blob/master/ratchet-tree.go#L844). ",
          "createdAt": "2020-04-21T14:35:44Z",
          "updatedAt": "2020-04-21T14:35:44Z"
        },
        {
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "body": "This implementation doesn't have a recursive structure, it [uses a slice of nodes](https://github.com/bifurcation/mls/blob/master/ratchet-tree.go#L378) and the first thing you do is `len(t.Nodes)`. A recursive implementation would be defined like:\r\n```\r\ntype Node struct {\r\n    left, right *Node\r\n}\r\n```\r\n\r\nIn which case, yeah, a method like `func (n *Node) Hash` wouldn't know how big its subtree is, or whether it's an intermediate or the root.",
          "createdAt": "2020-04-21T16:30:06Z",
          "updatedAt": "2020-04-21T16:30:06Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "To make the protocol work, you need to know which leaf is at which index, and you need to store the total number of leaves somewhere.  So you have the information you need to figure out which non-leaf node has which index.\r\n",
          "createdAt": "2020-04-21T16:50:22Z",
          "updatedAt": "2020-04-21T16:50:22Z"
        },
        {
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "body": "I don't believe you need that information to make anything in the *ratchet tree* work. So you're arguing that we should include unnecessary information in one component of the protocol, because we happen to have that information somewhere else?",
          "createdAt": "2020-04-21T17:38:51Z",
          "updatedAt": "2020-04-21T17:38:51Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 321,
      "id": "MDExOlB1bGxSZXF1ZXN0MzkxODcyNzg5",
      "title": "Extensions -> Extension",
      "url": "https://github.com/mlswg/mls-protocol/pull/321",
      "state": "MERGED",
      "author": "raphaelrobert",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-03-21T15:26:59Z",
      "updatedAt": "2020-03-25T00:07:55Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "35a68735c06c7d6cfa497cb63d6e7fa90e0aa82e",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "raphaelrobert-minor-edits",
      "headRefOid": "a89e27bfade1b787a8f717878f31ce3d4d61747b",
      "closedAt": "2020-03-21T15:55:12Z",
      "mergedAt": "2020-03-21T15:55:12Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "55c292ce69157193da616f2460d0b5de5a6df906"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc4OTI4NjA3",
          "commit": {
            "abbreviatedOid": "a89e27b"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-03-21T15:55:06Z",
          "updatedAt": "2020-03-21T15:55:06Z",
          "comments": []
        }
      ]
    },
    {
      "number": 322,
      "id": "MDExOlB1bGxSZXF1ZXN0MzkzMzE2NTA0",
      "title": "Minor fix",
      "url": "https://github.com/mlswg/mls-protocol/pull/322",
      "state": "MERGED",
      "author": "raphaelrobert",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-03-25T00:10:09Z",
      "updatedAt": "2020-04-27T11:00:46Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "55c292ce69157193da616f2460d0b5de5a6df906",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "raphaelrobert-minor-fix",
      "headRefOid": "d5e453b7c3899850c8000e36e406636ac9e1ef89",
      "closedAt": "2020-03-25T05:49:14Z",
      "mergedAt": "2020-03-25T05:49:14Z",
      "mergedBy": "beurdouche",
      "mergeCommit": {
        "oid": "9b22a1af59a06adf1f18afc2464708f4ae1176e6"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 327,
      "id": "MDExOlB1bGxSZXF1ZXN0Mzk1MTI3ODE1",
      "title": "Fix bugs in tree math and cleanup docs.",
      "url": "https://github.com/mlswg/mls-protocol/pull/327",
      "state": "CLOSED",
      "author": "Bren2010",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "enhancement",
        "editorial"
      ],
      "body": "",
      "createdAt": "2020-03-28T17:34:39Z",
      "updatedAt": "2020-07-12T20:04:17Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "c0f69e7f6b96afdffd9f45a7c73d1ef81f9ea99a",
      "headRepository": "Bren2010/mls-protocol",
      "headRefName": "brendan/2020.3.3",
      "headRefOid": "5ee9f5d0be4b666d22a318d9ce8695b25cca5e34",
      "closedAt": "2020-07-12T20:04:17Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "yihuang",
          "authorAssociation": "CONTRIBUTOR",
          "body": "```\r\nThe basic rule is that the high-order bits of parent and child nodes have the\r\nfollowing relation (where x is an arbitrary bit string):\r\n\r\n    parent=01x => left=00x, right=10x\r\n```\r\n\r\nI think it should change like this: \"where x is an arbitrary bit string\" => \"where x is an sequence of one bits\".",
          "createdAt": "2020-06-07T09:18:47Z",
          "updatedAt": "2020-06-07T09:19:09Z"
        },
        {
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "body": "You can have cases where x isn't all ones, for example when the left and right children are intermediate nodes",
          "createdAt": "2020-06-07T17:54:06Z",
          "updatedAt": "2020-06-07T17:54:06Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk3Mzc3MTYw",
          "commit": {
            "abbreviatedOid": "8eaad0f"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-04-21T14:18:17Z",
          "updatedAt": "2020-04-21T14:18:18Z",
          "comments": [
            {
              "originalPosition": 124,
              "body": "```suggestion\r\n# The direct path of a node, ordered from leaf to root,\r\n# including the root but not the leaf.\r\n```",
              "createdAt": "2020-04-21T14:18:17Z",
              "updatedAt": "2020-05-19T17:56:20Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk3Mzc5OTkz",
          "commit": {
            "abbreviatedOid": "8eaad0f"
          },
          "author": "mheinzel",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-04-21T14:21:06Z",
          "updatedAt": "2020-04-21T14:21:57Z",
          "comments": [
            {
              "originalPosition": 61,
              "body": "```suggestion\r\n# left-balanced, there is no dependency on the size of the tree.\r\n```\r\n\r\nTo stay consistent with the code change.",
              "createdAt": "2020-04-21T14:21:06Z",
              "updatedAt": "2020-05-19T17:56:20Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk3Mzg2NjYx",
          "commit": {
            "abbreviatedOid": "8eaad0f"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-04-21T14:27:51Z",
          "updatedAt": "2020-04-21T14:27:52Z",
          "comments": [
            {
              "originalPosition": 165,
              "body": "If you're going to the semantic clarity route, you might as well go all the way.\r\n\r\n```\r\ndef common_ancestor(x, y, n):\r\n    dx = set(direct_path(x, n))\r\n    dy = set(direct_path(y, n))\r\n    dxy = dx & dy\r\n    if len(dxy) == 0:\r\n        raise Exception('failed to find common ancestor')\r\n\r\n    return min(dxy, key=level)\r\n```\r\n\r\nI would prefer we also provide the old, direct version as an alternative implementation.  It is index magic, but it's not really any more magical than the stuff above.\r\n\r\n```\r\n# The same function as common_ancestor, but using the indices \r\n# directly instead of constructing the direct paths\r\ndef common_ancestor_dir(x, y, n):\r\n    ...\r\n```",
              "createdAt": "2020-04-21T14:27:51Z",
              "updatedAt": "2020-05-19T17:56:20Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk3NjAwMDgx",
          "commit": {
            "abbreviatedOid": "8eaad0f"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-04-21T19:14:30Z",
          "updatedAt": "2020-04-21T19:14:31Z",
          "comments": [
            {
              "originalPosition": 165,
              "body": "I also think we should have both implementations",
              "createdAt": "2020-04-21T19:14:30Z",
              "updatedAt": "2020-05-19T17:56:20Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk3ODExMTk2",
          "commit": {
            "abbreviatedOid": "8eaad0f"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-04-22T03:06:47Z",
          "updatedAt": "2020-04-22T03:06:47Z",
          "comments": [
            {
              "originalPosition": 124,
              "body": "This is redundant with the definition of direct path",
              "createdAt": "2020-04-22T03:06:47Z",
              "updatedAt": "2020-05-19T17:56:20Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk3ODE0NDAy",
          "commit": {
            "abbreviatedOid": "8eaad0f"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-04-22T03:17:48Z",
          "updatedAt": "2020-04-22T03:17:48Z",
          "comments": [
            {
              "originalPosition": 165,
              "body": "The code you've given is not correct, `common_ancestor(0, 7, 11) = 15 (should be 7)`.\r\nThe old code is also not correct, `common_ancestor(0, 7, 11) = 3 (should be 7)`, which is why I removed it.",
              "createdAt": "2020-04-22T03:17:48Z",
              "updatedAt": "2020-05-19T17:56:20Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk4MjYyOTI3",
          "commit": {
            "abbreviatedOid": "09d2bd3"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-04-22T14:41:26Z",
          "updatedAt": "2020-04-22T14:41:27Z",
          "comments": [
            {
              "originalPosition": 165,
              "body": "The semantic code fails when x == y because the leaf is not in the direct path; the direct code fails when one node is in the direct path of the other.  I had not worried about these because MLS only ever needs to call `ancestor(x, y)` with x and y  leaf nodes and x != y.  But both are easy to fix.  See fixed code and validation here:\r\n\r\nhttps://repl.it/@RichardBarnes/ImmediateCrookedScience",
              "createdAt": "2020-04-22T14:41:26Z",
              "updatedAt": "2020-05-19T17:56:20Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk4ODYxMDM0",
          "commit": {
            "abbreviatedOid": "7451a17"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-04-23T08:12:36Z",
          "updatedAt": "2020-04-23T08:12:36Z",
          "comments": [
            {
              "originalPosition": 170,
              "body": "How can a leaf be the ancestor of another leaf?",
              "createdAt": "2020-04-23T08:12:36Z",
              "updatedAt": "2020-05-19T17:56:20Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI1ODQxNTk0",
          "commit": {
            "abbreviatedOid": "5ee9f5d"
          },
          "author": "yihuang",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-07T18:09:51Z",
          "updatedAt": "2020-06-07T18:09:52Z",
          "comments": [
            {
              "originalPosition": 104,
              "body": "If passed in x is larger than `node_width(x)`, the loop might not finish.\r\nso maybe add `assert x < node_width(n)` at the beginning.",
              "createdAt": "2020-06-07T18:09:51Z",
              "updatedAt": "2020-06-07T18:36:59Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI1ODQyNTk0",
          "commit": {
            "abbreviatedOid": "5ee9f5d"
          },
          "author": "yihuang",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-07T18:25:44Z",
          "updatedAt": "2020-06-07T18:25:45Z",
          "comments": [
            {
              "originalPosition": 48,
              "body": "```suggestion\r\n    if n == 0:\r\n        return 0\r\n    else:\r\n        return n + n - 1\r\n```",
              "createdAt": "2020-06-07T18:25:44Z",
              "updatedAt": "2020-06-08T04:18:33Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI4MzAzMzQ2",
          "commit": {
            "abbreviatedOid": "5ee9f5d"
          },
          "author": "yihuang",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-10T18:02:12Z",
          "updatedAt": "2020-06-10T18:02:14Z",
          "comments": [
            {
              "originalPosition": 153,
              "body": "Since `direct_path` contains root, and `sibling(root)` raise exception, so it'll raises exception here.",
              "createdAt": "2020-06-10T18:02:13Z",
              "updatedAt": "2020-06-10T18:02:14Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ2OTA2MDQ3",
          "commit": {
            "abbreviatedOid": "5ee9f5d"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-12T20:03:52Z",
          "updatedAt": "2020-07-12T20:03:53Z",
          "comments": [
            {
              "originalPosition": 153,
              "body": "d doesn't contain the root because of the last d.pop()",
              "createdAt": "2020-07-12T20:03:53Z",
              "updatedAt": "2020-07-12T20:03:53Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ2OTA2MDY0",
          "commit": {
            "abbreviatedOid": "5ee9f5d"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-12T20:04:10Z",
          "updatedAt": "2020-07-12T20:04:10Z",
          "comments": [
            {
              "originalPosition": 104,
              "body": "We don't assert anywhere else, probably fine",
              "createdAt": "2020-07-12T20:04:10Z",
              "updatedAt": "2020-07-12T20:04:10Z"
            }
          ]
        }
      ]
    },
    {
      "number": 329,
      "id": "MDExOlB1bGxSZXF1ZXN0Mzk3MDk2NTUw",
      "title": "Rename messaging service to service provider",
      "url": "https://github.com/mlswg/mls-protocol/pull/329",
      "state": "MERGED",
      "author": "GaPhil",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "This PR addresses https://github.com/mlswg/mls-architecture/issues/62.",
      "createdAt": "2020-04-01T16:17:48Z",
      "updatedAt": "2020-04-01T16:18:41Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "9b22a1af59a06adf1f18afc2464708f4ae1176e6",
      "headRepository": null,
      "headRefName": "master",
      "headRefOid": "b38bc9e65edd6e68addbf8760e71fa22910f10f8",
      "closedAt": "2020-04-01T16:18:41Z",
      "mergedAt": "2020-04-01T16:18:41Z",
      "mergedBy": "beurdouche",
      "mergeCommit": {
        "oid": "16481cecca9420f5928ce4327b55ac5a9911b6f8"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 330,
      "id": "MDExOlB1bGxSZXF1ZXN0NDA5NDM2NDY1",
      "title": "Minor fixes",
      "url": "https://github.com/mlswg/mls-protocol/pull/330",
      "state": "MERGED",
      "author": "raphaelrobert",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-04-27T11:25:32Z",
      "updatedAt": "2021-10-08T22:20:22Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "50b276b3d6b07c60e69ee54c62e0bede2ee7c527",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "raphaelrobert-minor-fix",
      "headRefOid": "4d095697bb742284283e0eb09380094f6bb04225",
      "closedAt": "2020-04-27T13:49:12Z",
      "mergedAt": "2020-04-27T13:49:12Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "5d6a2864054857e18966463d69dde5f8cca71e5a"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAwOTY5NTE0",
          "commit": {
            "abbreviatedOid": "4d09569"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-04-27T13:49:05Z",
          "updatedAt": "2020-04-27T13:49:05Z",
          "comments": []
        }
      ]
    },
    {
      "number": 331,
      "id": "MDExOlB1bGxSZXF1ZXN0NDA5NTI2MTc4",
      "title": "Make ratcheting optional for Adds",
      "url": "https://github.com/mlswg/mls-protocol/pull/331",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "security",
        "performance",
        "functionality"
      ],
      "body": "When we converted to the Proposal/Commit scheme, one of the consequences was that Adds became O(N) instead of O(1), since they had to Committed and commits encrypt the committer's direct path to the remainder of the tree.  This is ~log(N) in the nice case and ~N in the worst case.  At the time, we noted that one could special-case Add-only Commits in the future and make the update to the direct path optional in that case.\r\n\r\nThis PR implements that suggestion.  The leaf KeyPackage for the Commit is moved into the DirectPath struct, and the whole DirectPath is made optional.  The optional value MUST be provided for:\r\n\r\n* A Commit committing an update or remove\r\n* A \"just update my path\" Commit covering no proposals",
      "createdAt": "2020-04-27T14:08:46Z",
      "updatedAt": "2020-05-21T19:27:44Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "5d6a2864054857e18966463d69dde5f8cca71e5a",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "no-ratchet-on-add",
      "headRefOid": "43e2f5ef4745bcbfabc8316fb9e54e6bfbf61aa8",
      "closedAt": "2020-05-21T19:27:44Z",
      "mergedAt": "2020-05-21T19:27:44Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "8264f452c27354ac043d289a893b4bec80c1d556"
      },
      "comments": [
        {
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "So we _do_ go forward one epoch, but with an all-zero commit secret. Do I understand that correctly?",
          "createdAt": "2020-04-29T05:42:13Z",
          "updatedAt": "2020-04-29T05:42:13Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "@kkohbrok That's correct.  The idea is that you don't need to send the current group any additional entropy, you just need them to hash forward.\r\n\r\nNote that this could change the FS/PCS guarantees available.  But I don't think we ever proposed that Add would cause any FS/PCS changes to the group, so maybe this doesn't matter.",
          "createdAt": "2020-04-29T16:54:37Z",
          "updatedAt": "2020-04-29T16:54:37Z"
        },
        {
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Add should give FS guarantees in so far as that the new member shouldn't be able to decrypt old messages or derive old keys. But I think ratcheting forward should do the trick. We should note, though, that this breaks the (implicit) assumption that a commit always introduces fresh key material to the group. As far as I can see, that's not breaking anything right now, but we should keep it in mind.",
          "createdAt": "2020-04-30T06:06:52Z",
          "updatedAt": "2020-04-30T06:06:52Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Note: The latest commit fixes a gap that was discovered in [implementing this PR in Go](https://github.com/cisco/go-mls/pull/69).",
          "createdAt": "2020-05-20T17:17:40Z",
          "updatedAt": "2020-05-20T17:17:40Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAxMDIzOTk0",
          "commit": {
            "abbreviatedOid": "f657621"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-04-27T14:44:53Z",
          "updatedAt": "2020-04-27T14:44:54Z",
          "comments": [
            {
              "originalPosition": 58,
              "body": "Why not set `commit_secret` to zero length vector? Seems easier to me.",
              "createdAt": "2020-04-27T14:44:53Z",
              "updatedAt": "2020-05-21T19:00:43Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAyODU0MDY4",
          "commit": {
            "abbreviatedOid": "f657621"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-04-29T16:49:52Z",
          "updatedAt": "2020-04-29T16:49:53Z",
          "comments": [
            {
              "originalPosition": 58,
              "body": "That would also work for me.  I just copied what TLS does, e.g., for missing PSK inputs.",
              "createdAt": "2020-04-29T16:49:52Z",
              "updatedAt": "2020-05-21T19:00:43Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE0NjIyMTA5",
          "commit": {
            "abbreviatedOid": "f657621"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-05-19T16:30:08Z",
          "updatedAt": "2020-05-19T16:30:09Z",
          "comments": [
            {
              "originalPosition": 32,
              "body": "TODO: Add pseudocode here to express the algorithm.",
              "createdAt": "2020-05-19T16:30:08Z",
              "updatedAt": "2020-05-21T19:00:43Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE1NjYwNjg5",
          "commit": {
            "abbreviatedOid": "a803b8c"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-05-20T19:45:06Z",
          "updatedAt": "2020-05-20T19:45:07Z",
          "comments": [
            {
              "originalPosition": 94,
              "body": "I think we could be more flexible here: Since the path value MAY be omitted if the Commit only contains Adds, it MAY also not be omitted.\r\nThe sender should be able to choose whether they want to use the commit to also do an update and the receivers should simply process it.",
              "createdAt": "2020-05-20T19:45:06Z",
              "updatedAt": "2020-05-21T19:00:43Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE2MzkyMjI1",
          "commit": {
            "abbreviatedOid": "a803b8c"
          },
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "See the flexibility question.",
          "createdAt": "2020-05-21T18:33:25Z",
          "updatedAt": "2020-05-21T18:33:25Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE2NDEwNTY4",
          "commit": {
            "abbreviatedOid": "a803b8c"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-05-21T19:00:34Z",
          "updatedAt": "2020-05-21T19:00:35Z",
          "comments": [
            {
              "originalPosition": 94,
              "body": "I think this is already the case, but I added a bit more text to clarify\r\n",
              "createdAt": "2020-05-21T19:00:35Z",
              "updatedAt": "2020-05-21T19:00:43Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE2NDE1ODEw",
          "commit": {
            "abbreviatedOid": "43e2f5e"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-05-21T19:08:29Z",
          "updatedAt": "2020-05-21T19:08:29Z",
          "comments": []
        }
      ]
    },
    {
      "number": 332,
      "id": "MDExOlB1bGxSZXF1ZXN0NDEzNjkyNTky",
      "title": "adding a table of contents",
      "url": "https://github.com/mlswg/mls-protocol/pull/332",
      "state": "CLOSED",
      "author": "bast",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "We did this together with @chrisbrzuska live on Twitch.",
      "createdAt": "2020-05-05T18:53:29Z",
      "updatedAt": "2020-05-06T11:37:20Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "5d6a2864054857e18966463d69dde5f8cca71e5a",
      "headRepository": null,
      "headRefName": "patch-1",
      "headRefOid": "76e78c54e2bdab46b6f549735db6daeb0adaf969",
      "closedAt": "2020-05-06T11:37:19Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "body": "The table of contents is auto-generated in the text format, there is no need to add it:\r\n\r\nhttps://www.ietf.org/id/draft-ietf-mls-protocol-09.txt",
          "createdAt": "2020-05-05T20:36:56Z",
          "updatedAt": "2020-05-05T20:36:56Z"
        },
        {
          "author": "bast",
          "authorAssociation": "NONE",
          "body": "OK. Thank you for the clarification!",
          "createdAt": "2020-05-06T11:37:19Z",
          "updatedAt": "2020-05-06T11:37:19Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 333,
      "id": "MDExOlB1bGxSZXF1ZXN0NDEzNzMyMTIz",
      "title": "add code highlighting for the python code part",
      "url": "https://github.com/mlswg/mls-protocol/pull/333",
      "state": "CLOSED",
      "author": "bast",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-05-05T20:19:24Z",
      "updatedAt": "2020-05-06T13:56:08Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "5d6a2864054857e18966463d69dde5f8cca71e5a",
      "headRepository": null,
      "headRefName": "radovan/code-highlighting",
      "headRefOid": "e7e1cdb4d34e7bd218b078167f510909e476a572",
      "closedAt": "2020-05-06T13:56:08Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "body": "Code highlighting wouldn't work in the text format.",
          "createdAt": "2020-05-05T20:38:01Z",
          "updatedAt": "2020-05-05T20:38:01Z"
        },
        {
          "author": "bast",
          "authorAssociation": "NONE",
          "body": "OK I considered only the rendered Markdown page on GitHub but forgot that the webpages are generated and possibly does not work there. Where are the generated webpages? Feel free to close it.",
          "createdAt": "2020-05-06T11:36:31Z",
          "updatedAt": "2020-05-06T11:36:31Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 334,
      "id": "MDExOlB1bGxSZXF1ZXN0NDE1MTcxNTE2",
      "title": "Explicitly state the order in which proposals are applied when creating a commit",
      "url": "https://github.com/mlswg/mls-protocol/pull/334",
      "state": "MERGED",
      "author": "ericcornelissen",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #300 by updating the description for creating a commit to explicitly mention that first all update proposals are applied, then remove proposals, and last add proposals.",
      "createdAt": "2020-05-08T10:44:03Z",
      "updatedAt": "2020-05-08T14:20:39Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "5d6a2864054857e18966463d69dde5f8cca71e5a",
      "headRepository": null,
      "headRefName": "proposal-apply-order",
      "headRefOid": "693d3ff1cd4b0ddbf37dbdec2d9e8f6115aeb6a0",
      "closedAt": "2020-05-08T14:20:39Z",
      "mergedAt": "2020-05-08T14:20:39Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "c519e9d8ac723ed19fa114198abb09922d1027f7"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA4MTg0NTc0",
          "commit": {
            "abbreviatedOid": "693d3ff"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-05-08T11:50:54Z",
          "updatedAt": "2020-05-08T11:50:54Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA4MjczMzc1",
          "commit": {
            "abbreviatedOid": "693d3ff"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-05-08T14:20:32Z",
          "updatedAt": "2020-05-08T14:20:32Z",
          "comments": []
        }
      ]
    },
    {
      "number": 335,
      "id": "MDExOlB1bGxSZXF1ZXN0NDE1ODA5OTQy",
      "title": "Fix HPKE setup function name",
      "url": "https://github.com/mlswg/mls-protocol/pull/335",
      "state": "MERGED",
      "author": "tomtau",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "In the latest HPKE draft (draft-irtf-cfrg-hpke-04), \"Initiator (I)\" was renamed to \"Sender (S)\".",
      "createdAt": "2020-05-11T00:47:59Z",
      "updatedAt": "2020-05-17T17:21:12Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "c519e9d8ac723ed19fa114198abb09922d1027f7",
      "headRepository": "tomtau/mls-protocol",
      "headRefName": "patch-1",
      "headRefOid": "4b76ac15dd0ed2c20069d8801f434b6be2488092",
      "closedAt": "2020-05-17T17:21:12Z",
      "mergedAt": "2020-05-17T17:21:12Z",
      "mergedBy": "beurdouche",
      "mergeCommit": {
        "oid": "bb3a3de94cc75e91dee62d24f702fb2b1b5d1182"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDEzMDg1Mzgw",
          "commit": {
            "abbreviatedOid": "4b76ac1"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-05-16T15:29:17Z",
          "updatedAt": "2020-05-16T15:29:17Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDEzMTgxOTAw",
          "commit": {
            "abbreviatedOid": "4b76ac1"
          },
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-05-17T17:20:58Z",
          "updatedAt": "2020-05-17T17:20:58Z",
          "comments": []
        }
      ]
    },
    {
      "number": 336,
      "id": "MDExOlB1bGxSZXF1ZXN0NDE5MDE0ODc4",
      "title": "PSK Injection, Group recovery, Re-Init, Sub-group Branching",
      "url": "https://github.com/mlswg/mls-protocol/pull/336",
      "state": "MERGED",
      "author": "br-hale",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "key schedule"
      ],
      "body": "Changes to key schedule and corresponding directions on use of PSKs for group recovery, re-initialization, sub-group branching, and external PSK injection.",
      "createdAt": "2020-05-16T19:48:40Z",
      "updatedAt": "2020-10-08T14:40:11Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "5f06f08d001054b74ce40b95bf4b2949eac81dc4",
      "headRepository": "br-hale/mls-protocol",
      "headRefName": "exporters",
      "headRefOid": "3846416b89e800292958566e8aff7081d34bb142",
      "closedAt": "2020-10-08T14:40:11Z",
      "mergedAt": "2020-10-08T14:40:10Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "dca87748bfc9b98b8ed34168e9fbf16fddccad79"
      },
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "I had some long-form comments on this PR, so I sent them to the mailing list.",
          "createdAt": "2020-06-17T22:54:38Z",
          "updatedAt": "2020-06-17T22:54:38Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE0NjAxMzg4",
          "commit": {
            "abbreviatedOid": "0106dff"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-05-19T16:06:10Z",
          "updatedAt": "2020-05-19T16:06:11Z",
          "comments": [
            {
              "originalPosition": 532,
              "body": "There already is a struct called `KeyPackage`",
              "createdAt": "2020-05-19T16:06:11Z",
              "updatedAt": "2020-10-08T11:32:33Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE1MDA0MzE5",
          "commit": {
            "abbreviatedOid": "0106dff"
          },
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-05-20T05:34:41Z",
          "updatedAt": "2020-05-20T05:34:41Z",
          "comments": [
            {
              "originalPosition": 532,
              "body": "Hm. Not sure how that got there. I don't think we intended renaming the struct. The change was supposed to be that the `psk`s are included in the Welcome message.",
              "createdAt": "2020-05-20T05:34:41Z",
              "updatedAt": "2020-10-08T11:32:33Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI2NzYyNTA2",
          "commit": {
            "abbreviatedOid": "20145e4"
          },
          "author": "chris-wood",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-09T03:22:17Z",
          "updatedAt": "2020-06-09T03:22:18Z",
          "comments": [
            {
              "originalPosition": 158,
              "body": "Over in TLS, we worked on an interface for injecting PSKs:\r\n\r\n   https://tools.ietf.org/html/draft-ietf-tls-external-psk-importer-05\r\n\r\nWe concluded binding the imported PSK to the target protocol and KDF was sufficient. Maybe the same thing should be done here, i.e., to ensure that an injected PSK for MLS v1.0 does not collide with one injected for a different version?",
              "createdAt": "2020-06-09T03:22:17Z",
              "updatedAt": "2020-10-08T11:32:33Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI2NzYzMDYx",
          "commit": {
            "abbreviatedOid": "20145e4"
          },
          "author": "chris-wood",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-09T03:24:05Z",
          "updatedAt": "2020-06-09T03:24:05Z",
          "comments": [
            {
              "originalPosition": 265,
              "body": "Are \"external\" PSKs fixed? Would it make sense for them to also include an epoch, to allow applications to roll them forward for some FS?",
              "createdAt": "2020-06-09T03:24:05Z",
              "updatedAt": "2020-10-08T11:32:33Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI2NzcwNjkx",
          "commit": {
            "abbreviatedOid": "20145e4"
          },
          "author": "br-hale",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-09T03:52:22Z",
          "updatedAt": "2020-06-09T03:52:23Z",
          "comments": [
            {
              "originalPosition": 265,
              "body": "External PSKs are required to be of an \"equivalent security level\" (although that terminology was added to the draft a long time ago and not yet defined). As such, any FS guarantees or other requirements must be met before being injected. It does not make sense to ratchet external PSK forward per MLS spec, as then we would be trying to correlate the time of existence of the PSK to MLS (i.e. parallel ratcheting); in that case the PSK is no longer external to the protocol but somehow correlated to it. The nonce prevents reuse, but any additional guarantees should be met by the application, not the protocol (going back to meeting requirements before being injected). ",
              "createdAt": "2020-06-09T03:52:23Z",
              "updatedAt": "2020-10-08T11:32:33Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI2NzcxMTU1",
          "commit": {
            "abbreviatedOid": "20145e4"
          },
          "author": "br-hale",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-09T03:54:07Z",
          "updatedAt": "2020-06-09T03:54:07Z",
          "comments": [
            {
              "originalPosition": 158,
              "body": "Adding the MLS version number to the PSK type sounds like a solid addition.",
              "createdAt": "2020-06-09T03:54:07Z",
              "updatedAt": "2020-10-08T11:32:33Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI2NzcxNjM4",
          "commit": {
            "abbreviatedOid": "20145e4"
          },
          "author": "chris-wood",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-09T03:55:58Z",
          "updatedAt": "2020-06-09T03:55:58Z",
          "comments": [
            {
              "originalPosition": 265,
              "body": "I\u2019m not sure I agree. You can certainly do the ratcheting outside of the protocol, but you can also do it inside. For example, send an epoch and psk_id, and hash forward the external PSK corresponding to the ID based on the epoch. Some applications might not be able to augment their external PSK provision machinery to ratchet, so handling it in the protocol can be appealing. Food for thought.",
              "createdAt": "2020-06-09T03:55:58Z",
              "updatedAt": "2020-10-08T11:32:33Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI2ODE2ODc5",
          "commit": {
            "abbreviatedOid": "20145e4"
          },
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-09T06:15:37Z",
          "updatedAt": "2020-06-09T06:15:37Z",
          "comments": [
            {
              "originalPosition": 265,
              "body": "So the proposal would be to extend MLS to allow ratcheting of \"external\" PSKs that continuously get injected into the protocol?\r\n\r\nIt's interesting, but it seems to me like we'd be creating a degree of redundancy here. MLS doesn't have very good FS capabilities (although they can be improved by something like RTreeKEM), so it's tempting to create a secondary mechanism, i.e. ratcheting a PSK along the epoch-chain. However, then the FS guarantees hinge on the FS properties of whatever means was used to distribute the PSK. So what is a scenario where the means of PSK distribution gives you better FS than MLS? If you have this really good out-of-band distribution channel for PSKs, do you really still need MLS?\r\n\r\nI don't think it's a bad idea, but I'm not sure how often it will be used and if it warrants the added complexity in the protocol. But that's maybe an issue we should discuss on the list or in the next virtual interim? \r\n\r\nIn any case, I think it's a good idea that's worth thinking about and that might match the use case of a number of people, but it's relatively orthogonal enough to our PR. Maybe it would be worth a new github issue?",
              "createdAt": "2020-06-09T06:15:37Z",
              "updatedAt": "2020-10-08T11:32:33Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI4Mjc4NDIy",
          "commit": {
            "abbreviatedOid": "20145e4"
          },
          "author": "br-hale",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-10T17:29:12Z",
          "updatedAt": "2020-06-10T17:29:12Z",
          "comments": [
            {
              "originalPosition": 265,
              "body": "This proposal it about taking in an external PSK, and then maintaining it in sync to protocol ratcheting. As FS is the main benefit of this, the working assumption/use case that it addresses is one where:\r\n\r\nA) the application does not have the capability of aligning security level of the PSK to the current epoch but provides it directly to the protocol (which begs the question of whether the application is checking \"equivalent security level\" for the PSK to begin with) and \r\n\r\nB) the external PSK will be used at multiple epochs (FS benefits become relevant when the external PSK has already been used in a past epoch).\r\n\r\nThis is a very specific case. Although it has clear benefits, those benefits derive from poor application choices or machinery.\r\n\r\nMany of the MLS protocol design choices have been made with the explicit goal of separating out necessary protocol actions and peripheral behavior that can be determined by the application, even if it has security implications (e.g. the entire key management of the AS is out of scope). In the same way, this proposal seems to be more suited to the architecture than the core protocol. Perhaps you can draft a PR on the architecture document for this? \r\n\r\nI will add a new github issue so people get a chance to comment as a relevant, separate issue.\r\n",
              "createdAt": "2020-06-10T17:29:12Z",
              "updatedAt": "2020-10-08T11:32:33Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI4MzE4Nzgy",
          "commit": {
            "abbreviatedOid": "20145e4"
          },
          "author": "chris-wood",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-10T18:23:48Z",
          "updatedAt": "2020-06-10T18:23:49Z",
          "comments": [
            {
              "originalPosition": 265,
              "body": "Yeah, it's certainly orthogonal. We can address it elsewhere (if at all)!",
              "createdAt": "2020-06-10T18:23:49Z",
              "updatedAt": "2020-10-08T11:32:33Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY0MDYzNzQ0",
          "commit": {
            "abbreviatedOid": "1646e19"
          },
          "author": "ericcornelissen",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-10T09:05:35Z",
          "updatedAt": "2020-08-10T09:05:35Z",
          "comments": [
            {
              "originalPosition": 78,
              "body": "Seems like the `confirmation_key` got duplicated accidentally\r\n\r\n```suggestion\r\n| `confirmation_key`      | \"confirm\"     |\r\n```",
              "createdAt": "2020-08-10T09:05:35Z",
              "updatedAt": "2020-10-08T11:32:33Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY0MDY1MjIy",
          "commit": {
            "abbreviatedOid": "1646e19"
          },
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-10T09:07:59Z",
          "updatedAt": "2020-08-10T09:07:59Z",
          "comments": [
            {
              "originalPosition": 78,
              "body": "Whoops you're right. For some reason I can't commit your suggestion, but I'll change the PR accordingly.",
              "createdAt": "2020-08-10T09:07:59Z",
              "updatedAt": "2020-10-08T11:32:33Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY0MzAyNjM4",
          "commit": {
            "abbreviatedOid": "1646e19"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-10T14:53:18Z",
          "updatedAt": "2020-08-10T16:03:58Z",
          "comments": [
            {
              "originalPosition": 183,
              "body": "```suggestion\r\n```",
              "createdAt": "2020-08-10T14:53:18Z",
              "updatedAt": "2020-10-08T11:32:33Z"
            },
            {
              "originalPosition": 110,
              "body": "Nit: Please format OPEN ISSUEs with the `<!-- -->` bracketing as below.",
              "createdAt": "2020-08-10T14:54:16Z",
              "updatedAt": "2020-10-08T11:32:33Z"
            },
            {
              "originalPosition": 134,
              "body": "It's not \"either/or\" -- when you signal to the existing members in Commit, you MUST include the same instructions in the Welcome.  So I would rephrase this more declaratively:\r\n\r\n> The injection of one or more PSKs into the key schedule is signalied by including a PreSharedKeys value in two places: (1) As an extension in the Commit that initiates a new epoch, and (2) in the GroupSecrets object carried in the Welcome message sent to members added in that epoch.",
              "createdAt": "2020-08-10T14:57:22Z",
              "updatedAt": "2020-10-08T11:32:33Z"
            },
            {
              "originalPosition": 165,
              "body": "\"... or a GroupSecrets object with the `psks` field set\"",
              "createdAt": "2020-08-10T14:58:25Z",
              "updatedAt": "2020-10-08T11:32:33Z"
            },
            {
              "originalPosition": 118,
              "body": "This seems like a good spot to indicate that PSKs are typed.\r\n\r\n> Each PSK in MLS has a type that designates how it was provisioned.  External PSKs are provided by the application logic.  Resumption PSKs are derived from the MLS key schedule, and used in cases where it is necessary to authenticate a member's participation in a prior group state:",
              "createdAt": "2020-08-10T15:01:37Z",
              "updatedAt": "2020-10-08T11:32:33Z"
            },
            {
              "originalPosition": 123,
              "body": "Instead of \"reboot\", suggest \"carry entropy from the old group forward into a new group with the desired parameters\"",
              "createdAt": "2020-08-10T15:02:56Z",
              "updatedAt": "2020-10-08T11:32:33Z"
            },
            {
              "originalPosition": 126,
              "body": "Just to confirm, \"securely\" here means, \"continuing members can verify that the newly added member was a prior participant.\r\n\r\nNote that this will have some complexity in practice, since the continuing members *also* have to have been in the group at that time.  So you couldn't have the following sequence:\r\n\r\n```\r\nEpoch 1: Group = {A, B, C}\r\n=== B loses sync with group ===\r\nEpoch 2: D added, Group = {A, B, C, D}\r\nEpoch 3: B is re-added with PSK to prove that they were in epoch 1\r\n```\r\n\r\n... because D won't have the PSK.",
              "createdAt": "2020-08-10T15:05:46Z",
              "updatedAt": "2020-10-08T11:32:33Z"
            },
            {
              "originalPosition": 162,
              "body": "```suggestion\r\n```",
              "createdAt": "2020-08-10T15:18:01Z",
              "updatedAt": "2020-10-08T11:32:33Z"
            },
            {
              "originalPosition": 139,
              "body": "Nit: I'm not sure if the `-` is allowed in the TLS syntax, but folks tend to reuse notation in programming, and it's definitely not allowed in variable/const names in typical programming languages.  Suggest `reinit`.",
              "createdAt": "2020-08-10T15:20:14Z",
              "updatedAt": "2020-10-08T11:32:33Z"
            },
            {
              "originalPosition": 139,
              "body": "I wonder whether all of these specializations are necessary, or whether a single `resumption` case would suffice.  If you include the *destination* group ID / epoch in the label as well, then you would have even better separation/context than you do here.",
              "createdAt": "2020-08-10T15:21:34Z",
              "updatedAt": "2020-10-08T11:32:33Z"
            },
            {
              "originalPosition": 152,
              "body": "Explicitly enumerating the cases here will be better for future extensibility.",
              "createdAt": "2020-08-10T15:21:58Z",
              "updatedAt": "2020-10-08T11:32:33Z"
            },
            {
              "originalPosition": 157,
              "body": "```suggestion\r\n} PreSharedKeyID;\r\n```",
              "createdAt": "2020-08-10T15:22:25Z",
              "updatedAt": "2020-10-08T11:32:33Z"
            },
            {
              "originalPosition": 175,
              "body": "`PreSharedKey(type);` doesn't make sense syntactically.  I think you can just replace these top two fields with `PreSharedKey psk_id`, since that specifies both the type and the value.",
              "createdAt": "2020-08-10T15:23:48Z",
              "updatedAt": "2020-10-08T11:32:33Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY0Mzg4MzQy",
          "commit": {
            "abbreviatedOid": "79ac9b9"
          },
          "author": "br-hale",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-10T16:28:58Z",
          "updatedAt": "2020-08-10T16:28:58Z",
          "comments": [
            {
              "originalPosition": 139,
              "body": "Dash removed to address first comment.\r\n\r\nFor second comment: a single resumption case does not cover key differences between the three options here, and mixing them into one (which was considered at length) causes issues down the line. In reinit, the original group must be fully terminated as a requirement, which is not the case in branching and recovery. Branching \"copies\" a subset of the current group into a new one, and it is essential that members know that this is not done with recovery (where a member is added back in, but there is no divergence in history). If the PSKtype does not signal distinctions sufficiently well, then there will likely be group authentication attacks over the history of group evolution (i.e. disagreement on what has occurred).",
              "createdAt": "2020-08-10T16:28:58Z",
              "updatedAt": "2020-10-08T11:32:33Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY0NDE0Nzky",
          "commit": {
            "abbreviatedOid": "2fa7ad4"
          },
          "author": "br-hale",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-10T17:04:56Z",
          "updatedAt": "2020-08-10T17:04:57Z",
          "comments": [
            {
              "originalPosition": 126,
              "body": "Good observation. Clarification added.",
              "createdAt": "2020-08-10T17:04:56Z",
              "updatedAt": "2020-10-08T11:32:33Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY0NTAyMDAw",
          "commit": {
            "abbreviatedOid": "6689044"
          },
          "author": "br-hale",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-10T19:13:20Z",
          "updatedAt": "2020-08-10T19:13:21Z",
          "comments": [
            {
              "originalPosition": 118,
              "body": "Addressed.",
              "createdAt": "2020-08-10T19:13:21Z",
              "updatedAt": "2020-10-08T11:32:33Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY0NTA2NDY0",
          "commit": {
            "abbreviatedOid": "7bd759d"
          },
          "author": "br-hale",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-10T19:20:36Z",
          "updatedAt": "2020-08-10T19:20:37Z",
          "comments": [
            {
              "originalPosition": 152,
              "body": "Addressed, according to what you seem to be requesting.",
              "createdAt": "2020-08-10T19:20:37Z",
              "updatedAt": "2020-10-08T11:32:33Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc1NDAwMTM1",
          "commit": {
            "abbreviatedOid": "3bbd706"
          },
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-26T11:34:09Z",
          "updatedAt": "2020-08-26T11:34:09Z",
          "comments": [
            {
              "originalPosition": 175,
              "body": "Good point. Should be fixed now.",
              "createdAt": "2020-08-26T11:34:09Z",
              "updatedAt": "2020-10-08T11:32:33Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc1NzU5MjU2",
          "commit": {
            "abbreviatedOid": "3bbd706"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-26T18:42:45Z",
          "updatedAt": "2020-08-26T20:48:09Z",
          "comments": [
            {
              "originalPosition": 115,
              "body": "I think this Open Issue can be removed -- it is closed by this PR!\r\n",
              "createdAt": "2020-08-26T18:42:45Z",
              "updatedAt": "2020-10-08T11:32:33Z"
            },
            {
              "originalPosition": 122,
              "body": "Is it really necessary to distinguish all of these cases at this level?\r\n\r\nIf so, then the above text needs to change from \"how it was provisioned\", because these types relate to *use*, not provisioning.",
              "createdAt": "2020-08-26T18:48:21Z",
              "updatedAt": "2020-10-08T11:32:33Z"
            },
            {
              "originalPosition": 246,
              "body": "Please revert these changes.",
              "createdAt": "2020-08-26T18:55:52Z",
              "updatedAt": "2020-10-08T11:32:33Z"
            },
            {
              "originalPosition": 269,
              "body": "Maybe \"Associating a New Group to a Previous Group\"",
              "createdAt": "2020-08-26T18:56:39Z",
              "updatedAt": "2020-10-08T11:32:33Z"
            },
            {
              "originalPosition": 281,
              "body": "Need to specify how big the nonce is.  `KDF.Nh`?\r\n\r\nBut I'm not clear on what the nonce reuse criterion here is.  TLS session resumption PSKs can be used for an arbitrary number of sessions, since the sessions into which the PSKs are injected are distinct for other reasons.  The same seems like it is true here: In both the branching and reinit cases, you have a fresh init secret that will cause the resulting secrets to diverge.",
              "createdAt": "2020-08-26T19:01:37Z",
              "updatedAt": "2020-10-08T11:32:33Z"
            },
            {
              "originalPosition": 281,
              "body": "It would be helpful to say here that in both of these cases, the association is signaled by including the PreSharedKeyID in the Welcome initiating the new group.",
              "createdAt": "2020-08-26T19:02:16Z",
              "updatedAt": "2020-10-08T11:32:33Z"
            },
            {
              "originalPosition": 349,
              "body": "Honestly, I'm not sure how much value this adds.  The new group already has a pointer to the old group (by way of the PSK ID).  The best that this can do is cause folks not to use the old group any more, and it seems like doing that at the application layer is sufficient.  The only thing doing it in MLS adds is that it gets into the transcript -- and by definition, the transcript doesn't matter after this!\r\n\r\nIf we're going to have a message here, I would propose we do it a bit differently:\r\n\r\n* Use a different message type, parallel to Proposal or Commit.  Commit advances the group to a new epoch; this operation does not.\r\n* ... and explain that this needs the same sequencing as Commit.\r\n* Have the semantic be just \"close\", with an optional forward pointer.\r\n* For the forward pointer, just use a hash of the Welcome message.\r\n\r\n```\r\nopaque WelcomeID<0..255>; \r\n\r\nstruct {\r\n    optional<WelcomeID> welcome_hash;\r\n} Close;\r\n```",
              "createdAt": "2020-08-26T20:40:37Z",
              "updatedAt": "2020-10-08T11:32:33Z"
            },
            {
              "originalPosition": 549,
              "body": "Please revert these unrelated changes.",
              "createdAt": "2020-08-26T20:45:45Z",
              "updatedAt": "2020-10-08T11:32:33Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc1OTA4NTQ5",
          "commit": {
            "abbreviatedOid": "3bbd706"
          },
          "author": "br-hale",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-26T22:08:22Z",
          "updatedAt": "2020-08-26T22:08:22Z",
          "comments": [
            {
              "originalPosition": 115,
              "body": "Actually not -- the \"security level\" is mentioned at different points in the document and still requires clarification as it is never defined. \r\n\r\nFor example, what does it mean for a PSK to be of the same security level as the intended group? In reality, we need to match intended PCS and FS levels, and that is determined by how often keys are ratcheted (including signature keys). If there is a mis-match with incoming external PSKs, then the value of use of a PSK may be minor. If the external PSK was a TLS exporter key for example, then its PCS/FS guarantees are partially dependent on its freshness. \r\n\r\nIf deniable signature keys are ever considered, then PSKs should also not undermine that \"security level\".\r\n\r\nSecurity level explanation is something probably belongs in the architecture doc.",
              "createdAt": "2020-08-26T22:08:22Z",
              "updatedAt": "2020-10-08T11:32:33Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc2NDM4NjE1",
          "commit": {
            "abbreviatedOid": "3bbd706"
          },
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-27T07:03:24Z",
          "updatedAt": "2020-08-27T07:03:25Z",
          "comments": [
            {
              "originalPosition": 122,
              "body": "Good point in that the types relate their use rather than their provisioning. What do you mean by \"at this level\"? We do agree that we need strong key separation between the different PSK types, right? That was one of the lessons of various TLS Key Schedule analysis. It's not quite clear to me what you are suggesting we change.",
              "createdAt": "2020-08-27T07:03:24Z",
              "updatedAt": "2020-10-08T11:32:33Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc2NDM4OTk4",
          "commit": {
            "abbreviatedOid": "3bbd706"
          },
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-27T07:04:02Z",
          "updatedAt": "2020-08-27T07:04:03Z",
          "comments": [
            {
              "originalPosition": 246,
              "body": "Sorry about that. There must have been a mixup when merging. I'll fix it.",
              "createdAt": "2020-08-27T07:04:02Z",
              "updatedAt": "2020-10-08T11:32:33Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc2NDM5MTkw",
          "commit": {
            "abbreviatedOid": "3bbd706"
          },
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-27T07:04:21Z",
          "updatedAt": "2020-08-27T07:04:21Z",
          "comments": [
            {
              "originalPosition": 269,
              "body": "Works for me.",
              "createdAt": "2020-08-27T07:04:21Z",
              "updatedAt": "2020-10-08T11:32:34Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc2NDY0MDI3",
          "commit": {
            "abbreviatedOid": "3bbd706"
          },
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-27T07:41:45Z",
          "updatedAt": "2020-08-27T07:41:46Z",
          "comments": [
            {
              "originalPosition": 349,
              "body": "I understand that you're reluctant to bloat the proposal space like this. However, I think a ReInit proposal serves two purposes. 1) It allows an external party (e.g. the DS) to indicate to the group that they should change/upgrade the group. A ReInit proposal authenticates the DS' intent and even the upgrade/change it wants to do.\r\n2) It makes sure that the group agrees on the ReInit. The PSK in the Welcome message is derived from the epoch _after_ the commit, so everyone must have processed it and registered that the group should be closed.\r\n\r\nI think both authentication and agreement are valuable properties for an action that has the power to change ciphersuite, version and extensions.\r\n\r\nOther than potentially bloating the number of proposals we have: Why not have a ReInit proposal?",
              "createdAt": "2020-08-27T07:41:46Z",
              "updatedAt": "2020-10-08T11:32:34Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc2NDg3ODAx",
          "commit": {
            "abbreviatedOid": "b8e1283"
          },
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-27T08:15:16Z",
          "updatedAt": "2020-08-27T08:15:17Z",
          "comments": [
            {
              "originalPosition": 246,
              "body": "Never mind. It was actually emacs, which \"cleared up\" all markdown tables upon saving the file -.-",
              "createdAt": "2020-08-27T08:15:16Z",
              "updatedAt": "2020-10-08T11:32:34Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc2OTMwNzA0",
          "commit": {
            "abbreviatedOid": "b8e1283"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-27T17:22:53Z",
          "updatedAt": "2020-08-28T14:00:07Z",
          "comments": [
            {
              "originalPosition": 115,
              "body": "Sorry, I meant the \"external coordination via proposal\" open issue.",
              "createdAt": "2020-08-27T17:22:53Z",
              "updatedAt": "2020-10-08T11:32:34Z"
            },
            {
              "originalPosition": 122,
              "body": "Concretely, do we need different `PSKType` values for these different cases, or would a single `recovery` value be sufficient?",
              "createdAt": "2020-08-27T17:23:43Z",
              "updatedAt": "2020-10-08T11:32:34Z"
            },
            {
              "originalPosition": 349,
              "body": "As to \"why not\" -- typically we try not to put things in the protocol that don't do anything ;)\r\n\r\nBut your two points are a convincing argument that this does do something, namely (1) provides an authenticated \"nudge\" to re-init, and more importantly (2) advances the group to a final \"tail epoch\" that is used only for initializing the next group.\r\n\r\nI think I still prefer that it be a Handshake message rather than a Proposal. That way you don't have to worry about what it means to have other Proposals or a `path` in the Commit.  And you can specify that a `Close` message is processed by \"closing off\" the key schedule:\r\n\r\n```\r\n                  init_secret_[n]\r\n                         |\r\n                         V\r\n          0 ------> KDF.Extract = final_secret\r\n```\r\n\r\nThe only additional complexity would be that now the rule is \"you can only have one Commit **or Close** message per epoch\", where the bold bit is the addition.  Doesn't seem too bad.  I kind of like that it rounds out the key schedule, complementing the \"initial fresh init secret\" discussion we had recently:\r\n\r\n```\r\n                   init_secret_[0]\r\n                         |\r\n                         V\r\n          [normal key schedule diagram as above]\r\n                         |\r\n                         V\r\n                   init_secret_[1]\r\n                         |\r\n                         V\r\n                        ...\r\n                         |\r\n                         V\r\n                   init_secret_[n]\r\n                         |\r\n                         V\r\n               0 -> KDF.Extract \r\n                         |\r\n                         V\r\n                    final_secret\r\n```\r\n",
              "createdAt": "2020-08-27T18:00:03Z",
              "updatedAt": "2020-10-08T11:32:34Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc3Nzk5Mjc5",
          "commit": {
            "abbreviatedOid": "b8e1283"
          },
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-28T14:57:41Z",
          "updatedAt": "2020-08-28T14:57:42Z",
          "comments": [
            {
              "originalPosition": 349,
              "body": "> As to \"why not\" -- typically we try not to put things in the protocol that don't do anything ;)\r\n\r\nPoint taken  :smile: \r\n\r\nRegarding the handshake message: I wasn't aware that they're also pretty extensible, so sure, that would work as well. Just to make sure I understand correctly: The server would be able to send the message themselves (if they're \"preconfigured\") and the message would be authenticated, right? Also, we would have to add the data fields to the handshake message instead like so:\r\n```\r\nstruct {\r\n    opaque group_id<0..255>;\r\n    uint64 epoch;\r\n    Sender sender;\r\n    opaque authenticated_data<0..2^32-1>;\r\n\r\n    ContentType content_type;\r\n    select (MLSPlaintext.content_type) {\r\n        case application:\r\n          opaque application_data<0..2^32-1>;\r\n\r\n        case proposal:\r\n          Proposal proposal;\r\n\r\n        case commit:\r\n          Commit commit;\r\n          opaque confirmation_tag<0..255>;\r\n\r\n        case close:\r\n          ProtocolVersion version;\r\n          CipherSuite cipher_suite;\r\n          Extension extensions<0..2^32-1>;\r\n    }\r\n\r\n    opaque signature<0..2^16-1>;\r\n} MLSPlaintext;\r\n```\r\nFor maximum security guarantees, we could also add a `confirmation_tag` just like for the commit.",
              "createdAt": "2020-08-28T14:57:41Z",
              "updatedAt": "2020-10-08T11:32:34Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc3ODAxNTk1",
          "commit": {
            "abbreviatedOid": "b8e1283"
          },
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-28T15:00:32Z",
          "updatedAt": "2020-08-28T15:00:33Z",
          "comments": [
            {
              "originalPosition": 122,
              "body": "I think we do to properly separate the keys depending on their use. This is comparable to TLS, where improper separation between application- and resumption PSKs led to problems down the road. However, we sill only need to derive a single value off of the Key Schedule, as the type is used later when the PSK gets injected into the Key Schedule.",
              "createdAt": "2020-08-28T15:00:33Z",
              "updatedAt": "2020-10-08T11:32:34Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgxMTYyOTUy",
          "commit": {
            "abbreviatedOid": "b8e1283"
          },
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-02T18:36:38Z",
          "updatedAt": "2020-09-02T18:36:39Z",
          "comments": [
            {
              "originalPosition": 269,
              "body": "Tweaked the title a little. It's now \"Linking a New Group to an Existing Group\".",
              "createdAt": "2020-09-02T18:36:39Z",
              "updatedAt": "2020-10-08T11:32:34Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgxMTYzNzA0",
          "commit": {
            "abbreviatedOid": "b8e1283"
          },
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-02T18:37:40Z",
          "updatedAt": "2020-09-02T18:37:40Z",
          "comments": [
            {
              "originalPosition": 281,
              "body": "I've specified the nonce length to be `KDF.Nh` and added an open issue regarding the possibility to avoid the nonce altogether using the GroupId of the new group.",
              "createdAt": "2020-09-02T18:37:40Z",
              "updatedAt": "2020-10-08T11:32:34Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgxMTcwNDUy",
          "commit": {
            "abbreviatedOid": "b8e1283"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-02T18:47:28Z",
          "updatedAt": "2020-09-02T19:11:02Z",
          "comments": [
            {
              "originalPosition": 122,
              "body": "OK, I can live with this.",
              "createdAt": "2020-09-02T18:47:28Z",
              "updatedAt": "2020-10-08T11:32:34Z"
            },
            {
              "originalPosition": 281,
              "body": "^^^ still outstanding",
              "createdAt": "2020-09-02T18:48:31Z",
              "updatedAt": "2020-10-08T11:32:34Z"
            },
            {
              "originalPosition": 115,
              "body": "^^^ still outstanding",
              "createdAt": "2020-09-02T18:48:38Z",
              "updatedAt": "2020-10-08T11:32:34Z"
            },
            {
              "originalPosition": 349,
              "body": "> The server would be able to send the message themselves (if they're \"preconfigured\") and the message would be authenticated, right?\r\n\r\nYep, it would be sent as an MLSPlaintext, so the normal authentication stuff applies.  \r\n\r\nSyntactically, I think it would be even simpler than what you lay out.  We would just define a Close object parallel to commit that has the forward-pointer to the new group (NB: see below).  So where you have the version/cipher_suite fields, we would just have Close object.\r\n\r\nCouple of other points:\r\n\r\n* Is this message useful when closing the group *without a successor*?\r\n    * If so, then the forward pointer needs to be optional\r\n    * If not (so there's always a successor), suggest renaming Close -> Replace\r\n* `version+cipher_suite` seems like an odd way to refer to a new group.  Propose we just send the Welcome or H(Welcome) here, since that will implicitly bind to these fields as well as the group ID, membership, etc.  \r\n\r\n```\r\nstruct {\r\n    opaque welcome_hash<0..255>; // or \r\n    Welcome welcome;\r\n} Replace;\r\n```\r\n\r\n* Just to confirm, the receiver processing of this message is:\r\n    * Ratchet the key schedule forward with commit_secret = 0 to get the last epoch\r\n    * Verify the confirmation tag in the new/last epoch\r\n    * Produce a PSK of type `reinit` (or maybe `replace`), which can be referenced in the new Welcome\r\n* ... which means the sender processing would be:\r\n    * Create a Welcome for the new group referencing the reinit PSK (as groupID + last_epoch)\r\n    * Ratchet to the last epoch => reinit PSK\r\n    * Create MLSPlaintext(Replace(H(Welcome)))\r\n\r\nA little convoluted, but not an unexpected amount of interlock.\r\n\r\n",
              "createdAt": "2020-09-02T18:54:04Z",
              "updatedAt": "2020-10-08T11:32:34Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgyMzkzMDAy",
          "commit": {
            "abbreviatedOid": "05d1f8a"
          },
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-04T06:35:00Z",
          "updatedAt": "2020-09-04T06:35:00Z",
          "comments": [
            {
              "originalPosition": 349,
              "body": "Very good points. Using the Welcome message seems like an elegant way to link the groups.\r\nRegarding ReInit vs. Replace, I have no strong opinion on that. Replace seems a little more direct, so I'll go with that for now. I'll make the changes either today or over the weekend so hopefully we can get the green light for a merge on Tuesday :-)",
              "createdAt": "2020-09-04T06:35:00Z",
              "updatedAt": "2020-10-08T11:32:34Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgzMTE3NTI2",
          "commit": {
            "abbreviatedOid": "05d1f8a"
          },
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-06T07:05:35Z",
          "updatedAt": "2020-09-06T07:05:35Z",
          "comments": [
            {
              "originalPosition": 349,
              "body": "I just noticed that if we use a Welcome message (or its hash) in the Replace message, then the Server won't be able to send it, because it lacks the necessary information to craft it. So until we find a better way of doing it, I'm going with the way I originally sketched. Let me know if you have another idea.\r\n\r\n(The `Capabilities` struct is pretty close to what we need, but the name is a little misleading in that context.)",
              "createdAt": "2020-09-06T07:05:35Z",
              "updatedAt": "2020-10-08T11:32:34Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgzMTIwODc0",
          "commit": {
            "abbreviatedOid": "05d1f8a"
          },
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-06T07:55:03Z",
          "updatedAt": "2020-09-06T07:55:03Z",
          "comments": [
            {
              "originalPosition": 349,
              "body": "If we go for a Handshake Message as opposed to a Proposal, it's also not clear, which group member sends the Welcome message for the new group, as the Close message can come from the Server itself. The Server could nominate a member, but it doesn't know if that member is online and so there is a risk that other members would then have to wait for that member to come online. The other possibility is to just have any member do it, which would create a race condition and possibly multiple follow-up groups.\r\n\r\n Do you have an idea on how to deal with that? Since there is otherwise not that much of a difference between Handshake Message and Proposal, I'm inclined to stick with a Proposal, but rename it to \"Close\" and make the content optional.",
              "createdAt": "2020-09-06T07:55:03Z",
              "updatedAt": "2020-10-08T11:32:34Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkzNTE2NDgw",
          "commit": {
            "abbreviatedOid": "5fb03bd"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "This is getting real close.  Just a few things to tighten up.",
          "createdAt": "2020-09-22T14:23:41Z",
          "updatedAt": "2020-09-22T14:42:10Z",
          "comments": [
            {
              "originalPosition": 139,
              "body": "Not an extension, a new Proposal.  Seems like the content of the Proposal and the extension can be the same object?  Or since we're doing multiplicities here, the Welcome extension would have the union of the Proposals.",
              "createdAt": "2020-09-22T14:23:41Z",
              "updatedAt": "2020-10-08T11:32:34Z"
            },
            {
              "originalPosition": 318,
              "body": "Nit: I would prefer to spell out PreSharedKey.\r\n\r\nDo we need a separate structure here, or could we re-use the PreSharedKeys struct defined above?",
              "createdAt": "2020-09-22T14:25:10Z",
              "updatedAt": "2020-10-08T11:32:34Z"
            },
            {
              "originalPosition": 343,
              "body": "Do we want to specify a PSK that carries over from the old group to the new group?  So you would define here something like: The new Welcome MUST have a PreSharedKey extension with a `reinit` entry pointing to the epoch initiated by the Commit that covers the ReInit proposal.",
              "createdAt": "2020-09-22T14:30:22Z",
              "updatedAt": "2020-10-08T11:32:34Z"
            },
            {
              "originalPosition": 354,
              "body": "I would strike this.  It's up to the committer to decide what they commit.  For example, if someone proposes adding a nonsense PSK, that shouldn't get committed.",
              "createdAt": "2020-09-22T14:32:13Z",
              "updatedAt": "2020-10-08T11:32:34Z"
            },
            {
              "originalPosition": 364,
              "body": "```suggestion\r\nIf there are multiple ReInit proposals during an epoch, the committer MUST choose exactly one to include in the Commit message.  The `version` field in the ReInit proposal MUST be no less than the version for the current group.  A client processing a Commit that covers multiple ReInit proposals or a ReInit proposal with a lower version MUST reject it as malformed.  The committer SHOULD choose a ReInit proposal with a unique `group_id` and parameters that are supported by all clients in the group.\r\n```",
              "createdAt": "2020-09-22T14:37:17Z",
              "updatedAt": "2020-10-08T11:32:34Z"
            },
            {
              "originalPosition": 378,
              "body": "```suggestion\r\n  * A ReInit proposal is applied by marking the group as \"closed\".  Further proposals and commits for this group MUST be rejected.  The group's only further purpose is to provide a PSK used by the successor group.\r\n```",
              "createdAt": "2020-09-22T14:39:10Z",
              "updatedAt": "2020-10-08T11:32:34Z"
            },
            {
              "originalPosition": 378,
              "body": "Actually, this probably goes in the receiver processing below...",
              "createdAt": "2020-09-22T14:40:09Z",
              "updatedAt": "2020-10-08T11:32:34Z"
            },
            {
              "originalPosition": 430,
              "body": "```suggestion\r\n* Verify that at most one ReInit proposal is present and that the `mls_version`\r\n```",
              "createdAt": "2020-09-22T14:40:26Z",
              "updatedAt": "2020-10-08T11:32:34Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkzNTkwMDMx",
          "commit": {
            "abbreviatedOid": "5fb03bd"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2020-09-22T15:30:37Z",
          "updatedAt": "2020-09-22T15:40:06Z",
          "comments": [
            {
              "originalPosition": 191,
              "body": "Maybe for the sake of efficiency, concat all the `psk_[i]` before they're put into Extract?",
              "createdAt": "2020-09-22T15:30:37Z",
              "updatedAt": "2020-10-08T11:32:34Z"
            },
            {
              "originalPosition": 211,
              "body": "```suggestion\r\nThere are three ways in which a `recovery_secret` can be used: to re-initialize\r\n```",
              "createdAt": "2020-09-22T15:33:23Z",
              "updatedAt": "2020-10-08T11:32:34Z"
            },
            {
              "originalPosition": 229,
              "body": "I think you definitely need to elaborate on what this means / how it would be done?",
              "createdAt": "2020-09-22T15:34:41Z",
              "updatedAt": "2020-10-08T11:32:34Z"
            },
            {
              "originalPosition": 154,
              "body": "- empty line",
              "createdAt": "2020-09-22T15:38:13Z",
              "updatedAt": "2020-10-08T11:32:34Z"
            },
            {
              "originalPosition": 132,
              "body": "Please elaborate on how recovery happens. From skimming, it's not clear how I would do this",
              "createdAt": "2020-09-22T15:39:54Z",
              "updatedAt": "2020-10-08T11:32:34Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk0NDE4ODE5",
          "commit": {
            "abbreviatedOid": "ea04350"
          },
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-23T08:25:34Z",
          "updatedAt": "2020-09-23T08:25:34Z",
          "comments": [
            {
              "originalPosition": 139,
              "body": "Right, it's a Proposal (again). Hm. Right now, the Proposal contains a single `PreSharedKeyID`, while the `Welcome` contains an array of `PreSharedKeyID`s. So the `Welcome` needs to contain the PSKs referenced by the Proposals in the order in which the individual Proposals are contained in the Commit. Is that what you meant?",
              "createdAt": "2020-09-23T08:25:34Z",
              "updatedAt": "2020-10-08T11:32:34Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk0NDIwODU5",
          "commit": {
            "abbreviatedOid": "ea04350"
          },
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-23T08:27:56Z",
          "updatedAt": "2020-09-23T08:27:57Z",
          "comments": [
            {
              "originalPosition": 318,
              "body": "I'll change it such that it spells it out. As I mentioned in my comment above, the Proposal only contains a single `PreSharedKeyID`, while `PreSharedKeys` contains an array. We could change that, though. I don't have a strong opinion on this, so I'll leave it as it is for now.",
              "createdAt": "2020-09-23T08:27:56Z",
              "updatedAt": "2020-10-08T11:32:34Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk0NDIxNjgz",
          "commit": {
            "abbreviatedOid": "ea04350"
          },
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-23T08:28:52Z",
          "updatedAt": "2020-09-23T08:28:52Z",
          "comments": [
            {
              "originalPosition": 343,
              "body": "That's exactly what we want to do, so you're right indeed.",
              "createdAt": "2020-09-23T08:28:52Z",
              "updatedAt": "2020-10-08T11:32:34Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk0NDMxODUz",
          "commit": {
            "abbreviatedOid": "10c3316"
          },
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-23T08:41:22Z",
          "updatedAt": "2020-09-23T08:41:23Z",
          "comments": [
            {
              "originalPosition": 132,
              "body": "Good point. That's a relic from a past design that actually supported recovery. I'll remove it, as it is not relevant anymore.",
              "createdAt": "2020-09-23T08:41:22Z",
              "updatedAt": "2020-10-08T11:32:34Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk0NDM4NzY1",
          "commit": {
            "abbreviatedOid": "10c3316"
          },
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-23T08:49:49Z",
          "updatedAt": "2020-09-23T08:49:49Z",
          "comments": [
            {
              "originalPosition": 139,
              "body": "Note, that it's not an extension in the `Welcome` anymore, but instead an optional `PreSharedKeys` field in the `GroupSecrets` object.",
              "createdAt": "2020-09-23T08:49:49Z",
              "updatedAt": "2020-10-08T11:32:34Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk0NDgwNzI2",
          "commit": {
            "abbreviatedOid": "10c3316"
          },
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-23T09:40:39Z",
          "updatedAt": "2020-09-23T09:40:40Z",
          "comments": [
            {
              "originalPosition": 318,
              "body": "Terminology is a bit tricky. We have \"PSK\"s (i.e. the concrete keys), but now we also have \"PreSharedKey\" which is the name of the Proposal. However, the Proposal in turn only contains `PreSharedKeyID`s, i.e. pointers to how the PSK can be derived.",
              "createdAt": "2020-09-23T09:40:39Z",
              "updatedAt": "2020-10-08T11:32:34Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk3NTAyMTQ4",
          "commit": {
            "abbreviatedOid": "850704b"
          },
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-28T13:18:51Z",
          "updatedAt": "2020-09-28T13:18:51Z",
          "comments": [
            {
              "originalPosition": 229,
              "body": "I've added another sentence or two on what this is supposed to achieve and how.",
              "createdAt": "2020-09-28T13:18:51Z",
              "updatedAt": "2020-10-08T11:32:34Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk3NTExNzM0",
          "commit": {
            "abbreviatedOid": "850704b"
          },
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-28T13:29:03Z",
          "updatedAt": "2020-09-28T13:29:04Z",
          "comments": [
            {
              "originalPosition": 191,
              "body": "I'm not sure what the assumptions would be under which we could prove that secure. Other than a random oracle that is. Since I don't think it's likely that people will inject more than one PSK at once very often, I'd rather leave this as it is.",
              "createdAt": "2020-09-28T13:29:04Z",
              "updatedAt": "2020-10-08T11:32:34Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk3ODE5Mjc2",
          "commit": {
            "abbreviatedOid": "850704b"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-09-28T19:09:25Z",
          "updatedAt": "2020-09-28T19:09:25Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk3ODI5MjAz",
          "commit": {
            "abbreviatedOid": "850704b"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2020-09-28T19:24:30Z",
          "updatedAt": "2020-09-28T21:19:46Z",
          "comments": [
            {
              "originalPosition": 109,
              "body": "```suggestion\r\n<!-- OPEN ISSUE: Clarify lifetime vs security level mandated above. E.g. if\r\n```",
              "createdAt": "2020-09-28T19:24:30Z",
              "updatedAt": "2020-10-08T11:32:34Z"
            },
            {
              "originalPosition": 113,
              "body": "```suggestion\r\n<!-- OPEN ISSUE: Define \"security level\", and what it means to match the\r\n```",
              "createdAt": "2020-09-28T19:24:38Z",
              "updatedAt": "2020-10-08T11:32:34Z"
            },
            {
              "originalPosition": 139,
              "body": "Please make zero `reserved`",
              "createdAt": "2020-09-28T21:00:18Z",
              "updatedAt": "2020-10-08T11:32:34Z"
            },
            {
              "originalPosition": 147,
              "body": "```suggestion\r\n  select (PreSharedKeyID.psktype) {\r\n```",
              "createdAt": "2020-09-28T21:01:03Z",
              "updatedAt": "2020-10-08T11:32:34Z"
            },
            {
              "originalPosition": 159,
              "body": "Never used",
              "createdAt": "2020-09-28T21:04:19Z",
              "updatedAt": "2020-10-08T11:32:34Z"
            },
            {
              "originalPosition": 489,
              "body": "```suggestion\r\n  optional<PreSharedKeys> psks;\r\n```",
              "createdAt": "2020-09-28T21:05:13Z",
              "updatedAt": "2020-10-08T11:32:34Z"
            },
            {
              "originalPosition": 173,
              "body": "References Commit extensions",
              "createdAt": "2020-09-28T21:06:39Z",
              "updatedAt": "2020-10-08T11:32:34Z"
            },
            {
              "originalPosition": 182,
              "body": "```suggestion\r\npsk_input_[i] = KDF.Extract(psk_[i], \"\")\r\n```",
              "createdAt": "2020-09-28T21:10:38Z",
              "updatedAt": "2020-10-08T11:32:34Z"
            },
            {
              "originalPosition": 212,
              "body": "Probably can get rid of the last sentence in this paragraph, it comes off as hostile",
              "createdAt": "2020-09-28T21:15:38Z",
              "updatedAt": "2020-10-08T11:32:34Z"
            },
            {
              "originalPosition": 225,
              "body": "Try to compress this section into one paragraph",
              "createdAt": "2020-09-28T21:18:56Z",
              "updatedAt": "2020-10-08T11:32:34Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk4MTA5NTM2",
          "commit": {
            "abbreviatedOid": "a1833cf"
          },
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-29T05:39:07Z",
          "updatedAt": "2020-09-29T05:39:08Z",
          "comments": [
            {
              "originalPosition": 159,
              "body": "It's used in the derivation of `psk_secret`. `PSKLabel` contains the `PreSharedKeyID`, which in turn contains the nonce.",
              "createdAt": "2020-09-29T05:39:07Z",
              "updatedAt": "2020-10-08T11:32:34Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk4MTEwNTcz",
          "commit": {
            "abbreviatedOid": "6c7a4d8"
          },
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-29T05:41:55Z",
          "updatedAt": "2020-09-29T05:41:56Z",
          "comments": [
            {
              "originalPosition": 173,
              "body": "Good catch. I thought I'd gotten rid of all of that stuff.",
              "createdAt": "2020-09-29T05:41:55Z",
              "updatedAt": "2020-10-08T11:32:34Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk4MTExMTM0",
          "commit": {
            "abbreviatedOid": "6c7a4d8"
          },
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-29T05:43:27Z",
          "updatedAt": "2020-09-29T05:43:27Z",
          "comments": [
            {
              "originalPosition": 182,
              "body": "What's wrong with calling `Extract` like this?",
              "createdAt": "2020-09-29T05:43:27Z",
              "updatedAt": "2020-10-08T11:32:34Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk4MTE0Nzgz",
          "commit": {
            "abbreviatedOid": "6c7a4d8"
          },
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-29T05:53:21Z",
          "updatedAt": "2020-09-29T05:53:21Z",
          "comments": [
            {
              "originalPosition": 225,
              "body": "I've shortened it a little bit and left it with two paragraphs. It should be in keeping with the style of the rest of the spec now.",
              "createdAt": "2020-09-29T05:53:21Z",
              "updatedAt": "2020-10-08T11:32:34Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA0NjgxMDUx",
          "commit": {
            "abbreviatedOid": "8d6d8a8"
          },
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-08T11:23:31Z",
          "updatedAt": "2020-10-08T11:23:32Z",
          "comments": [
            {
              "originalPosition": 182,
              "body": "I think Extract specifies the left input to be the keying material and the right one the salt. Since I  would consider `psk_[i]` as the keying material, I'll leave it on the right for now. I'm pretty sure we rely on Extract to provide a \"good\" result independent of the \"good\" input being on the left or the right side anyway, so we should be safe either way.",
              "createdAt": "2020-10-08T11:23:31Z",
              "updatedAt": "2020-10-08T11:32:34Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA0ODUwNTEz",
          "commit": {
            "abbreviatedOid": "3846416"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-08T14:34:37Z",
          "updatedAt": "2020-10-08T14:34:47Z",
          "comments": [
            {
              "originalPosition": 182,
              "body": "Nope, the IKM is on the right: `Extract(salt, ikm)`.  I agree this is unlikely to be an issue, but it seems more conservative to use the IKM slot.\r\n\r\nhttps://github.com/cfrg/draft-irtf-cfrg-hpke/blob/master/draft-irtf-cfrg-hpke.md#cryptographic-dependencies",
              "createdAt": "2020-10-08T14:34:37Z",
              "updatedAt": "2020-10-08T14:34:47Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA0ODUzODYy",
          "commit": {
            "abbreviatedOid": "3846416"
          },
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-08T14:37:38Z",
          "updatedAt": "2020-10-08T14:37:38Z",
          "comments": [
            {
              "originalPosition": 182,
              "body": "Right, sorry. That's what I meant to say, just got the directions confused. Anyway, we're calling with the psk on the right right now, so we should be good.",
              "createdAt": "2020-10-08T14:37:38Z",
              "updatedAt": "2020-10-08T14:37:39Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA0ODU1OTQ3",
          "commit": {
            "abbreviatedOid": "3846416"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-10-08T14:39:38Z",
          "updatedAt": "2020-10-08T14:39:55Z",
          "comments": [
            {
              "originalPosition": 182,
              "body": "Ah right.  I got mixed up on which was the thing in the PR and which was Brendan's edit.  I agree that the PR has the PSK in the IKM slot.",
              "createdAt": "2020-10-08T14:39:38Z",
              "updatedAt": "2020-10-08T14:39:55Z"
            }
          ]
        }
      ]
    },
    {
      "number": 337,
      "id": "MDExOlB1bGxSZXF1ZXN0NDE5MTA5NjA4",
      "title": "Replace DKDF by n-PRF in key schedule; minor fix",
      "url": "https://github.com/mlswg/mls-protocol/pull/337",
      "state": "CLOSED",
      "author": "chrisbrzuska",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "security",
        "work in progress",
        "discussion",
        "key schedule"
      ],
      "body": "We propose to replace the two-stage Extract-Expand-\r\nExtract-Expand method to derive a single key from\r\nmultiple input keys by an Expand-XOR-Expand method.\r\n\r\nAs a small fix we added the Context argument to the\r\nDerive-Secret function and pass it on to the\r\nHKDF-Extract-Label function. In the key schedule\r\ngraph the function was called with the Context\r\nargument, but it wasn't present in the function\r\ndefinition of Derive-Secret.\r\n\r\nMotivation for the Expand-XOR-Expand method:\r\n- Extract was not used before, KDF was used as DPRF only.\r\n- Previous construction relied on ad hoc assumption on DPRF/DKDF\r\n- Previous construction required uniqueness of secrets to obtain distinct and independent keys (can be fragile when keys are under adversarial control)\r\n- n-PRF reduces reliance on uniqueness of secrets and instead relies on the uniqueness of a public value under the protocol designer's control\r\n\r\nTodo: Find/Design a unique public value.\r\n\r\nThis commit was co-authored by @keks and @chrisbrzuska.",
      "createdAt": "2020-05-17T12:57:24Z",
      "updatedAt": "2020-10-19T15:22:34Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "c519e9d8ac723ed19fa114198abb09922d1027f7",
      "headRepository": "keks/mls-protocol",
      "headRefName": "cb_jw/nprf",
      "headRefOid": "1785e973b99fa395bd0cfce982f7241c5785a59b",
      "closedAt": "2020-10-19T15:22:34Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "NONE",
          "body": "@chrisbrzuska are you certain this general construction gives us an n-PRF with the desired properties? To what extent does it rely on HMAC/HKDF? What if we wanted to replace HMAC with a different PRF?",
          "createdAt": "2020-06-09T03:17:35Z",
          "updatedAt": "2020-06-09T03:17:56Z"
        },
        {
          "author": "jhoyla",
          "authorAssociation": "NONE",
          "body": "> I don't like that before, we had Extract calls which theoretically turn non-uniform randomness into uniform randomness, and now that's all replaced with HKDF-Expand calls that theoretically always assume the randomness is uniform.\r\n\r\nI agree with @Bren2010, what's the theory justification for changing to an Expand-XOR-Expand?\r\nGiven that Expand and Extract are both calls to an underlying HMAC this is potentially OK, but it's definitely not obvious. \r\n\r\nThe unique value in the `Derive-Secrets` acts as a salt, and the key material acts as the IKM, so the first call to `Derive-Secrets` can act as `HKDF-Extract`, and the subsequent calls to `Derive-Secret` can act as `HKDF-Expand`s, but I think there should be an explicit requirement / mentioning that the two functions must always have different types when used as `Extract`s vs `Expand`s. \r\n\r\nAs far as I can tell this mostly seems to be a labelling change, renaming `Extract` to overload `Expand`. A security section expanding on why this is secure, preferably with some references to computational proofs would be really good here. \r\n\r\nIt might be better to just define a new `HKDF-Extract`-type function as `(Expand-XOR)`, and enforce a different label in the inner `Extract` step. That would hopefully prevent any collisions of subkeys. \r\n\r\nIt also seems like you could define \r\n```\r\nDerive-Secret(Secret, Label, Context) =\r\n        Derive-Secrets([Secret], 1, Label, Context)\r\n```\r\nso we need to be aware of type collisions there as well. \r\n\r\n",
          "createdAt": "2020-06-17T14:25:35Z",
          "updatedAt": "2020-06-17T14:25:35Z"
        },
        {
          "author": "chrisbrzuska",
          "authorAssociation": "NONE",
          "body": "> > I don't like that before, we had Extract calls which theoretically turn non-uniform randomness into uniform randomness, and now that's all replaced with HKDF-Expand calls that theoretically always assume the randomness is uniform.\r\n> \r\n> I agree with @Bren2010, what's the theory justification for changing to an Expand-XOR-Expand?\r\n> Given that Expand and Extract are both calls to an underlying HMAC this is potentially OK, but it's definitely not obvious.\r\n> \r\n> The unique value in the `Derive-Secrets` acts as a salt, and the key material acts as the IKM, so the first call to `Derive-Secrets` can act as `HKDF-Extract`, and the subsequent calls to `Derive-Secret` can act A security section expanding on why this is secure, preferably with some references to computational proofs would be really good here.\r\n\r\nHere is the accompanying paper with a full discussion of advantages/disadvantages and computational proofs:\r\nhttp://chrisbrzuska.de/2020-NPRF.html\r\n\r\nWhat would be a suitable location for the security section?",
          "createdAt": "2020-06-17T14:42:14Z",
          "updatedAt": "2020-06-17T14:42:14Z"
        },
        {
          "author": "jhoyla",
          "authorAssociation": "NONE",
          "body": "@chrisbrzuska Have you submitted your paper somewhere for publication / peer review?\r\nI had a read of it, and I tried to follow some of your proofs, but despite the excellent diagrams I really struggled. \r\n\r\nThere are many very similarly named things that it's unclear what the difference is. For example I couldn't figure out the difference between CORE_{GNPRF}^0 and CORE^0_{NPRF}. \r\nThe text says:\r\n> CORE_{GNPRF}^0 is defined in Figure 20a\r\n\r\nBut 20a is labelled `CORE^0_{NPRF},R^0_{NPRF}`\r\n\r\nI also was a bit confused by the overloading of `Eval`.\r\n\r\nAnother issue I had was finding all the parts of the proof. To follow the NPRF proof, for example, requires huge amounts of paging back and forth through the document, which large gaps between sections (for the other proofs). Could you possibly share the TeX file, or provide a re-ordered document with all the pieces of each proof next to each other. It would really help people to evaluate the proof. \r\n(A glossary which explains what each thing is and provides a link to the definition would be awesome too.)\r\n\r\nEven though I couldn't completely follow the proofs it does look like all the pieces are there, so maybe add a section to the Security Considerations with a link to the paper. I think if people find this proof satisfactory then this change seems reasonable.\r\n\r\nI know this is getting a bit off topic, but I found a couple of nits in your paper. Things like on page 12 you have `skX_i = skY = \u22a5`, which seems like it should be `skX_i = skY_i = \u22a5`. Let me know if a list would be helpful to you. \r\n",
          "createdAt": "2020-06-19T17:35:13Z",
          "updatedAt": "2020-06-19T17:35:13Z"
        },
        {
          "author": "chrisbrzuska",
          "authorAssociation": "NONE",
          "body": ">>> Let me know if a list would be helpful to you.\r\n\r\n@jhoyla Thank you for the close read, very appreciated. Yes, a list of nits as well as any other feedback would be very useful to us. Especially, also: How did you proceed to read the proof? What distracted, confused or annoyed you? Which were the bits which required page-scrolling? What came first to my mind is the Key package, but I guess there are more parts of the proof which require scrolling? The idea of a glossary is nice.\r\n\r\nPeer review: We submitted the article to Asiacrypt.",
          "createdAt": "2020-06-19T20:03:19Z",
          "updatedAt": "2020-06-19T21:38:20Z"
        },
        {
          "author": "jhoyla",
          "authorAssociation": "NONE",
          "body": "Hi @chrisbrzuska\r\n\r\nI tried to read the proof by following just the proof for the NPRF. I wanted to see all the stages in their simplest form.\r\nI read the paper from start to finish, just skimming the proofs, just to get a sense of what was going on, and then I started to work backwards from Claim 1.\r\nThe first step of the proof is to compare Figure 20a, Figure 17a, and Figure 15a, or pages 35, 26, and 21. \r\nThen one must refer to Fig. 14, Fig. 13a, and Fig. 10 or pages 18, 16, and 12.\r\n\r\nFigure 19 brings them all together, but I like to compare the details. The big jumps from 35 to 26 and 21 are particularly frustrating.\r\nI ended up screenshotting all the definitions and putting them side by side in powerpoint. \r\n\r\nI was able to convince myself that claim 1 is true, but I didn't really follow the proof in Section 6.2. \r\n\r\nI struggled with both the logic of the steps, i.e. that each step followed from the previous step, and with understanding the conclusion.\r\nIn very informal terms, my understanding of the reduction in Fig 20a-d is:\r\nReplace the PRF with the collision resistant PRF.\r\nThe XOR can now be replaced with the collision resistant XOR.\r\nThe PRF can then be replaced with the non-collision resistant PRF.\r\nFig. 20d thus describes the collision resistant NPRF.\r\nIs that approximately right?\r\n\r\nWith respect to the result, the probability equation has terms that I can't evaluate.\r\nWhat does e_{PRF}(B\u2192R^1_{NPRF}) actually evaluate to? \r\nIs it obvious that it is \u2264 e_{PRF}(A)?\r\n\r\nNits / Clarification questions:\r\n1. In the Key package, is there a requirement that the public name be _cryptographically_ bound to the key? \r\n2. Figure 7. could use a more permanent reference, i.e. \"current\" will change eventually.\r\n3. On pg. 12 should `skXi = skY = \u22a5` read `skXi = skYi = \u22a5`?\r\n4. Is there a significance to `sort` being unstable?\r\n5. On pg. 14 you write \"Finally in Section 3.2\", when 3.2 is not the last subsection of section 3.\r\n6. Some of your references have gone a bit weird, specifically [1,3,4,5,8,10,11,12,16]. \"in [name], editor\" seems wrong.\r\n7. Please add a reference to [Kra10] by the min-entropy def. \r\n8. The pseudo-code in Fig. 12 is out of order. `Set(h, k, ctr)` should read `Set(ctr, k, h)` I think.\r\n9. In Fig. 13b. should the lower `Key^{00}` read `Key^{b0}`?\r\n10. Ditto with Fig. 13c.\r\n11. In Fig. 13c. `k <- xtr(S, pkX^Y)` should read `k <- xtr(S, pkX^y)` (i.e. the `Y` should be in lower case.)\r\n12. In Fig. 14 `S: {0, 1}^{l}` should probably read `S: {0,1}^{sl}`. \r\n13. \"thus duped\" should probably read \"thus dubbed\".\r\n14. The package CRPRF is never defined as such. The definition appears in Fig. 14 with the label GcrPRF^b. Without a glossary it's hard to know whether GcrPRF \u225f NPRF \u225f CRPRF.\r\n15. The final column of Fig. 19 replaces code with f_{cfNPRF}, but the code does not exactly match. `f_{PRF}(k_i, (ctx1, i), ol)`  is replaced with `f_{PRF}(k_i, (ctx1, i))`, i.e. the final parameter disappears.\r\n\r\nI didn't try and go through the other 2 code comparisons exactly, but if I have time I will.  ",
          "createdAt": "2020-06-22T15:13:53Z",
          "updatedAt": "2020-06-22T15:13:53Z"
        },
        {
          "author": "chrisbrzuska",
          "authorAssociation": "NONE",
          "body": "Hi @jhoyla \r\n\r\nThanks a lot for the thorough read and the reading feedback! It took me a while to get around integrating your suggested changes into the document. I started with the nits and clarifications (comments below). Will post the new document within the next days.\r\n\r\n> Nits / Clarification questions:\r\n> \r\n> 1. In the Key package, is there a requirement that the public name be _cryptographically_ bound to the key?\r\n\r\nNo, it can be a purely administrative value. However, in the NamePRF and the DHNPRF construction, we explore the use of cryptographic public names (handles).\r\n\r\n> 2. Figure 7. could use a more permanent reference, i.e. \"current\" will change eventually.\r\n\r\nGood point. Done.\r\n\r\n> 3. On pg. 12 should `skXi = skY = \u22a5` read `skXi = skYi = \u22a5`?\r\n\r\nThank you for catching this. Fixed.\r\n\r\n> 4. Is there a significance to `sort` being unstable?\r\n\r\nWhat does 'unstable' mean in this context?\r\n\r\n> 5. On pg. 14 you write \"Finally in Section 3.2\", when 3.2 is not the last subsection of section 3.\r\n\r\nFixed.\r\n\r\n> 6. Some of your references have gone a bit weird, specifically [1,3,4,5,8,10,11,12,16]. \"in [name], editor\" seems wrong.\r\n\r\nThank you, not yet fixed.\r\n\r\n> 7. Please add a reference to [Kra10] by the min-entropy def.\r\n\r\nFixed.\r\n\r\n> 8. The pseudo-code in Fig. 12 is out of order. `Set(h, k, ctr)` should read `Set(ctr, k, h)` I think.\r\n\r\nThat's correct. Thanks! Fixed.\r\n\r\n> 9. In Fig. 13b. should the lower `Key^{00}` read `Key^{b0}`?\r\n> 10. Ditto with Fig. 13c.\r\n\r\nIndeed. Fixed.\r\n\r\n> 11. In Fig. 13c. `k <- xtr(S, pkX^Y)` should read `k <- xtr(S, pkX^y)` (i.e. the `Y` should be in lower case.)\r\n> 12. In Fig. 14 `S: {0, 1}^{l}` should probably read `S: {0,1}^{sl}`.\r\n\r\nFixed.\r\n\r\n> 13. \"thus duped\" should probably read \"thus dubbed\".\r\n\r\nFixed :-D\r\n\r\n> 14. The package CRPRF is never defined as such. The definition appears in Fig. 14 with the label GcrPRF^b. Without a glossary it's hard to know whether GcrPRF \u225f NPRF \u225f CRPRF.\r\n\r\nClarified Fig. 14 to describe the packages crPRF and PRF. There should be no \"CRPRF\", this is a typo. Removed throughout the paper. NPRF is not equal to CPRF, too bad there was a confusion.\r\n\r\n> 15. The final column of Fig. 19 replaces code with f_{cfNPRF}, but the code does not exactly match. `f_{PRF}(k_i, (ctx1, i), ol)`  is replaced with `f_{PRF}(k_i, (ctx1, i))`, i.e. the final parameter disappears.\r\n\r\nRight. We are still wondering whether different output lengths are needed or not and are inconsistent w.r.t. this currently in the paper. Will make it uniform once we determined whether this is needed.",
          "createdAt": "2020-07-14T16:17:36Z",
          "updatedAt": "2020-07-14T16:17:36Z"
        },
        {
          "author": "seanturner",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@chrisbrzuska Here's a link to the [CFRG](https://irtf.org/cfrg) (Crypto Forum Research Group).  It's in IRTF (Internet Research Task Force) the sister organization of the IETF. As noted during the interim, there a lot of cryptographers there and IETF WGs often go to get a review of crypto-related items. You can subscribe [here](https://www.irtf.org/mailman/listinfo/cfrg).",
          "createdAt": "2020-07-14T17:03:56Z",
          "updatedAt": "2020-07-14T17:03:56Z"
        },
        {
          "author": "chrisbrzuska",
          "authorAssociation": "NONE",
          "body": "> @chrisbrzuska Here's a link to the [CFRG](https://irtf.org/cfrg) (Crypto Forum Research Group). It's in IRTF (Internet Research Task Force) the sister organization of the IETF. As noted during the interim, there a lot of cryptographers there and IETF WGs often go to get a review of crypto-related items. You can subscribe [here](https://www.irtf.org/mailman/listinfo/cfrg).\r\n\r\n@seanturner: Excellent, thank you! I subscribed and will be there tomorrow in case I get an opportunity to present the design.",
          "createdAt": "2020-07-14T22:19:40Z",
          "updatedAt": "2020-07-14T22:19:40Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "This PR has fallen a bit behind, and the key schedule has been updated so that it's less relevant.  Still open to the idea of n-PRF, but it will need a new PR.",
          "createdAt": "2020-10-19T15:22:34Z",
          "updatedAt": "2020-10-19T15:22:34Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE0NjI3MTEx",
          "commit": {
            "abbreviatedOid": "8fec56a"
          },
          "author": "wbl",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-05-19T16:35:44Z",
          "updatedAt": "2020-05-19T16:35:44Z",
          "comments": [
            {
              "originalPosition": 26,
              "body": "Are you sure you don't mean Secretn here?",
              "createdAt": "2020-05-19T16:35:44Z",
              "updatedAt": "2020-05-19T19:13:13Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE0ODQ4NjY1",
          "commit": {
            "abbreviatedOid": "1785e97"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "In general, this seems like a nice simplification.  Couple of minor questions.",
          "createdAt": "2020-05-19T21:49:25Z",
          "updatedAt": "2020-05-19T21:54:32Z",
          "comments": [
            {
              "originalPosition": 95,
              "body": "Is there a reason that `unique_value` needs to be folded in  both at the `epoch_secret` level and for the secrets derived from it?  Seems like it would be simpler to fold it into the `epoch_secret`.",
              "createdAt": "2020-05-19T21:49:26Z",
              "updatedAt": "2020-05-19T21:54:32Z"
            },
            {
              "originalPosition": 71,
              "body": "The `(x, y)` syntax is not defined.  And in any case, I think `GroupContext_[n]` is the unique value you're looking for.",
              "createdAt": "2020-05-19T21:49:54Z",
              "updatedAt": "2020-05-19T21:54:32Z"
            },
            {
              "originalPosition": 95,
              "body": "Also, \"unique\" in what sense?",
              "createdAt": "2020-05-19T21:53:04Z",
              "updatedAt": "2020-05-19T21:54:32Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE0ODU5NDgz",
          "commit": {
            "abbreviatedOid": "1785e97"
          },
          "author": "chrisbrzuska",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-05-19T22:10:17Z",
          "updatedAt": "2020-05-19T22:10:17Z",
          "comments": [
            {
              "originalPosition": 26,
              "body": "Thanks! Fixed that.",
              "createdAt": "2020-05-19T22:10:17Z",
              "updatedAt": "2020-05-19T22:10:17Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE0ODY4OTIx",
          "commit": {
            "abbreviatedOid": "1785e97"
          },
          "author": "chrisbrzuska",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-05-19T22:31:11Z",
          "updatedAt": "2020-05-19T22:31:11Z",
          "comments": [
            {
              "originalPosition": 95,
              "body": "Excellent questions! Thanks :-)\r\n\r\n**Double use of unique value:**\r\nDerive-Secrets derives a keys from each input keys and xors them and the result is assigned to epoch_secret. It is important that the inputs to the xor have not been used before and the unique value ensures that. tl;dr: 1st use of unique_value is needed for pseudorandomness.\r\n\r\nThe second use of the unique value ensures that different sessions derive different key values. For honest sessions, this is the case anyway (since pseudorandom key values are unlikely to collide), but for dishonest sessions, the unique value is needed since the xor does not maintain collision-resistance.\r\n\r\n**Definition of unique:**\r\nIn a call to a Derive-Secrets function with fixed label, e.g.,\r\n\r\nDerive-Secrets([., ., .], \"combine\", unique_value),\r\n\r\nthe unique-value should not repeat (across protocol runs), even with different input keys. In Derive-Secret with fixed label, e.g., \r\n\r\nDerive-Secret(., \"sender data\", (unique_value,.)),\r\n\r\nthe unique-value should not repeat (across protocol runs), even with different input keys. However, it is allowed that unique_values are re-used when the labels are different.",
              "createdAt": "2020-05-19T22:31:11Z",
              "updatedAt": "2020-05-19T22:31:11Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE0ODcxODU2",
          "commit": {
            "abbreviatedOid": "1785e97"
          },
          "author": "chrisbrzuska",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-05-19T22:37:47Z",
          "updatedAt": "2020-05-19T22:37:47Z",
          "comments": [
            {
              "originalPosition": 71,
              "body": "(x,y) should refer to an injective encoding of pairs. If GroupContext_[n] is already unique, this simplifies the construction and would be very nice. We were hoping that GroupContext_[n] is already unique, but we don't have the full MLS context to make this judgement. Is GroupContext_[n] also already available at the point when we compute the epoch_secret?",
              "createdAt": "2020-05-19T22:37:47Z",
              "updatedAt": "2020-05-19T22:37:48Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIyOTcxNjAx",
          "commit": {
            "abbreviatedOid": "1785e97"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "I don't like that before, we had Extract calls which theoretically turn non-uniform randomness into uniform randomness, and now that's all replaced with HKDF-Expand calls that theoretically always assume the randomness is uniform.",
          "createdAt": "2020-06-02T18:58:55Z",
          "updatedAt": "2020-06-02T19:23:00Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "Please update all the calls to HKDF-Expand-Label with the new arguments",
              "createdAt": "2020-06-02T18:58:55Z",
              "updatedAt": "2020-06-02T19:23:00Z"
            },
            {
              "originalPosition": 23,
              "body": "I think the correct syntax here would be `Secrets[0]`, `Secrets[1]` ...",
              "createdAt": "2020-06-02T19:01:17Z",
              "updatedAt": "2020-06-02T19:23:00Z"
            },
            {
              "originalPosition": 23,
              "body": "Also, you've added extra spaces before \"n, \" but they don't seem to align with the last call",
              "createdAt": "2020-06-02T19:02:22Z",
              "updatedAt": "2020-06-02T19:23:00Z"
            },
            {
              "originalPosition": 1,
              "body": "The line just above here references HKDF-Extract, which is no longer used anywhere. Please remove",
              "createdAt": "2020-06-02T19:04:39Z",
              "updatedAt": "2020-06-02T19:23:00Z"
            },
            {
              "originalPosition": 14,
              "body": "Just \"uint8\" no \"_t\"",
              "createdAt": "2020-06-02T19:05:24Z",
              "updatedAt": "2020-06-02T19:23:00Z"
            },
            {
              "originalPosition": 28,
              "body": "```suggestion\r\nwhere n is the length of Secrets.\r\n```",
              "createdAt": "2020-06-02T19:06:45Z",
              "updatedAt": "2020-06-02T19:23:00Z"
            },
            {
              "originalPosition": 65,
              "body": "Not enough arguments to Derive-Secrets",
              "createdAt": "2020-06-02T19:10:09Z",
              "updatedAt": "2020-06-02T19:23:00Z"
            },
            {
              "originalPosition": 71,
              "body": "Yes GroupContext_[n] is what you're looking for, and I also don't like the tuples.",
              "createdAt": "2020-06-02T19:12:18Z",
              "updatedAt": "2020-06-02T19:23:00Z"
            },
            {
              "originalPosition": 65,
              "body": "The label \"combine\" is weird, maybe \"epoch\" instead",
              "createdAt": "2020-06-02T19:22:56Z",
              "updatedAt": "2020-06-02T19:23:00Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMwMTYxMjc1",
          "commit": {
            "abbreviatedOid": "1785e97"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-13T19:36:47Z",
          "updatedAt": "2020-06-13T19:36:47Z",
          "comments": [
            {
              "originalPosition": 95,
              "body": "Thanks for the clarification on the double input.\r\n\r\nI think the GroupContext value does meet the requirement for uniqueness here.  It contains the following values:\r\n\r\n* Group ID\r\n* Epoch\r\n* Tree hash\r\n* Transcript hash\r\n\r\nObviously, GroupID and Epoch provide a first level of protection, and the tree hash diverges if there are any different choices of keys. Even if the participants make the same choices in two protocol runs, HPKE uses random keys which are fed into the transcript hash, so will be different.",
              "createdAt": "2020-06-13T19:36:47Z",
              "updatedAt": "2020-06-13T19:36:47Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMwMTYxMzg0",
          "commit": {
            "abbreviatedOid": "1785e97"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-13T19:38:44Z",
          "updatedAt": "2020-06-13T19:38:44Z",
          "comments": [
            {
              "originalPosition": 71,
              "body": "Thanks for the clarification.  We would want a defined injective encoding here.  But if we agree that GroupContext is unique enough, maybe we can just use that?",
              "createdAt": "2020-06-13T19:38:44Z",
              "updatedAt": "2020-06-13T19:38:44Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ4MTY1MDM3",
          "commit": {
            "abbreviatedOid": "1785e97"
          },
          "author": "chrisbrzuska",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-14T14:32:44Z",
          "updatedAt": "2020-07-14T14:32:45Z",
          "comments": [
            {
              "originalPosition": 28,
              "body": "Sorry for the delay in my response. Is the length of Secrets equal to the number of secrets?",
              "createdAt": "2020-07-14T14:32:44Z",
              "updatedAt": "2020-07-14T14:32:45Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ4MzY2NTcw",
          "commit": {
            "abbreviatedOid": "1785e97"
          },
          "author": "chrisbrzuska",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-14T18:38:09Z",
          "updatedAt": "2020-07-14T18:38:09Z",
          "comments": [
            {
              "originalPosition": 95,
              "body": "Okay, this sounds very good, thank you!",
              "createdAt": "2020-07-14T18:38:09Z",
              "updatedAt": "2020-07-14T18:38:09Z"
            }
          ]
        }
      ]
    },
    {
      "number": 338,
      "id": "MDExOlB1bGxSZXF1ZXN0NDE5ODc1MzUx",
      "title": "Rely More on HPKE",
      "url": "https://github.com/mlswg/mls-protocol/pull/338",
      "state": "MERGED",
      "author": "rozbb",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "The first commit is editorial. I removed all the DH terminology I could find and replaced it with KEM terminology.\r\n\r\nThe second commit is related to https://github.com/cfrg/draft-irtf-cfrg-hpke/pull/79. It would massively reduce complexity of implementations if people were able to rely on HPKE to do all private key parsing, key validation, public key computation, etc. Currently, all the information in the deleted CFRG and NIST sections is either redundant (performed by HPKE) or outdated and performed correctly by HPKE (e.g., old P-256 DH secret representation). Instead of having all this duplicated, it would be easier to keep it in one place.\r\n\r\nAn issue with the new definition of `Derive-Key-Pair`: Repeatedly calling `HKDF-Expand-Label` can be computationally expensive. Each call requires computing the group hash (which, okay, it could be cached) and serializing a struct. It would be nice to do something that's cheaper but still ties context into the secret key generation.",
      "createdAt": "2020-05-19T04:50:08Z",
      "updatedAt": "2020-06-13T19:29:38Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "bb3a3de94cc75e91dee62d24f702fb2b1b5d1182",
      "headRepository": "rozbb/mls-protocol",
      "headRefName": "hpke_updates",
      "headRefOid": "1a39053ade8469decba8a3c682a887927edb2f83",
      "closedAt": "2020-06-13T19:29:38Z",
      "mergedAt": "2020-06-13T19:29:37Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "8bb36cb9cbede8e383d8a1a59e5e8473f7f25302"
      },
      "comments": [
        {
          "author": "rozbb",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Update: This now uses HPKE's `DeriveKeyPair` function to do all the heavy lifting",
          "createdAt": "2020-05-19T19:48:32Z",
          "updatedAt": "2020-05-19T19:48:32Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE0NjgxMTI3",
          "commit": {
            "abbreviatedOid": "ef319c5"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-05-19T17:44:16Z",
          "updatedAt": "2020-05-19T17:44:16Z",
          "comments": [
            {
              "originalPosition": 28,
              "body": "I think it would make more sense for the ciphersuite / HPKE to define how it generates a private key, given a seed, than to specify an Unmarshal function and do rejection sampling. Rejection sampling isn't guaranteed to work for many schemes -- RSA being the one that comes to mind, but possibly some PQ schemes also.",
              "createdAt": "2020-05-19T17:44:16Z",
              "updatedAt": "2020-06-10T03:56:52Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE0Njk2OTQw",
          "commit": {
            "abbreviatedOid": "ef319c5"
          },
          "author": "rozbb",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-05-19T18:04:17Z",
          "updatedAt": "2020-05-19T18:04:17Z",
          "comments": [
            {
              "originalPosition": 28,
              "body": "This is a great point. In this case, `Derive-Key-Pair` should just be HPKE's version of `Derive-Key-Pair`, possibly after some HKDF step. This also lets us avoid doing an `Expand-Label` for every iteration.",
              "createdAt": "2020-05-19T18:04:17Z",
              "updatedAt": "2020-06-10T03:56:52Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIyOTY3MjAy",
          "commit": {
            "abbreviatedOid": "59080fc"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-06-02T18:52:46Z",
          "updatedAt": "2020-06-02T18:52:46Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI2MjYyNTIz",
          "commit": {
            "abbreviatedOid": "59080fc"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-06-08T13:50:03Z",
          "updatedAt": "2020-06-08T13:51:53Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "Might be clearer to write something like `KEM.Nsk`.",
              "createdAt": "2020-06-08T13:50:03Z",
              "updatedAt": "2020-06-10T03:56:52Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI2NzU3MzY5",
          "commit": {
            "abbreviatedOid": "59080fc"
          },
          "author": "chris-wood",
          "authorAssociation": "NONE",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-06-09T03:03:45Z",
          "updatedAt": "2020-06-09T03:03:45Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMwMTYwODU4",
          "commit": {
            "abbreviatedOid": "1a39053"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-06-13T19:29:30Z",
          "updatedAt": "2020-06-13T19:29:30Z",
          "comments": []
        }
      ]
    },
    {
      "number": 339,
      "id": "MDExOlB1bGxSZXF1ZXN0NDIwMDU2ODc5",
      "title": "Upper bound on group size in early phase too low",
      "url": "https://github.com/mlswg/mls-protocol/pull/339",
      "state": "MERGED",
      "author": "raphaelrobert",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "The co-path might contain a high number of resolved nodes when the tree is still empty. The worst case is ~N which is why the limit should be the same as for sender ID.",
      "createdAt": "2020-05-19T11:28:27Z",
      "updatedAt": "2020-05-20T08:03:54Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "bb3a3de94cc75e91dee62d24f702fb2b1b5d1182",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "raphaelrobert-upper-bound",
      "headRefOid": "24356b922bd0039ba9b83e9071b5a69c9cf1b196",
      "closedAt": "2020-05-19T17:32:33Z",
      "mergedAt": "2020-05-19T17:32:33Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "c0f69e7f6b96afdffd9f45a7c73d1ef81f9ea99a"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE0NDIyNDA3",
          "commit": {
            "abbreviatedOid": "24356b9"
          },
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-05-19T13:04:17Z",
          "updatedAt": "2020-05-19T13:04:17Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE0NjcyMTEx",
          "commit": {
            "abbreviatedOid": "24356b9"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Thank you for changing this to what my code has been doing all along :)",
          "createdAt": "2020-05-19T17:32:25Z",
          "updatedAt": "2020-05-19T17:32:25Z",
          "comments": []
        }
      ]
    },
    {
      "number": 341,
      "id": "MDExOlB1bGxSZXF1ZXN0NDIxMjc2MzA3",
      "title": "Fix in lifetime extension",
      "url": "https://github.com/mlswg/mls-protocol/pull/341",
      "state": "MERGED",
      "author": "raphaelrobert",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-05-21T10:30:26Z",
      "updatedAt": "2020-10-05T15:44:26Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "c0f69e7f6b96afdffd9f45a7c73d1ef81f9ea99a",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "raphaelrobert-lifetime",
      "headRefOid": "31f69d9c823045e7eb5734898c27459fa2f1955d",
      "closedAt": "2020-05-22T19:16:53Z",
      "mergedAt": "2020-05-22T19:16:53Z",
      "mergedBy": "beurdouche",
      "mergeCommit": {
        "oid": "48442a2491bfd8e044ddfb044d8db9f029204384"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE2MDQ5MTIy",
          "commit": {
            "abbreviatedOid": "31f69d9"
          },
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-05-21T10:45:43Z",
          "updatedAt": "2020-05-21T10:45:43Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE3MTE1MjQ2",
          "commit": {
            "abbreviatedOid": "31f69d9"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-05-22T18:40:27Z",
          "updatedAt": "2020-05-22T18:40:27Z",
          "comments": []
        }
      ]
    },
    {
      "number": 342,
      "id": "MDExOlB1bGxSZXF1ZXN0NDI1NDA5MjQx",
      "title": "Allow external proposals to be signed.",
      "url": "https://github.com/mlswg/mls-protocol/pull/342",
      "state": "MERGED",
      "author": "Bren2010",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #323 by special-casing external senders. Removing the GroupContext would allow me to take messages that user A sent in one instance of a group, and make it look like they're speaking in another group by re-encrypting the ciphertext.",
      "createdAt": "2020-05-30T03:52:30Z",
      "updatedAt": "2020-06-16T19:07:44Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "48442a2491bfd8e044ddfb044d8db9f029204384",
      "headRepository": "Bren2010/mls-protocol",
      "headRefName": "brendan/2020.5.0",
      "headRefOid": "1cafde832e0e21da7a0ffba0a36994dae86655ab",
      "closedAt": "2020-06-16T19:07:44Z",
      "mergedAt": "2020-06-16T19:07:43Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "85b5cdad9aa59408e6fc1f1390dbba60351413e5"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIyODczMzg2",
          "commit": {
            "abbreviatedOid": "d15f1cc"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-02T16:52:47Z",
          "updatedAt": "2020-06-02T17:06:17Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "I might prefer something like the following, in order to preserve the property that the signed data is `prefix || MLSPlaintext`:\r\n\r\n```\r\nstruct {\r\n  select (MLSPlaintextTBS.sender.sender_type) {\r\n    case member:\r\n      opaque tree_hash<0..255>;\r\n      opaque confirmed_transcript_hash<0..255>;\r\n\r\n    case preconfigured, new_member:\r\n      struct{};\r\n  }\r\n\r\n  opaque group_id<0..255>;\r\n  uint64 epoch;\r\n   ...\r\n}\r\n```",
              "createdAt": "2020-06-02T16:52:48Z",
              "updatedAt": "2020-06-03T03:26:00Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIzMTkyNzY5",
          "commit": {
            "abbreviatedOid": "1b021d8"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-03T03:23:42Z",
          "updatedAt": "2020-06-03T03:23:42Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "- Also included extensions\r\n- I think this struct is technically un-parse-able because the select is before the field that the select is on, but implementations can probably cheat to get it to work",
              "createdAt": "2020-06-03T03:23:42Z",
              "updatedAt": "2020-06-03T03:26:00Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMxODEyMDYw",
          "commit": {
            "abbreviatedOid": "1cafde8"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-16T19:07:35Z",
          "updatedAt": "2020-06-16T19:07:35Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "It doesn't actually need to be parseable, just serializable.  If you wanted to make it parseable, you could change the `select` to an `optional<GroupContext>` and mandate is presence when `sender_type == member`.",
              "createdAt": "2020-06-16T19:07:35Z",
              "updatedAt": "2020-06-16T19:07:35Z"
            }
          ]
        }
      ]
    },
    {
      "number": 343,
      "id": "MDExOlB1bGxSZXF1ZXN0NDI1NDYxMzMy",
      "title": "Upper bound for Commit",
      "url": "https://github.com/mlswg/mls-protocol/pull/343",
      "state": "MERGED",
      "author": "raphaelrobert",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "The upper bound for the number of Proposals of each type in a Commit is currently 2^16.\r\n\r\nThis makes it impossible to create groups with more than 2^16 members in one go and it also limits the number of UpdateProposals and RemoveProposals that can happen between two Commits to 2^16.",
      "createdAt": "2020-05-30T12:44:18Z",
      "updatedAt": "2020-10-05T15:44:28Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "48442a2491bfd8e044ddfb044d8db9f029204384",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "raphaelrobert-large-groups",
      "headRefOid": "3471ad65d73f02400d87dc59303c5f66d8d91026",
      "closedAt": "2020-06-13T19:42:56Z",
      "mergedAt": "2020-06-13T19:42:56Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "e38aac72400f157bff29f96810234e39230753d1"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMwMTYxNTk4",
          "commit": {
            "abbreviatedOid": "3471ad6"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-06-13T19:42:49Z",
          "updatedAt": "2020-06-13T19:42:49Z",
          "comments": []
        }
      ]
    },
    {
      "number": 345,
      "id": "MDExOlB1bGxSZXF1ZXN0NDMyNDM0ODM1",
      "title": "no need extra layer of optional in GroupInfo.tree",
      "url": "https://github.com/mlswg/mls-protocol/pull/345",
      "state": "CLOSED",
      "author": "yihuang",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "since the Node is optional inside.",
      "createdAt": "2020-06-10T12:53:35Z",
      "updatedAt": "2020-06-16T19:05:39Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "48442a2491bfd8e044ddfb044d8db9f029204384",
      "headRepository": "yihuang/mls-protocol",
      "headRefName": "remove-optional",
      "headRefOid": "d8557b07b54ae5f03bd1cae7cfaacfd7cf7b0006",
      "closedAt": "2020-06-16T19:05:39Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "yihuang",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> You do need the `optional<...>` because some of the nodes may be blank\r\n\r\nBut there is already optional inside `Node` type:\r\n```\r\nstruct {\r\n    NodeType node_type;\r\n    select (Node.node_type) {\r\n        case leaf:   optional<KeyPackage> key_package;\r\n        case parent: optional<ParentNode> node;\r\n    };\r\n} Node;\r\n```\r\n\r\nSo we already can express blank nodes like this:\r\n```\r\n[ Node(Leaf, none)\r\n, Node(Parent, none)\r\n, ...\r\n]\r\n```\r\n\r\nNo need for extra optional, there should be no difference between: `None` and `Node(Leaf, none)`, right?",
          "createdAt": "2020-06-10T16:25:36Z",
          "updatedAt": "2020-06-10T16:27:02Z"
        },
        {
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "body": "This should really be replaced by a commit hash so that the tree can be transmitted out-of-band (cf. #344). The TLS encoding doesn't scale very well here for large groups and we also want to allow server assist to work.",
          "createdAt": "2020-06-10T16:26:56Z",
          "updatedAt": "2020-06-10T16:26:56Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "@yihuang I think your analysis is correct here, but I would eliminate the other `optional<>`.  That is, something like:\r\n\r\n```\r\nstruct {\r\n    NodeType node_type;\r\n    select (Node.node_type) {\r\n        case leaf:   KeyPackage key_package;\r\n        case parent: ParentNode node;\r\n    };\r\n} Node;\r\n\r\noptional<Node> tree<1..2^32-1>;\r\n```\r\n\r\nIf we agree on the approach here, I can implement it in #348, which makes the tree optional as @raphaelrobert suggests.",
          "createdAt": "2020-06-13T18:46:53Z",
          "updatedAt": "2020-06-13T18:46:53Z"
        },
        {
          "author": "yihuang",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> @yihuang I think your analysis is correct here, but I would eliminate the other `optional<>`. That is, something like:\r\n> \r\n> ```\r\n> struct {\r\n>     NodeType node_type;\r\n>     select (Node.node_type) {\r\n>         case leaf:   KeyPackage key_package;\r\n>         case parent: ParentNode node;\r\n>     };\r\n> } Node;\r\n> \r\n> optional<Node> tree<1..2^32-1>;\r\n> ```\r\n> \r\n> If we agree on the approach here, I can implement it in #348, which makes the tree optional as @raphaelrobert suggests.\r\n\r\nYour approach is even better.",
          "createdAt": "2020-06-14T02:32:35Z",
          "updatedAt": "2020-06-14T02:32:35Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks @yihuang.  This has been folded into #348 ",
          "createdAt": "2020-06-16T19:05:33Z",
          "updatedAt": "2020-06-16T19:05:33Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI4MjIzMzY2",
          "commit": {
            "abbreviatedOid": "d8557b0"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "You do need the `optional<...>` because some of the nodes may be blank",
          "createdAt": "2020-06-10T16:19:07Z",
          "updatedAt": "2020-06-10T16:19:07Z",
          "comments": []
        }
      ]
    },
    {
      "number": 347,
      "id": "MDExOlB1bGxSZXF1ZXN0NDMzOTAyMzMw",
      "title": "Explicitly specify which nodes are targeted",
      "url": "https://github.com/mlswg/mls-protocol/pull/347",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Currently, processing a DirectPath requires that the recipient have a full view of the ratchet tree, so that it can compute the resolutions of copath nodes.  This PR changes the DirectPath structure to explicitly state which tree node a given encryption of a path secret is targeted to.  This is a prerequisit for making full knowledge of the tree optional, as in #344.",
      "createdAt": "2020-06-12T22:03:24Z",
      "updatedAt": "2020-06-16T19:06:05Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "48442a2491bfd8e044ddfb044d8db9f029204384",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "irresolute",
      "headRefOid": "bea46080ee807f3c7f082f58e4c130983b5b1050",
      "closedAt": "2020-06-16T19:06:05Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "seanturner",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Plan is to close this PR.",
          "createdAt": "2020-06-16T16:27:06Z",
          "updatedAt": "2020-06-16T16:27:06Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 348,
      "id": "MDExOlB1bGxSZXF1ZXN0NDMzOTA5NTYx",
      "title": "Make the tree in the Welcome optional",
      "url": "https://github.com/mlswg/mls-protocol/pull/348",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #344 ",
      "createdAt": "2020-06-12T22:31:09Z",
      "updatedAt": "2020-07-24T21:14:45Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "60572e71e0e46c1f202352266e1762595f40beb9",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "deforest",
      "headRefOid": "07c1e98e201dfda11f3b3946d3c3c13c1b6c90ec",
      "closedAt": "2020-07-24T21:14:45Z",
      "mergedAt": "2020-07-24T21:14:45Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "e1c56540b40d0ce59b0905f8dc195026805d1e27"
      },
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "A couple of shortcomings to note on this PR:\r\n\r\n* The joiner can't compute their private keys because they're not told where they are in the tree or how big the tree is.  The former should be added to `GroupSecrets` and the latter to `GroupInfo`.\r\n\r\n* This approach assumes that the joiner gets the tree OOB before processing the Welcome, otherwise they can't verify the signature on the Welcome.  (Since Welcome presumes they get the credential for the signer from the tree.)\r\n\r\nWe could avoid the latter problem by including a credential for the signer and a \"membership proof\" comprising the hashes needed to tie that leaf to the tree hash in the Welcome.  That could allow participants to remain \"passive\" (without a full tree, just their private keys) for longer, especially if such a proof could be provided on Commit as well.  This might be a good candidate for an extension, though.",
          "createdAt": "2020-07-07T15:05:38Z",
          "updatedAt": "2020-07-07T15:05:38Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Discussion at the 2020-07-14 interim indicated that we should go ahead with this strategy, and just note the requirement that you have to get the tree before you process the Welcome.",
          "createdAt": "2020-07-24T21:13:26Z",
          "updatedAt": "2020-07-24T21:13:26Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 349,
      "id": "MDExOlB1bGxSZXF1ZXN0NDM1Mzk1MDE3",
      "title": "Use opaque epoch IDs and encrypt content type",
      "url": "https://github.com/mlswg/mls-protocol/pull/349",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #269 \r\nFixes #142 ",
      "createdAt": "2020-06-16T18:27:12Z",
      "updatedAt": "2020-10-06T15:23:10Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "e38aac72400f157bff29f96810234e39230753d1",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "opaque-epoch",
      "headRefOid": "23f64356a8fc949daab60d2a83e69a4de6e3c697",
      "closedAt": "2020-10-06T15:23:10Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "@raphaelrobert - You asked today if I had implemented this.  I tried to today and failed!  The problem is that we use different keys for the content encryption depending on the content type.  So the content_type can't go in the encrypted content, it has to go in the sender data.  With that modification, the remainder of the PR worked as expected.  Pushing an update to this PR shortly.\r\n\r\nPR on the Go implementation here: https://github.com/cisco/go-mls/pull/77",
          "createdAt": "2020-07-07T20:33:50Z",
          "updatedAt": "2020-07-07T20:33:50Z"
        },
        {
          "author": "uhoreg",
          "authorAssociation": "CONTRIBUTOR",
          "body": "FWIW, making the epoch opaque rather than an increasing number will help with the decentralized case where users' views of the ratchet tree may branch and merge.  There are of course still other things that will need to change for this case, but this will be one fewer difference.",
          "createdAt": "2020-07-13T20:22:33Z",
          "updatedAt": "2020-07-13T20:22:33Z"
        },
        {
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "body": "@bifurcation Re-iterating my points from the mailing list discussion:\r\n- Implementations that can branch will still have to handle branching on their own, consistent with the way in which they branch.\r\n- The privacy properties of the opaque epoch id are very weak and privacy-preserving applications will still have to invent their own way to hide this metadata.\r\n\r\nPlease decline this PR!",
          "createdAt": "2020-09-08T20:36:20Z",
          "updatedAt": "2020-09-08T20:36:20Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing because:\r\n* This behavior can be emulated by applications, e.g., by exporting an ID and keeping state locally\r\n* There's some operational simplicity to having things the way they are.",
          "createdAt": "2020-10-06T15:23:10Z",
          "updatedAt": "2020-10-06T15:23:10Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQzOTkwNTA4",
          "commit": {
            "abbreviatedOid": "b6c3b26"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-07T15:12:21Z",
          "updatedAt": "2020-07-07T19:33:18Z",
          "comments": [
            {
              "originalPosition": 40,
              "body": "Note: This should use Derive-Secret, since it doesn't need to be free of context like `welcome_secret` does.",
              "createdAt": "2020-07-07T15:12:22Z",
              "updatedAt": "2020-07-07T20:35:17Z"
            }
          ]
        }
      ]
    },
    {
      "number": 350,
      "id": "MDExOlB1bGxSZXF1ZXN0NDM1NDUwMjM0",
      "title": "IANA updates and their consequences",
      "url": "https://github.com/mlswg/mls-protocol/pull/350",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This started off just fixing #312, then grew a bit.\r\n\r\n* Defines an IANA registry for ExtensionType values\r\n* Defines an IANA registry for CredentialType values\r\n* Updates the Ciphersuites registry to share formatting with the other two, and to be more explicit about its ties to HPKE algorithms\r\n* Removes the unnecessary `signature_scheme` field from `BasicCredential`\r\n* ... and as a result removes the definition of `SignatureScheme` (which is used nowhere else)\r\n\r\nFixes #312 ",
      "createdAt": "2020-06-16T20:29:29Z",
      "updatedAt": "2020-07-14T17:25:16Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "7d7b07325f618acd7d254be3bf5ea45615a1445e",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "iana-extensions",
      "headRefOid": "31bb22aab47bdb6d84f21a3deff1627e02072dba",
      "closedAt": "2020-07-14T17:25:16Z",
      "mergedAt": "2020-07-14T17:25:16Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "5970817438e45c3bdb6f3c92d338a983dcbe45b1"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ3NzIyODQ5",
          "commit": {
            "abbreviatedOid": "46db202"
          },
          "author": "seanturner",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-14T01:30:58Z",
          "updatedAt": "2020-07-14T01:30:58Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "Okay I see that we are referring to the uncompressed key format in SECG. I know there's a reference for that somewhere else, but I can't think of it right now. Go ahead and don't block on me and I can submit reference updates later.",
              "createdAt": "2020-07-14T01:30:58Z",
              "updatedAt": "2020-07-14T17:23:29Z"
            }
          ]
        }
      ]
    },
    {
      "number": 352,
      "id": "MDExOlB1bGxSZXF1ZXN0NDM1NDU0Njg3",
      "title": "Use node_index for both hashes",
      "url": "https://github.com/mlswg/mls-protocol/pull/352",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #328 ",
      "createdAt": "2020-06-16T20:39:17Z",
      "updatedAt": "2020-07-07T19:04:55Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "85b5cdad9aa59408e6fc1f1390dbba60351413e5",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "same-index",
      "headRefOid": "f43a7ae18ff51c2e13118c3ce0b63f6244ab7eca",
      "closedAt": "2020-07-07T19:04:55Z",
      "mergedAt": "2020-07-07T19:04:55Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "50fdd379ef6f56855d1c1bf135cb5cb843c99c34"
      },
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "@Bren2010 - I seem to recall you had some opinions on node hashing?",
          "createdAt": "2020-06-16T20:39:37Z",
          "updatedAt": "2020-06-16T20:39:37Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMxOTQ3Nzg3",
          "commit": {
            "abbreviatedOid": "f43a7ae"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-06-16T22:57:44Z",
          "updatedAt": "2020-06-16T22:57:44Z",
          "comments": []
        }
      ]
    },
    {
      "number": 353,
      "id": "MDExOlB1bGxSZXF1ZXN0NDM1NDYwOTU0",
      "title": "Explain the meaning of a Commit with no proposals",
      "url": "https://github.com/mlswg/mls-protocol/pull/353",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #340 ",
      "createdAt": "2020-06-16T20:53:33Z",
      "updatedAt": "2020-07-24T21:11:12Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "60572e71e0e46c1f202352266e1762595f40beb9",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "commit-no-proposals",
      "headRefOid": "ea8ed606b857a4b64b79365742d0df9deb4ca9de",
      "closedAt": "2020-07-24T21:11:12Z",
      "mergedAt": "2020-07-24T21:11:11Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "1130b97a05489f428e3d07a1a05c098489d64c85"
      },
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "I think we need to clearly define \"FS / PCS with regard to\", but once we do that, it seems like a fine phrase.  That seems like a good topic for a review / update of the Security Considerations once we have the protocol mostly in shape, for which I have filed #365.",
          "createdAt": "2020-07-24T21:11:06Z",
          "updatedAt": "2020-07-24T21:11:06Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMxOTQ4NDcx",
          "commit": {
            "abbreviatedOid": "4d98cec"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-16T22:59:29Z",
          "updatedAt": "2020-06-16T22:59:29Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "I don't believe such a commit would change the leaf. Makes more sense to me to not allow empty commits",
              "createdAt": "2020-06-16T22:59:29Z",
              "updatedAt": "2020-07-24T20:19:29Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMxOTYxMTMx",
          "commit": {
            "abbreviatedOid": "4d98cec"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-16T23:33:46Z",
          "updatedAt": "2020-06-16T23:33:46Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "It would reset the leaf, via `Commit.path.leaf_key_package`.\r\n\r\nISTM there is a very concrete use case for this feature, namely keeping the tree full.  If you want to maintain a full tree, then you would want to have each new joiner should send an empty commit immediately on joining, have the neighbor of a removed node send an empty commit after a remove, etc.",
              "createdAt": "2020-06-16T23:33:46Z",
              "updatedAt": "2020-07-24T20:19:29Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMzMzczMTAy",
          "commit": {
            "abbreviatedOid": "4d98cec"
          },
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-18T14:59:57Z",
          "updatedAt": "2020-06-18T14:59:57Z",
          "comments": [
            {
              "originalPosition": 10,
              "body": "So an empty commit is essentially what used to be an Update, i.e. fresh key material for the committers leaf, which is then KDFed up the tree. Functionally, I am ok with this, but it seems a little counter-intuitive to me. Wouldn't it be clearer if we disallowed empty commits and a party that would like to keep the tree full simply committed an Update proposal targeting their own leaf? That would yield the same result, wouldn't it?\r\n\r\nAlso: Advancing an epoch doesn't always give PCS guarantees. If an Add proposal is committed without an Update and `path` is empty, the epoch changes, but we don't get PCS (this is why I was critical of allowing Adds without Updates. It breaks the assumption that epoch change implies PCS).",
              "createdAt": "2020-06-18T14:59:57Z",
              "updatedAt": "2020-07-24T20:19:29Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDUxODYzOTkw",
          "commit": {
            "abbreviatedOid": "b9bd601"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-20T18:40:42Z",
          "updatedAt": "2020-07-20T18:40:43Z",
          "comments": [
            {
              "originalPosition": 10,
              "body": "Advancing the epoch gives you PCS with respect to the committer and and any nodes that were updated/removed in the epoch.  That doesn't change here.",
              "createdAt": "2020-07-20T18:40:42Z",
              "updatedAt": "2020-07-24T20:19:29Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDUzODUzMDQ5",
          "commit": {
            "abbreviatedOid": "b9bd601"
          },
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-23T06:02:04Z",
          "updatedAt": "2020-07-23T06:02:05Z",
          "comments": [
            {
              "originalPosition": 10,
              "body": "I'm pretty sure it doesn't if there is no `path` value. If I understand correctly, an `Add` only commit doesn't update the committers secrets (and thus doesn't get you PCS), but _does_ advance the epoch. I was only pointing out that advancing the epoch doesn't imply PCS if we allow empty `path` fields.",
              "createdAt": "2020-07-23T06:02:04Z",
              "updatedAt": "2020-07-24T20:19:29Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU1MTY1NjYx",
          "commit": {
            "abbreviatedOid": "ea8ed60"
          },
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "That works fine. I am a bit bothered by the phrasing regarding properties \u00ab\u00a0with regard to\u00a0...\u00bb. If you can find an alternate phrasing that would be \ud83d\udc4d",
          "createdAt": "2020-07-24T20:26:40Z",
          "updatedAt": "2020-07-24T20:26:40Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU1MTg2NDA4",
          "commit": {
            "abbreviatedOid": "ea8ed60"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-24T21:08:01Z",
          "updatedAt": "2020-07-24T21:08:02Z",
          "comments": [
            {
              "originalPosition": 10,
              "body": "You are correct that a Commit with no `path` doesn't cause any PCS.  But we're talking about empty Commits here, which are required to have a `path`.  I've edited to be more precise.",
              "createdAt": "2020-07-24T21:08:01Z",
              "updatedAt": "2020-07-24T21:08:02Z"
            }
          ]
        }
      ]
    },
    {
      "number": 354,
      "id": "MDExOlB1bGxSZXF1ZXN0NDM4ODU4MjQ4",
      "title": "misc little fixes",
      "url": "https://github.com/mlswg/mls-protocol/pull/354",
      "state": "MERGED",
      "author": "uhoreg",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "I've put a bunch of little fixes in here.  If you disagree with any of these changes, I can back them out or change them.\r\n\r\n- maximal is defined but never used\r\n- k-th leaf/leaf index is defined in two places; merge definitions\r\n- change KeyPackage struct definition to reflect that ~2~ 3 extensions are required\r\n- `lifetime` is also a required extension\r\n- grammar fix\r\n- add missing semicolon",
      "createdAt": "2020-06-23T22:32:31Z",
      "updatedAt": "2020-07-07T19:05:51Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "85b5cdad9aa59408e6fc1f1390dbba60351413e5",
      "headRepository": "uhoreg/mls-protocol",
      "headRefName": "misc_fixes",
      "headRefOid": "023a2e7711b382b4cf466eca223afe574bf2802a",
      "closedAt": "2020-07-07T19:05:51Z",
      "mergedAt": "2020-07-07T19:05:51Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "ee969f006752b34ff94da67908b184f95a5c7870"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQzOTc3NzM2",
          "commit": {
            "abbreviatedOid": "4069eca"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "One minor thing, otherwise LGTM",
          "createdAt": "2020-07-07T14:59:15Z",
          "updatedAt": "2020-07-07T14:59:49Z",
          "comments": [
            {
              "originalPosition": 35,
              "body": "Each extension is at least 4 bytes long (2 for type, 2 for length), so if you want the real minimum here, it should be 12.  I'm generally not sanguine about using the TLS struct definition to enforce this sort of thing, though.",
              "createdAt": "2020-07-07T14:59:15Z",
              "updatedAt": "2020-07-07T16:21:41Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ0MDc1Nzkx",
          "commit": {
            "abbreviatedOid": "023a2e7"
          },
          "author": "uhoreg",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-07T16:50:13Z",
          "updatedAt": "2020-07-07T16:50:13Z",
          "comments": [
            {
              "originalPosition": 35,
              "body": "Fixed",
              "createdAt": "2020-07-07T16:50:13Z",
              "updatedAt": "2020-07-07T16:50:13Z"
            }
          ]
        }
      ]
    },
    {
      "number": 355,
      "id": "MDExOlB1bGxSZXF1ZXN0NDQ3NDQ1MTY3",
      "title": "Validate external proposals from preconfigured senders",
      "url": "https://github.com/mlswg/mls-protocol/pull/355",
      "state": "MERGED",
      "author": "d1vyank",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-07-10T13:36:32Z",
      "updatedAt": "2020-07-11T14:52:01Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "ee969f006752b34ff94da67908b184f95a5c7870",
      "headRepository": "d1vyank/mls-protocol",
      "headRefName": "external-proposal",
      "headRefOid": "41c508d2170860fea7542a4b4b650bbaf280ec8d",
      "closedAt": "2020-07-11T14:52:01Z",
      "mergedAt": "2020-07-11T14:52:01Z",
      "mergedBy": "Bren2010",
      "mergeCommit": {
        "oid": "1f9f90578eecd61103cc02f98b8a0d058d265e65"
      },
      "comments": [
        {
          "author": "d1vyank",
          "authorAssociation": "CONTRIBUTOR",
          "body": "This stuck out to me while reading because verification is explicitly specified for the 'new_member' sender type in the paragraph above this and not for the 'preconfigured' sender type.\r\n\r\nI think it would be better to specify this as the verification flow is different for these external proposals i.e. the KeyPackage in the proposal is used for new_member sender types, and the key corresponding to an authorized sender is used for preconfigured senders.",
          "createdAt": "2020-07-11T03:13:56Z",
          "updatedAt": "2020-07-11T03:13:56Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ2NjI4Mjcz",
          "commit": {
            "abbreviatedOid": "41c508d"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Was there reasonable confusion that these proposals wouldn't be verified? I see we have this line in the spec:\r\n\r\n```\r\nOn receiving an MLSPlaintext containing a Proposal, a client MUST verify the\r\nsignature on the enclosing MLSPlaintext.\r\n```",
          "createdAt": "2020-07-10T18:46:46Z",
          "updatedAt": "2020-07-10T18:46:46Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ2ODA3MzQz",
          "commit": {
            "abbreviatedOid": "41c508d"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-07-11T14:48:24Z",
          "updatedAt": "2020-07-11T14:48:24Z",
          "comments": []
        }
      ]
    },
    {
      "number": 356,
      "id": "MDExOlB1bGxSZXF1ZXN0NDQ3NDQ1MzA2",
      "title": "Minor editorial changes",
      "url": "https://github.com/mlswg/mls-protocol/pull/356",
      "state": "MERGED",
      "author": "d1vyank",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-07-10T13:36:47Z",
      "updatedAt": "2020-07-10T18:35:31Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "ee969f006752b34ff94da67908b184f95a5c7870",
      "headRepository": "d1vyank/mls-protocol",
      "headRefName": "nits",
      "headRefOid": "b135de93f1fcb978f051c6fd35b756562c96b689",
      "closedAt": "2020-07-10T18:35:31Z",
      "mergedAt": "2020-07-10T18:35:31Z",
      "mergedBy": "beurdouche",
      "mergeCommit": {
        "oid": "fd9222cea4454e6b1714886896b8449ad82300f1"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ2NjE4NTYw",
          "commit": {
            "abbreviatedOid": "b135de9"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-07-10T18:34:14Z",
          "updatedAt": "2020-07-10T18:34:14Z",
          "comments": []
        }
      ]
    },
    {
      "number": 357,
      "id": "MDExOlB1bGxSZXF1ZXN0NDQ3NTkwMzIy",
      "title": "Fix all compiler warnings.",
      "url": "https://github.com/mlswg/mls-protocol/pull/357",
      "state": "MERGED",
      "author": "Bren2010",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Previously we used [[ ... ]] for comments, and the body of the comment was only getting elided because the compiler didn't know what that syntax meant.",
      "createdAt": "2020-07-10T18:43:26Z",
      "updatedAt": "2020-07-20T21:01:48Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "90a85c4144d5904ce31f36d5cdc07e49c219d721",
      "headRepository": "Bren2010/mls-protocol",
      "headRefName": "brendan/2020.7.0",
      "headRefOid": "4047ddc883a73a50d7d2ac201bf8ec368b7fea68",
      "closedAt": "2020-07-20T21:01:47Z",
      "mergedAt": "2020-07-20T21:01:47Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "d68b832e69abcee6150eb69d5d82500f161175db"
      },
      "comments": [
        {
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "body": "Please don't remove the .editorconfig file again! It's a [normal thing](https://github.com/quicwg/base-drafts/blob/master/.editorconfig) for projects to have!!",
          "createdAt": "2020-07-10T22:57:06Z",
          "updatedAt": "2020-07-10T22:57:06Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ2OTA4NTI1",
          "commit": {
            "abbreviatedOid": "05f9d4c"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-12T20:44:42Z",
          "updatedAt": "2020-07-12T20:45:36Z",
          "comments": [
            {
              "originalPosition": 342,
              "body": "I don't think this quite matches the intent -- we want these OPEN ISSUES to be visible in the rendered HTML",
              "createdAt": "2020-07-12T20:44:42Z",
              "updatedAt": "2020-07-20T21:01:27Z"
            },
            {
              "originalPosition": 317,
              "body": "I think we can delete this TODO.",
              "createdAt": "2020-07-12T20:45:15Z",
              "updatedAt": "2020-07-20T21:01:27Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ2OTA5MjU4",
          "commit": {
            "abbreviatedOid": "05f9d4c"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-12T20:57:32Z",
          "updatedAt": "2020-07-12T20:57:32Z",
          "comments": [
            {
              "originalPosition": 342,
              "body": "I noticed this is how QUIC WG does it: https://github.com/quicwg/base-drafts/commit/09338d0e237e67c648aa172c32b872e10bf737ff",
              "createdAt": "2020-07-12T20:57:32Z",
              "updatedAt": "2020-07-20T21:01:27Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDUxOTU1ODAy",
          "commit": {
            "abbreviatedOid": "024fa7d"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-07-20T21:00:27Z",
          "updatedAt": "2020-07-20T21:00:27Z",
          "comments": []
        }
      ]
    },
    {
      "number": 358,
      "id": "MDExOlB1bGxSZXF1ZXN0NDQ3NjczMTgy",
      "title": "Fix build by switching to GitHub actions",
      "url": "https://github.com/mlswg/mls-protocol/pull/358",
      "state": "MERGED",
      "author": "Bren2010",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-07-10T22:47:11Z",
      "updatedAt": "2020-07-11T13:39:12Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "fd9222cea4454e6b1714886896b8449ad82300f1",
      "headRepository": "Bren2010/mls-protocol",
      "headRefName": "master",
      "headRefOid": "83bf0237a4dd58acbd60f41697b657d14742d42e",
      "closedAt": "2020-07-11T13:39:12Z",
      "mergedAt": "2020-07-11T13:39:12Z",
      "mergedBy": "katrielalex",
      "mergeCommit": {
        "oid": "3a6ac80ff98946991dc02ce71873069230834aa0"
      },
      "comments": [
        {
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "body": "@katrielalex Once this is merged, we should have an automatically maintained gh-pages branch. You can cname mls.rocks to mlswg.github.io",
          "createdAt": "2020-07-10T22:48:10Z",
          "updatedAt": "2020-07-10T22:48:10Z"
        },
        {
          "author": "katrielalex",
          "authorAssociation": "MEMBER",
          "body": "Should work! Let\u2019s try it and see",
          "createdAt": "2020-07-11T13:30:34Z",
          "updatedAt": "2020-07-11T13:30:34Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 359,
      "id": "MDExOlB1bGxSZXF1ZXN0NDQ3OTQ4NDc3",
      "title": "Fix bugs in tree math and cleanup docs.",
      "url": "https://github.com/mlswg/mls-protocol/pull/359",
      "state": "MERGED",
      "author": "Bren2010",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-07-12T20:09:04Z",
      "updatedAt": "2022-05-06T15:42:28Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "1f9f90578eecd61103cc02f98b8a0d058d265e65",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "brendan/fix-tree-math",
      "headRefOid": "46854f86605d01dd597992a12aab12c9fcee675b",
      "closedAt": "2020-07-14T18:17:01Z",
      "mergedAt": "2020-07-14T18:17:01Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "5433610fbdde8989df929cd44bd97c9656fcbb91"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ4MzUxNDAz",
          "commit": {
            "abbreviatedOid": "46854f8"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-07-14T18:16:56Z",
          "updatedAt": "2020-07-14T18:16:56Z",
          "comments": []
        }
      ]
    },
    {
      "number": 360,
      "id": "MDExOlB1bGxSZXF1ZXN0NDQ4NjA1ODMx",
      "title": "#302: Reduce encryption overhead to just auth tag",
      "url": "https://github.com/mlswg/mls-protocol/pull/360",
      "state": "MERGED",
      "author": "Bren2010",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-07-14T02:34:30Z",
      "updatedAt": "2022-05-06T15:42:27Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "1d5e14d79435834bc5cab6c7aa9e2fcdd6afeabc",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "brendan/masking",
      "headRefOid": "1b57be612b2f58ca248f78e6373ffad3463be36c",
      "closedAt": "2020-09-10T15:00:27Z",
      "mergedAt": "2020-09-10T15:00:27Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "bb303085f3748a7ba171f9f12fdbeef22d063283"
      },
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Just to recap the options as I understand them:\r\n\r\na) Today:\r\n   encrypted_sender_data = AEAD(sender_data_key, sender_data_nonce, (groupID, epoch), sender_data)\r\n   encrypted_content = AEAD(app_key[i][j], app_key[i][j], (groupID, epoch, encrypted_sender_data), content)\r\n\r\nb) Sample sender data nonce from ciphertext (saves explicit nonce)\r\n   encrypted_content = AEAD(app_key[i][j], app_nonce[i][j], (groupID, epoch), content)\r\n   encrypted_sender_data = AEAD(sender_data_key, sample(encrypted_content), (groupID, epoch, encrypted_content), sender_data)\r\n\r\nc) Drop auth tag from content encryption (saves explicit nonce and content auth tag)\r\n   encrypted_content = Enc(app_key[i][j], app_nonce[i][j], content)\r\n   encrypted_sender_data = AEAD(sender_data_key, sample(encrypted_content), (groupID, epoch, encrypted_content), sender_data)",
          "createdAt": "2020-08-11T16:41:40Z",
          "updatedAt": "2020-08-11T16:41:40Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDUxODg5NDAx",
          "commit": {
            "abbreviatedOid": "8de7bda"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-20T19:17:54Z",
          "updatedAt": "2020-07-20T19:58:05Z",
          "comments": [
            {
              "originalPosition": 132,
              "body": "I think the overview steps are important to have here, especially since the ciphertext sampling makes the order of things a bit complex (you have to encrypt the content, then loop back to the sender data).  But I think we streamline a little bit:\r\n\r\n```\r\n* Set group_id, epoch, content_type and authenticated_data fields from the\r\n  MLSPlaintext object directly\r\n\r\n* Identify the key and key generation depending on the content type\r\n\r\n* Encrypt an MLSCiphertextContent for the ciphertext field using the key\r\n  identified and MLSPlaintext object\r\n\r\n* Encrypt the sender data using the sender data key for the epoch and a\r\n   nonce sampled from  encrypted MLSCiphertextContent.\r\n```",
              "createdAt": "2020-07-20T19:17:55Z",
              "updatedAt": "2020-09-04T22:43:53Z"
            },
            {
              "originalPosition": 241,
              "body": "You've removed the AAD from the main content encryption, which seems wrong.  it seems like we should have the unencrypted sender data feed in the ciphertext AAD, and the ciphertext (or the derived nonce) in the sender data AAD.  Something like:\r\n\r\n```\r\n      /  group_id            \\\r\n      |  epoch               |--+\r\n   +--|  content_type        /  |\r\n   |  |  sender_data         <--+\r\n   |  \\  authenticated_data  \\__|\r\n   +-->  content             /\r\n\r\nstruct {\r\n    opaque group_id<0..255>;\r\n    uint64 epoch;\r\n    ContentType content_type;\r\n    opaque authenticated_data<0..2^32-1>; // <---\r\n    opaque ciphertext<0..2^32-1>;\r\n} SenderDataAAD;\r\n\r\nstruct {\r\n    opaque group_id<0..255>;\r\n    uint64 epoch;\r\n    ContentType content_type;\r\n    SenderData sender_data;\r\n    opaque authenticated_data<0..2^32-1>; // <--- \r\n} ContentAAD;\r\n```",
              "createdAt": "2020-07-20T19:24:04Z",
              "updatedAt": "2020-09-04T22:43:53Z"
            },
            {
              "originalPosition": 281,
              "body": "Can't we just use the existing KDF we have on hand?",
              "createdAt": "2020-07-20T19:25:16Z",
              "updatedAt": "2020-09-04T22:43:53Z"
            },
            {
              "originalPosition": 181,
              "body": "Since we're going to have an auth tag anyway, it seems like we could simplify this a fair bit by just using the ciphersuite's AEAD to encrypt the SenderData (as we do now), and just sampling the *nonce* from the ciphertext.\r\n\r\nThat obviously removes the need to do XOR in addition to normal AEAD, and may allow us to simplify the sampling as well.  Since the nonce only needs to be random and not secret, we might be able to get away with just using the first `nonce_size` bytes of the ciphertext (or HKDF-Extract thereof).  So it gets rid of the AES-ECB dependency as well.\r\n\r\nAnd since this changes from (AEAD + XOR + AEAD) to (AEAD + AEAD), we no longer need the `authentication_key`.\r\n\r\n```\r\nciphertext = AEAD.Seal(key=generation.key,\r\n                       nonce=generation.nonce,\r\n                       pt=content,\r\n                       aad=header_with_plaintext_sender_data)\r\nsender_data_nonce = ciphertext[:nonce_size]\r\nencrypted_sender_data = AEAD.Seal(key=sender_data_key,\r\n                                  nonce=sender_data_nonce,\r\n                                  pt=sender_data,\r\n                                  aad=header_without_sender_data_and_with_ciphertext)\r\n```",
              "createdAt": "2020-07-20T19:57:47Z",
              "updatedAt": "2020-09-04T22:43:53Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDUyOTE2OTc2",
          "commit": {
            "abbreviatedOid": "8de7bda"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-22T00:28:58Z",
          "updatedAt": "2020-07-22T00:28:58Z",
          "comments": [
            {
              "originalPosition": 241,
              "body": "The ciphertext's auth tag is truncated so there's no point in having AAD on the content. All AAD is against the sender data.",
              "createdAt": "2020-07-22T00:28:58Z",
              "updatedAt": "2020-09-04T22:43:53Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgyMDU2MjQy",
          "commit": {
            "abbreviatedOid": "1e84b5c"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "Thanks, @Bren2010, this looks pretty close.  Couple things that need adjusting before we can merge.",
          "createdAt": "2020-09-03T17:29:45Z",
          "updatedAt": "2020-09-04T15:00:47Z",
          "comments": [
            {
              "originalPosition": 147,
              "body": "Having this in the ciphertext AAD creates a circular dependency, since the nonce for the sender data encryption is derived from the ciphertext.  Need to either have the plaintext sender data or nothing.",
              "createdAt": "2020-09-03T17:29:45Z",
              "updatedAt": "2020-09-04T22:43:53Z"
            },
            {
              "originalPosition": 183,
              "body": "This doesn't seem right.  First, this should be `KDF.Expand` for generatlity.  Second, IIRC, HKDF-Expand expects a PRK of the output size of hash function, so your PRK here is to short.\r\n\r\nHowever, I wonder if we can refactor here to also solve a problem I noted above, namely that deriving the key with Derive-Secret doesn't give you the right size key.  What about something like:\r\n\r\n```\r\nsender_data_secret = Derive-Secret(epoch_secret, \"sender data\")\r\nsender_data_key = ExpandWithLabel(sender_data_secret, \"key\", \"\", AEAD.Nk)\r\n\r\nciphertext_sample = ciphertext[0..AEAD.Nn-1]\r\nsender_data_nonce = ExpandWithLabel(sender_data_secret, \"nonce\", ciphertext_sample, AEAD.Nn)\r\n```\r\n\r\nAlternatively, is there a need for the `Expand` call here at all?  The output of the AEAD function should already be indistinguishable from random, so maybe we could use `sender_data_nonce == ciphertext_sample`?\r\n",
              "createdAt": "2020-09-04T14:59:09Z",
              "updatedAt": "2020-09-04T22:43:53Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg2MDI4NDM0",
          "commit": {
            "abbreviatedOid": "1b57be6"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-09-10T15:00:16Z",
          "updatedAt": "2020-09-10T15:00:16Z",
          "comments": []
        }
      ]
    },
    {
      "number": 361,
      "id": "MDExOlB1bGxSZXF1ZXN0NDUzNjg5MzY0",
      "title": "Use correct arguments to Derive-Secret",
      "url": "https://github.com/mlswg/mls-protocol/pull/361",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #324 ",
      "createdAt": "2020-07-20T17:56:46Z",
      "updatedAt": "2020-07-20T18:21:51Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "5433610fbdde8989df929cd44bd97c9656fcbb91",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "derive-secret",
      "headRefOid": "0bae585e6f48de1721aee383f37412c15ac78eb2",
      "closedAt": "2020-07-20T18:21:51Z",
      "mergedAt": "2020-07-20T18:21:51Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "90a85c4144d5904ce31f36d5cdc07e49c219d721"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDUxODUwMjU3",
          "commit": {
            "abbreviatedOid": "0bae585"
          },
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-07-20T18:20:49Z",
          "updatedAt": "2020-07-20T18:20:49Z",
          "comments": []
        }
      ]
    },
    {
      "number": 362,
      "id": "MDExOlB1bGxSZXF1ZXN0NDUzNzE1OTg5",
      "title": "Reorder key schedule inputs",
      "url": "https://github.com/mlswg/mls-protocol/pull/362",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This PR rearranges the key schedule so that the following values are all fed into the init secret to form epoch secret:\r\n\r\n1. The commit secret\r\n2. The PSK (if any)\r\n3. The group context\r\n\r\nThis assures that new joiners know the PSK for the epoch, since they now need to know it to compute the epoch secret.  It also moves the group context from the `Derive-Secret` calls under the epoch secret to the derivation of the epoch secret itself, ensuring that everything derived in the epoch has the same context folded in.\r\n\r\nFixes #325 \r\nFixes #326 ",
      "createdAt": "2020-07-20T18:29:58Z",
      "updatedAt": "2020-07-28T17:29:27Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "b8b1951b0f315e57377f5ca493c4325d04ab8106",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "key-schedule",
      "headRefOid": "3b330f3110fd4dd60fa57cc423353ced1711d8fd",
      "closedAt": "2020-07-28T17:29:27Z",
      "mergedAt": "2020-07-28T17:29:26Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "593cc3b1af05111436d934a73442518d92303444"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU2Nzc2MDky",
          "commit": {
            "abbreviatedOid": "147b9a3"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Lgtm",
          "createdAt": "2020-07-28T15:53:23Z",
          "updatedAt": "2020-07-28T15:53:23Z",
          "comments": []
        }
      ]
    },
    {
      "number": 363,
      "id": "MDExOlB1bGxSZXF1ZXN0NDU0ODIzNzM3",
      "title": "Fix compile errors again.",
      "url": "https://github.com/mlswg/mls-protocol/pull/363",
      "state": "MERGED",
      "author": "Bren2010",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-07-22T01:16:10Z",
      "updatedAt": "2020-07-24T18:36:07Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "d68b832e69abcee6150eb69d5d82500f161175db",
      "headRepository": "Bren2010/mls-protocol",
      "headRefName": "brendan/2020.7.3",
      "headRefOid": "45ca0afd974c554d4b668c80a1e00b6aabe5f1de",
      "closedAt": "2020-07-24T18:36:07Z",
      "mergedAt": "2020-07-24T18:36:07Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "930a1b388d81956761655592d1e26ab701455939"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU1MTA0NDY0",
          "commit": {
            "abbreviatedOid": "45ca0af"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-07-24T18:35:59Z",
          "updatedAt": "2020-07-24T18:35:59Z",
          "comments": []
        }
      ]
    },
    {
      "number": 364,
      "id": "MDExOlB1bGxSZXF1ZXN0NDU2NDI4NDQ0",
      "title": "Use the KDF from HPKE",
      "url": "https://github.com/mlswg/mls-protocol/pull/364",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #351 ",
      "createdAt": "2020-07-24T18:28:40Z",
      "updatedAt": "2020-07-24T19:49:13Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "930a1b388d81956761655592d1e26ab701455939",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "hpke-kdf",
      "headRefOid": "10d19660772a6d91da3fa64a3c7ef2ae9b875e4a",
      "closedAt": "2020-07-24T19:49:13Z",
      "mergedAt": "2020-07-24T19:49:13Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "60572e71e0e46c1f202352266e1762595f40beb9"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU1MTAzMDk3",
          "commit": {
            "abbreviatedOid": "02b57f8"
          },
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-07-24T18:33:43Z",
          "updatedAt": "2020-07-24T18:33:43Z",
          "comments": []
        }
      ]
    },
    {
      "number": 369,
      "id": "MDExOlB1bGxSZXF1ZXN0NDU2NjYzNDEz",
      "title": "Add Commit extensions and clarify the extensibility story",
      "url": "https://github.com/mlswg/mls-protocol/pull/369",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #366 ",
      "createdAt": "2020-07-25T20:06:41Z",
      "updatedAt": "2020-08-25T18:44:13Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "593cc3b1af05111436d934a73442518d92303444",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "commit-ext",
      "headRefOid": "f3599f673a1a5720187c54205061ba9d5c89aef8",
      "closedAt": "2020-08-25T18:44:13Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": []
    },
    {
      "number": 370,
      "id": "MDExOlB1bGxSZXF1ZXN0NDU2NjY0MTgz",
      "title": "Minor extension fixes",
      "url": "https://github.com/mlswg/mls-protocol/pull/370",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This PR makes a few minor fixes to extensions:\r\n\r\n* Coalesces `supported_versions` and `supported_ciphersuites` into a single extension\r\n* Adds a list of supported extensions in parallel with the versions and ciphersuites\r\n* Adds a missing value to the IANA table for the `ratchet_tree` extension",
      "createdAt": "2020-07-25T20:14:35Z",
      "updatedAt": "2020-07-27T13:29:41Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "e1c56540b40d0ce59b0905f8dc195026805d1e27",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "client-capabilities",
      "headRefOid": "ff79548f1854ed64d4f3ce2c305c067f149af0c6",
      "closedAt": "2020-07-27T13:29:40Z",
      "mergedAt": "2020-07-27T13:29:40Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "9b52e6a735cc926d3a3b5488b5c3e5e6de2f1dab"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU1Mzg4NDQw",
          "commit": {
            "abbreviatedOid": "ff79548"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-07-26T19:14:22Z",
          "updatedAt": "2020-07-26T19:14:22Z",
          "comments": []
        }
      ]
    },
    {
      "number": 371,
      "id": "MDExOlB1bGxSZXF1ZXN0NDU2ODA0Mzc3",
      "title": "Define HPKE on first use",
      "url": "https://github.com/mlswg/mls-protocol/pull/371",
      "state": "MERGED",
      "author": "chelseakomlo",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "This PR defines and links to the HPKE draft when first introducing this term in the draft.",
      "createdAt": "2020-07-26T20:55:14Z",
      "updatedAt": "2020-07-27T13:30:44Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "e1c56540b40d0ce59b0905f8dc195026805d1e27",
      "headRepository": null,
      "headRefName": "define-hpke-on-first-use",
      "headRefOid": "2f84cd477dc9dd9197150296b42f72b79fef90c8",
      "closedAt": "2020-07-27T13:30:44Z",
      "mergedAt": "2020-07-27T13:30:44Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "da6d4ebf3abdd459ff57b9ec954600475067c29a"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU1NzgyMDQ1",
          "commit": {
            "abbreviatedOid": "2f84cd4"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-07-27T13:30:38Z",
          "updatedAt": "2020-07-27T13:30:38Z",
          "comments": []
        }
      ]
    },
    {
      "number": 372,
      "id": "MDExOlB1bGxSZXF1ZXN0NDU2ODU0MDQ3",
      "title": "Commit Generation Clarifications",
      "url": "https://github.com/mlswg/mls-protocol/pull/372",
      "state": "MERGED",
      "author": "chelseakomlo",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "This PR tries to clarify these paragraphs by the following: \r\n\r\n- Differentiating between HPKE public/private keys when describing how these keys are rotated for a commit\r\n- Clarifying who does the actions associated with a commit\r\n- Adding consistency fixes between the two paragraphs\r\n\r\nLet me know if these fixes are not quite right, as this PR tries to clarify where I had questions when reading. ",
      "createdAt": "2020-07-27T02:07:58Z",
      "updatedAt": "2020-07-27T21:07:28Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "e1c56540b40d0ce59b0905f8dc195026805d1e27",
      "headRepository": null,
      "headRefName": "hpke-pub-key-update",
      "headRefOid": "d136e979ebb89c5f371a1b6aa2d58a98f5766919",
      "closedAt": "2020-07-27T21:07:28Z",
      "mergedAt": "2020-07-27T21:07:27Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "b8b1951b0f315e57377f5ca493c4325d04ab8106"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU1Nzg2NTIw",
          "commit": {
            "abbreviatedOid": "bd391f4"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-27T13:35:33Z",
          "updatedAt": "2020-07-27T13:37:26Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "This isn't quite right.  `leaf_hpke_secret` is a symmetric secret value, from which an HPKE secret key is derived, as illustrated below:\r\n\r\n```\r\n    path_secret[0] --> node_priv[0], node_pub[0]\r\n         ^\r\n         |\r\n   leaf_hpke_secret\r\n```\r\n\r\nMaybe it would be helpful to annotate that diagram to reinforce that the `[0]` is the leaf?\r\n\r\n```\r\n    path_secret[0] --> node_priv[0], node_pub[0]\r\n         ^             = leaf_priv, leaf_pub\r\n         |             ~> leaf_key_package\r\n         |\r\n   leaf_hpke_secret\r\n```",
              "createdAt": "2020-07-27T13:35:33Z",
              "updatedAt": "2020-07-27T21:01:56Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU2MTA2OTA3",
          "commit": {
            "abbreviatedOid": "bd391f4"
          },
          "author": "chelseakomlo",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-27T20:22:47Z",
          "updatedAt": "2020-07-27T20:22:47Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "This annotation would be helpful. ",
              "createdAt": "2020-07-27T20:22:47Z",
              "updatedAt": "2020-07-27T21:01:56Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU2MTE5NTg1",
          "commit": {
            "abbreviatedOid": "bd391f4"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-27T20:42:15Z",
          "updatedAt": "2020-07-27T20:42:15Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "Actually, as you pointed out to me offline, this is inconsistent with the diagram below.  I think what it should be instead is:\r\n\r\n```\r\n       path_secret[1] --> node_priv[1], node_pub[1]\r\n            ^\r\n            |\r\n       path_secret[0] --> node_priv[0], node_pub[0]\r\n            ^\r\n            |\r\n       leaf_secret    --> leaf_priv, leaf_pub\r\n                          ~> leaf_key_package\r\n```",
              "createdAt": "2020-07-27T20:42:15Z",
              "updatedAt": "2020-07-27T21:01:56Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU2MTM1ODQ4",
          "commit": {
            "abbreviatedOid": "d136e97"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-07-27T21:07:20Z",
          "updatedAt": "2020-07-27T21:07:20Z",
          "comments": []
        }
      ]
    },
    {
      "number": 375,
      "id": "MDExOlB1bGxSZXF1ZXN0NDU3NTE2Mjg1",
      "title": "Fix grammar and add some initials",
      "url": "https://github.com/mlswg/mls-protocol/pull/375",
      "state": "CLOSED",
      "author": "claucece",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "After reviewing for a second time the document, I decided to do some grammar fixes as well. Hope it is helpful.\r\ncc./ @beurdouche ",
      "createdAt": "2020-07-28T03:25:33Z",
      "updatedAt": "2020-07-29T07:40:11Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "b8b1951b0f315e57377f5ca493c4325d04ab8106",
      "headRepository": "claucece/mls-protocol",
      "headRefName": "master",
      "headRefOid": "8b152c16c255f68c33cb4e2f61cdbb29ad71dac8",
      "closedAt": "2020-07-29T07:40:11Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "claucece",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Mmm.. as the PR has too many line fixes, I'm going to open a new one with only the grammar changes. ",
          "createdAt": "2020-07-29T07:40:11Z",
          "updatedAt": "2020-07-29T07:40:11Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU2NzgwODIz",
          "commit": {
            "abbreviatedOid": "8b152c1"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-28T15:58:39Z",
          "updatedAt": "2020-07-28T16:10:41Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "needs is correct, the subject is \"group\" which is singular",
              "createdAt": "2020-07-28T15:58:39Z",
              "updatedAt": "2020-07-28T16:10:41Z"
            },
            {
              "originalPosition": 46,
              "body": "-as",
              "createdAt": "2020-07-28T16:00:03Z",
              "updatedAt": "2020-07-28T16:10:41Z"
            },
            {
              "originalPosition": 43,
              "body": "Wrapping text pollutes \"git blame\" unnecessarily. We don't have any real line length",
              "createdAt": "2020-07-28T16:01:50Z",
              "updatedAt": "2020-07-28T16:10:41Z"
            },
            {
              "originalPosition": 15,
              "body": "I think the punctuation was fine before",
              "createdAt": "2020-07-28T16:02:25Z",
              "updatedAt": "2020-07-28T16:10:41Z"
            },
            {
              "originalPosition": 409,
              "body": "FC -> FS",
              "createdAt": "2020-07-28T16:04:38Z",
              "updatedAt": "2020-07-28T16:10:41Z"
            },
            {
              "originalPosition": 455,
              "body": "Two options:\r\n- sends itself an Add and commits, then (how it was)\r\n- sends itself an Add, commits, and then",
              "createdAt": "2020-07-28T16:06:41Z",
              "updatedAt": "2020-07-28T16:10:41Z"
            },
            {
              "originalPosition": 501,
              "body": "\"by which\" or \"where\"",
              "createdAt": "2020-07-28T16:07:51Z",
              "updatedAt": "2020-07-28T16:10:41Z"
            },
            {
              "originalPosition": 843,
              "body": "-to",
              "createdAt": "2020-07-28T16:10:02Z",
              "updatedAt": "2020-07-28T16:10:41Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU3MjY4Mjcy",
          "commit": {
            "abbreviatedOid": "8b152c1"
          },
          "author": "claucece",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-29T07:38:36Z",
          "updatedAt": "2020-07-29T07:38:37Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "Oh, yes! Thanks! I got confused by this: https://english.stackexchange.com/questions/39838/is-group-singular-or-plural ",
              "createdAt": "2020-07-29T07:38:36Z",
              "updatedAt": "2020-07-29T07:38:37Z"
            }
          ]
        }
      ]
    },
    {
      "number": 376,
      "id": "MDExOlB1bGxSZXF1ZXN0NDU3OTk2NjM0",
      "title": "Negotiate PSKs",
      "url": "https://github.com/mlswg/mls-protocol/pull/376",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #367 ",
      "createdAt": "2020-07-28T19:09:47Z",
      "updatedAt": "2020-08-03T22:22:09Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "593cc3b1af05111436d934a73442518d92303444",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "negotiate-psk",
      "headRefOid": "ddbca946933352357ea323111aa311d9d5c38b13",
      "closedAt": "2020-08-03T22:22:09Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing this one for now.  After discussion with @kkohbrok, he's going to refactor the relevant bits out of #336 once we have the required tools from fixing #366.",
          "createdAt": "2020-08-03T22:22:08Z",
          "updatedAt": "2020-08-03T22:22:08Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU4OTY3MzY0",
          "commit": {
            "abbreviatedOid": "ddbca94"
          },
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-31T07:24:09Z",
          "updatedAt": "2020-07-31T07:24:09Z",
          "comments": [
            {
              "originalPosition": 160,
              "body": "As I noted on the mailinglist, the issue with the PSKId being (part of) an extension and those extensions in turn being part of the `GroupInfo` object, means that the PSK can't be required for decrypting that `GroupInfo` object in the first place. In #336 , we suggested that the PSKId be part of the `GroupSecrets` object along with the other secrets. This would also ensure compatibility with the pending nPRF key schedule proposal.",
              "createdAt": "2020-07-31T07:24:09Z",
              "updatedAt": "2020-07-31T07:24:09Z"
            }
          ]
        }
      ]
    },
    {
      "number": 377,
      "id": "MDExOlB1bGxSZXF1ZXN0NDU4MjU5MDg2",
      "title": "Fix grammar",
      "url": "https://github.com/mlswg/mls-protocol/pull/377",
      "state": "MERGED",
      "author": "claucece",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "cc./ @Bren2010, it should be better now.",
      "createdAt": "2020-07-29T07:49:07Z",
      "updatedAt": "2020-07-29T16:37:49Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "593cc3b1af05111436d934a73442518d92303444",
      "headRepository": "claucece/mls-protocol",
      "headRefName": "master",
      "headRefOid": "74f90f89cbef122616cc459df68b9b82adc6e4b0",
      "closedAt": "2020-07-29T16:37:33Z",
      "mergedAt": "2020-07-29T16:37:33Z",
      "mergedBy": "beurdouche",
      "mergeCommit": {
        "oid": "e09ea022f428273d0b7ca2b5c01cce11e5e00aca"
      },
      "comments": [
        {
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "body": "Thanks both ! :)",
          "createdAt": "2020-07-29T16:37:49Z",
          "updatedAt": "2020-07-29T16:37:49Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU3NjI1NTAw",
          "commit": {
            "abbreviatedOid": "74f90f8"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-07-29T15:15:00Z",
          "updatedAt": "2020-07-29T15:15:00Z",
          "comments": []
        }
      ]
    },
    {
      "number": 378,
      "id": "MDExOlB1bGxSZXF1ZXN0NDU4ODMzNzc4",
      "title": "Readability edits for section 'Synchronizing Views of the Tree'",
      "url": "https://github.com/mlswg/mls-protocol/pull/378",
      "state": "MERGED",
      "author": "chelseakomlo",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "This PR does the following: \r\n\r\n- Adds a lead-in sentence describing how this section builds on the prior. \r\n- Differentiates between public keys for nodes and public keys for leaves (users)\r\n- Clarifies when secret key material needs to be deleted. \r\n\r\nI also wanted to make a couple other changes, but wanted feedback first. \r\n\r\n1. This section describes the private value corresponding to a node's public key as 'ns[0]' (or node secret), whereas the prior section referred to it as 'np[0]' (or node_priv). It would be better to have these terms be consistent.\r\n2.  On line 773, it says that the client \"...transmits a handshake message containing a set of **public** values\" and on line 776 it says that \"other members of the group can use these **public** values to update\". However, this values seems to be contradictory with the value listed on line 785. \r\n3. The current terminology is unclear regarding 1) a Commit to the tree, 2) an update to the tree, and and 3) a handshake message. I think these are very similar but using the same language consistently would be better (such as defining a Commit as what updates the tree, and then describing how the handshake message is different from a Commit message, which is described earlier in the spec). ",
      "createdAt": "2020-07-30T02:53:00Z",
      "updatedAt": "2020-07-31T20:55:23Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "e09ea022f428273d0b7ca2b5c01cce11e5e00aca",
      "headRepository": null,
      "headRefName": "read-sync",
      "headRefOid": "c2b0bd607d596ab10dd1dc9831a5ce1fbbfd36c0",
      "closedAt": "2020-07-31T20:55:23Z",
      "mergedAt": "2020-07-31T20:55:23Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "c3db39266505e9d202158d642d65918d35870e77"
      },
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks for looking through this, @chelseakomlo.  There's a lot of historical baggage here, so it's good to get it cleaned up.  I'll review the diff in a moment, but to respond to your points:\r\n\r\n1. Just to confirm terminology here, there are three values in play, (1) a symmetric secret, (2) a KEM private key derived from the secret, and (3) the corresponding public key.  It _should_ be the case that you only need to store the latter two in the tree (priv+pub), since the secrets are used transiently: For deriving the tree key pairs, for deriving the commit secret, and for initializing new members added in an epoch.  [My implementation](https://github.com/cisco/mlspp/blob/master/include/treekem.h#L42) stores the node secrets to simplify these operations, but it feels like it should be possible to arrange things so that this isn't necessary.  So I think the right answer here is to just refer to node private keys.\r\n\r\n2. Line 785 is correct, the Commit contains a public key and encrypted copies of the path secret for each node.  So the text should refer to public **and encrypted private** values as necessary.\r\n\r\n3. The right taxonomy here is: \"Handshake message\" encompasses `Proposal` and `Commit`.  Processing the Commit is the thing that causes an update to the tree; more specifically, applying a DirectPath.  So we should only talk about handshake messages when we want to cover both Proposals and Commits, and most instances of \"update\" should probably refer to either Commit or DirectPath.",
          "createdAt": "2020-07-31T17:33:36Z",
          "updatedAt": "2020-07-31T17:33:36Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU5MzQ2MTI0",
          "commit": {
            "abbreviatedOid": "043cb5c"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-31T17:37:01Z",
          "updatedAt": "2020-07-31T18:00:05Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "`s/will need to//`",
              "createdAt": "2020-07-31T17:37:26Z",
              "updatedAt": "2020-07-31T20:54:10Z"
            },
            {
              "originalPosition": 7,
              "body": "Might rephrase as \"apply it to their local views of the tree to keep them in sync with the sender's.\"",
              "createdAt": "2020-07-31T17:37:58Z",
              "updatedAt": "2020-07-31T20:54:10Z"
            },
            {
              "originalPosition": 5,
              "body": "This stuff might be better phrased in terms of a `DirectPath` (which maybe we should rename to `UpdatePath`?), since a Commit no longer has to have an update of this character.",
              "createdAt": "2020-07-31T17:57:17Z",
              "updatedAt": "2020-07-31T20:54:10Z"
            },
            {
              "originalPosition": 23,
              "body": "Unclear whether \"outdated\" here means \"from before the Commit\" or \"transmitted in the Commit, but now obsolete because the keys have been generated from them\".  Like I said above, I think we can focus on the latter (so that you'll never even have the former stored), we just need to make sure that the wording of the requirement doesn't interfere with the secondary uses of the path secrets.",
              "createdAt": "2020-07-31T17:59:58Z",
              "updatedAt": "2020-07-31T20:54:10Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU5NDA0NjYw",
          "commit": {
            "abbreviatedOid": "043cb5c"
          },
          "author": "chelseakomlo",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-31T19:18:29Z",
          "updatedAt": "2020-07-31T19:18:30Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "`UpdatePath` sounds like a better name. I'll do this renaming in a separate PR, but will rephrase this section to refer to a `DirectPath` as opposed to a `Commit` in the meantime.  ",
              "createdAt": "2020-07-31T19:18:29Z",
              "updatedAt": "2020-07-31T20:54:10Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU5NDA4MTg4",
          "commit": {
            "abbreviatedOid": "043cb5c"
          },
          "author": "chelseakomlo",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-31T19:24:56Z",
          "updatedAt": "2020-07-31T19:24:56Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "Actually, you know, I think it would be better to do this change in a separate commit as well, as it will involve re-writing the \"Ratchet Tree Evolution\" section to refer to `DirectPath` as well, no? ",
              "createdAt": "2020-07-31T19:24:56Z",
              "updatedAt": "2020-07-31T20:54:10Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU5NDE1MDMw",
          "commit": {
            "abbreviatedOid": "4344030"
          },
          "author": "chelseakomlo",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-31T19:30:53Z",
          "updatedAt": "2020-07-31T19:30:54Z",
          "comments": [
            {
              "originalPosition": 23,
              "body": "Do you mind suggesting phrasing here? This doesn't match my mental model of \"when replacing key material in the tree after receiving a `DirectPath`, the outdated key material (that was replaced by key material in the `DirectPath` message) should be deleted, but there could be something I'm profoundly missing. ",
              "createdAt": "2020-07-31T19:30:53Z",
              "updatedAt": "2020-07-31T20:54:10Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU5NDE5NjY2",
          "commit": {
            "abbreviatedOid": "4344030"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-31T19:39:23Z",
          "updatedAt": "2020-07-31T19:43:35Z",
          "comments": [
            {
              "originalPosition": 23,
              "body": "The question is: if your nodes have `(secret, sk, pk)`, and you move from `(secret0, sk0, pk0) -> (secret1, sk1, pk1)`, do you need to delete secret0, secret1, or both?  (If you delete `secret1`, then you never have a `secret0` to delete)",
              "createdAt": "2020-07-31T19:39:23Z",
              "updatedAt": "2020-07-31T20:54:10Z"
            },
            {
              "originalPosition": 5,
              "body": "Given this and the discussion below, do you want to close this and come back after the other refactors are done?",
              "createdAt": "2020-07-31T19:41:24Z",
              "updatedAt": "2020-07-31T20:54:10Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU5NDcyNzI2",
          "commit": {
            "abbreviatedOid": "c2b0bd6"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-07-31T20:55:17Z",
          "updatedAt": "2020-07-31T20:55:17Z",
          "comments": []
        }
      ]
    },
    {
      "number": 379,
      "id": "MDExOlB1bGxSZXF1ZXN0NDU5OTc4MTcx",
      "title": "Fix typo at minimal number of extensions",
      "url": "https://github.com/mlswg/mls-protocol/pull/379",
      "state": "MERGED",
      "author": "yihuang",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-07-31T09:47:54Z",
      "updatedAt": "2020-08-03T22:22:59Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "c3db39266505e9d202158d642d65918d35870e77",
      "headRepository": "yihuang/mls-protocol",
      "headRefName": "patch-1",
      "headRefOid": "bbbd812b9c6638a5840c02f2fe7f14aa94f08e98",
      "closedAt": "2020-08-03T22:22:59Z",
      "mergedAt": "2020-08-03T22:22:59Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "fa567ad1fba2a24f09d4cdd7d5a9a2138aeffa56"
      },
      "comments": [
        {
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "body": "This is not the number of extensions, it's the size of the payload.",
          "createdAt": "2020-07-31T11:03:00Z",
          "updatedAt": "2020-07-31T11:03:00Z"
        },
        {
          "author": "yihuang",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> This is not the number of extensions, it's the size of the payload.\r\n\r\nok",
          "createdAt": "2020-07-31T11:10:41Z",
          "updatedAt": "2020-07-31T11:10:41Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Actually, there's still a change here, since we bumped from 3 required extensions down to 2 (`lifetime` and `capabilities`).  So the minimum should be `8`.  @yihuang you want to make that tweak?",
          "createdAt": "2020-07-31T17:20:29Z",
          "updatedAt": "2020-07-31T17:20:29Z"
        },
        {
          "author": "yihuang",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> Actually, there's still a change here, since we bumped from 3 required extensions down to 2 (`lifetime` and `capabilities`). So the minimum should be `8`. @yihuang you want to make that tweak?\r\n\r\nWhy it's 8? I think lifetime extension have two u64 which is 16 bytes already?",
          "createdAt": "2020-08-01T02:05:19Z",
          "updatedAt": "2020-08-01T02:05:19Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "2x (2-byte type + 2-byte length)\n\nThat\u2019s why it was 12 when we had 3 required extensions :)\n\nOn Fri, Jul 31, 2020 at 22:05 yihuang <notifications@github.com> wrote:\n\n> Actually, there's still a change here, since we bumped from 3 required\n> extensions down to 2 (lifetime and capabilities). So the minimum should\n> be 8. @yihuang <https://github.com/yihuang> you want to make that tweak?\n>\n> Why it's 8? I think lifetime extension have two u64 which is 16 bytes\n> already?\n>\n> \u2014\n> You are receiving this because you modified the open/close state.\n>\n>\n> Reply to this email directly, view it on GitHub\n> <https://github.com/mlswg/mls-protocol/pull/379#issuecomment-667451819>,\n> or unsubscribe\n> <https://github.com/notifications/unsubscribe-auth/AAASOTJWNSHHII2ZVCXSFQ3R6NZ63ANCNFSM4PP443EA>\n> .\n>\n",
          "createdAt": "2020-08-01T02:10:06Z",
          "updatedAt": "2020-08-01T02:10:06Z"
        },
        {
          "author": "yihuang",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> 2x (2-byte type + 2-byte length) That\u2019s why it was 12 when we had 3 required extensions :)\r\n> [\u2026](#)\r\n> On Fri, Jul 31, 2020 at 22:05 yihuang ***@***.***> wrote: Actually, there's still a change here, since we bumped from 3 required extensions down to 2 (lifetime and capabilities). So the minimum should be 8. @yihuang <https://github.com/yihuang> you want to make that tweak? Why it's 8? I think lifetime extension have two u64 which is 16 bytes already? \u2014 You are receiving this because you modified the open/close state. Reply to this email directly, view it on GitHub <[#379 (comment)](https://github.com/mlswg/mls-protocol/pull/379#issuecomment-667451819)>, or unsubscribe <https://github.com/notifications/unsubscribe-auth/AAASOTJWNSHHII2ZVCXSFQ3R6NZ63ANCNFSM4PP443EA> .\r\n\r\nok, changed.",
          "createdAt": "2020-08-01T02:21:57Z",
          "updatedAt": "2020-08-01T02:21:57Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 380,
      "id": "MDExOlB1bGxSZXF1ZXN0NDYwMDY4NTA2",
      "title": "Fix inconsistency in deriving welcome_secret",
      "url": "https://github.com/mlswg/mls-protocol/pull/380",
      "state": "MERGED",
      "author": "yihuang",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Keep it consistent with #key-schedule",
      "createdAt": "2020-07-31T11:45:08Z",
      "updatedAt": "2020-07-31T17:21:29Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "e09ea022f428273d0b7ca2b5c01cce11e5e00aca",
      "headRepository": "yihuang/mls-protocol",
      "headRefName": "patch-2",
      "headRefOid": "d5f4bc91861f37c2f947c9a4674e546367a08c8f",
      "closedAt": "2020-07-31T17:21:29Z",
      "mergedAt": "2020-07-31T17:21:29Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "37d42127bf0a1951841a6e156dc96ca8e264169f"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU5MzAwNTY2",
          "commit": {
            "abbreviatedOid": "d5f4bc9"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-07-31T16:22:07Z",
          "updatedAt": "2020-07-31T16:22:07Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU5MzM2Njgx",
          "commit": {
            "abbreviatedOid": "d5f4bc9"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-07-31T17:21:23Z",
          "updatedAt": "2020-07-31T17:21:23Z",
          "comments": []
        }
      ]
    },
    {
      "number": 381,
      "id": "MDExOlB1bGxSZXF1ZXN0NDYwNjE0Mzg0",
      "title": "Consistency fix for description of key material sent in an update message",
      "url": "https://github.com/mlswg/mls-protocol/pull/381",
      "state": "MERGED",
      "author": "chelseakomlo",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "This PR adds a fix mentioned in #378 but was not included in the PR that was eventually merged. Specifically, both **public and encrypted private** values are sent in a message containing key material to ratchet the tree forward. ",
      "createdAt": "2020-07-31T23:36:44Z",
      "updatedAt": "2020-08-03T22:23:29Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "c3db39266505e9d202158d642d65918d35870e77",
      "headRepository": null,
      "headRefName": "sync-consist",
      "headRefOid": "73b023cd7d0997610ed9d39587b7465b28c836a8",
      "closedAt": "2020-08-03T22:23:29Z",
      "mergedAt": "2020-08-03T22:23:29Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "39455d2ea5e8fb42e8f0f0624bddd8c56675da0e"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYwMzc4MzU2",
          "commit": {
            "abbreviatedOid": "73b023c"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-08-03T22:23:24Z",
          "updatedAt": "2020-08-03T22:23:24Z",
          "comments": []
        }
      ]
    },
    {
      "number": 382,
      "id": "MDExOlB1bGxSZXF1ZXN0NDYyMTgwOTI5",
      "title": "Add Konrad and Britta to contribtors",
      "url": "https://github.com/mlswg/mls-protocol/pull/382",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-08-03T13:34:11Z",
      "updatedAt": "2020-08-03T13:35:03Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "c3db39266505e9d202158d642d65918d35870e77",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "kb",
      "headRefOid": "6bcc578508cbf214dc5b46047f4167bbd8d91c64",
      "closedAt": "2020-08-03T13:35:03Z",
      "mergedAt": "2020-08-03T13:35:03Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "a775172284bc6ca7a5196e7c7be7b1bcf01ca183"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 384,
      "id": "MDExOlB1bGxSZXF1ZXN0NDYyNTcyMTE5",
      "title": "4 editorial edits to the draft",
      "url": "https://github.com/mlswg/mls-protocol/pull/384",
      "state": "MERGED",
      "author": "ericcornelissen",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "A couple of minor editorial changes to the current draft, namely:\r\n\r\n<details>\r\n<summary>There was a missing grave accent in one of the paragraphs of <a href=\"https://github.com/mlswg/mls-protocol/blob/c3db39266505e9d202158d642d65918d35870e77/draft-ietf-mls-protocol.md#commit\">the Commit section</a> causing some formatting issues</summary>\r\n\r\n**Before**:\r\n\r\n![paragraph before](https://user-images.githubusercontent.com/3742559/89263277-9fc21c80-d639-11ea-9bd1-19e377fa3628.png)\r\n\r\n**After**:\r\n\r\n![paragraph after](https://user-images.githubusercontent.com/3742559/89263328-b9fbfa80-d639-11ea-8d5d-3b1c27c7d884.png)\r\n\r\n</details>\r\n\r\n<details>\r\n<summary>Fix typo Pre-Shared Keys section</summary>\r\n\r\n\r\n[...], it does not necessarily provide the same [...] guarantees ~than~ as a Commit message.\r\n\r\n</details>\r\n\r\n\r\n<details>\r\n<summary>Resolve remaining reference to <code>prior_epoch</code></summary>\r\n\r\nIn the Sequencing section there was a reference to a `prior_epoch` field that was introduced in 2fa6ed3c6afc7d308905255b4cabe154a48d1e4b. However, in 69e12cd61378aae4a81199c28a16e2802666b6e3, it was removed from the struct where it was added. That entire struct was then removed in 27c9c28f9634a06a9b7921ea9c15e276f8c9ff6f, after which the trail runs cold. So I wasn't able to figure out exactly what it must be based on what on what it originally was. Hence, I replaced it with something that makes sense in context.\r\n\r\nI based the new text on the following line found in the <a href=\"https://github.com/mlswg/mls-protocol/blob/39455d2ea5e8fb42e8f0f0624bddd8c56675da0e/draft-ietf-mls-protocol.md#commit\">(current) Commit section</a>:\r\n\r\n> Verify that the `epoch` field of the enclosing MLSPlaintext message is\r\n> equal to the `epoch` field of the current GroupContext object\r\n\r\n</details>\r\n\r\n\r\n<details>\r\n<summary>Rewrite paragraph on the <code>new_member</code> SenderType</summary>\r\n\r\nI found the phrase \" In such cases\" after the sentence \"Proposals with types other than Add MUST NOT be sent with this sender type\" slightly confusing and awkward. To improve this I rewrote the paragraph.\r\n\r\n</details>",
      "createdAt": "2020-08-04T07:04:58Z",
      "updatedAt": "2020-08-07T08:36:54Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "39455d2ea5e8fb42e8f0f0624bddd8c56675da0e",
      "headRepository": null,
      "headRefName": "formatting/issue-in-commit",
      "headRefOid": "db7028e06b776de0cf514d351e4f9f169d9d18fb",
      "closedAt": "2020-08-06T18:01:27Z",
      "mergedAt": "2020-08-06T18:01:27Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "d1d5f56a5d83781042d19c830497ab5aa104907f"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYyNDc4MjI3",
          "commit": {
            "abbreviatedOid": "6ea4861"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Couple of nits on your nits",
          "createdAt": "2020-08-06T12:40:01Z",
          "updatedAt": "2020-08-06T12:41:32Z",
          "comments": [
            {
              "originalPosition": 19,
              "body": "```suggestion\r\nMUST be Add. The MLSPlaintext MUST be signed with the private key corresponding\r\n```",
              "createdAt": "2020-08-06T12:40:01Z",
              "updatedAt": "2020-08-06T17:55:48Z"
            },
            {
              "originalPosition": 44,
              "body": "```suggestion\r\n```",
              "createdAt": "2020-08-06T12:40:42Z",
              "updatedAt": "2020-08-06T17:55:48Z"
            }
          ]
        }
      ]
    },
    {
      "number": 385,
      "id": "MDExOlB1bGxSZXF1ZXN0NDYzOTU3NTQ2",
      "title": "Require the initial init_secret to be a random value",
      "url": "https://github.com/mlswg/mls-protocol/pull/385",
      "state": "MERGED",
      "author": "ericcornelissen",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "This suggestion is based on a discussion in the MLS mailing list [[1]](https://mailarchive.ietf.org/arch/msg/mls/qrpAoK7aNSzKxX4O60pOLvM3cp8). It prevents issues that currently arrise when the very first commit of a group is an \"add-only\" commit because both the `commit_secret` and `init_secret` would be **0**.\r\n\r\nLet me know if the wording or anything else should be changed.\r\n\r\n/cc @bifurcation\r\n\r\n---\r\n\r\n1. https://mailarchive.ietf.org/arch/msg/mls/qrpAoK7aNSzKxX4O60pOLvM3cp8",
      "createdAt": "2020-08-06T11:09:18Z",
      "updatedAt": "2020-08-12T06:12:52Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "39455d2ea5e8fb42e8f0f0624bddd8c56675da0e",
      "headRepository": null,
      "headRefName": "random-first-init-secret",
      "headRefOid": "5a34af6b36509dd1eff4ca4abbedd31288fe904f",
      "closedAt": "2020-08-06T13:35:34Z",
      "mergedAt": "2020-08-06T13:35:34Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "4829451c5a21cd7b85d59407bd46fcd2a194283d"
      },
      "comments": [
        {
          "author": "ericcornelissen",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I believe this change invalidates the last paragraph of the [Group Creation section](https://github.com/mlswg/mls-protocol/blob/d1d5f56a5d83781042d19c830497ab5aa104907f/draft-ietf-mls-protocol.md#group-creation), as it is impossible to verify the group creation process for the joiner without knowing the random `init_secret` that the group creator used.\r\n\r\n\r\n> A new member receiving a Welcome message can recognize group creation if the number of entries in the members array is equal to the number of leaves in the tree minus one. A client receiving a Welcome message SHOULD verify whether it is a newly created group, and if so, **SHOULD verify that the above process was followed by reconstructing the Add and Commit messages and verifying that the resulting transcript hashes and epoch secret match those found in the Welcome message.**",
          "createdAt": "2020-08-11T13:32:49Z",
          "updatedAt": "2020-08-11T13:32:49Z"
        },
        {
          "author": "tomtau",
          "authorAssociation": "CONTRIBUTOR",
          "body": "maybe one alternative is to keep the zero `init_secret`, but make it compulsory to populate the path for this group creation welcome/commit (so that `commit_secret` isn't zero)?",
          "createdAt": "2020-08-12T05:24:36Z",
          "updatedAt": "2020-08-12T05:28:14Z"
        },
        {
          "author": "ericcornelissen",
          "authorAssociation": "CONTRIBUTOR",
          "body": "That would also work @tomtau (I also suggested that as an alternative in my original report in the mailing list), to me it is a little bit less elegant though. Personally, I also wonder why it is necessary to verify that group creation just happened. (Moreover, this way of recognizing group creation would prevent any group from which all but one person left from continuing, which my be confusing to end-users)",
          "createdAt": "2020-08-12T06:12:51Z",
          "updatedAt": "2020-08-12T06:12:51Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYyNDc2ODQ3",
          "commit": {
            "abbreviatedOid": "d66463a"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "lgtm with one minor thing fixed",
          "createdAt": "2020-08-06T12:38:04Z",
          "updatedAt": "2020-08-06T12:38:47Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "```suggestion\r\n  * Init secret: a fresh random value of size `KDF.Nh`\r\n```\r\n\r\n... just to ensure you have enough entropy here.",
              "createdAt": "2020-08-06T12:38:04Z",
              "updatedAt": "2020-08-06T12:59:35Z"
            }
          ]
        }
      ]
    },
    {
      "number": 387,
      "id": "MDExOlB1bGxSZXF1ZXN0NDY1NjI1MDI2",
      "title": "Make composite types 2^32 and make 0 invalid for enums",
      "url": "https://github.com/mlswg/mls-protocol/pull/387",
      "state": "MERGED",
      "author": "Bren2010",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "- 0 is invalid for all enums except a few, and I wasn't sure if it mattered? So I made them consistent\r\n- `DirectPath.nodes` needs to be 2^32 to fit the largest DirectPathNode\r\n- Make the `extensions` array 2^32 as well to fit the largest Extension, and also 2^16 for *all* extensions seems small",
      "createdAt": "2020-08-10T17:09:38Z",
      "updatedAt": "2020-08-11T19:48:58Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "d1d5f56a5d83781042d19c830497ab5aa104907f",
      "headRepository": "Bren2010/mls-protocol",
      "headRefName": "brendan/2020.8.0",
      "headRefOid": "83471ad6a95c7f1bb0c8ccb42f2eed2bdcc1f958",
      "closedAt": "2020-08-11T19:48:58Z",
      "mergedAt": "2020-08-11T19:48:58Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "4fc8afa1f7548ebf56bde9e2d45d0352c66fcf5b"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY1MjMzODA5",
          "commit": {
            "abbreviatedOid": "63e14af"
          },
          "author": "seanturner",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-11T16:28:44Z",
          "updatedAt": "2020-08-11T16:28:44Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "Change to reserved.",
              "createdAt": "2020-08-11T16:28:44Z",
              "updatedAt": "2020-08-11T18:45:44Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY1MjMzOTU4",
          "commit": {
            "abbreviatedOid": "63e14af"
          },
          "author": "seanturner",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-11T16:28:53Z",
          "updatedAt": "2020-08-11T16:28:54Z",
          "comments": [
            {
              "originalPosition": 52,
              "body": "Change to reserved.",
              "createdAt": "2020-08-11T16:28:54Z",
              "updatedAt": "2020-08-11T18:45:44Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY1Mzc3OTc0",
          "commit": {
            "abbreviatedOid": "83471ad"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-08-11T19:48:51Z",
          "updatedAt": "2020-08-11T19:48:51Z",
          "comments": []
        }
      ]
    },
    {
      "number": 388,
      "id": "MDExOlB1bGxSZXF1ZXN0NDY2MTc0NzI2",
      "title": "Clarify the transcript hash computation",
      "url": "https://github.com/mlswg/mls-protocol/pull/388",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Addresses ambiguity pointed out on the mailing list by @ericcornelissen.\r\n\r\nFixes #386 ",
      "createdAt": "2020-08-11T15:20:44Z",
      "updatedAt": "2020-08-11T19:18:12Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "d1d5f56a5d83781042d19c830497ab5aa104907f",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "interim",
      "headRefOid": "2c570160ae48c198a31ff3e9dedb27d1c0ed110a",
      "closedAt": "2020-08-11T19:18:11Z",
      "mergedAt": "2020-08-11T19:18:11Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "385c19416355b5f2900e3b499bdeb4e718b08348"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY1MjI4NDMz",
          "commit": {
            "abbreviatedOid": "870674d"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-11T16:22:24Z",
          "updatedAt": "2020-08-11T16:22:25Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "Still not clear to me what `0` means here. ",
              "createdAt": "2020-08-11T16:22:24Z",
              "updatedAt": "2020-08-11T16:23:23Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY1MzU1ODM4",
          "commit": {
            "abbreviatedOid": "2c57016"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-08-11T19:14:20Z",
          "updatedAt": "2020-08-11T19:14:20Z",
          "comments": []
        }
      ]
    },
    {
      "number": 389,
      "id": "MDExOlB1bGxSZXF1ZXN0NDY2MzI5NzQw",
      "title": "#383: Enable Commit to cover new proposal types",
      "url": "https://github.com/mlswg/mls-protocol/pull/389",
      "state": "MERGED",
      "author": "Bren2010",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-08-11T20:10:13Z",
      "updatedAt": "2020-08-25T18:33:18Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "e477ea4279f680446d2cc6f2011b2b8961d77033",
      "headRepository": "Bren2010/mls-protocol",
      "headRefName": "brendan/2020.8.2",
      "headRefOid": "dd70f10f2701ef46e4f0cd6b19488b1574b9ce2f",
      "closedAt": "2020-08-25T18:33:17Z",
      "mergedAt": "2020-08-25T18:33:17Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "28c6099e92f2b4767e247cd2016abd760a6620d0"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY1Mzk5Mjk2",
          "commit": {
            "abbreviatedOid": "1a2ee8a"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-11T20:21:50Z",
          "updatedAt": "2020-08-11T21:04:35Z",
          "comments": [
            {
              "originalPosition": 113,
              "body": "This algorithm doesn't validate that the `proposals` vector is in the proper order, which is the complexity I'm most worried about.  Do you have a proposed algorithm for that?",
              "createdAt": "2020-08-11T20:21:50Z",
              "updatedAt": "2020-08-25T18:28:18Z"
            },
            {
              "originalPosition": 103,
              "body": "It might be good to (1) break these out into bullets, and (2) state explicitly where other proposal types fit (presumably after Adds, in any order defined by the proposals?).",
              "createdAt": "2020-08-11T21:03:07Z",
              "updatedAt": "2020-08-25T18:28:18Z"
            },
            {
              "originalPosition": 103,
              "body": "As I mentioned on the call today, we need a way for clients to state their support for proposals, e.g., a `supported_proposals` field in the `capabilities` extension.",
              "createdAt": "2020-08-11T21:04:32Z",
              "updatedAt": "2020-08-25T18:28:18Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY1NDI5NTYz",
          "commit": {
            "abbreviatedOid": "1a2ee8a"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-11T21:07:16Z",
          "updatedAt": "2020-08-11T21:07:16Z",
          "comments": [
            {
              "originalPosition": 113,
              "body": "Yes it does, line 1962 does that check",
              "createdAt": "2020-08-11T21:07:16Z",
              "updatedAt": "2020-08-25T18:28:18Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY1NDMyMTEw",
          "commit": {
            "abbreviatedOid": "1a2ee8a"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-11T21:11:35Z",
          "updatedAt": "2020-08-11T21:11:35Z",
          "comments": [
            {
              "originalPosition": 103,
              "body": "I didn't state where other proposals go, because I thought extensions would want to decide for themselves.\r\n\r\nI think support for given proposals should be assumed if the client supports a given group extension",
              "createdAt": "2020-08-11T21:11:35Z",
              "updatedAt": "2020-08-25T18:28:18Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY2MDkyMjUx",
          "commit": {
            "abbreviatedOid": "f76ad2e"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-12T16:43:25Z",
          "updatedAt": "2020-08-12T16:43:26Z",
          "comments": [
            {
              "originalPosition": 113,
              "body": "line 1967 now",
              "createdAt": "2020-08-12T16:43:26Z",
              "updatedAt": "2020-08-25T18:28:18Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY3ODI1MDYx",
          "commit": {
            "abbreviatedOid": "3b27aa3"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-14T19:26:29Z",
          "updatedAt": "2020-08-14T20:56:44Z",
          "comments": [
            {
              "originalPosition": 113,
              "body": "I see what you mean.  That also explains why you reordered the proposal definitions, which I found a bit puzzling :)  You've still got them in the wrong order, (Add, Update, Remove) instead of (Update, Remove, Add).\r\n\r\nI would prefer not to rely interpreting ProposalType values as integers / the order of the enum here.  Instead, how about something more explicit, like:\r\n\r\n```\r\ndef proposal_order(proposal_type):\r\n    if proposal_type == update:\r\n        return 1\r\n    elif proposal_type == remove:\r\n        return 2\r\n    elif proposal_type == add:\r\n        return 3\r\n    else:\r\n        return 4\r\n```",
              "createdAt": "2020-08-14T19:26:29Z",
              "updatedAt": "2020-08-25T18:28:18Z"
            },
            {
              "originalPosition": 113,
              "body": "At this point, though, I wonder what the utility is of requiring the proposals to be ordered.  We already require that the recipient MUST first apply the Updates, then Removes, then Adds.  It will remove the need for validation logic, and not make the processing logic much worse.\r\n\r\n```\r\napplied = set()\r\napplied = state.apply_updates(proposals, applied)\r\napplied = state.apply_removes(proposals, applied)\r\napplied = state.apply_adds(proposals, applied)\r\nif len(applied) != len(proposals):\r\n    raise Exception(\"Unsupported proposals\")\r\n```\r\n\r\nThis would get you to a point where new proposal types wouldn't require a *syntax* change, but would require different processing.  That doesn't seem awful, since new proposal types will have to be negotiated, and thus we can assume that if one is used, then everyone will have the right processing logic.",
              "createdAt": "2020-08-14T19:40:07Z",
              "updatedAt": "2020-08-25T18:28:18Z"
            },
            {
              "originalPosition": 113,
              "body": "In a related vein, this PR should:\r\n1. Extend the `capabilities` extension to have `supported_proposals`\r\n2. Add a note to the proposal processing step below that future proposal handling is defined by the future proposals.",
              "createdAt": "2020-08-14T20:56:40Z",
              "updatedAt": "2020-08-25T18:28:18Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY5NjA0OTk1",
          "commit": {
            "abbreviatedOid": "d6dd20e"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-18T16:04:37Z",
          "updatedAt": "2020-08-18T16:04:38Z",
          "comments": [
            {
              "originalPosition": 113,
              "body": "Added a note that the processing should be updated by extensions that add new proposals.\r\n\r\nI don't want to add a `supported_proposals` vector, because proposals can't be supported piecemeal. If you support an extension and that extension adds several proposals, you'd need to support them all",
              "createdAt": "2020-08-18T16:04:38Z",
              "updatedAt": "2020-08-25T18:28:18Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc0NzM4NDMw",
          "commit": {
            "abbreviatedOid": "632c901"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Two small things, otherwise lgtm.",
          "createdAt": "2020-08-25T18:18:41Z",
          "updatedAt": "2020-08-25T18:23:02Z",
          "comments": [
            {
              "originalPosition": 40,
              "body": "\r\n```suggestion\r\nif the Commit covers no proposals at all (i.e., if the proposal vector\r\n```",
              "createdAt": "2020-08-25T18:18:41Z",
              "updatedAt": "2020-08-25T18:28:18Z"
            }
          ]
        }
      ]
    },
    {
      "number": 391,
      "id": "MDExOlB1bGxSZXF1ZXN0NDY3Njk5NDEx",
      "title": "Rename DirectPath to UpdatePath",
      "url": "https://github.com/mlswg/mls-protocol/pull/391",
      "state": "MERGED",
      "author": "chelseakomlo",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "This is a simple rename of `DirectPath` to `UpdatePath` to be more descriptive of the action being performed by the message.\r\n\r\nI'll open a separate PR after this PIR is merged with updates to the spec where it uses `Commit` when instead it should say `UpdatePath` (since not every `Commit` actually ratchets forward key material, as I understand). Some examples of where these clarifications should happen are: \r\n\r\n- Line 1203 should instead say \"each MLS UpdatePath message\" \r\n- The sections \"Ratchet Tree Evolution\" and \"Sychronizing Views of the Tree\" should describe the process of generating the key material for an `UpdatePath` message\r\n\r\ncc @bifurcation ",
      "createdAt": "2020-08-14T00:11:44Z",
      "updatedAt": "2020-08-20T16:03:46Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "4fc8afa1f7548ebf56bde9e2d45d0352c66fcf5b",
      "headRepository": null,
      "headRefName": "direct-path-to-update-path",
      "headRefOid": "09fcebc4d20fcb49e7ae3e4a9989b41b70af3fef",
      "closedAt": "2020-08-20T16:03:46Z",
      "mergedAt": "2020-08-20T16:03:46Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "9f52307a138e303b967eca3df9df966ee581e9ef"
      },
      "comments": [
        {
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "body": "DirectPath corresponds to the graph theory term \"direct path\" of a leaf with the root",
          "createdAt": "2020-08-14T00:20:13Z",
          "updatedAt": "2020-08-14T00:20:13Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "\"Direct path\" is still a thing, and the object in question here operates along a direct path, but I think \"UpdatePath\" indicates more clearly what it's doing.",
          "createdAt": "2020-08-20T16:03:42Z",
          "updatedAt": "2020-08-20T16:03:42Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 393,
      "id": "MDExOlB1bGxSZXF1ZXN0NDY3OTgwNDIw",
      "title": "Application messages MUST be encrypted",
      "url": "https://github.com/mlswg/mls-protocol/pull/393",
      "state": "MERGED",
      "author": "raphaelrobert",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-08-14T13:20:20Z",
      "updatedAt": "2020-10-05T15:44:30Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "4fc8afa1f7548ebf56bde9e2d45d0352c66fcf5b",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "raphaelrobert-message-encryption",
      "headRefOid": "6855c706ed7b9a7e87a9da11b6c2c971c8c6cc88",
      "closedAt": "2020-08-25T16:17:54Z",
      "mergedAt": "2020-08-25T16:17:54Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "e477ea4279f680446d2cc6f2011b2b8961d77033"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY3ODIwMzc0",
          "commit": {
            "abbreviatedOid": "6855c70"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-14T19:17:27Z",
          "updatedAt": "2020-08-14T19:17:37Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "I don't think this MUST makes sense -- for example, there may be cases where you want to take an MLS key exchange and protect application data with an exported key.\r\n\r\nInstead, can we just delete \"both application and\" here?  I think the intent of the sentence was to encourage encryption of handshake messages, not to say anything about application messages.",
              "createdAt": "2020-08-14T19:17:28Z",
              "updatedAt": "2020-08-14T19:17:37Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY3OTY2Nzky",
          "commit": {
            "abbreviatedOid": "6855c70"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-15T11:56:20Z",
          "updatedAt": "2020-08-15T11:56:20Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "> I don't think this MUST makes sense -- for example, there may be cases where you want to take an MLS key exchange and protect application data with an exported key.\r\n\r\nIf you just want to use MLS for key exchange and then use key material from the exporter that's fine, but that's orthogonal to using Application Messages.\r\n\r\nI really want to make sure that client never send unencrypted Application Messages. If you don't care about confidentiality you can always use the AAD for that.",
              "createdAt": "2020-08-15T11:56:20Z",
              "updatedAt": "2020-08-15T11:56:20Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc0NjQyNjMz",
          "commit": {
            "abbreviatedOid": "6855c70"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-08-25T16:17:29Z",
          "updatedAt": "2020-08-25T16:17:38Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "Actually, on re-read, seems clear from context.",
              "createdAt": "2020-08-25T16:17:29Z",
              "updatedAt": "2020-08-25T16:17:38Z"
            }
          ]
        }
      ]
    },
    {
      "number": 394,
      "id": "MDExOlB1bGxSZXF1ZXN0NDY3OTg3Mjk4",
      "title": "Confirmation fix",
      "url": "https://github.com/mlswg/mls-protocol/pull/394",
      "state": "MERGED",
      "author": "raphaelrobert",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": " This PR gets rid of the explicit HMAC reference and uses KDF.Extract instead (which internally uses HMAC). Also `confirmation` is renamed to `confirmation_tag`.",
      "createdAt": "2020-08-14T13:33:50Z",
      "updatedAt": "2020-10-05T15:44:31Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "4fc8afa1f7548ebf56bde9e2d45d0352c66fcf5b",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "raphaelrobert-hmac",
      "headRefOid": "71e5cb48115be760667704af12837119b706dff2",
      "closedAt": "2020-08-14T19:14:25Z",
      "mergedAt": "2020-08-14T19:14:25Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "1982f307a772d17c0470ee492fcedf4cfafac62d"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY3ODE4NzAx",
          "commit": {
            "abbreviatedOid": "71e5cb4"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "I don't love the extra `_tag`, but I can live with it.",
          "createdAt": "2020-08-14T19:14:18Z",
          "updatedAt": "2020-08-14T19:14:18Z",
          "comments": []
        }
      ]
    },
    {
      "number": 395,
      "id": "MDExOlB1bGxSZXF1ZXN0NDY5NTQ3NDgy",
      "title": "Remove requirement to verify the group creation process",
      "url": "https://github.com/mlswg/mls-protocol/pull/395",
      "state": "MERGED",
      "author": "ericcornelissen",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #390\r\n\r\nAs discussed on [the mailing list](https://mailarchive.ietf.org/arch/msg/mls/CbBEhH5A7OyoP6Mf5FFXgSU0r30/) this removes the paragraph in the Group Creation section specifying that joiners SHOULD verify group creation if it is detected. A recent change to group creation - namely a random initial `init_secret` - makes it impossible to verify group creation.\r\n",
      "createdAt": "2020-08-18T14:46:24Z",
      "updatedAt": "2020-08-18T15:18:35Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "1982f307a772d17c0470ee492fcedf4cfafac62d",
      "headRepository": null,
      "headRefName": "update-group-creation",
      "headRefOid": "76d115f8f3f4eee55feff5f09ee177820bf1d32f",
      "closedAt": "2020-08-18T14:50:20Z",
      "mergedAt": "2020-08-18T14:50:19Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "bb6b3fa6ae3869275a16be24250e9ac26ddfe02a"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY5NTMzNzc5",
          "commit": {
            "abbreviatedOid": "76d115f"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-08-18T14:50:14Z",
          "updatedAt": "2020-08-18T14:50:14Z",
          "comments": []
        }
      ]
    },
    {
      "number": 396,
      "id": "MDExOlB1bGxSZXF1ZXN0NDY5Njc4NjM2",
      "title": "Authenticate group membership in MLSPlaintext",
      "url": "https://github.com/mlswg/mls-protocol/pull/396",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "[Jo\u00ebl pointed out on the list](https://mailarchive.ietf.org/arch/msg/mls/LFz5nC4BnNTf7-OGIac5_QdlCRs/) that MLSPlaintext does not currently authenticate the sender's membership on the group, and as a result, some important attacks arise.  Discussion on the list indicated that adding a MAC with a key derived from the key schedule would provide this authentication.  This PR implements that suggestion.",
      "createdAt": "2020-08-18T18:57:31Z",
      "updatedAt": "2020-10-07T15:19:33Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "62c2b24f4c406eddd80e528ca07fb1dfca8b5505",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "member-pt",
      "headRefOid": "ac35b2336d1cc8e668d552c7fcd19073416fb051",
      "closedAt": "2020-10-07T15:18:36Z",
      "mergedAt": "2020-10-07T15:18:36Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "81c3949040724725d76568887851dba7930238f9"
      },
      "comments": [
        {
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "body": "Lgtm. Rebase and I'll properly approve.",
          "createdAt": "2020-09-10T17:12:14Z",
          "updatedAt": "2020-09-10T17:12:14Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Generally not a fan of rebasing, but here you go.",
          "createdAt": "2020-09-10T17:23:10Z",
          "updatedAt": "2020-09-10T17:23:10Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDczODU2NTM0",
          "commit": {
            "abbreviatedOid": "02cb4f5"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-24T21:05:59Z",
          "updatedAt": "2020-08-24T21:15:10Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "You didn't fix this issue?",
              "createdAt": "2020-08-24T21:05:59Z",
              "updatedAt": "2020-10-07T15:16:32Z"
            },
            {
              "originalPosition": 30,
              "body": "\"contains the content\"",
              "createdAt": "2020-08-24T21:11:12Z",
              "updatedAt": "2020-10-07T15:16:32Z"
            },
            {
              "originalPosition": 32,
              "body": "\"the AEAD authenticates\"",
              "createdAt": "2020-08-24T21:12:04Z",
              "updatedAt": "2020-10-07T15:16:32Z"
            },
            {
              "originalPosition": 25,
              "body": "Using a KDF output for authentication feels wrong",
              "createdAt": "2020-08-24T21:15:05Z",
              "updatedAt": "2020-10-07T15:16:32Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc0NTM5OTMw",
          "commit": {
            "abbreviatedOid": "02cb4f5"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-25T14:29:33Z",
          "updatedAt": "2020-08-25T14:29:33Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "I thought about it, and decided not to worry about it.  If you feel strongly, we can keep it.",
              "createdAt": "2020-08-25T14:29:33Z",
              "updatedAt": "2020-10-07T15:16:32Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc0NTQxNzY3",
          "commit": {
            "abbreviatedOid": "02cb4f5"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-25T14:31:28Z",
          "updatedAt": "2020-08-25T14:31:28Z",
          "comments": [
            {
              "originalPosition": 25,
              "body": "We already do this elsewhere:\r\n```\r\nMLSPlaintext.confirmation_tag =\r\n    KDF.Extract(confirmation_key, GroupContext.confirmed_transcript_hash)\r\n```\r\n\r\nThis seems OK with HKDF, since Extract is just HMAC.  But I agree that we should confirm that this generalizes properly.",
              "createdAt": "2020-08-25T14:31:28Z",
              "updatedAt": "2020-10-07T15:16:32Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc0NjYyOTQ1",
          "commit": {
            "abbreviatedOid": "02cb4f5"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-25T16:41:53Z",
          "updatedAt": "2020-08-25T16:41:54Z",
          "comments": [
            {
              "originalPosition": 25,
              "body": "Agreements on the 2020-08-25 call:\r\n* Use an explicit MAC here instead of KDF.Extract\r\n* Use a separate key from the key schedule, different from the confirmation_key\r\n\r\n```\r\nepoch\r\n  |\r\n  +-- confirmation_key\r\n  |\r\n  +-- membership_key\r\n  |\r\n  +-- authentication_secret (todo)\r\n```",
              "createdAt": "2020-08-25T16:41:54Z",
              "updatedAt": "2020-10-07T15:16:32Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg2MzUxOTQw",
          "commit": {
            "abbreviatedOid": "0275142"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-09-10T22:23:07Z",
          "updatedAt": "2020-09-10T22:23:07Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg3MTg3Mjgw",
          "commit": {
            "abbreviatedOid": "0275142"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-12T00:49:09Z",
          "updatedAt": "2020-09-12T00:49:09Z",
          "comments": [
            {
              "originalPosition": 37,
              "body": "Actually this isn't quite right because the signature doesn't cover the membership token",
              "createdAt": "2020-09-12T00:49:09Z",
              "updatedAt": "2020-10-07T15:16:32Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg3MTg4MDg1",
          "commit": {
            "abbreviatedOid": "0275142"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-12T00:56:14Z",
          "updatedAt": "2020-09-12T00:56:14Z",
          "comments": [
            {
              "originalPosition": 45,
              "body": "Please make this its own sub-section titled \"Plaintext Authentication\" or similar, and add an explainer that `membership_tag` is only necessary when sending MLSPlaintext over-the-wire",
              "createdAt": "2020-09-12T00:56:14Z",
              "updatedAt": "2020-10-07T15:16:32Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkzMzMwNDU5",
          "commit": {
            "abbreviatedOid": "0275142"
          },
          "author": "psyoptix",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2020-09-22T10:41:27Z",
          "updatedAt": "2020-09-22T11:34:31Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "I think membership_tag field can be moved to the \"case proposal\"  section (line 1500). We only need it if the content type = proposal so including it in all MLSPlaintexts would waste bandwidth. Here's my reasoning:\r\n\r\n- content type = application should never be sent as MLSPlaintext and an MLSCiphertext already has a mechanism for authenticating that a sender knows the current key schedule\r\n\r\n- content type = commit already includes the confirmation_tag. That in turn is derived (in part) from the MLSPlaintext content of this packet and secrets in the application key schedule. So if I were to change any of that content then I'd have to derive a fresh confirmation_tag. That in turn means I need to know secrets from the key schedule which is what we wanted.",
              "createdAt": "2020-09-22T10:41:28Z",
              "updatedAt": "2020-10-07T15:16:32Z"
            }
          ]
        }
      ]
    },
    {
      "number": 397,
      "id": "MDExOlB1bGxSZXF1ZXN0NDcxMjQwODg2",
      "title": "Always use path secrets with KDF.Expand",
      "url": "https://github.com/mlswg/mls-protocol/pull/397",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "@ericcornelissen pointed out on the mailing list that path secrets are currently used with both KDF.Expand and KEM.DeriveKeyPair.  This PR introduces an extra KDF.Expand call so that each key is used with exactly one algorithm.",
      "createdAt": "2020-08-20T21:04:23Z",
      "updatedAt": "2020-08-25T16:11:15Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "9f52307a138e303b967eca3df9df966ee581e9ef",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "re-expand",
      "headRefOid": "0e926c2b72209d71a12f7463a3620c5d8e967576",
      "closedAt": "2020-08-25T16:11:15Z",
      "mergedAt": "2020-08-25T16:11:15Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "7b9065d4cba1e8f1636a9e99354b761920ca5d99"
      },
      "comments": [
        {
          "author": "ericcornelissen",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I believe it was @chrisbrzuska who that [pointed this out](https://mailarchive.ietf.org/arch/msg/mls/EQLdrkuVBeB5ExDcFx4EMbJcpOg/), not me. Also, shouldn't the `node_priv[n]` and `node_pub[n]` derivation be updated as well?\r\n\r\n```diff\r\n- node_priv[n], node_pub[n] = KEM.DeriveKeyPair(path_secret[n])\r\n+ node_priv[n], node_pub[n] = KEM.DeriveKeyPair(node_secret[n])\r\n```",
          "createdAt": "2020-08-21T06:11:41Z",
          "updatedAt": "2020-08-21T06:11:41Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Ah, sorry!  I'll make that change.",
          "createdAt": "2020-08-25T14:27:56Z",
          "updatedAt": "2020-08-25T14:27:56Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Approved at the interim 2020-08-25.",
          "createdAt": "2020-08-25T16:11:10Z",
          "updatedAt": "2020-08-25T16:11:10Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 398,
      "id": "MDExOlB1bGxSZXF1ZXN0NDczNDIwODAw",
      "title": "Use full-size path secrets",
      "url": "https://github.com/mlswg/mls-protocol/pull/398",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #392 \r\n\r\n(Also, when I made the change from `KEM.Nsk` to `KDF.Nh`, I realized that the calls to `ExpandWithLabel` all had the same structure as `DeriveSecret`, so I changed to just call DeriveSecret directly.)",
      "createdAt": "2020-08-25T19:45:43Z",
      "updatedAt": "2020-09-03T00:30:22Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "28c6099e92f2b4767e247cd2016abd760a6620d0",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "full-size-secrets",
      "headRefOid": "5fbcb392b853ba30754c2dc6e1b57136b49f056f",
      "closedAt": "2020-09-03T00:30:22Z",
      "mergedAt": "2020-09-03T00:30:22Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "1d5e14d79435834bc5cab6c7aa9e2fcdd6afeabc"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc0OTI1NTYy",
          "commit": {
            "abbreviatedOid": "5fbcb39"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-08-25T21:27:22Z",
          "updatedAt": "2020-08-25T21:27:22Z",
          "comments": []
        }
      ]
    },
    {
      "number": 399,
      "id": "MDExOlB1bGxSZXF1ZXN0NDc0MTE2MzYy",
      "title": "Use UpdatePath instead of Commit when describing tree updates",
      "url": "https://github.com/mlswg/mls-protocol/pull/399",
      "state": "MERGED",
      "author": "chelseakomlo",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "This PR updates two sections to reference generating and sending an `UpdatePath` message, as not all Commits transmit fresh key material (as discussed in #391). \r\n\r\nThis PR also includes light editorial edits for clarity and adds detail around the steps to perform an update.\r\n\r\nSection 7.7 `Update Paths` currently says that \"each MLS Commit message needs to transmit a KeyPackage leaf and node values along its direct path\", but section 10.2 `Commit` says that an UpdatePath is optional. I can update 7.7 as well, if 10.2 is correct.",
      "createdAt": "2020-08-26T19:44:57Z",
      "updatedAt": "2020-09-03T00:30:01Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "28c6099e92f2b4767e247cd2016abd760a6620d0",
      "headRepository": null,
      "headRefName": "commit-to-update-path-specification",
      "headRefOid": "8b3dd5d33fa2d689534035b6cbbde4799527f407",
      "closedAt": "2020-09-03T00:30:01Z",
      "mergedAt": "2020-09-03T00:30:01Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "d50188c7549d640d557b2b6524d412915eed48ae"
      },
      "comments": [
        {
          "author": "chelseakomlo",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I went ahead and changed Section 7.7 to specify that MLS commits may optionally transmit updates for consistency with Section 10.2",
          "createdAt": "2020-09-01T03:09:31Z",
          "updatedAt": "2020-09-01T03:09:31Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc5NzM5MzQx",
          "commit": {
            "abbreviatedOid": "0882711"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-01T13:27:20Z",
          "updatedAt": "2020-09-01T13:29:15Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "```suggestion\r\nA member of an MLS group advances the key schedule to provide forward secrecy\r\nand post-compromise security by providing the group with fresh key material to\r\nbe added into the group's shared secret. To do so, the member generates fresh key\r\n```\r\n\r\n... and change to present tense in the rest of the sentence",
              "createdAt": "2020-09-01T13:27:20Z",
              "updatedAt": "2020-09-03T00:27:48Z"
            },
            {
              "originalPosition": 54,
              "body": "```suggestion\r\nthis update to other members of the group in a Commit message, who\r\n```\r\n\r\n... or \"by including an UpdatePath in a Commit message\"",
              "createdAt": "2020-09-01T13:28:48Z",
              "updatedAt": "2020-09-03T00:27:48Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgxMzk5ODc0",
          "commit": {
            "abbreviatedOid": "94bc2ec"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-03T00:27:41Z",
          "updatedAt": "2020-09-03T00:27:41Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "```suggestion\r\nA member of an MLS group advances the key schedule to provide forward secrecy\r\n```",
              "createdAt": "2020-09-03T00:27:41Z",
              "updatedAt": "2020-09-03T00:27:48Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgxNDAwMDUy",
          "commit": {
            "abbreviatedOid": "8b3dd5d"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-09-03T00:28:20Z",
          "updatedAt": "2020-09-03T00:28:20Z",
          "comments": []
        }
      ]
    },
    {
      "number": 400,
      "id": "MDExOlB1bGxSZXF1ZXN0NDg1NTg1MjY3",
      "title": "Update security considerations.",
      "url": "https://github.com/mlswg/mls-protocol/pull/400",
      "state": "MERGED",
      "author": "Bren2010",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "bifurcation",
        "beurdouche"
      ],
      "labels": [],
      "body": "Security considerations has gotten a little outdated. Updated with new info",
      "createdAt": "2020-09-12T00:10:01Z",
      "updatedAt": "2020-10-07T15:21:25Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "eec3985d34dbb5a38fa45ec7edd3a0a1f2bd1fdc",
      "headRepository": "Bren2010/mls-protocol",
      "headRefName": "brendan/2020.9.0",
      "headRefOid": "53b3a5ec05e7402febfc5626deb27800db555183",
      "closedAt": "2020-10-07T15:21:25Z",
      "mergedAt": "2020-10-07T15:21:25Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "5f06f08d001054b74ce40b95bf4b2949eac81dc4"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg3NDkyNjAz",
          "commit": {
            "abbreviatedOid": "51850fb"
          },
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "Some very necessary updates, but I think we should be precise with regard to FS/PCS and/or leave it to the architecture document to go into detail. Especially FS (or PCFS) is very tricky in MLS.",
          "createdAt": "2020-09-14T07:38:44Z",
          "updatedAt": "2020-09-14T08:00:20Z",
          "comments": [
            {
              "originalPosition": 52,
              "body": "Do you mean public here? Private keys are usually not used for encryption. \r\n\r\nA small nitpick: Also, in theory, the old key _can_ still be used. The update just signals that other members shouldn't use it.",
              "createdAt": "2020-09-14T07:38:44Z",
              "updatedAt": "2020-10-05T17:55:44Z"
            },
            {
              "originalPosition": 96,
              "body": "`message_tag` -> `confirmation_tag`?",
              "createdAt": "2020-09-14T07:40:07Z",
              "updatedAt": "2020-10-05T17:55:44Z"
            },
            {
              "originalPosition": 110,
              "body": "I think FS is a bit more nuanced, as you only get full FS if you update your own leaf key and delete the old private key afterwards. That means you only get proper FS between epochs where you update your own leaf.\r\n\r\nYou might get some weaker version of FS, because you still need the init secret of the past epoch, but, for example, a member that was just removed might still have that. I think FS for a given epoch should not depend on other epochs having been compromised in the past.\r\n\r\nYou also get some partial FS if someone else updates a key in your path, I think, but I'm not sure we should advertise this here.",
              "createdAt": "2020-09-14T07:46:44Z",
              "updatedAt": "2020-10-05T17:55:44Z"
            },
            {
              "originalPosition": 112,
              "body": "In line with my comment above, I don't think you can get full FS \"within\" an epoch, as the key material used to derive the application secrets/keys in the first place might still be around. The AS Tree and the sender ratchets allow you to still provide optimal FS while keeping old keys around to decrypt out-of-order messages, but only _after_ you've deleted the other key material.",
              "createdAt": "2020-09-14T07:55:46Z",
              "updatedAt": "2020-10-05T17:55:44Z"
            },
            {
              "originalPosition": 105,
              "body": "Maybe qualify that only the updating parties get PCS as opposed to the whole group? This is not explicit here, but just to be precise.",
              "createdAt": "2020-09-14T07:57:08Z",
              "updatedAt": "2020-10-05T17:55:44Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg3OTY3NzEy",
          "commit": {
            "abbreviatedOid": "51850fb"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-14T16:54:26Z",
          "updatedAt": "2020-09-14T16:54:27Z",
          "comments": [
            {
              "originalPosition": 96,
              "body": "`membership_tag` actually, https://github.com/mlswg/mls-protocol/pull/396",
              "createdAt": "2020-09-14T16:54:26Z",
              "updatedAt": "2020-10-05T17:55:44Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg3OTcyNjY5",
          "commit": {
            "abbreviatedOid": "51850fb"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-14T17:00:53Z",
          "updatedAt": "2020-09-14T17:00:53Z",
          "comments": [
            {
              "originalPosition": 105,
              "body": "I think it's fine to only discuss PCS wrt to an individual member. FS is talked about the same way, and it makes sense to me",
              "createdAt": "2020-09-14T17:00:53Z",
              "updatedAt": "2020-10-05T17:55:44Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg3OTc5Nzgx",
          "commit": {
            "abbreviatedOid": "51850fb"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-14T17:10:42Z",
          "updatedAt": "2020-09-14T17:10:42Z",
          "comments": [
            {
              "originalPosition": 112,
              "body": "That key material must be deleted per the protocol, so I don't feel the need to re-specify that in its entirety here",
              "createdAt": "2020-09-14T17:10:42Z",
              "updatedAt": "2020-10-05T17:55:44Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg3OTgxMjkz",
          "commit": {
            "abbreviatedOid": "51850fb"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-14T17:12:47Z",
          "updatedAt": "2020-09-14T17:12:47Z",
          "comments": [
            {
              "originalPosition": 110,
              "body": "I think what I said is correct in principle, I'm just cutting corners. There's a disclaimer at the top of this section saying that this is just meant to give a high-level understanding of why MLS is secure but a full discussion is out of scope",
              "createdAt": "2020-09-14T17:12:47Z",
              "updatedAt": "2020-10-05T17:55:44Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg4MjQ1MzM3",
          "commit": {
            "abbreviatedOid": "a0f96a5"
          },
          "author": "tomtau",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-15T00:39:33Z",
          "updatedAt": "2020-09-15T00:39:34Z",
          "comments": [
            {
              "originalPosition": 39,
              "body": "```suggestion\r\nsubtree. This is called the *ratchet tree invariant* and it makes it possible to\r\n```",
              "createdAt": "2020-09-15T00:39:33Z",
              "updatedAt": "2020-10-05T17:55:44Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg4Mzc5Mzg3",
          "commit": {
            "abbreviatedOid": "a0f96a5"
          },
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-15T06:59:42Z",
          "updatedAt": "2020-09-15T06:59:43Z",
          "comments": [
            {
              "originalPosition": 112,
              "body": "It's true that it must be deleted. It's just that deleting it doesn't give you FS within an epoch.",
              "createdAt": "2020-09-15T06:59:42Z",
              "updatedAt": "2020-10-05T17:55:44Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAzOTk3NTkw",
          "commit": {
            "abbreviatedOid": "53b3a5e"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-10-07T15:21:18Z",
          "updatedAt": "2020-10-07T15:21:18Z",
          "comments": []
        }
      ]
    },
    {
      "number": 401,
      "id": "MDExOlB1bGxSZXF1ZXN0NDg2ODYyNDEz",
      "title": "Derive handshake keys from a secret tree as well.",
      "url": "https://github.com/mlswg/mls-protocol/pull/401",
      "state": "MERGED",
      "author": "Bren2010",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-09-14T20:24:24Z",
      "updatedAt": "2022-05-06T15:42:23Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "bb303085f3748a7ba171f9f12fdbeef22d063283",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "brendan/2020.9.2",
      "headRefOid": "5a4bfcff4b5377438d02e2e4488c44ee5fc1c156",
      "closedAt": "2020-10-06T13:55:10Z",
      "mergedAt": "2020-10-06T13:55:10Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "62c2b24f4c406eddd80e528ca07fb1dfca8b5505"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk3NDc4Mjc2",
          "commit": {
            "abbreviatedOid": "7483556"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-28T12:52:16Z",
          "updatedAt": "2020-09-28T12:52:37Z",
          "comments": [
            {
              "originalPosition": 25,
              "body": "I think that on the last interim call, we agreed to split off at the leaves of the tree, instead of at the root.  So you would have one secret tree per epoch, and the leaves would split into application and handshake hash chains.\r\n\r\n@Bren2010 if you could make that update, I think this is good to go.",
              "createdAt": "2020-09-28T12:52:16Z",
              "updatedAt": "2020-09-29T02:35:19Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk4MDIzNDM2",
          "commit": {
            "abbreviatedOid": "5a4bfcf"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-29T02:35:46Z",
          "updatedAt": "2020-09-29T02:35:47Z",
          "comments": [
            {
              "originalPosition": 25,
              "body": "Updated, thank you!",
              "createdAt": "2020-09-29T02:35:47Z",
              "updatedAt": "2020-09-29T02:35:47Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk4NTA0MzEx",
          "commit": {
            "abbreviatedOid": "5a4bfcf"
          },
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-09-29T14:02:33Z",
          "updatedAt": "2020-09-29T14:02:33Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAyOTg5NDAx",
          "commit": {
            "abbreviatedOid": "5a4bfcf"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-10-06T13:55:03Z",
          "updatedAt": "2020-10-06T13:55:03Z",
          "comments": []
        }
      ]
    },
    {
      "number": 402,
      "id": "MDExOlB1bGxSZXF1ZXN0NDg4MTE5OTAz",
      "title": "Allow for credentials supporting multiple signature schemes",
      "url": "https://github.com/mlswg/mls-protocol/pull/402",
      "state": "MERGED",
      "author": "kkohbrok",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "The credentials we have defined at the moment only contain a single public key and no information regarding what signature scheme that keypair works with (even though the Spec actually says it should include the signature scheme as well).\r\n\r\nIt would be nice, however, to support potential CredentialTypes that, similar to KeyPackages, include multiple supported signature schemes, each accompanied by a corresponding public key.\r\n\r\nThe Key that should be used in any given group is then determined by the CipherSuite of the group (which includes a Signature Scheme). When choosing a KeyPackage of a new member, it has to be one that contains a Credential which supports that Signature Scheme.\r\n\r\nNote, that I'm not suggesting that this be the case in all Credentials, or even that we change the BasicCredential.\r\n\r\nI understand that it's possible to have multiple credentials per identity, but in some authentication settings it can be beneficial to have a 1-to-1 mapping between Credential and identity.",
      "createdAt": "2020-09-16T16:53:31Z",
      "updatedAt": "2020-10-08T14:55:17Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "ca187c70d7a5a5ac38f027526e78a72fa043bdf5",
      "headRepository": "kkohbrok/mls-protocol",
      "headRefName": "multiple_signature_schemes",
      "headRefOid": "d3cde81650ae10568b658d16acb91c1233b2825b",
      "closedAt": "2020-10-08T14:55:17Z",
      "mergedAt": "2020-10-08T14:55:17Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "04ac5c00c6586acf60fa02354f5f2e17dc844812"
      },
      "comments": [
        {
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "body": "> It would be nice, however, to support potential CredentialTypes that, similar to KeyPackages, include multiple supported signature schemes, each accompanied by a corresponding public key.\r\n\r\nKeyPackages don't support multiple signature schemes?\r\n\r\n> I understand that it's possible to have multiple credentials per identity, but in some authentication settings it can be beneficial to have a 1-to-1 mapping between Credential and identity.\r\n\r\nIn what scenario is it beneficial?",
          "createdAt": "2020-09-17T20:43:41Z",
          "updatedAt": "2020-09-17T20:43:41Z"
        },
        {
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> KeyPackages don't support multiple signature schemes?\r\n\r\nAh, right. I think that was the case in the past, but you're right, they don't.\r\n\r\n> In what scenario is it beneficial?\r\n\r\nOf course it's always possible to just bundle a bunch of certificates, each supporting a different signature scheme and then treat that as your \"Multi-Scheme Credential\" in the grand scheme of things. \r\n\r\nHowever, if you end up rotating them a lot, where you have to sign them and potentially store the whole chain for a longer period of time, being able to support multiple signature schemes in only one credential means less overhead.",
          "createdAt": "2020-09-18T06:09:32Z",
          "updatedAt": "2020-09-18T06:09:32Z"
        },
        {
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "body": "> However, if you end up rotating them a lot, where you have to sign them and potentially store the whole chain for a longer period of time, being able to support multiple signature schemes in only one credential means less overhead.\r\n\r\nCredentials are stored in each group's ratchet tree though, so you're keeping a bunch of unnecessary key material in the group's tree which everyone has to store",
          "createdAt": "2020-09-18T15:17:01Z",
          "updatedAt": "2020-09-18T15:17:01Z"
        },
        {
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "That's fair. And it's not something you have to do if you don't want to. I'm just proposing for MLS to support that type of Credential in general.",
          "createdAt": "2020-09-18T15:21:11Z",
          "updatedAt": "2020-09-18T15:21:35Z"
        },
        {
          "author": "br-hale",
          "authorAssociation": "CONTRIBUTOR",
          "body": "To support hybrid PQ/standard schemes at any point in the future, allowing for multiple schemes is reasonable (in addition to the above arguments for it). Most applications probably will not use the feature, especially to start with, but providing support for just the option is not going to cause any of the problems noted. ",
          "createdAt": "2020-09-21T15:48:15Z",
          "updatedAt": "2020-09-21T15:48:15Z"
        },
        {
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "body": "> To support hybrid PQ/standard schemes at any point in the future, allowing for multiple schemes is reasonable\r\n\r\nPQ schemes can be used by switching the entire group to a new ciphersuite using those schemes. Requiring everybody in the group to store a bunch of unused key material isn't reasonable",
          "createdAt": "2020-09-21T16:26:02Z",
          "updatedAt": "2020-09-21T16:26:02Z"
        },
        {
          "author": "br-hale",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The statement was not about PQ, but hybrid PQ/standard schemes. Those require use to two signature schemes, for which both types of keying material are used.",
          "createdAt": "2020-09-21T16:27:57Z",
          "updatedAt": "2020-09-21T16:27:57Z"
        },
        {
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "body": "Then you need a ciphersuite that specifies a hybrid scheme.",
          "createdAt": "2020-09-21T16:30:20Z",
          "updatedAt": "2020-09-21T16:30:20Z"
        },
        {
          "author": "br-hale",
          "authorAssociation": "CONTRIBUTOR",
          "body": "It would be ideal to have a ciphersuite specifying a single hybrid scheme, but even that does not imply use of a single credential, unfortunately. In fact, hybrid schemes may rely on two separate credentials, with the ciphersuite specifying the hybrid algorithm for combining them. Since the \"main\" method of building a solo hybrid credential is under patent, there is also additional motivation for applications to use two.",
          "createdAt": "2020-09-21T16:39:38Z",
          "updatedAt": "2020-09-21T16:39:38Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "I concur with Brendan here.  To be consistent with our earlier decisions to (a) keep KeyPackages to one ciphersuite and (b) include the signature algorithm in the ciphersuite, we should keep credentials to one signature algorithm as well.\r\n\r\nPropose closing this PR without merging.",
          "createdAt": "2020-10-06T13:57:30Z",
          "updatedAt": "2020-10-06T13:57:30Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Discussed at 2020-10-06 interim, TODO:\r\n* Re-add SignatureScheme enum, re-using the TLS signature schemes\r\n* Clarify that the main job of a Credential is to provide a public key for verifying messages\r\n    * How it provides the credential might be different per credential type\r\n    * e.g., in BasicCredential, it's provided directly, X509Credential, have to parse the leaf certificate",
          "createdAt": "2020-10-06T15:48:49Z",
          "updatedAt": "2020-10-06T15:48:49Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA0ODU3NDMz",
          "commit": {
            "abbreviatedOid": "2b9a84e"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "LGTM with a couple nits.",
          "createdAt": "2020-10-08T14:41:07Z",
          "updatedAt": "2020-10-08T14:48:59Z",
          "comments": [
            {
              "originalPosition": 27,
              "body": "```suggestion\r\n```",
              "createdAt": "2020-10-08T14:41:07Z",
              "updatedAt": "2020-10-08T14:50:44Z"
            },
            {
              "originalPosition": 37,
              "body": "```suggestion\r\n    SignatureScheme signature_scheme;\r\n    opaque signature_key<0..2^16-1>;\r\n```",
              "createdAt": "2020-10-08T14:41:27Z",
              "updatedAt": "2020-10-08T14:50:44Z"
            }
          ]
        }
      ]
    },
    {
      "number": 403,
      "id": "MDExOlB1bGxSZXF1ZXN0NDg4MTIxMTg5",
      "title": "Rename identity key to signature key",
      "url": "https://github.com/mlswg/mls-protocol/pull/403",
      "state": "MERGED",
      "author": "kkohbrok",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "The public key in a credential is introduced without a special name and the field in the BasicCredential is currently called public_key, which is not very expressive. A few paragraphs below, it is referenced as \"Identity Key\" or simply \"Identity\", which is a bit misleading, as Credentials are supposed to contain an additional \"identity\" which is not the key.\r\n\r\nI propose we clear up the terminology a bit here and refer to the public key contained in a Credential as \"Signature Key\". ",
      "createdAt": "2020-09-16T16:56:03Z",
      "updatedAt": "2020-09-22T16:21:17Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "bb303085f3748a7ba171f9f12fdbeef22d063283",
      "headRepository": "kkohbrok/mls-protocol",
      "headRefName": "identity_key_rename",
      "headRefOid": "ffa13ae56d54fff10d51c9829e14dbd7a1d7ca05",
      "closedAt": "2020-09-22T16:21:17Z",
      "mergedAt": "2020-09-22T16:21:17Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "ca187c70d7a5a5ac38f027526e78a72fa043bdf5"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkwOTcyMTU2",
          "commit": {
            "abbreviatedOid": "ffa13ae"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-09-17T20:39:46Z",
          "updatedAt": "2020-09-17T20:39:46Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkzNjM3MTQx",
          "commit": {
            "abbreviatedOid": "ffa13ae"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-09-22T16:21:08Z",
          "updatedAt": "2020-09-22T16:21:08Z",
          "comments": []
        }
      ]
    },
    {
      "number": 404,
      "id": "MDExOlB1bGxSZXF1ZXN0NDg4MTIyNjU5",
      "title": "Remove long term and explicitly prevent changing of identity",
      "url": "https://github.com/mlswg/mls-protocol/pull/404",
      "state": "MERGED",
      "author": "kkohbrok",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Rotating keys is important and in some cases, Signature Keys are not going to be very \"long-term\". Instead they're going to be rotated periodically.\r\n\r\nI thus propose we simply remove the assumption that Signature Keys are of a \"long-term\" nature (or otherwise \"long-lived\"). \r\n\r\nThe second change in this PR is that I added a few words indicating explicitly that the identity must not change when updating a KeyPackage.",
      "createdAt": "2020-09-16T16:58:59Z",
      "updatedAt": "2020-09-28T12:49:11Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "ca187c70d7a5a5ac38f027526e78a72fa043bdf5",
      "headRepository": "kkohbrok/mls-protocol",
      "headRefName": "remove_long_term",
      "headRefOid": "25a2cdc6c477efdfeec8180d7a966354b7456991",
      "closedAt": "2020-09-28T12:49:11Z",
      "mergedAt": "2020-09-28T12:49:10Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "43a514125cfbd4fa00710babc6270b39139f1ef4"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkwOTY4MzEw",
          "commit": {
            "abbreviatedOid": "96cd22d"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-17T20:34:40Z",
          "updatedAt": "2020-09-17T20:38:39Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "```suggestion\r\n* An identity key provider which allows clients to authenticate\r\n```",
              "createdAt": "2020-09-17T20:34:40Z",
              "updatedAt": "2020-09-23T06:11:59Z"
            },
            {
              "originalPosition": 34,
              "body": "This doesn't necessarily make sense because not all credentials have an `identity`",
              "createdAt": "2020-09-17T20:38:25Z",
              "updatedAt": "2020-09-23T06:11:59Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkxNTU4NTM4",
          "commit": {
            "abbreviatedOid": "c6aae6f"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-09-18T15:15:28Z",
          "updatedAt": "2020-09-18T15:15:28Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkzNjYxNjAx",
          "commit": {
            "abbreviatedOid": "c6aae6f"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-09-22T16:50:39Z",
          "updatedAt": "2020-09-22T16:50:39Z",
          "comments": []
        }
      ]
    },
    {
      "number": 406,
      "id": "MDExOlB1bGxSZXF1ZXN0NDkwNDczOTI0",
      "title": "External Commits",
      "url": "https://github.com/mlswg/mls-protocol/pull/406",
      "state": "MERGED",
      "author": "raphaelrobert",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-09-21T18:13:54Z",
      "updatedAt": "2021-10-08T22:20:24Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "6c89e9fb40b15f225d0349b88426ac7ee2124212",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "external_commit",
      "headRefOid": "bc8445ceecb96c4742ca5dba0b792f9d974ab3cd",
      "closedAt": "2020-10-26T21:35:05Z",
      "mergedAt": "2020-10-26T21:35:05Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "5ea742c9770cd5f8b2964badba4e6e7b756fa13f"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAyMjkzMDAy",
          "commit": {
            "abbreviatedOid": "56c847f"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "- Please wrap lines at 80 characters\r\n- Please update to use an asymmetrically encrypted init secret (for *all* Commits, ideally)",
          "createdAt": "2020-10-05T17:59:54Z",
          "updatedAt": "2020-10-05T18:01:43Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "```suggestion\r\n2. A member of the group or a new member broadcasts a Commit message that causes one or more\r\n```",
              "createdAt": "2020-10-05T17:59:54Z",
              "updatedAt": "2020-10-26T21:10:46Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEyMDIwOTUw",
          "commit": {
            "abbreviatedOid": "a31fdee"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-19T17:56:10Z",
          "updatedAt": "2020-10-19T17:56:11Z",
          "comments": [
            {
              "originalPosition": 180,
              "body": "```suggestion\r\n* An external commit MUST reference exactly one ExternalInit proposal, and the\r\n  sender of the proposal MUST be the same as the sender of the Commit. When\r\n  processing a Commit, both existing and new members MUST use the external init\r\n  secret as described in {{external-initialization}}.\r\n```",
              "createdAt": "2020-10-19T17:56:10Z",
              "updatedAt": "2020-10-26T21:10:46Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEyMDIzNzUy",
          "commit": {
            "abbreviatedOid": "7edb721"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-19T17:59:51Z",
          "updatedAt": "2020-10-19T17:59:51Z",
          "comments": [
            {
              "originalPosition": 181,
              "body": "```suggestion\r\n* An external commit MUST reference no more than one ExternalInit proposal, and the\r\n  ExternalInit proposal MUST be supplied by value, not by reference. When\r\n  processing a Commit, both existing and new members MUST use the external init\r\n  secret as described in {{external-initialization}}.\r\n```",
              "createdAt": "2020-10-19T17:59:51Z",
              "updatedAt": "2020-10-26T21:10:46Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEyMDU5OTg0",
          "commit": {
            "abbreviatedOid": "7edb721"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-19T18:45:30Z",
          "updatedAt": "2020-10-19T18:45:31Z",
          "comments": [
            {
              "originalPosition": 181,
              "body": "I think we said that `ExternalInit` can only be an inline proposal, but we didn't specify it. So I'd rather specify that requirement in the ExternalInit section.",
              "createdAt": "2020-10-19T18:45:30Z",
              "updatedAt": "2020-10-26T21:10:46Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEyMDY2NTI5",
          "commit": {
            "abbreviatedOid": "7edb721"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-19T18:54:16Z",
          "updatedAt": "2020-10-19T18:54:16Z",
          "comments": [
            {
              "originalPosition": 181,
              "body": "(I updated your suggestion)",
              "createdAt": "2020-10-19T18:54:16Z",
              "updatedAt": "2020-10-26T21:10:46Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEyMjA5MjQy",
          "commit": {
            "abbreviatedOid": "7edb721"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-19T22:38:45Z",
          "updatedAt": "2020-10-19T22:38:45Z",
          "comments": [
            {
              "originalPosition": 181,
              "body": "I was about to argue that I don't think it technically needs to be an inline proposal, but it does -- there's no way to send ExternalInit if you're not in the group.  (You can use `new-member` for Add, but not ExternalInit.)  So your tweak works for me.\r\n",
              "createdAt": "2020-10-19T22:38:45Z",
              "updatedAt": "2020-10-26T21:10:46Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEyMjEyMzM0",
          "commit": {
            "abbreviatedOid": "7edb721"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-19T22:46:11Z",
          "updatedAt": "2020-10-20T02:08:45Z",
          "comments": [
            {
              "originalPosition": 18,
              "body": "Table is messed up again",
              "createdAt": "2020-10-19T22:46:11Z",
              "updatedAt": "2020-10-26T21:10:46Z"
            },
            {
              "originalPosition": 159,
              "body": "The ratchet tree is also needed for external joiners, so let's remove `tree_hash` and replace with `ratchet_tree`, and rename to something more descriptive like `GroupPublicState`",
              "createdAt": "2020-10-19T23:56:42Z",
              "updatedAt": "2020-10-26T21:10:46Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEyNzY3NTYy",
          "commit": {
            "abbreviatedOid": "9cabc69"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-20T14:16:35Z",
          "updatedAt": "2020-10-20T14:16:36Z",
          "comments": [
            {
              "originalPosition": 159,
              "body": "We should keep the same flexibility here. It makes no sense that clients upload a large tree for every epoch, if the tree is maintained by the server.",
              "createdAt": "2020-10-20T14:16:36Z",
              "updatedAt": "2020-10-26T21:10:46Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEyODE1Mzg0",
          "commit": {
            "abbreviatedOid": "0f24a78"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-20T14:58:40Z",
          "updatedAt": "2020-10-20T14:58:40Z",
          "comments": [
            {
              "originalPosition": 159,
              "body": "This structure is already maintained by the server. Users don't have to re-upload the whole thing, they can just tell the DS the new external_pub",
              "createdAt": "2020-10-20T14:58:40Z",
              "updatedAt": "2020-10-26T21:10:46Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEyODQyMzI4",
          "commit": {
            "abbreviatedOid": "0f24a78"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-20T15:15:33Z",
          "updatedAt": "2020-10-20T15:15:33Z",
          "comments": [
            {
              "originalPosition": 159,
              "body": "In that scenario, in addition to the pub key they also send the hash, so that the server can make sure it has the right public tree.",
              "createdAt": "2020-10-20T15:15:33Z",
              "updatedAt": "2020-10-26T21:10:46Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEzMDM3NzM5",
          "commit": {
            "abbreviatedOid": "0f24a78"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2020-10-20T18:51:40Z",
          "updatedAt": "2020-10-20T18:53:18Z",
          "comments": [
            {
              "originalPosition": 144,
              "body": "```suggestion\r\n* interim transcript hash\r\n```",
              "createdAt": "2020-10-20T18:51:40Z",
              "updatedAt": "2020-10-26T21:10:46Z"
            },
            {
              "originalPosition": 156,
              "body": "```suggestion\r\n    opaque interim_transcript_hash<0..255>;\r\n```",
              "createdAt": "2020-10-20T18:52:58Z",
              "updatedAt": "2020-10-26T21:10:46Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEzODIwNDMw",
          "commit": {
            "abbreviatedOid": "8773fc3"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-10-21T15:32:21Z",
          "updatedAt": "2020-10-21T15:32:21Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE3MDYzMTI4",
          "commit": {
            "abbreviatedOid": "8773fc3"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-26T18:27:27Z",
          "updatedAt": "2020-10-26T18:29:13Z",
          "comments": [
            {
              "originalPosition": 159,
              "body": "```suggestion\r\n} PublicGroupState;\r\n```",
              "createdAt": "2020-10-26T18:27:27Z",
              "updatedAt": "2020-10-26T21:10:46Z"
            },
            {
              "originalPosition": 31,
              "body": "```suggestion\r\nThe public key `external_pub` can be published as part of the `PublicGroupState`\r\n```",
              "createdAt": "2020-10-26T18:27:55Z",
              "updatedAt": "2020-10-26T21:10:46Z"
            },
            {
              "originalPosition": 43,
              "body": "```suggestion\r\ninformation provided in the PublicGroupState and an external Commit to initialize\r\n```",
              "createdAt": "2020-10-26T18:28:09Z",
              "updatedAt": "2020-10-26T21:10:46Z"
            },
            {
              "originalPosition": 47,
              "body": "```suggestion\r\nkem_output, context = SetupBaseS(external_pub, PublicGroupState)\r\n```",
              "createdAt": "2020-10-26T18:28:16Z",
              "updatedAt": "2020-10-26T21:10:46Z"
            },
            {
              "originalPosition": 55,
              "body": "```suggestion\r\ncontext = SetupBaseR(kem_output, external_priv, PublicGroupState)\r\n```",
              "createdAt": "2020-10-26T18:28:30Z",
              "updatedAt": "2020-10-26T21:10:46Z"
            },
            {
              "originalPosition": 59,
              "body": "```suggestion\r\nIn both cases, the `info` input to HPKE is set to the PublicGroupState for the\r\n```",
              "createdAt": "2020-10-26T18:28:38Z",
              "updatedAt": "2020-10-26T21:10:46Z"
            },
            {
              "originalPosition": 148,
              "body": "```suggestion\r\nThis information is aggregated in a `PublicGroupState` object as follows:\r\n```",
              "createdAt": "2020-10-26T18:29:00Z",
              "updatedAt": "2020-10-26T21:10:46Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE3MjI5NzA0",
          "commit": {
            "abbreviatedOid": "bc8445c"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-26T22:45:42Z",
          "updatedAt": "2020-10-26T22:50:52Z",
          "comments": [
            {
              "originalPosition": 109,
              "body": "proposal",
              "createdAt": "2020-10-26T22:45:42Z",
              "updatedAt": "2020-10-26T22:50:52Z"
            },
            {
              "originalPosition": 179,
              "body": "Shouldn't the signature come from the credential in the Add proposal? Not the Commit. That's how it is for everyone else",
              "createdAt": "2020-10-26T22:49:31Z",
              "updatedAt": "2020-10-26T22:50:52Z"
            },
            {
              "originalPosition": 180,
              "body": "exactly one ExternalInit",
              "createdAt": "2020-10-26T22:49:56Z",
              "updatedAt": "2020-10-26T22:50:52Z"
            }
          ]
        }
      ]
    },
    {
      "number": 407,
      "id": "MDExOlB1bGxSZXF1ZXN0NDkwOTMxMTcx",
      "title": "Fix typo",
      "url": "https://github.com/mlswg/mls-protocol/pull/407",
      "state": "MERGED",
      "author": "rex4539",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-09-22T13:13:15Z",
      "updatedAt": "2020-09-22T14:42:46Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "bb303085f3748a7ba171f9f12fdbeef22d063283",
      "headRepository": null,
      "headRefName": "typos",
      "headRefOid": "2dd0edf0cf8285bcdb8cdf5ad36d006893cca62b",
      "closedAt": "2020-09-22T14:42:46Z",
      "mergedAt": "2020-09-22T14:42:46Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "395ffd56d330ae32239f22e981209deae2937448"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkzNTM3Njcw",
          "commit": {
            "abbreviatedOid": "2dd0edf"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-09-22T14:42:41Z",
          "updatedAt": "2020-09-22T14:42:41Z",
          "comments": []
        }
      ]
    },
    {
      "number": 408,
      "id": "MDExOlB1bGxSZXF1ZXN0NDkyMDQ4MDI0",
      "title": "Clarify X509Credential structure",
      "url": "https://github.com/mlswg/mls-protocol/pull/408",
      "state": "MERGED",
      "author": "suhasHere",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "This PR adds clarification around X509 cert structure, the chain and its encoding X509.",
      "createdAt": "2020-09-23T21:22:59Z",
      "updatedAt": "2020-10-05T14:59:56Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "ca187c70d7a5a5ac38f027526e78a72fa043bdf5",
      "headRepository": "suhasHere/mls-protocol",
      "headRefName": "master",
      "headRefOid": "8dec7125dfce6dd14f6d9494ca3c911b6b3eb876",
      "closedAt": "2020-10-05T14:59:56Z",
      "mergedAt": "2020-10-05T14:59:56Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "eec3985d34dbb5a38fa45ec7edd3a0a1f2bd1fdc"
      },
      "comments": [
        {
          "author": "suhasHere",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@Bren2010  thanks for the suggestions. updated PR to reflect the changes . pls let me know .. ",
          "createdAt": "2020-09-24T23:14:06Z",
          "updatedAt": "2020-09-24T23:14:06Z"
        },
        {
          "author": "suhasHere",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@Bren2010 i have pushed another commit .. can you please check. thanks",
          "createdAt": "2020-09-29T19:54:38Z",
          "updatedAt": "2020-09-29T19:54:38Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk1NjMwMDkz",
          "commit": {
            "abbreviatedOid": "7df46d7"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Thanks, @suhasHere.  I agree that separating out the certificates is a good idea.  While it's different from how TLS does things, I'm ready to declare TLS wrong here, since this saves mixing TLS-syntax and X.509 parsing logic.\r\n\r\nAs for the chain ordering, I really thought we had this in here already, so I'm glad to have it back.",
          "createdAt": "2020-09-24T14:25:01Z",
          "updatedAt": "2020-09-24T14:25:01Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk1NzM0NTI2",
          "commit": {
            "abbreviatedOid": "7df46d7"
          },
          "author": "DemiMarie",
          "authorAssociation": "NONE",
          "state": "APPROVED",
          "body": "Looks good.  In particular, requiring that certificates be ordered from leaf to root allows for arbitrarily long certificate chains to be verified in O(1) memory.",
          "createdAt": "2020-09-24T16:11:36Z",
          "updatedAt": "2020-09-24T16:11:36Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk1ODQ0NjIy",
          "commit": {
            "abbreviatedOid": "7df46d7"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2020-09-24T18:26:30Z",
          "updatedAt": "2020-09-24T18:32:30Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "remove newline",
              "createdAt": "2020-09-24T18:26:30Z",
              "updatedAt": "2020-09-29T19:52:14Z"
            },
            {
              "originalPosition": 25,
              "body": "```suggestion\r\nFor X509Credential, each entry in the chain represents a single DER-encoded\r\n```",
              "createdAt": "2020-09-24T18:27:35Z",
              "updatedAt": "2020-09-29T19:52:14Z"
            },
            {
              "originalPosition": 26,
              "body": "```suggestion\r\nX509 certificate. The chain is ordered such that the first entry (chain[0])\r\n```",
              "createdAt": "2020-09-24T18:27:55Z",
              "updatedAt": "2020-09-29T19:52:14Z"
            },
            {
              "originalPosition": 27,
              "body": "```suggestion\r\nis the end-entity certificate and each subsequent certificate in the chain MUST be\r\n```",
              "createdAt": "2020-09-24T18:28:15Z",
              "updatedAt": "2020-09-29T19:52:14Z"
            },
            {
              "originalPosition": 28,
              "body": "```suggestion\r\nthe issuer of the previous certificate. The algorithm for the `public_key` in the\r\n```",
              "createdAt": "2020-09-24T18:28:43Z",
              "updatedAt": "2020-09-29T19:52:14Z"
            },
            {
              "originalPosition": 29,
              "body": "```suggestion\r\nend-entity certificate MUST match the relevant ciphersuite.\r\n```",
              "createdAt": "2020-09-24T18:31:09Z",
              "updatedAt": "2020-09-29T19:52:14Z"
            },
            {
              "originalPosition": 30,
              "body": "```suggestion\r\n\r\n```",
              "createdAt": "2020-09-24T18:31:49Z",
              "updatedAt": "2020-09-29T19:52:14Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk2MDMwNjA0",
          "commit": {
            "abbreviatedOid": "9e6d452"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "Many lines still have trailing spaces, please fix",
          "createdAt": "2020-09-25T00:16:07Z",
          "updatedAt": "2020-09-25T00:16:23Z",
          "comments": [
            {
              "originalPosition": 32,
              "body": "```suggestion\r\nciphersuite.\r\n```",
              "createdAt": "2020-09-25T00:16:07Z",
              "updatedAt": "2020-09-29T19:52:14Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk2MTkwMzc3",
          "commit": {
            "abbreviatedOid": "9e6d452"
          },
          "author": "franziskuskiefer",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-25T07:54:34Z",
          "updatedAt": "2020-09-25T07:54:35Z",
          "comments": [
            {
              "originalPosition": 31,
              "body": "This wasn't clearly defined before so I appreciate making it clear.\r\nHowever, this `MUST` makes the mandatory ciphersuite pretty hard to use with x509 certificates. Public CAs don't issue ed25519 certificates.",
              "createdAt": "2020-09-25T07:54:34Z",
              "updatedAt": "2020-09-29T19:52:14Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk2NDk1NjAw",
          "commit": {
            "abbreviatedOid": "9e6d452"
          },
          "author": "DemiMarie",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-25T14:51:41Z",
          "updatedAt": "2020-09-25T14:51:41Z",
          "comments": [
            {
              "originalPosition": 31,
              "body": "Most uses for MLS don\u2019t involve public CAs.",
              "createdAt": "2020-09-25T14:51:41Z",
              "updatedAt": "2020-09-29T19:52:14Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk2NjAwNzkw",
          "commit": {
            "abbreviatedOid": "9e6d452"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-25T17:09:40Z",
          "updatedAt": "2020-09-25T17:09:41Z",
          "comments": [
            {
              "originalPosition": 31,
              "body": "It seems a bit early to talk about \"most uses for MLS\", since AFAIK there aren't any yet :) \r\n\r\nBut I think the overall point still stands -- precedent in the Web PKI doesn't really matter here, because (again in most of the envisioned use cases), these certificates will be for user identifiers that aren't even allowed in Web PKI certificates.  I suppose it's possible to have a bunch of entities with domain names and Web PKI certificates doing MLS, but (a) that doesn't seem like a core use cases and (b) they can just use a ciphersuite that is lines up with those certs.",
              "createdAt": "2020-09-25T17:09:40Z",
              "updatedAt": "2020-09-29T19:52:14Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAxNTY5NjI5",
          "commit": {
            "abbreviatedOid": "8dec712"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-10-03T19:40:18Z",
          "updatedAt": "2020-10-03T19:40:18Z",
          "comments": []
        }
      ]
    },
    {
      "number": 412,
      "id": "MDExOlB1bGxSZXF1ZXN0NDk5NjA2ODkx",
      "title": "Editorial changes to Content Auth section.",
      "url": "https://github.com/mlswg/mls-protocol/pull/412",
      "state": "MERGED",
      "author": "Bren2010",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-10-08T01:52:41Z",
      "updatedAt": "2020-10-08T15:28:05Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "5f06f08d001054b74ce40b95bf4b2949eac81dc4",
      "headRepository": "Bren2010/mls-protocol",
      "headRefName": "brendan/2020.10.0",
      "headRefOid": "5e6a958d910c5353ae6b54bd28726092467b5c5d",
      "closedAt": "2020-10-08T15:28:05Z",
      "mergedAt": "2020-10-08T15:28:05Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "831ee5e61644246b3be5b4ef7d2c7d0eb93d6886"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA0OTA1NjA1",
          "commit": {
            "abbreviatedOid": "5e6a958"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-10-08T15:27:59Z",
          "updatedAt": "2020-10-08T15:27:59Z",
          "comments": []
        }
      ]
    },
    {
      "number": 413,
      "id": "MDExOlB1bGxSZXF1ZXN0NTAwMDExMjEw",
      "title": "Remove references to undefined SignatureScheme enum.",
      "url": "https://github.com/mlswg/mls-protocol/pull/413",
      "state": "CLOSED",
      "author": "Bren2010",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-10-08T15:31:58Z",
      "updatedAt": "2020-10-09T23:31:19Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "831ee5e61644246b3be5b4ef7d2c7d0eb93d6886",
      "headRepository": "Bren2010/mls-protocol",
      "headRefName": "brendan/2020.10.1",
      "headRefOid": "ea44b9e5b46990cea96e9bb64a72bf8a590cf581",
      "closedAt": "2020-10-09T23:31:19Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": []
    },
    {
      "number": 414,
      "id": "MDExOlB1bGxSZXF1ZXN0NTAwMDE4OTg1",
      "title": "Allow proposals by value in Commit",
      "url": "https://github.com/mlswg/mls-protocol/pull/414",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This avoids extra signatures and message overhead in the case where the committer is originating proposals.",
      "createdAt": "2020-10-08T15:44:09Z",
      "updatedAt": "2020-10-20T20:53:19Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "831ee5e61644246b3be5b4ef7d2c7d0eb93d6886",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "inline-proposal",
      "headRefOid": "cbffafdd3552d172a1d86fb863fa312bad8a180e",
      "closedAt": "2020-10-20T20:53:19Z",
      "mergedAt": "2020-10-20T20:53:19Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "d17b8ac7fb7b7c7d228398700fec11f9aee9d5b2"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA0OTM3MDgz",
          "commit": {
            "abbreviatedOid": "e2b99f5"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-10-08T16:01:21Z",
          "updatedAt": "2020-10-08T16:03:01Z",
          "comments": [
            {
              "originalPosition": 23,
              "body": "```suggestion\r\n  select (ProposalID.type) {\r\n```",
              "createdAt": "2020-10-08T16:01:21Z",
              "updatedAt": "2020-10-20T19:12:58Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA1MzI3OTY0",
          "commit": {
            "abbreviatedOid": "27775a2"
          },
          "author": "suhasHere",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-10-09T02:57:35Z",
          "updatedAt": "2020-10-09T02:57:35Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA1MzM5Mjgy",
          "commit": {
            "abbreviatedOid": "27775a2"
          },
          "author": "suhasHere",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-09T03:39:35Z",
          "updatedAt": "2020-10-09T03:39:35Z",
          "comments": [
            {
              "originalPosition": 28,
              "body": "i wonder an informal note on when one variant is used vs another might be helpful for the implementors ..",
              "createdAt": "2020-10-09T03:39:35Z",
              "updatedAt": "2020-10-20T19:12:58Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA1MzY4NDk5",
          "commit": {
            "abbreviatedOid": "27775a2"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-09T05:16:43Z",
          "updatedAt": "2020-10-09T05:16:43Z",
          "comments": [
            {
              "originalPosition": 24,
              "body": "It's strange that something called `ProposalID` contains an actual Proposal.",
              "createdAt": "2020-10-09T05:16:43Z",
              "updatedAt": "2020-10-20T19:12:58Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTExODg5MjQz",
          "commit": {
            "abbreviatedOid": "1e357aa"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-19T15:29:11Z",
          "updatedAt": "2020-10-19T15:29:11Z",
          "comments": [
            {
              "originalPosition": 10,
              "body": " > For proposals whose application depends on who sent them\r\n\r\nI think this is true for all proposals, because they might get rejected depending on the application's policy.",
              "createdAt": "2020-10-19T15:29:11Z",
              "updatedAt": "2020-10-20T19:12:58Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEyMTQyOTAw",
          "commit": {
            "abbreviatedOid": "1d13e25"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2020-10-19T20:41:56Z",
          "updatedAt": "2020-10-19T20:42:34Z",
          "comments": [
            {
              "originalPosition": 3,
              "body": "Need to update a few references of ProposalID to ProposalOrRefType;",
              "createdAt": "2020-10-19T20:41:56Z",
              "updatedAt": "2020-10-20T19:12:58Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEyMTc4MTgy",
          "commit": {
            "abbreviatedOid": "d8baecc"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-19T21:37:35Z",
          "updatedAt": "2020-10-19T21:37:35Z",
          "comments": [
            {
              "originalPosition": 3,
              "body": "Good point, thanks.",
              "createdAt": "2020-10-19T21:37:35Z",
              "updatedAt": "2020-10-20T19:12:58Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEyMjA2MjEy",
          "commit": {
            "abbreviatedOid": "d8baecc"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2020-10-19T22:32:02Z",
          "updatedAt": "2020-10-19T22:34:01Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "```suggestion\r\nretrieved by hash (as a ProposalOrRef object) in a later Commit message.\r\n```",
              "createdAt": "2020-10-19T22:32:02Z",
              "updatedAt": "2020-10-20T19:12:58Z"
            },
            {
              "originalPosition": 37,
              "body": "```suggestion\r\n    case 1: Proposal proposal;\r\n```",
              "createdAt": "2020-10-19T22:33:26Z",
              "updatedAt": "2020-10-20T19:12:58Z"
            },
            {
              "originalPosition": 38,
              "body": "```suggestion\r\n    case 2: opaque hash<0..255>;\r\n```",
              "createdAt": "2020-10-19T22:33:35Z",
              "updatedAt": "2020-10-20T19:12:58Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEzMTIwMDky",
          "commit": {
            "abbreviatedOid": "cbffafd"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-10-20T20:47:16Z",
          "updatedAt": "2020-10-20T20:47:16Z",
          "comments": []
        }
      ]
    },
    {
      "number": 415,
      "id": "MDExOlB1bGxSZXF1ZXN0NTAwMTgxOTQz",
      "title": "make IANA reference for Signature Schemes more precise",
      "url": "https://github.com/mlswg/mls-protocol/pull/415",
      "state": "MERGED",
      "author": "kkohbrok",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Thanks @Bren2010 pointing out the imprecision. Is this what you were looking for?\r\n\r\nThanks @bifurcation for the pointer to the correct registry.\r\n\r\n",
      "createdAt": "2020-10-08T20:52:45Z",
      "updatedAt": "2020-10-19T14:11:43Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "831ee5e61644246b3be5b4ef7d2c7d0eb93d6886",
      "headRepository": "kkohbrok/mls-protocol",
      "headRefName": "signature_scheme_reference",
      "headRefOid": "2b4d5d4e846225cde0ee473c4ed4258d0ccc7e79",
      "closedAt": "2020-10-19T14:11:43Z",
      "mergedAt": "2020-10-19T14:11:43Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "b7baca2cc44a55f05be4823c6df78743b25607bb"
      },
      "comments": [
        {
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "body": "This doesn't make sense because we don't actually use this registry. The signature scheme is defined by the ciphersuite, and the ciphersuite registry doesn't map to this unrelated registry",
          "createdAt": "2020-10-09T14:34:31Z",
          "updatedAt": "2020-10-09T14:34:31Z"
        },
        {
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The `SignatureScheme` is not authoritative in the group context and will always correspond with the one in the group (as is required by the generic description of the functionalities that Credentials have to provide). The SignatureScheme is there for when the Credential is handled in a context where there is no surrounding group. For example, when it's handled by the AS.\r\n\r\nThere is a mapping from ciphersuit to SignatureScheme in Table 5, the entries of which correspond to the entries in the referenced registry. Is that what you meant?",
          "createdAt": "2020-10-09T14:53:45Z",
          "updatedAt": "2020-10-09T14:53:45Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA2MDE2OTk2",
          "commit": {
            "abbreviatedOid": "41c36d3"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2020-10-09T22:24:49Z",
          "updatedAt": "2020-10-09T22:25:39Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "```suggestion\r\n// See RFC 8446 and the IANA TLS SignatureScheme registry\r\n```",
              "createdAt": "2020-10-09T22:24:49Z",
              "updatedAt": "2020-10-12T07:06:02Z"
            },
            {
              "originalPosition": 5,
              "body": "Please also update a few lines above here, \"private keys\" -> \"private key\"",
              "createdAt": "2020-10-09T22:25:19Z",
              "updatedAt": "2020-10-12T07:06:02Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA2NTc0NTIx",
          "commit": {
            "abbreviatedOid": "2b4d5d4"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-10-12T12:29:38Z",
          "updatedAt": "2020-10-12T12:29:38Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA2NzI5OTMy",
          "commit": {
            "abbreviatedOid": "2b4d5d4"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-10-12T15:41:46Z",
          "updatedAt": "2020-10-12T15:41:46Z",
          "comments": []
        }
      ]
    },
    {
      "number": 416,
      "id": "MDExOlB1bGxSZXF1ZXN0NTAwODczOTYz",
      "title": "Inlclude the signature in the confirmation tag",
      "url": "https://github.com/mlswg/mls-protocol/pull/416",
      "state": "MERGED",
      "author": "dajost",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "As discussed in the mailing list, not having the signature contribute to the new epoch's key schedule leads to a one-off effect where parties stay in sync (with respect to keys) for one more epoch, before inevitably go out of sync. This pull request addresses this issue by including the signature in the confirmed transcript hash rather than the interim transcript hash. See the mailing list for a security consideration of this change.\r\n\r\nCredit: This pull request was primarily authored by Marta Mularczk; I'm just posting it here for administrative reasons. ",
      "createdAt": "2020-10-10T00:15:42Z",
      "updatedAt": "2020-10-14T14:21:22Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "831ee5e61644246b3be5b4ef7d2c7d0eb93d6886",
      "headRepository": "dajost/mls-protocol",
      "headRefName": "signature-in-conf-tag",
      "headRefOid": "fe3658eb8d8848ca0b7df4f8015934e41bc1238c",
      "closedAt": "2020-10-14T14:21:22Z",
      "mergedAt": "2020-10-14T14:21:22Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "fba989d1d17d9e4a543b0e30d53757f9fdb33b8b"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA2MDQ1MzU2",
          "commit": {
            "abbreviatedOid": "fe3658e"
          },
          "author": "dajost",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-10T00:22:33Z",
          "updatedAt": "2020-10-10T00:22:33Z",
          "comments": [
            {
              "originalPosition": 39,
              "body": "An alternative would be to use:\r\nselect (MLSPlaintext.content_type) {\r\n        case commit:\r\n          MAC confirmation_tag;\r\n}\r\nsparing the need for the definition below that the confirmation tag must be present iff it is a commit.",
              "createdAt": "2020-10-10T00:22:33Z",
              "updatedAt": "2020-10-10T00:22:33Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA2NTgwODQw",
          "commit": {
            "abbreviatedOid": "fe3658e"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-10-12T12:38:23Z",
          "updatedAt": "2020-10-12T12:39:04Z",
          "comments": [
            {
              "originalPosition": 39,
              "body": "Not a bad idea; it would save an octet and give you \"syntactic\" enforcement.  I'm still inclined to go with the `optional<>` approach for two reasons:\r\n\r\n1. I'm not aware of TLS syntax implementatiosn that implement `select()` in any sort of automated fashion, so there would be manual logic here in any case.  It's just slightly easier to omit with `optional<>`.\r\n\r\n2. If we do `select` for `confirmation_tag`, we should probably also do it with `membership_tag` (selecting based on `sender_type`), which gets to be ugly.",
              "createdAt": "2020-10-12T12:38:23Z",
              "updatedAt": "2020-10-12T12:39:04Z"
            }
          ]
        }
      ]
    },
    {
      "number": 417,
      "id": "MDExOlB1bGxSZXF1ZXN0NTAxNDIyODgx",
      "title": "use `KDF.Nh` instead of `Hash.length`",
      "url": "https://github.com/mlswg/mls-protocol/pull/417",
      "state": "MERGED",
      "author": "kkohbrok",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-10-12T08:45:51Z",
      "updatedAt": "2020-10-12T13:40:47Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "831ee5e61644246b3be5b4ef7d2c7d0eb93d6886",
      "headRepository": "kkohbrok/mls-protocol",
      "headRefName": "hash_length",
      "headRefOid": "40f7c4bf6e32aabdbe29f202ec5ba2922603ea0f",
      "closedAt": "2020-10-12T12:28:40Z",
      "mergedAt": "2020-10-12T12:28:40Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "9d9804017016325d26460aff96b548670daf173d"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA2NTczNzYy",
          "commit": {
            "abbreviatedOid": "40f7c4b"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "For the record: I asked @kkohbrok whether we could just update DeriveTreeSecret so that it always produces `KDF.Nh` octets.  But he pointed out that DeriveTreeSecret is also used to produce keys and nonces.  Might be something to clean up later.",
          "createdAt": "2020-10-12T12:28:33Z",
          "updatedAt": "2020-10-12T12:28:33Z",
          "comments": []
        }
      ]
    },
    {
      "number": 419,
      "id": "MDExOlB1bGxSZXF1ZXN0NTAxODgxMjA2",
      "title": "Authentication Secret",
      "url": "https://github.com/mlswg/mls-protocol/pull/419",
      "state": "MERGED",
      "author": "br-hale",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "The authentication_secret was previously in a PR and agreed, but seems to have been removed from the key schedule (possibly during a merge). The discussion on its use is still present. This PR is just to add it back in to the key schedule.",
      "createdAt": "2020-10-12T23:43:21Z",
      "updatedAt": "2020-10-19T14:05:16Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "9d9804017016325d26460aff96b548670daf173d",
      "headRepository": "br-hale/mls-protocol",
      "headRefName": "exporters",
      "headRefOid": "6b94f4a6ae7c20524ed201322197a4dba784f76f",
      "closedAt": "2020-10-19T14:05:07Z",
      "mergedAt": "2020-10-19T14:05:07Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "4e515a7cbb68720ab8b2bb591c71abc4946c923f"
      },
      "comments": [
        {
          "author": "br-hale",
          "authorAssociation": "CONTRIBUTOR",
          "body": "True! Haha. I was working on getting on the dashes to line up nicely as a box for presentation, and the repo view does not show spaces in the same way as a text file.\r\n\r\nCheers,\r\n\r\n. . .\r\nProf. Britta Hale, PhD\r\nCryptography\r\nNaval Postgraduate School  | Computer Science\r\nhttp://faculty.nps.edu/haleb/\r\n\r\n\r\nFrom: Brendan McMillion <notifications@github.com>\r\nReply-To: mlswg/mls-protocol <reply@reply.github.com>\r\nDate: Tuesday, October 13, 2020 at 12:34 PM\r\nTo: mlswg/mls-protocol <mls-protocol@noreply.github.com>\r\nCc: \"Hale, Britta (CIV)\" <britta.hale@nps.edu>, Author <author@noreply.github.com>\r\nSubject: Re: [mlswg/mls-protocol] Authentication Secret (#419)\r\n\r\n\r\n\r\n@Bren2010 approved this pull request.\r\n\r\nWhoever merges this better squash, no way Britta is getting credit for 16 commits on a 2 line change\r\n\r\n\u2014\r\nYou are receiving this because you authored the thread.\r\nReply to this email directly, view it on GitHub<https://github.com/mlswg/mls-protocol/pull/419#pullrequestreview-507764956>, or unsubscribe<https://github.com/notifications/unsubscribe-auth/ALEYMX6AHBN2BF3VKOAYBQDSKSTUNANCNFSM4SNVIIHA>.\r\n",
          "createdAt": "2020-10-13T19:37:56Z",
          "updatedAt": "2020-10-13T19:37:56Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "@Bren2010 your wish is my command",
          "createdAt": "2020-10-19T14:05:16Z",
          "updatedAt": "2020-10-19T14:05:16Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA3NzY0OTU2",
          "commit": {
            "abbreviatedOid": "6b94f4a"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Whoever merges this better squash, no way Britta is getting credit for 16 commits on a 2 line change",
          "createdAt": "2020-10-13T19:34:15Z",
          "updatedAt": "2020-10-13T19:34:15Z",
          "comments": []
        }
      ]
    },
    {
      "number": 420,
      "id": "MDExOlB1bGxSZXF1ZXN0NTAzMzMzODAx",
      "title": "make confirmation_tag a MAC just like membership_tag",
      "url": "https://github.com/mlswg/mls-protocol/pull/420",
      "state": "CLOSED",
      "author": "kkohbrok",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-10-14T12:22:13Z",
      "updatedAt": "2020-10-14T15:19:55Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "9d9804017016325d26460aff96b548670daf173d",
      "headRepository": "kkohbrok/mls-protocol",
      "headRefName": "confirmation_tag",
      "headRefOid": "f6a5447b1342502dc37d5b40f086d9acd222598a",
      "closedAt": "2020-10-14T15:19:55Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Ah, I missed that this is apparently already underway in #416.",
          "createdAt": "2020-10-14T15:19:55Z",
          "updatedAt": "2020-10-14T15:19:55Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 421,
      "id": "MDExOlB1bGxSZXF1ZXN0NTAzNTAxMDU1",
      "title": "Review PSK PR.",
      "url": "https://github.com/mlswg/mls-protocol/pull/421",
      "state": "MERGED",
      "author": "Bren2010",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-10-14T16:37:27Z",
      "updatedAt": "2020-10-21T18:58:55Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "68d2ea0e5fbf3fc914c03d44d0249f873064378c",
      "headRepository": "Bren2010/mls-protocol",
      "headRefName": "brendan/2020.10.3",
      "headRefOid": "deae9c08e1ad848ebc8635bac0f709d7e45d4863",
      "closedAt": "2020-10-21T18:58:55Z",
      "mergedAt": "2020-10-21T18:58:55Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "54519449b09423bd2a44702f5be9388ebdf8bc48"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA5MzI5MzQ0",
          "commit": {
            "abbreviatedOid": "1ed7471"
          },
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-15T12:35:57Z",
          "updatedAt": "2020-10-19T06:29:54Z",
          "comments": [
            {
              "originalPosition": 37,
              "body": "A re-initialization could also be proposed by a non-member.",
              "createdAt": "2020-10-15T12:35:57Z",
              "updatedAt": "2020-10-21T18:23:51Z"
            },
            {
              "originalPosition": 66,
              "body": "We don't really have \"resumption\" psks. Also, I think that \"internal\" fits quite well here. Although to be fair, neither branching nor re-initialization PKSs are communicated via `PreSharedKey` proposals. However, it might still be useful to use with internal PSKs (e.g. to re-add member so the group that have lost group state for some reason).",
              "createdAt": "2020-10-15T12:38:54Z",
              "updatedAt": "2020-10-21T18:23:51Z"
            },
            {
              "originalPosition": 94,
              "body": "Why remove this section? If I understand correctly, it fits well into the subsections explaining the use of the various keys derived from the key schedule.",
              "createdAt": "2020-10-19T06:23:09Z",
              "updatedAt": "2020-10-21T18:23:51Z"
            },
            {
              "originalPosition": 147,
              "body": "Why remove this, but not the subsection below on Sub-group branching? I think both section serve the purpose of giving an overview over the respective process and should be left in.",
              "createdAt": "2020-10-19T06:25:18Z",
              "updatedAt": "2020-10-21T18:23:51Z"
            },
            {
              "originalPosition": 167,
              "body": "@bifurcation wanted to have this spelled out. I'm happy with the abbreviation.",
              "createdAt": "2020-10-19T06:26:12Z",
              "updatedAt": "2020-10-21T18:23:51Z"
            },
            {
              "originalPosition": 232,
              "body": "Why remove this? I think we should at least specify that only one re-init proposal can be included in a commit.",
              "createdAt": "2020-10-19T06:27:49Z",
              "updatedAt": "2020-10-21T18:23:51Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTExODEzMDIy",
          "commit": {
            "abbreviatedOid": "1ed7471"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-19T14:18:16Z",
          "updatedAt": "2020-10-19T14:18:16Z",
          "comments": [
            {
              "originalPosition": 167,
              "body": "I can live with this.  ",
              "createdAt": "2020-10-19T14:18:16Z",
              "updatedAt": "2020-10-21T18:23:51Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTExODMyOTM0",
          "commit": {
            "abbreviatedOid": "1ed7471"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-19T14:34:12Z",
          "updatedAt": "2020-10-19T14:34:12Z",
          "comments": [
            {
              "originalPosition": 28,
              "body": "```suggestion\r\nExternal PSKs are provided by the application, while recovery and re-init PSKs\r\n```",
              "createdAt": "2020-10-19T14:34:12Z",
              "updatedAt": "2020-10-21T18:23:51Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTExODM0NTUy",
          "commit": {
            "abbreviatedOid": "1ed7471"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-19T14:35:40Z",
          "updatedAt": "2020-10-19T14:52:06Z",
          "comments": [
            {
              "originalPosition": 167,
              "body": "Or `pre_shared_key(4)`",
              "createdAt": "2020-10-19T14:35:40Z",
              "updatedAt": "2020-10-21T18:23:51Z"
            },
            {
              "originalPosition": 199,
              "body": "\"MUST be `external`\" is too strong here; this proposal is also how \"recovery\" PSKs are injected, right?  I think all you want to say is \"MUST NOT be `reinit`\"",
              "createdAt": "2020-10-19T14:38:59Z",
              "updatedAt": "2020-10-21T18:23:51Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTExOTk2MjIz",
          "commit": {
            "abbreviatedOid": "1ed7471"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2020-10-19T17:31:27Z",
          "updatedAt": "2020-10-19T17:43:05Z",
          "comments": [
            {
              "originalPosition": 119,
              "body": "I think detecting attacks is a valid goal of the authentication keys, we shouldn't remove it.",
              "createdAt": "2020-10-19T17:31:27Z",
              "updatedAt": "2020-10-21T18:23:51Z"
            },
            {
              "originalPosition": 223,
              "body": "This sounds like existing proposals should be dropped, which should not be the case. I think it better to mandate an extra Commit that is issued when there are no more pending proposals.",
              "createdAt": "2020-10-19T17:35:51Z",
              "updatedAt": "2020-10-21T18:23:51Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEyMTI1MjEy",
          "commit": {
            "abbreviatedOid": "1ed7471"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-19T20:15:54Z",
          "updatedAt": "2020-10-19T20:39:15Z",
          "comments": [
            {
              "originalPosition": 37,
              "body": "I don't see a provision for that in the External Proposals section. I think there's more to think through in that case, which we can do in another PR",
              "createdAt": "2020-10-19T20:15:54Z",
              "updatedAt": "2020-10-21T18:23:51Z"
            },
            {
              "originalPosition": 94,
              "body": "You did not define how to do recovery. Define how to do recovery in another PR and you can add it back",
              "createdAt": "2020-10-19T20:26:59Z",
              "updatedAt": "2020-10-21T18:23:51Z"
            },
            {
              "originalPosition": 119,
              "body": "It's redundant. The second clause of the sentence just says \"detect attacks\" again in a different way.",
              "createdAt": "2020-10-19T20:28:20Z",
              "updatedAt": "2020-10-21T18:23:51Z"
            },
            {
              "originalPosition": 147,
              "body": "This is all (correctly) discussed in the section on ReInit proposals. Sub-group branching isn't discussed anywhere else",
              "createdAt": "2020-10-19T20:32:11Z",
              "updatedAt": "2020-10-21T18:23:51Z"
            },
            {
              "originalPosition": 199,
              "body": "There are no recovery PSKs, `external` is currently the only valid PSK type to put here",
              "createdAt": "2020-10-19T20:33:36Z",
              "updatedAt": "2020-10-21T18:23:51Z"
            },
            {
              "originalPosition": 223,
              "body": "Yes, the ReInit must be dropped or the rest of the proposals must be dropped. Applications can do what you say automatically: Commit outstanding proposals -> send new ReInit -> Commit ReInit. There's no reason to mandate it",
              "createdAt": "2020-10-19T20:36:44Z",
              "updatedAt": "2020-10-21T18:23:51Z"
            },
            {
              "originalPosition": 232,
              "body": "This discussion was moved to the ReInit proposal section\r\n\r\n> If a ReInit proposal is included in a Commit, it MUST be the only proposal\r\nreferenced by the Commit.",
              "createdAt": "2020-10-19T20:37:43Z",
              "updatedAt": "2020-10-21T18:23:51Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEyMzYyMTIw",
          "commit": {
            "abbreviatedOid": "2212df5"
          },
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-20T06:18:38Z",
          "updatedAt": "2020-10-20T06:18:38Z",
          "comments": [
            {
              "originalPosition": 37,
              "body": "In my mind, that was one of the main features of having a ReInit proposal. But you are right, we should have mentioned it in the External Proposals section. I'll make a PR.",
              "createdAt": "2020-10-20T06:18:38Z",
              "updatedAt": "2020-10-21T18:23:51Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEyMzYzMzk0",
          "commit": {
            "abbreviatedOid": "2212df5"
          },
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-20T06:21:19Z",
          "updatedAt": "2020-10-20T06:21:19Z",
          "comments": [
            {
              "originalPosition": 94,
              "body": "This Section is not about keys for recovery specifically, but about the `recovery_secret`, which is the basis for internal PSK derivation. I agree that the name is not ideal, though.",
              "createdAt": "2020-10-20T06:21:19Z",
              "updatedAt": "2020-10-21T18:23:51Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEyMzY1NzY3",
          "commit": {
            "abbreviatedOid": "2212df5"
          },
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-20T06:26:00Z",
          "updatedAt": "2020-10-20T06:26:00Z",
          "comments": [
            {
              "originalPosition": 199,
              "body": "You are right, that the of the currently specified PSK types, only `external` can be used in a psk proposal. However, implementors could define proprietary PSK types (e.g. for recovery) that they would want to use with a psk proposal as well. Not sure how we should write the spec so that option remains open.",
              "createdAt": "2020-10-20T06:26:00Z",
              "updatedAt": "2020-10-21T18:23:51Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEyMzY2NTU5",
          "commit": {
            "abbreviatedOid": "2212df5"
          },
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-20T06:27:32Z",
          "updatedAt": "2020-10-20T06:27:33Z",
          "comments": [
            {
              "originalPosition": 223,
              "body": "Why does it have to be the only proposal in the commit? I mean, updates are going to be useless, but Adds and Removes can still be processed.",
              "createdAt": "2020-10-20T06:27:33Z",
              "updatedAt": "2020-10-21T18:23:51Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEyOTA0MTU1",
          "commit": {
            "abbreviatedOid": "2212df5"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-20T16:09:58Z",
          "updatedAt": "2020-10-20T16:09:58Z",
          "comments": [
            {
              "originalPosition": 223,
              "body": "Discussed at virtual interim 2020-10-20:\r\n* ReInit MUST be only proposal\r\n* If non-ReInit and ReInit received in same epoch, SHOULD prefer non-ReInit\r\n* Options for recovering from contention: committer re-originates or original proposer retries",
              "createdAt": "2020-10-20T16:09:58Z",
              "updatedAt": "2020-10-21T18:23:51Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE0MDY4MjM4",
          "commit": {
            "abbreviatedOid": "deae9c0"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-10-21T18:37:12Z",
          "updatedAt": "2020-10-21T18:37:12Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE0MDg2OTk2",
          "commit": {
            "abbreviatedOid": "deae9c0"
          },
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Looks good! Thanks for cleaning up some of the bits we missed in the original PSK PR!",
          "createdAt": "2020-10-21T18:57:32Z",
          "updatedAt": "2020-10-21T18:57:32Z",
          "comments": []
        }
      ]
    },
    {
      "number": 422,
      "id": "MDExOlB1bGxSZXF1ZXN0NTA0MTk3Nzk5",
      "title": "No redundant ciphertexts",
      "url": "https://github.com/mlswg/mls-protocol/pull/422",
      "state": "MERGED",
      "author": "dajost",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "As briefly explained in the mailing list, commit messages currently contain encryptions for newly added group members that never even receive this commit message. This PR explicitely exlcudes them during the preparation of the UpdatePath.",
      "createdAt": "2020-10-15T15:38:35Z",
      "updatedAt": "2020-10-20T15:40:12Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "fba989d1d17d9e4a543b0e30d53757f9fdb33b8b",
      "headRepository": "dajost/mls-protocol",
      "headRefName": "no-redundant-ciphertexts",
      "headRefOid": "705fd58705612c1171d0a98681ca6f95faccd417",
      "closedAt": "2020-10-20T15:40:12Z",
      "mergedAt": "2020-10-20T15:40:12Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "5acf3e402023eb3cab5675d188844a22f1a78563"
      },
      "comments": [
        {
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "body": "I think this is a good point that wasn't really specified so far. The wording sounds a bit convoluted, maybe there is an easier way to describe it, like saying that the final resolution list should be filtered and all new leaf nodes should be removed from it.",
          "createdAt": "2020-10-19T16:25:02Z",
          "updatedAt": "2020-10-19T16:25:02Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEyODE1MTQy",
          "commit": {
            "abbreviatedOid": "705fd58"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-10-20T14:58:27Z",
          "updatedAt": "2020-10-20T14:58:27Z",
          "comments": []
        }
      ]
    },
    {
      "number": 423,
      "id": "MDExOlB1bGxSZXF1ZXN0NTA0OTM3NjUx",
      "title": "Remove encrypted sender data from ciphertext AAD.",
      "url": "https://github.com/mlswg/mls-protocol/pull/423",
      "state": "MERGED",
      "author": "Bren2010",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-10-16T15:44:25Z",
      "updatedAt": "2020-10-20T15:37:54Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "fba989d1d17d9e4a543b0e30d53757f9fdb33b8b",
      "headRepository": "Bren2010/mls-protocol",
      "headRefName": "brendan/2020.10.4",
      "headRefOid": "c1b4bdef3e139d25428e1fe0e561b77802674400",
      "closedAt": "2020-10-20T15:37:54Z",
      "mergedAt": "2020-10-20T15:37:54Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "d32287e85298b3c26c054f08c00f50e2462bd3cf"
      },
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "@psyoptix - We had talked about this circular dependency offline.  Does this resolution make sense to you?",
          "createdAt": "2020-10-19T18:00:47Z",
          "updatedAt": "2020-10-19T18:00:47Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "@Bren2010 It seems like at this point, we can provide the same AAD to the content and sender data encryption.  Should we consolidate into something like this?\r\n\r\n```\r\nstruct {\r\n    opaque group_id<0..255>;\r\n    uint64 epoch;\r\n    ContentType content_type;\r\n    opaque authenticated_data<0..2^32-1>;\r\n} MLSCiphertextAAD;\r\n```\r\n\r\nOr is there some reason not to provide the `authenticated_data` to the sender data encryption.",
          "createdAt": "2020-10-19T18:04:09Z",
          "updatedAt": "2020-10-19T18:04:39Z"
        },
        {
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "body": "Well, we don't know how large `authenticated_data` will be. If it's large, doing multiple passes over it when they aren't necessary would be undesirable",
          "createdAt": "2020-10-19T20:10:54Z",
          "updatedAt": "2020-10-19T20:10:54Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Discussed on virtual interim 2020-10-20:\r\n* Sender data AAD is almost not necessary, since the key/nonce are derived from the ciphertext, which includes the whole header as AAD\r\n* But sampling introduces some ambiguity here, and this argument could be difficult for composability\r\n* So the original path of having minimal AAD in sender data encryption is the right compromise",
          "createdAt": "2020-10-20T15:37:23Z",
          "updatedAt": "2020-10-20T15:37:23Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 424,
      "id": "MDExOlB1bGxSZXF1ZXN0NTA1MDAxMTM0",
      "title": "Update paragraph about handshake key schedule.",
      "url": "https://github.com/mlswg/mls-protocol/pull/424",
      "state": "MERGED",
      "author": "Bren2010",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-10-16T17:36:57Z",
      "updatedAt": "2020-10-19T14:13:59Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "fba989d1d17d9e4a543b0e30d53757f9fdb33b8b",
      "headRepository": "Bren2010/mls-protocol",
      "headRefName": "brendan/2020.10.5",
      "headRefOid": "556d4b76a5f729834c2f3635adeac288da01a4cc",
      "closedAt": "2020-10-19T14:13:59Z",
      "mergedAt": "2020-10-19T14:13:59Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "f6ff3e41c702dabcaa0721878fec337669dd459d"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTExODA4NDQ5",
          "commit": {
            "abbreviatedOid": "556d4b7"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-10-19T14:13:54Z",
          "updatedAt": "2020-10-19T14:13:54Z",
          "comments": []
        }
      ]
    },
    {
      "number": 425,
      "id": "MDExOlB1bGxSZXF1ZXN0NTA1NTE4MTI5",
      "title": "RLB edit",
      "url": "https://github.com/mlswg/mls-protocol/pull/425",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Some editorial rearrangement of the external commit PR",
      "createdAt": "2020-10-18T18:30:52Z",
      "updatedAt": "2020-10-19T14:23:10Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "external_commit",
      "baseRefOid": "65e1a24300e676ccec9b22f03cc4b2150826286b",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "external_commit_edit",
      "headRefOid": "b8b4cbf008ab42664c29ae9af70345cf25570a22",
      "closedAt": "2020-10-19T14:23:10Z",
      "mergedAt": "2020-10-19T14:23:10Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "db3b4ab23497c6091bb64bf855ac106764126b2f"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTExODE1NjI0",
          "commit": {
            "abbreviatedOid": "0b1ea1f"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-19T14:20:40Z",
          "updatedAt": "2020-10-19T14:20:41Z",
          "comments": [
            {
              "originalPosition": 54,
              "body": "```suggestion\r\ncontext = SetupBaseR(kem_output, external_priv, GroupKeyPackage)\r\n```",
              "createdAt": "2020-10-19T14:20:40Z",
              "updatedAt": "2020-10-19T14:22:59Z"
            }
          ]
        }
      ]
    },
    {
      "number": 427,
      "id": "MDExOlB1bGxSZXF1ZXN0NTA2ODk4NzAx",
      "title": "Groupcontext as context",
      "url": "https://github.com/mlswg/mls-protocol/pull/427",
      "state": "MERGED",
      "author": "kkohbrok",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "This fixes issue #426 . This is originally the work of @chrisbrzuska . I'm only submitting it for administrative purposes.",
      "createdAt": "2020-10-20T15:22:03Z",
      "updatedAt": "2020-10-20T15:30:51Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "f6ff3e41c702dabcaa0721878fec337669dd459d",
      "headRepository": "kkohbrok/mls-protocol",
      "headRefName": "groupcontext_as_context",
      "headRefOid": "9f2f9a7981e0c9d32a57fd6081ed30574d678e8d",
      "closedAt": "2020-10-20T15:30:51Z",
      "mergedAt": "2020-10-20T15:30:51Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "0a932a191070d1e534bbcc351dbadaf9a075ae25"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEyODY0Mzcx",
          "commit": {
            "abbreviatedOid": "9f2f9a7"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-10-20T15:30:25Z",
          "updatedAt": "2020-10-20T15:30:25Z",
          "comments": []
        }
      ]
    },
    {
      "number": 428,
      "id": "MDExOlB1bGxSZXF1ZXN0NTA3MDI0Njc2",
      "title": "Remove interim transcript hash from GroupInfo",
      "url": "https://github.com/mlswg/mls-protocol/pull/428",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "As discussed on 2020-10-20, this field is not needed now that #416 moved the signature under the confirmation tag.",
      "createdAt": "2020-10-20T18:50:32Z",
      "updatedAt": "2020-10-21T18:06:42Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "5acf3e402023eb3cab5675d188844a22f1a78563",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "transcript-min",
      "headRefOid": "b61a44874c7b713eebad6e1a83d15e9efbcdcf98",
      "closedAt": "2020-10-21T18:06:42Z",
      "mergedAt": "2020-10-21T18:06:42Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "68d2ea0e5fbf3fc914c03d44d0249f873064378c"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEzMTI3NzIx",
          "commit": {
            "abbreviatedOid": "b61a448"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-10-20T20:57:48Z",
          "updatedAt": "2020-10-20T20:57:48Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEzODE1NDI2",
          "commit": {
            "abbreviatedOid": "b61a448"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-10-21T15:27:36Z",
          "updatedAt": "2020-10-21T15:27:36Z",
          "comments": []
        }
      ]
    },
    {
      "number": 429,
      "id": "MDExOlB1bGxSZXF1ZXN0NTA3MDg3OTY0",
      "title": "Update changelog for draft-10",
      "url": "https://github.com/mlswg/mls-protocol/pull/429",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "We have a changelog for the document by I-D release, but haven't been updating it as we go.  This PR updates the changelog based on merged PRs and the few we expect to close before releasing draft-10.\r\n\r\nMarking this as draft right now, until the other PRs have merged.",
      "createdAt": "2020-10-20T20:49:50Z",
      "updatedAt": "2020-10-23T18:32:36Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "5acf3e402023eb3cab5675d188844a22f1a78563",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "change-log-10",
      "headRefOid": "47f6c09bf7696849f27206aa9794e3261ce43d5f",
      "closedAt": "2020-10-23T18:32:36Z",
      "mergedAt": "2020-10-23T18:32:36Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "6c89e9fb40b15f225d0349b88426ac7ee2124212"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE1OTA3NTk5",
          "commit": {
            "abbreviatedOid": "47f6c09"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-10-23T18:27:39Z",
          "updatedAt": "2020-10-23T18:27:39Z",
          "comments": []
        }
      ]
    },
    {
      "number": 430,
      "id": "MDExOlB1bGxSZXF1ZXN0NTA3MzEzOTI2",
      "title": "Allow ReInit proposals from preconfigured senders",
      "url": "https://github.com/mlswg/mls-protocol/pull/430",
      "state": "MERGED",
      "author": "kkohbrok",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-10-21T07:16:33Z",
      "updatedAt": "2020-10-21T14:40:52Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "d17b8ac7fb7b7c7d228398700fec11f9aee9d5b2",
      "headRepository": "kkohbrok/mls-protocol",
      "headRefName": "external_proposals",
      "headRefOid": "49d8872a23dc525ec6880b187db977a7e5a6f95b",
      "closedAt": "2020-10-21T14:40:52Z",
      "mergedAt": "2020-10-21T14:40:52Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "10d58381d7a5d8a431c3d38fc1d917b74a8b3eb5"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEzNzY0Nzgx",
          "commit": {
            "abbreviatedOid": "49d8872"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-10-21T14:40:47Z",
          "updatedAt": "2020-10-21T14:40:47Z",
          "comments": []
        }
      ]
    },
    {
      "number": 431,
      "id": "MDExOlB1bGxSZXF1ZXN0NTA4MDg0ODg4",
      "title": "Secret Tree: clarifications and typos",
      "url": "https://github.com/mlswg/mls-protocol/pull/431",
      "state": "MERGED",
      "author": "fxguenther",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "Some clarifications and typos from my attempt to understand secret trees and the deletion schedule. Please verify that I'm correct in that `joiner_secret` and `member_secret` also need to be consumed.",
      "createdAt": "2020-10-22T07:37:44Z",
      "updatedAt": "2020-10-23T17:38:24Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "54519449b09423bd2a44702f5be9388ebdf8bc48",
      "headRepository": "fxguenther/mls-protocol",
      "headRefName": "secret-tree-clarifications",
      "headRefOid": "0a9562f5b9fdc9096984b31bf61a5b949390b760",
      "closedAt": "2020-10-23T17:38:24Z",
      "mergedAt": "2020-10-23T17:38:24Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "600d1d13ed7ddf7e13e21acfad76c31fdc933153"
      },
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "I'll hold off on merging until we resolve the discussion above, though.",
          "createdAt": "2020-10-22T14:21:26Z",
          "updatedAt": "2020-10-22T14:21:26Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE0NTEwMzA3",
          "commit": {
            "abbreviatedOid": "b466ab0"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-22T09:02:57Z",
          "updatedAt": "2020-10-22T10:12:09Z",
          "comments": [
            {
              "originalPosition": 27,
              "body": "Wouldn't this be the leaf index instead? It shouldn't make an actual difference, but it seems more appropriate here since the sender ratchets are based on leaf indexes, not node indexes.",
              "createdAt": "2020-10-22T09:02:57Z",
              "updatedAt": "2020-10-22T14:31:51Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE0NjA3MjU1",
          "commit": {
            "abbreviatedOid": "b466ab0"
          },
          "author": "fxguenther",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-22T11:03:54Z",
          "updatedAt": "2020-10-22T11:03:55Z",
          "comments": [
            {
              "originalPosition": 27,
              "body": "This might be me being confused, however I understood the \"index\" in this sentence (and the subsequent key derivation) referring to N, and N being the node index:\r\n\r\n> Nodes are also assigned an index according to their position in the array representation of the tree (described in Appendix A).\r\n\r\nGiven that we derive, e.g., `handshake_ratchet_secret_[N]_[0]` from `tree_node_[N]_secret`, and the latter being defined on these node indices, I assumed that, throughout, N should be a node index.\r\n\r\nIf you say the symmetric ratchets `..._ratchet_secret_...` are identified via _leaf indices_, then I'd agree this should all better refer to those leaf indices.",
              "createdAt": "2020-10-22T11:03:54Z",
              "updatedAt": "2020-10-22T14:31:51Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE0NjM3NTM1",
          "commit": {
            "abbreviatedOid": "b466ab0"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-22T11:47:28Z",
          "updatedAt": "2020-10-22T11:47:29Z",
          "comments": [
            {
              "originalPosition": 27,
              "body": "This seems to be quite under-specified indeed. I was working under the assumption that members are always referenced by leaf indexes, because node indexes are only relevant for operation within the tree, not at the leaf level.\r\n@Bren2010 @bifurcation any opinion on which it is?",
              "createdAt": "2020-10-22T11:47:29Z",
              "updatedAt": "2020-10-22T14:31:51Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE0Nzc0MzUz",
          "commit": {
            "abbreviatedOid": "b466ab0"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "With the formatting nits noted, this LGTM.  Thanks @fxguenther !",
          "createdAt": "2020-10-22T14:14:02Z",
          "updatedAt": "2020-10-22T14:18:05Z",
          "comments": [
            {
              "originalPosition": 27,
              "body": "The `N` in the indices in subscripts and context values is a **node** index, not a **leaf** index.  You need that to be the case so that you don't have collisions from switching between them.  If you want, we could clarify that the member at leaf `n` uses `ratchet_secret_[2*n]_[*]` (recall that the node index of the `n`-th leaf is `2*n`).",
              "createdAt": "2020-10-22T14:14:02Z",
              "updatedAt": "2020-10-22T14:31:51Z"
            },
            {
              "originalPosition": 55,
              "body": "```suggestion\r\n* the `commit_secret`, `joiner_secret`, `member_secret`, `epoch_secret`,\r\n  `encryption_secret` of that epoch n as well as the `init_secret` of the\r\n  previous epoch n-1,\r\n```",
              "createdAt": "2020-10-22T14:16:27Z",
              "updatedAt": "2020-10-22T14:31:51Z"
            },
            {
              "originalPosition": 60,
              "body": "```suggestion\r\n  node index N,\r\n```",
              "createdAt": "2020-10-22T14:16:56Z",
              "updatedAt": "2020-10-22T14:31:51Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE0Nzg3Njk2",
          "commit": {
            "abbreviatedOid": "b466ab0"
          },
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-22T14:26:22Z",
          "updatedAt": "2020-10-22T14:26:22Z",
          "comments": [
            {
              "originalPosition": 27,
              "body": "Is there a reason for keeping both node and leaf index around conceptually? Aren't we only ever indexing the tree array? If that is the case, why not just use node indices everywhere?",
              "createdAt": "2020-10-22T14:26:22Z",
              "updatedAt": "2020-10-22T14:31:51Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE0NzkzMDE3",
          "commit": {
            "abbreviatedOid": "b466ab0"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-22T14:30:34Z",
          "updatedAt": "2020-10-22T14:30:34Z",
          "comments": [
            {
              "originalPosition": 27,
              "body": "The case that comes immediately to mind: In Remove, it's nice if the syntax constrains you so that you can only remove leaf nodes, not arbitrary nodes.",
              "createdAt": "2020-10-22T14:30:34Z",
              "updatedAt": "2020-10-22T14:31:51Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE0Nzk0NTQ0",
          "commit": {
            "abbreviatedOid": "0a9562f"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-22T14:31:53Z",
          "updatedAt": "2020-10-22T14:31:53Z",
          "comments": [
            {
              "originalPosition": 27,
              "body": "FWIW, in the implementation work I've done, it has been pretty simple to avoid confusion by having LeafIndex and NodeIndex types and using type conversion to implement the relevant math.",
              "createdAt": "2020-10-22T14:31:53Z",
              "updatedAt": "2020-10-22T14:31:53Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE0ODA1MTMy",
          "commit": {
            "abbreviatedOid": "0a9562f"
          },
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-22T14:41:39Z",
          "updatedAt": "2020-10-22T14:41:40Z",
          "comments": [
            {
              "originalPosition": 27,
              "body": "It would be more robust if we exclusively used node indices. You still have to be mindful about where you have to convert and where you don't. We can add a simple check to Remove to make sure that only leaf nodes get removed. We have to check that the leaf is within the tree size anyway.\r\n\r\nYou told me before that we don't add stuff to the standard without good reason, so why now keep it in? :wink: \r\nBeside saving us the check at Remove: Is there really a reason to keep leaf indices around?",
              "createdAt": "2020-10-22T14:41:40Z",
              "updatedAt": "2020-10-22T14:41:40Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE0ODgxODgy",
          "commit": {
            "abbreviatedOid": "0a9562f"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-22T15:55:47Z",
          "updatedAt": "2020-10-22T15:55:48Z",
          "comments": [
            {
              "originalPosition": 27,
              "body": "To second what Konrad said: We need to do checks for Removes anyway, since you can't remove an empty leaf node and the index has to be <= than the number of members, so this would just be one more test.\r\nI like the idea to have only one type of index for all operations that are covered by the spec. Naturally applications can then choose to reference members with a different scheme if they so wish (especially since empty leaf nodes are already an issue today if the member list uses leaf indexes).",
              "createdAt": "2020-10-22T15:55:47Z",
              "updatedAt": "2020-10-22T15:55:48Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE0OTIzODM1",
          "commit": {
            "abbreviatedOid": "0a9562f"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-10-22T16:42:49Z",
          "updatedAt": "2020-10-22T16:42:49Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE0OTMxNDQ1",
          "commit": {
            "abbreviatedOid": "0a9562f"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-22T16:52:04Z",
          "updatedAt": "2020-10-22T16:52:05Z",
          "comments": [
            {
              "originalPosition": 27,
              "body": "- Leaf index is used in Remove and in `unmerged_leaves`, and also in internal APIs that refer to specific members\r\n- Like Richard, I haven't had trouble keeping leaf and node ids separate in my implementation\r\n- I personally like keeping the two separate because it's more semantic",
              "createdAt": "2020-10-22T16:52:05Z",
              "updatedAt": "2020-10-22T16:52:05Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE1NDAyNDI3",
          "commit": {
            "abbreviatedOid": "0a9562f"
          },
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-23T07:17:37Z",
          "updatedAt": "2020-10-23T07:17:37Z",
          "comments": [
            {
              "originalPosition": 27,
              "body": "I've created a separate issue (#432) for this, so this PR can go ahead. \r\n\r\nI'm aware that leaf indices are used, I just don't think they are necessary. As far as I can see, in every place they are used you can simply use a node index instead, with the exception of the Remove, where you have to add a simple check. Just because you _can_ implement it (and have already done so) doesn't mean it should be in the spec.",
              "createdAt": "2020-10-23T07:17:37Z",
              "updatedAt": "2020-10-23T07:35:03Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE1ODc0MTk4",
          "commit": {
            "abbreviatedOid": "0a9562f"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-23T17:38:16Z",
          "updatedAt": "2020-10-23T17:38:16Z",
          "comments": [
            {
              "originalPosition": 27,
              "body": "Thanks for following that issue, @kkohbrok.  If that issue is off the table, I think this is clear to merge.",
              "createdAt": "2020-10-23T17:38:16Z",
              "updatedAt": "2020-10-23T17:38:16Z"
            }
          ]
        }
      ]
    },
    {
      "number": 433,
      "id": "MDExOlB1bGxSZXF1ZXN0NTEwMzI4MzAx",
      "title": "Sign the PublicGroupState",
      "url": "https://github.com/mlswg/mls-protocol/pull/433",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "The unsigned PublicGroupState created by #406 leads to an attack on the new joiner.  The sender of a GroupPublicState can associate any HPKE it wants with the group, and thus learn the `init_secret` without being a member of the group.  (The UpdatePath and the resulting `commit_secret` partly defend against this attack, though they are subverted if the attacker has compromised any single key used in the Update Path.)\r\n\r\nTo guard against this attack, this PR adds a signature over the HPKE public key in the PublicGroupState.",
      "createdAt": "2020-10-26T21:49:57Z",
      "updatedAt": "2020-11-20T17:41:50Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "5ea742c9770cd5f8b2964badba4e6e7b756fa13f",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "sign-group-key",
      "headRefOid": "9b4a3c66b90ec3f889a6ef336695f625a1d0ad8d",
      "closedAt": "2020-11-20T17:41:50Z",
      "mergedAt": "2020-11-20T17:41:50Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "529a5ce7f4a08840593c6d5b23aab684d498ebb3"
      },
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "In light of the feedback on the mailing list from @claucece re: deniability, I have upgraded this PR to sign the whole PublicGroupState.",
          "createdAt": "2020-11-16T17:11:22Z",
          "updatedAt": "2020-11-16T17:11:22Z"
        },
        {
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "body": "Outstanding issue: One detail that is not fully covered by #436 is the strategy new joiners should apply to determine who the latest committer is and make sure that both the `PublicGroupState` and the last Commit are signed by the same member.",
          "createdAt": "2020-11-18T16:52:12Z",
          "updatedAt": "2020-11-18T16:52:12Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "The last node to send an UpdatePath is the last one to set the root.  So you can follow parent_hash to find which leaf it is.  But like I said on the IETF meeting call, I don't think we should actually require that PublicGroupState be signed by the last updater.  There are possible operational/sync issues if the PublicGroupState isn't fate-shared with the Commit, but that's a practical issue, not a security issue.\r\n\r\nAnd in any case, it's not a breaking change, so we can fix it post-draft-11 if we decide we need to.",
          "createdAt": "2020-11-20T17:41:14Z",
          "updatedAt": "2020-11-20T17:41:46Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE3MjI3MzY4",
          "commit": {
            "abbreviatedOid": "e18376f"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-26T22:40:30Z",
          "updatedAt": "2020-10-26T22:40:30Z",
          "comments": [
            {
              "originalPosition": 36,
              "body": "Is there a good reason not to sign everything? Would be simpler and more robust to do so",
              "createdAt": "2020-10-26T22:40:30Z",
              "updatedAt": "2020-11-16T17:10:37Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE3MjU3NDM2",
          "commit": {
            "abbreviatedOid": "e18376f"
          },
          "author": "br-hale",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-26T23:56:21Z",
          "updatedAt": "2020-10-26T23:56:21Z",
          "comments": [
            {
              "originalPosition": 36,
              "body": "I second this question. Following discussion elsewhere on the mailing list, deniability may be pushed to the application level. If deniability was a factor for not signing everything, then it may not apply anymore.",
              "createdAt": "2020-10-26T23:56:21Z",
              "updatedAt": "2020-11-16T17:10:37Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE4MDkzODgw",
          "commit": {
            "abbreviatedOid": "e18376f"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-27T19:59:01Z",
          "updatedAt": "2020-10-27T19:59:01Z",
          "comments": [
            {
              "originalPosition": 36,
              "body": "Personally, I agree with you both.  @raphaelrobert raised some concerns about deniability due to signing the tree, I think because he doesn't totally buy the \"punt\" argument I presented on the mailing list.  This was the minimum solution to address the obvious problem.",
              "createdAt": "2020-10-27T19:59:01Z",
              "updatedAt": "2020-11-16T17:10:37Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE4MTQ5Mzc2",
          "commit": {
            "abbreviatedOid": "e18376f"
          },
          "author": "br-hale",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-27T21:04:07Z",
          "updatedAt": "2020-10-27T21:04:07Z",
          "comments": [
            {
              "originalPosition": 36,
              "body": "That makes sense. Even if we are still aiming for some form of deniability here, I think that we can sign a little more. For example, the cipher_suite, extensions, should be fine. The opaque_signature should be the main issue with respect to deniability. @raphaelrobert : do you have a strong opinion about not signing the transcript hash?",
              "createdAt": "2020-10-27T21:04:07Z",
              "updatedAt": "2020-11-16T17:10:37Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE4NDExOTUw",
          "commit": {
            "abbreviatedOid": "e18376f"
          },
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-28T08:18:15Z",
          "updatedAt": "2020-10-28T08:18:16Z",
          "comments": [
            {
              "originalPosition": 36,
              "body": "The difference between signing the transcript hash and signing just the public key is that you need knowledge of the key schedule (and how it was derived) to tie the public key to the rest of the group state, while (if you don't encrypt handshake messages), the transcript hash can be computed by any party observing the traffic. At least as far as I understand the transcript hash computation. So in terms of deniability it certainly gets easier for the adversary.",
              "createdAt": "2020-10-28T08:18:15Z",
              "updatedAt": "2020-11-16T17:10:37Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIxMTU4OTg1",
          "commit": {
            "abbreviatedOid": "e18376f"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-31T18:18:29Z",
          "updatedAt": "2020-10-31T18:18:29Z",
          "comments": [
            {
              "originalPosition": 36,
              "body": "Sorry for the late reply. I think the PR really just covers the bare minimum of what needs to be signed. My initial proposal was to cover the whole PublicGroupState struct by the signature, except for the tree_hash field.\r\nJust like @br-hale I think including the transcript hash would make this more robust. That being said, @kkohbrok has a very valid point here: the transcript hash can be computed by a passive network observer without any knowledge of group secrets (this is where we are missing the derived epoch IDs we discarded). My intuition is that if we include the transcript hash we might as well include everything.\r\nAs @br-hale pointed out, if we go for the beefier version of the parent hash anyway, seeking any deniability guarantees at this level makes little sense.",
              "createdAt": "2020-10-31T18:18:29Z",
              "updatedAt": "2020-11-16T17:10:37Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTMxNTU1NDA5",
          "commit": {
            "abbreviatedOid": "9b4a3c6"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-11-16T17:39:47Z",
          "updatedAt": "2020-11-16T17:39:47Z",
          "comments": []
        }
      ]
    },
    {
      "number": 434,
      "id": "MDExOlB1bGxSZXF1ZXN0NTEyNTY5NDA5",
      "title": "move definition of ParentNode earlier",
      "url": "https://github.com/mlswg/mls-protocol/pull/434",
      "state": "MERGED",
      "author": "uhoreg",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "I think that this change will reduce the chance for [confusion](https://mailarchive.ietf.org/arch/msg/mls/UIWuwPC3ukryFUOANyH4cX4et3o/), as now the Parent Hash section will be self-contained, rather than needing to also look into the Tree Hashes section.  Also, it should hopefully be clearer that the `parent_hash` field in the `ParentNode` struct is calculated as the hash of another `ParentNode` struct, rather than the hash of a `ParentNodeHashInput`.\r\n\r\n(Though I don't see anywhere that says what to use as `parent_hash` when the `ParentNode` refers to the root.)",
      "createdAt": "2020-10-29T21:06:08Z",
      "updatedAt": "2020-11-16T16:36:53Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "5ea742c9770cd5f8b2964badba4e6e7b756fa13f",
      "headRepository": "uhoreg/mls-protocol",
      "headRefName": "hash_clarification",
      "headRefOid": "4d2367e672bd4f0119a70fac348198cd50cc03f8",
      "closedAt": "2020-11-16T16:36:53Z",
      "mergedAt": "2020-11-16T16:36:52Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "57bb2954265c57896249dcb2bbb04788205fb466"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIxMDA1Mjcx",
          "commit": {
            "abbreviatedOid": "4d2367e"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-10-30T20:16:38Z",
          "updatedAt": "2020-10-30T20:16:38Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTMxNDk2NzUy",
          "commit": {
            "abbreviatedOid": "4d2367e"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-11-16T16:36:42Z",
          "updatedAt": "2020-11-16T16:36:42Z",
          "comments": []
        }
      ]
    },
    {
      "number": 435,
      "id": "MDExOlB1bGxSZXF1ZXN0NTE0ODgxMzcy",
      "title": "Fix parent hash verification",
      "url": "https://github.com/mlswg/mls-protocol/pull/435",
      "state": "CLOSED",
      "author": "dajost",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "This is a spin-off from the work on tree-signing by Jo\u00ebl, Marta, and me. Note that this obsoletes #434 as I couldn't figure out how to do dependent PRs in Github.\r\n\r\nConsider the following ratchet tree and assume that (1) the left subtree is fully occupied and (2) E last committed in the right subtree, i.e., the key at node [A..F] has been sampled by E. \r\n```\r\n       [root]   \r\n           \\\r\n            \\\r\n             \\\r\n            [A..F]\r\n            /    \\\r\n           /      \\\r\n          /        \\\r\n         /          \\\r\n     [A..D]        [EF]\r\n      /  \\          /\\\r\n     /    \\        /  \\\r\n    /      \\      /    \\\r\n  [AB]    [CD]   [E]   [F]\r\n   /\\      /\\\r\n  /  \\    /  \\\r\n[A] [B] [C] [D]\r\n```\r\nNow say party Z from the left subtree committs a proposal that adds party G. According to my understanding the tree will look as follows, where I use the syntax [A..F,G] to denote that parties A to F know the secret key and G is tracked as an unmerged leaf. \r\n```\r\n       [root]   \r\n           \\\r\n            \\\r\n             \\\r\n           [A..F,G]\r\n            /    \\\r\n           /      \\\r\n          /        \\\r\n         /          \\\r\n     [A..D]        [X]\r\n      /  \\          /\\\r\n     /    \\        /  \\\r\n    /      \\      /    \\\r\n  [AB]    [CD]   [EF]  [G]\r\n   /\\      /\\     /\\\r\n  /  \\    /  \\   /  \\\r\n[A] [B] [C] [D] [E] [F]\r\n```\r\n\r\nNow observe the following two issues:\r\n* According to the draft, G now has to verify that either of [A..F,G]'s children store a correct parent hash. However, its parent-hash is no longer stored in its direct child [X], an additional blank node inserted for the add, but still in [EF] instead. This needs to be accounted for in the verification.\r\n* Orignally, the ``parent_hash`` includes ``unmerged_leaves``. Hence, for [A..F,G] the value stored in [EF] (and recursively signed by E) will no longer match the recomputed value. Since partent hashes are only updated along the committer's path which at this point has no unmerged leaves, however, there is no point in including unmerged leaves. ",
      "createdAt": "2020-11-03T17:16:15Z",
      "updatedAt": "2020-12-11T21:22:41Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "5ea742c9770cd5f8b2964badba4e6e7b756fa13f",
      "headRepository": "dajost/mls-protocol",
      "headRefName": "parent-hash-verification",
      "headRefOid": "ce81177b49fcfbf555189a3c56eb28990e7c6b40",
      "closedAt": "2020-12-11T21:22:41Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "dajost",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I am not sure I can follow your concern. Just to clarify, this is so far just about fixing the current scheme, preserving the deniability properties. The bigger change of reversing the order of the tree hashes in the parent hashes will be a different PR.",
          "createdAt": "2020-11-03T21:07:36Z",
          "updatedAt": "2020-11-03T21:07:36Z"
        },
        {
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "body": "Ah, if this is still about the old scheme, I would say we just wait for the change to the new one.",
          "createdAt": "2020-11-04T16:15:18Z",
          "updatedAt": "2020-11-04T16:15:18Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "I think I see where the misunderstanding is here.  The tree you present is only constructed transiently, for use in generating the `UpdatePath` for the commit.  The tree that is actually sent to G has the `UpdatePath` merged:\r\n\r\n```\r\n       [root]   \r\n           \\\r\n            \\\r\n             \\\r\n             [X3]               X3.ph = 0\r\n            /    \\\r\n           /      \\\r\n          /        \\\r\n         /          \\\r\n      [X2]         [__]         X2.ph = H(X3.pk, X3.ph, [EF.pk, G.pk])\r\n      /  \\          /\\\r\n     /    \\        /  \\\r\n    /      \\      /    \\\r\n  [AB]    [X1]   [EF]  [G]      X1.ph = H(X2.pk, X2.ph, [AB.pk])\r\n   /\\      /\\     /\\\r\n  /  \\    /  \\   /  \\\r\n[A] [B] [X] [D] [E] [F]         X.ph  = H(X1.pk, X1.ph, [D.pk])\r\n```\r\n\r\nHere `X` is the sender of the update, and the ParentHashes according to the scheme in #436 are shown.  In this tree, the updated nodes have valid parent hash values, and the new blank node doesn't need one. ",
          "createdAt": "2020-11-20T20:03:18Z",
          "updatedAt": "2020-11-20T20:03:18Z"
        },
        {
          "author": "MartaMularczyk",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> I think I see where the misunderstanding is here. The tree you present is only constructed transiently, for use in generating the `UpdatePath` for the commit. The tree that is actually sent to G has the `UpdatePath` merged:\r\n> \r\n> ```\r\n>        [root]   \r\n>            \\\r\n>             \\\r\n>              \\\r\n>              [X3]               X3.ph = 0\r\n>             /    \\\r\n>            /      \\\r\n>           /        \\\r\n>          /          \\\r\n>       [X2]         [__]         X2.ph = H(X3.pk, X3.ph, [EF.pk, G.pk])\r\n>       /  \\          /\\\r\n>      /    \\        /  \\\r\n>     /      \\      /    \\\r\n>   [AB]    [X1]   [EF]  [G]      X1.ph = H(X2.pk, X2.ph, [AB.pk])\r\n>    /\\      /\\     /\\\r\n>   /  \\    /  \\   /  \\\r\n> [A] [B] [X] [D] [E] [F]         X.ph  = H(X1.pk, X1.ph, [D.pk])\r\n> ```\r\n> \r\n> Here `X` is the sender of the update, and the ParentHashes according to the scheme in #436 are shown. In this tree, the updated nodes have valid parent hash values, and the new blank node doesn't need one.\r\n\r\nI think the misunderstanding may be in who's the committer: this picture shows only the right half of the tree and the committer X is in the left part (left child of [root]). So after X commits, [A..F,G].ph doesn't change and it's still computed using [EF]'s values.",
          "createdAt": "2020-11-25T16:53:02Z",
          "updatedAt": "2020-11-25T16:53:02Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Ah, thanks for the clarification, @MartaMularczyk.  So the observation here is that committing Add proposals can result in blank nodes being inserted beneath a parent node, as the tree grows.  That means that you can't just go down one level, you have to recurse to the left until you find a non-blank node (equivalently, take the first node in the resolution of the right child).\r\n\r\nIt seems like the right parent hash validation is then to do the following check for each non-blank `parent_node`:\r\n\r\n```\r\nH = Hash(parent_node)\r\nL = left_child(parent_node)\r\nR = left_child^k(right_child(parent_node) // k >= 0 smallest value such that R != blank\r\nreturn H == L.parent_hash || H == R.parent_hash;\r\n```\r\n\r\nThe theory being that extending the tree always adds nodes to the right, so that when these situations arise, you just need to recurse to the left.  \r\n",
          "createdAt": "2020-12-11T20:56:35Z",
          "updatedAt": "2020-12-11T20:56:35Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Given that this PR will need to be rebased on #436 anyway, I'm closing this one and proposing that we just update #436 to do the right thing.  I have suggested text on that PR.",
          "createdAt": "2020-12-11T21:22:41Z",
          "updatedAt": "2020-12-11T21:22:41Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIyODUzNDcx",
          "commit": {
            "abbreviatedOid": "ce81177"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "I'm not sure this gets where you want.\r\n\r\nparent_hash = H(subtree headed by my parent, excluding parent_hash related stuff)",
          "createdAt": "2020-11-03T20:32:48Z",
          "updatedAt": "2020-11-03T20:32:48Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM1NzMxOTE5",
          "commit": {
            "abbreviatedOid": "ce81177"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Given the issues noted, I am inclined to close this with no action.",
          "createdAt": "2020-11-20T19:50:28Z",
          "updatedAt": "2020-11-20T19:52:27Z",
          "comments": [
            {
              "originalPosition": 36,
              "body": "This seems incorrect to me.  The  value of `parent_hash` is set from the direct parent, so it's useless to look at the blank node's children.  You don't have enough information to verify that `parent_hash`; you're missing what was in the blank node.  You also can't reset the `parent_hash` to \"skip over\" the blank node when you set it to blank, because that would invalidate `parent_hash` values below it in the tree and ultimately, the signature on the leaf.",
              "createdAt": "2020-11-20T19:50:29Z",
              "updatedAt": "2020-11-20T19:52:27Z"
            },
            {
              "originalPosition": 23,
              "body": "I prefer not to group things like this, and just assemble the hash input as necessary.  Especially since #436 is going to change `ParentHashInput` to diverge further from `ParentNode`.  Implementations are of course free to store things this way.",
              "createdAt": "2020-11-20T19:51:25Z",
              "updatedAt": "2020-11-20T19:52:27Z"
            }
          ]
        }
      ]
    },
    {
      "number": 436,
      "id": "MDExOlB1bGxSZXF1ZXN0NTIwMTUxNDIx",
      "title": "Strong tree signing",
      "url": "https://github.com/mlswg/mls-protocol/pull/436",
      "state": "MERGED",
      "author": "psyoptix",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "This pull request makes editorial changes to the definition of Tree Hash  to hopefully make it easier to understand.\r\n\r\nIt also redefines Parent Hash to include the HPKE public keys to which a nodes secret key was sent. This binds a key package introduced to the ratchet tree in a commit not just to the HPKE keys on the commits direct path but also (indirectly) to the other members that were sent each of the new (secret) keys. \r\n\r\nIn particular, this prevents the attacks from the mailinglist that allowed an attacker to create artificial ratchet trees where the tree invariant was violated (which in turn lead to removes failing). But parent_hash only includes the HPKE pubkeys in the resolution so at least some amount of deniability might be preserved.",
      "createdAt": "2020-11-12T20:52:09Z",
      "updatedAt": "2020-12-21T21:48:25Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "5cedaf1ec905e046b86f057499f01a0259829278",
      "headRepository": "dajost/mls-protocol",
      "headRefName": "strong-tree-signing",
      "headRefOid": "f1dfd594d18db3b7d705800460467e0a11ad8d25",
      "closedAt": "2020-12-21T21:48:25Z",
      "mergedAt": "2020-12-21T21:48:25Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "10df4266e4733134decdcc6cfa80f2d480674261"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTMwODU0MzU1",
          "commit": {
            "abbreviatedOid": "8d4e183"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "Please also remove trailing spaces from many lines",
          "createdAt": "2020-11-16T00:27:02Z",
          "updatedAt": "2020-11-16T00:46:15Z",
          "comments": [
            {
              "originalPosition": 28,
              "body": "```suggestion\r\nconstructing an artificial ratchet tree with a node whose HPKE secret key is\r\n```",
              "createdAt": "2020-11-16T00:27:03Z",
              "updatedAt": "2020-12-21T17:16:00Z"
            },
            {
              "originalPosition": 30,
              "body": "```suggestion\r\ncorresponding subtree. (Indeed, such a ratchet tree would violate the tree\r\n```",
              "createdAt": "2020-11-16T00:27:25Z",
              "updatedAt": "2020-12-21T17:16:00Z"
            },
            {
              "originalPosition": 46,
              "body": "```suggestion\r\na group new members MUST verify that if a leaf contains a `parent_hash` value, then\r\n```",
              "createdAt": "2020-11-16T00:28:04Z",
              "updatedAt": "2020-12-21T17:16:00Z"
            },
            {
              "originalPosition": 57,
              "body": "```suggestion\r\nThe `parent_hash` at the root is a zero-length bit string. To compute the parent hash at a non-root\r\n```",
              "createdAt": "2020-11-16T00:28:30Z",
              "updatedAt": "2020-12-21T17:16:00Z"
            },
            {
              "originalPosition": 58,
              "body": "```suggestion\r\nnode V with parent P and sibling S, the `ParentHashInput` struct is used. It\r\n```",
              "createdAt": "2020-11-16T00:29:11Z",
              "updatedAt": "2020-12-21T17:16:00Z"
            },
            {
              "originalPosition": 59,
              "body": "```suggestion\r\nconsists of three fields: The first contains the HPKE public key of P. The second\r\n```",
              "createdAt": "2020-11-16T00:29:22Z",
              "updatedAt": "2020-12-21T17:16:00Z"
            },
            {
              "originalPosition": 60,
              "body": "```suggestion\r\ncontains the `parent_hash` at P. The third contains the list of HPKE public\r\n```",
              "createdAt": "2020-11-16T00:29:48Z",
              "updatedAt": "2020-12-21T17:16:00Z"
            },
            {
              "originalPosition": 61,
              "body": "```suggestion\r\nkeys to which the HPKE secret key of P was sent to. That is, it consists of\r\n```",
              "createdAt": "2020-11-16T00:31:42Z",
              "updatedAt": "2020-12-21T17:16:00Z"
            },
            {
              "originalPosition": 62,
              "body": "```suggestion\r\nthe array of `HPKEPublicKey` values of the nodes in the resolution of U, with\r\n```",
              "createdAt": "2020-11-16T00:31:56Z",
              "updatedAt": "2020-12-21T17:16:00Z"
            },
            {
              "originalPosition": 63,
              "body": "```suggestion\r\nthe`unmerged_leaves` of P omitted. \r\n```",
              "createdAt": "2020-11-16T00:32:24Z",
              "updatedAt": "2020-12-21T17:16:00Z"
            },
            {
              "originalPosition": 111,
              "body": "This struct got deleted but is still referenced in several places",
              "createdAt": "2020-11-16T00:46:01Z",
              "updatedAt": "2020-12-21T17:16:00Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTMxNTAyNjIz",
          "commit": {
            "abbreviatedOid": "8d4e183"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-16T16:42:53Z",
          "updatedAt": "2020-11-16T17:05:47Z",
          "comments": [
            {
              "originalPosition": 42,
              "body": "I think this can be stronger -- the extension MUST be present **if and only if** the KeyPackage is in the UpdatePath.  Just to be clear that for other KeyPackages (e.g., pre-published ones, ones sent in Update proposals), this extension MUST NOT be included.\r\n\r\n```suggestion\r\nThis extension MUST be present in the `leaf_key_package` field of an\r\n```",
              "createdAt": "2020-11-16T16:42:53Z",
              "updatedAt": "2020-12-21T17:16:00Z"
            },
            {
              "originalPosition": 57,
              "body": "Nit: Octet string, not bit string.\r\n\r\nIs there a reason to use the zero-length octet string instead of the `Nh`-long all-zero `0` string?  We use `0` for missing values elsewhere, e.g., PSK secret.  And it seems like it gives you an explicit \"null termination\" here.",
              "createdAt": "2020-11-16T16:44:48Z",
              "updatedAt": "2020-12-21T17:16:00Z"
            },
            {
              "originalPosition": 78,
              "body": "This scheme seems a little cumbersome, in that the `original_sibling_resolution` vector could get quite large.  I wonder if we should just define another layer of hashing underneath this that summarizes the HPKE public keys in the tree.  So something like the following picture:\r\n\r\n```\r\n/ / / /  TreeHash\r\n\\ \\ \\ \\  ParentHash\r\n/ / / /  ResolutionHash\r\n```\r\n\r\nWhere `/` indicates parents' hashes covering children, and `\\` indicates the reverse.",
              "createdAt": "2020-11-16T16:55:10Z",
              "updatedAt": "2020-12-21T17:16:00Z"
            },
            {
              "originalPosition": 78,
              "body": "It might be worth saying a something here on the validation strategy.  Before, we had the property that tree is valid if for every non-blank parent node, its ParentHashInput matches exactly one of its children's parent_hash fields.  It seems like that probably still applies here, but wanted to check.",
              "createdAt": "2020-11-16T16:58:37Z",
              "updatedAt": "2020-12-21T17:16:00Z"
            },
            {
              "originalPosition": 78,
              "body": "It seems a little odd that we have a pointer \"across\" the tree here, from a node to its sibling.  Would it work to move the resolution to the parent?  So the ParentHashInput would say, \"this public key under this parent, with the private key encrypted to this resolution\".  Together with the above suggestions, you would end up with something like:\r\n\r\n```\r\nstruct {\r\n  HPKEPublicKey public_key;     // from parent\r\n  opaque parent_hash<0..255>;   // from parent\r\n  opaque resolution_hash<0..8>; // from non-updated child\r\n} ParentHashInput;\r\n```\r\n\r\nThen your validity check for a non-blank parent node is that for one of its children:\r\n```\r\none_child.parent_hash = H(ParentHashInput{public_key, parent_hash, other_child.resolution_hash})\r\n```",
              "createdAt": "2020-11-16T17:04:04Z",
              "updatedAt": "2020-12-21T17:16:00Z"
            },
            {
              "originalPosition": 116,
              "body": "```suggestion\r\nThe tree hash of a leaf node is the hash of leaf's `LeafNodeHashInput` object which\r\n```",
              "createdAt": "2020-11-16T17:04:54Z",
              "updatedAt": "2020-12-21T17:16:00Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTMxNTUxNzEw",
          "commit": {
            "abbreviatedOid": "8d4e183"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-16T17:35:13Z",
          "updatedAt": "2020-11-16T17:35:13Z",
          "comments": [
            {
              "originalPosition": 57,
              "body": "I've always been trying to use zero-length octet strings instead of \"0\" because \"0\" is ambiguous to me. For `Nh`-long all-zero string, I don't think we've used that anywhere else. Probably just because it's wordier",
              "createdAt": "2020-11-16T17:35:13Z",
              "updatedAt": "2020-12-21T17:16:00Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTMyNDg4Nzk3",
          "commit": {
            "abbreviatedOid": "8e814ae"
          },
          "author": "psyoptix",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-17T15:27:46Z",
          "updatedAt": "2020-11-17T15:27:46Z",
          "comments": [
            {
              "originalPosition": 57,
              "body": "My (weak) preference is to use an Nh long all-zero string. But only because that makes it the right data type for the output of a hash function (in contrast to the empty string).",
              "createdAt": "2020-11-17T15:27:46Z",
              "updatedAt": "2020-12-21T17:16:00Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTMyNDkzNDgy",
          "commit": {
            "abbreviatedOid": "2c199ce"
          },
          "author": "psyoptix",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-17T15:32:09Z",
          "updatedAt": "2020-11-17T15:32:10Z",
          "comments": [
            {
              "originalPosition": 30,
              "body": "I'm not a fan of \"corresponding\" subtree because its a bit imprecise since we dont define what the correspondence is. I find \"subtree rooted at v\" clearer. Alternatively we could define \"corresponding subtree\" somewhere but my preference is to not introduce new (e.g. graph theory) terminology whenever standard terms can be used to the same end.",
              "createdAt": "2020-11-17T15:32:09Z",
              "updatedAt": "2020-12-21T17:16:00Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTMyNTAxNDY4",
          "commit": {
            "abbreviatedOid": "2c199ce"
          },
          "author": "psyoptix",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-17T15:39:44Z",
          "updatedAt": "2020-11-17T15:39:44Z",
          "comments": [
            {
              "originalPosition": 78,
              "body": "Re: Validation. Yes, i think the same validation algo should work as before. And I agree text describing validation is necessary. Just not sure where to put that. Could put it in the Parent Hash section but maybe its more appropriate when describing how to process commit packets and how to join a group? (Group members should check that the parent_hash in the commitors key package checks out by recomputing it and comparing to whats in the key package. New members should check that the parent hash of each internal node is stored at one of its two children.)",
              "createdAt": "2020-11-17T15:39:44Z",
              "updatedAt": "2020-12-21T17:16:00Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTMyNjExODA4",
          "commit": {
            "abbreviatedOid": "2c199ce"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-17T17:23:39Z",
          "updatedAt": "2020-11-17T17:23:40Z",
          "comments": [
            {
              "originalPosition": 57,
              "body": "```suggestion\r\nthe `unmerged_leaves` of P omitted.\r\n```",
              "createdAt": "2020-11-17T17:23:40Z",
              "updatedAt": "2020-12-21T17:16:00Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM1NzI3MjQw",
          "commit": {
            "abbreviatedOid": "2c199ce"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "@psyoptix I think you mean to change \"ParentNode\" to \"ParentNodeTreeHashData\", but didn't get all the way there.  I prefer it as \"ParentNode\" anyway :)  If you could fix that and the other comments noted, I think this will be ready to merge.",
          "createdAt": "2020-11-20T19:42:53Z",
          "updatedAt": "2020-11-21T00:08:55Z",
          "comments": [
            {
              "originalPosition": 78,
              "body": "After think through this a bit more (and getting a partial implementation working).  I think I'm OK with the original formulation here.  Jo\u00ebl reminded me that the sibling resolution will be short in a full tree, so the only case where you'll end up with large values here is in a sparse tree, which seems acceptable to me.  Given that, I think my only comment here is around naming, which I'll put in as a suggestion abvoe. ",
              "createdAt": "2020-11-20T19:42:53Z",
              "updatedAt": "2020-12-21T17:16:00Z"
            },
            {
              "originalPosition": 70,
              "body": "```suggestion\r\n    HPKEPublicKey public_key;\r\n    opaque parent_hash<0..255>;\r\n    HPKEPublicKey original_child_resolution<0..2^32-1>;\r\n```\r\n\r\n1. Convert tabs to spaces\r\n2. Phrase the variable names from the point of view of the parent.",
              "createdAt": "2020-11-20T19:44:32Z",
              "updatedAt": "2020-12-21T17:16:00Z"
            },
            {
              "originalPosition": 111,
              "body": "Yeah, I think we still need this one.  It goes in the syntax for how you send the tree to a new member.",
              "createdAt": "2020-11-21T00:04:17Z",
              "updatedAt": "2020-12-21T17:16:00Z"
            },
            {
              "originalPosition": 139,
              "body": "```suggestion\r\nstruct {\r\n    HPKEPublicKey public_key;\r\n    opaque parent_hash<0..255>;\r\n    uint32 unmerged_leaves<0..2^32-1>;\r\n} ParentNode;\r\n```",
              "createdAt": "2020-11-21T00:06:39Z",
              "updatedAt": "2020-12-21T17:16:00Z"
            },
            {
              "originalPosition": 131,
              "body": "```suggestion\r\nits `ParentNodeTreeHashInput`. This includes an optional `ParentNode`\r\n```\r\n\r\nI prefer \"ParentNode\", since we use this for sending the tree as well as hashing.",
              "createdAt": "2020-11-21T00:07:14Z",
              "updatedAt": "2020-12-21T17:16:00Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTUwNTcyODE4",
          "commit": {
            "abbreviatedOid": "37adf10"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "One more small fix here, then I think this is ready to merge.",
          "createdAt": "2020-12-11T20:57:38Z",
          "updatedAt": "2020-12-11T21:21:09Z",
          "comments": [
            {
              "originalPosition": 111,
              "body": "Resolving this conversation because it got re-added below.",
              "createdAt": "2020-12-11T20:57:39Z",
              "updatedAt": "2020-12-21T17:16:00Z"
            },
            {
              "originalPosition": 104,
              "body": "This section should address the problem noted in #435.  Namely, `V` should either be `left(P)` or `left^k(right(P)`, for the smallest possible `k >= 0`. Suggested text:\r\n\r\n```suggestion\r\nTo this end, when processing a Commit message clients MUST recompute the\r\nexpected value of `parent_hash` for the committer's new leaf and verify that it\r\nmatches the `parent_hash` value in the supplied `leaf_key_package`. Moreover, when\r\njoining a group, new members MUST authenticate each non-blank parent node P. A parent\r\nnode P is authenticated by performing the following check: \r\n\r\n* Let L and R be the left and right children of P, respectively\r\n* If L.parent_hash is equal to the Parent Hash of P with Co-Path Child R, the check passes \r\n* If R is blank, replace R with its left child until R is either non-blank or a leaf node\r\n* If R is a leaf node, the check fails\r\n* If R.parent_hash is equal to the Parent Hash of P with Co-Path Child L, the check passes\r\n* Otherwise, the check fails\r\n\r\nThe left-child recursion under the right child of P is necessary because the expansion of \r\nthe tree to the right due to Add proposals can cause blank nodes to be interposed \r\nbetween a parent node and its right child. \r\n```\r\n\r\ncc @MartaMularczyk @dajost ",
              "createdAt": "2020-12-11T21:14:24Z",
              "updatedAt": "2020-12-21T17:16:00Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU1NjMxNjQ0",
          "commit": {
            "abbreviatedOid": "37adf10"
          },
          "author": "psyoptix",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-12-18T16:24:38Z",
          "updatedAt": "2020-12-18T16:24:38Z",
          "comments": [
            {
              "originalPosition": 104,
              "body": "Nice! Looks good to me.",
              "createdAt": "2020-12-18T16:24:38Z",
              "updatedAt": "2020-12-21T17:16:00Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU1NjM5MzAz",
          "commit": {
            "abbreviatedOid": "9957be7"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-12-18T16:34:35Z",
          "updatedAt": "2020-12-18T16:34:35Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU2MDQzNjEz",
          "commit": {
            "abbreviatedOid": "9957be7"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Looks good, please fix conflicts",
          "createdAt": "2020-12-20T19:18:20Z",
          "updatedAt": "2020-12-20T19:34:46Z",
          "comments": [
            {
              "originalPosition": 71,
              "body": "```suggestion\r\nis the root, then `parent_hash` is set to a zero-length octet string.\r\n```",
              "createdAt": "2020-12-20T19:18:20Z",
              "updatedAt": "2020-12-21T17:16:00Z"
            },
            {
              "originalPosition": 81,
              "body": "```suggestion\r\n6 has an array with one element in it: the HPKE public key of 6.\r\n```",
              "createdAt": "2020-12-20T19:20:00Z",
              "updatedAt": "2020-12-21T17:16:00Z"
            },
            {
              "originalPosition": 86,
              "body": "```suggestion\r\nthen P's Parent Hash is stored in the `parent_hash` fields of both V's\r\n```",
              "createdAt": "2020-12-20T19:24:53Z",
              "updatedAt": "2020-12-21T17:16:00Z"
            },
            {
              "originalPosition": 202,
              "body": "```suggestion\r\n    leaf). If either of the node's children are empty, and in particular does not\r\n```",
              "createdAt": "2020-12-20T19:34:18Z",
              "updatedAt": "2020-12-21T17:16:00Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU2NTE3NjU4",
          "commit": {
            "abbreviatedOid": "9957be7"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-12-21T16:47:14Z",
          "updatedAt": "2020-12-21T16:47:14Z",
          "comments": [
            {
              "originalPosition": 202,
              "body": "No, the subject which which the verb must agree is \"either\" (singular), not \"children\" (plural).",
              "createdAt": "2020-12-21T16:47:14Z",
              "updatedAt": "2020-12-21T17:16:00Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU2NjA4MTM4",
          "commit": {
            "abbreviatedOid": "f1dfd59"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-12-21T19:18:56Z",
          "updatedAt": "2020-12-21T19:18:56Z",
          "comments": []
        }
      ]
    },
    {
      "number": 437,
      "id": "MDExOlB1bGxSZXF1ZXN0NTIwNjMxOTM5",
      "title": "Leave this phrase open to allow deniability",
      "url": "https://github.com/mlswg/mls-protocol/pull/437",
      "state": "MERGED",
      "author": "claucece",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "cc./ @raphaelrobert @beurdouche ",
      "createdAt": "2020-11-13T15:00:52Z",
      "updatedAt": "2020-11-16T16:36:14Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "5ea742c9770cd5f8b2964badba4e6e7b756fa13f",
      "headRepository": "claucece/mls-protocol",
      "headRefName": "master",
      "headRefOid": "92038a49d63b375bd5cf12992159660ba80cc064",
      "closedAt": "2020-11-16T16:36:14Z",
      "mergedAt": "2020-11-16T16:36:14Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "a1fe025945b7b2b3e2dd8cf102984637061b7655"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTMwODU0MDEx",
          "commit": {
            "abbreviatedOid": "92038a4"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-11-16T00:24:22Z",
          "updatedAt": "2020-11-16T00:24:22Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTMxMDA0NzQx",
          "commit": {
            "abbreviatedOid": "92038a4"
          },
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-11-16T07:50:30Z",
          "updatedAt": "2020-11-16T07:50:30Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTMxNDk2MjA2",
          "commit": {
            "abbreviatedOid": "92038a4"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-11-16T16:36:09Z",
          "updatedAt": "2020-11-16T16:36:09Z",
          "comments": []
        }
      ]
    },
    {
      "number": 438,
      "id": "MDExOlB1bGxSZXF1ZXN0NTIxODAzNDU5",
      "title": "Remove some stale OPEN ISSUEs",
      "url": "https://github.com/mlswg/mls-protocol/pull/438",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "In preparation for feature-freeze / post-first-WGLC living, this PR removes a few issues that have been discussed and pretty much resolved.  It leaves a few OPEN ISSUES that could benefit from analysis during the feature freeze.",
      "createdAt": "2020-11-16T17:08:24Z",
      "updatedAt": "2020-11-21T20:02:15Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "529a5ce7f4a08840593c6d5b23aab684d498ebb3",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "open-issues",
      "headRefOid": "80a9d687e9c44a630b858704dc393369a52bd1e7",
      "closedAt": "2020-11-21T20:02:15Z",
      "mergedAt": "2020-11-21T20:02:15Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "9afdd386ecaf391a948ec3e0de79991a683c89fc"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTMxNTUzNzI0",
          "commit": {
            "abbreviatedOid": "969c900"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-11-16T17:37:41Z",
          "updatedAt": "2020-11-16T17:37:41Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTMzNjU0OTMx",
          "commit": {
            "abbreviatedOid": "969c900"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "CHANGES_REQUESTED",
          "body": "Looks good in general. I flagged one issue I saw.",
          "createdAt": "2020-11-18T16:54:11Z",
          "updatedAt": "2020-11-18T16:55:24Z",
          "comments": [
            {
              "originalPosition": 36,
              "body": "I'm inclined to have this documented somewhere, perhaps not as an open issue. Otherwise someone will claim they discovered an \"attack\".",
              "createdAt": "2020-11-18T16:54:11Z",
              "updatedAt": "2020-11-20T19:24:39Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM1OTcxMjUw",
          "commit": {
            "abbreviatedOid": "80a9d68"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-11-21T14:50:42Z",
          "updatedAt": "2020-11-21T14:50:42Z",
          "comments": []
        }
      ]
    },
    {
      "number": 439,
      "id": "MDExOlB1bGxSZXF1ZXN0NTIyMjU3MDQ4",
      "title": "Identities SHOULD be unique per group",
      "url": "https://github.com/mlswg/mls-protocol/pull/439",
      "state": "CLOSED",
      "author": "kkohbrok",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "This PR changes the draft such that it mandates identities SHOULD be unique per group.\r\n\r\nIn particular, a committer SHOULD only include one Add per identity if multiple are present and SHOULD NOT include Adds for identities that are already members of the group.\r\n\r\nI also made the requirement more precise, that there shouldn't be multiple Adds for the same \"client\", which I change \"client\" to \"KeyPackage\".\r\n\r\nThe rationale here being that this change allows us to address group members by their identity rather than their leaf index, which would allow us to finally hide the fact that we're using a tree underneath from users of MLS.",
      "createdAt": "2020-11-17T09:13:12Z",
      "updatedAt": "2021-08-19T21:11:06Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "57bb2954265c57896249dcb2bbb04788205fb466",
      "headRepository": "kkohbrok/mls-protocol",
      "headRefName": "unique_identity_per_group",
      "headRefOid": "4d6dde92c86320c6df3b8981e5f8685b6ca67877",
      "closedAt": "2021-08-19T21:11:06Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "This PR seems like all down-side to me.  On the one hand, it's not clear what benefit there is to maintaining distinct identities in the credential.  On the other hand, it seems like there are cases where it is desirable to have multiple appearances of the same identity, for example, multiple devices owned by the same user.  \r\n\r\nIf the application wants to implement \"remove a user\" functionality, then they just need to iterate over all instances of that user in the tree.  If the application needs to individual device identifiers, it can choose to encode these in the credential or use an extension to provide a separate device identifier.\r\n\r\nSo I would be inclined to close this PR with no action.",
          "createdAt": "2020-11-18T12:51:11Z",
          "updatedAt": "2020-11-18T12:51:54Z"
        },
        {
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The benefit would be that group members are not solely identified by their leaf index. I understand if that's not motivation enough.\r\n\r\nHowever, the spec currently says\r\n\r\n> If there are multiple Add proposals for the same client, the committer again chooses one to include and considers the rest invalid.\r\n\r\n\"Client\" is a bit tricky if we don't define it via the identity. It's defined as an entity that is defined by the key material it holds.  But how to detect if a client is added multiple times? We could try checking if it's the same key package, but if that party uses the same identity for all their devices/clients then it might well be the same, because it's down to the key package of last resort. Or are we assuming that clients will always use different key packages? Or is that something where we leave the check to the application layer? That point should be either a bit more specific or removed entirely.\r\n\r\n>  If the application needs to individual device identifiers, it can choose to encode these in the credential or use an extension to provide a separate device identifier.\r\n\r\nWhy wouldn't that then be part of the `identity`? The only place we really do anything with the `identity` is currently the fact that it can't change with an update.",
          "createdAt": "2020-11-18T15:02:45Z",
          "updatedAt": "2020-11-18T15:02:45Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "> The benefit would be that group members are not solely identified by their leaf index. I understand if that's not motivation enough.\r\n\r\nYeah, I don't see why I would care about this.  The leaf index is clear and unambiguous for intra-MLS usage, and applications can use the rest of the KeyPackage to decide which leaves to remove.\r\n\r\nAgree that we should fix that spec text.  IMO the right answer is to make clear that it's up to the application to decide when two KeyPackages represent the same client.\r\n\r\n> Why wouldn't that then be part of the identity?\r\n\r\nThere are circumstances where `credential.identity` might be constrained so that it can't hold all the information you want.  For example, if you were using X509Credentials from a CA that certified email addresses, then all instances of a user with a given email address would have the same `credential.identity` (the email address).  You would need something else to distinguish different instances/devices of the same user, probably a KeyPackage extension.\r\n",
          "createdAt": "2020-11-20T19:37:12Z",
          "updatedAt": "2020-11-20T19:37:12Z"
        },
        {
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I see your point. I'll close this, then.",
          "createdAt": "2020-11-23T06:57:51Z",
          "updatedAt": "2020-11-23T06:57:51Z"
        },
        {
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "In light of the discussion on the mailing list regarding the improvement of client authentication, I'm reopening this PR. I've updated this PR to include both identities and signature keys.",
          "createdAt": "2021-01-20T12:31:40Z",
          "updatedAt": "2021-01-20T12:31:40Z"
        },
        {
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "body": "This looks almost good! I think it's missing the rule that Commits MUST be rejected if they contain identities that are not unique.",
          "createdAt": "2021-03-02T14:53:50Z",
          "updatedAt": "2021-03-02T14:53:50Z"
        },
        {
          "author": "seanturner",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Discussed at 20210526 Interim. Look to merge.",
          "createdAt": "2021-05-26T15:32:59Z",
          "updatedAt": "2021-05-26T15:32:59Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Replaced by #476 ",
          "createdAt": "2021-08-19T21:11:06Z",
          "updatedAt": "2021-08-19T21:11:06Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTMyMTcwODQ5",
          "commit": {
            "abbreviatedOid": "eb854af"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2020-11-17T09:27:53Z",
          "updatedAt": "2020-11-17T09:31:50Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "should -> SHOULD",
              "createdAt": "2020-11-17T09:27:53Z",
              "updatedAt": "2021-03-04T08:22:02Z"
            },
            {
              "originalPosition": 22,
              "body": "\"If there are multiple Add proposals of KeyPackages with the same identity\"",
              "createdAt": "2020-11-17T09:30:07Z",
              "updatedAt": "2021-03-04T08:22:02Z"
            },
            {
              "originalPosition": 24,
              "body": "\"if there are Add proposals of KeyPackages with an identity that is already present\"",
              "createdAt": "2020-11-17T09:31:30Z",
              "updatedAt": "2021-03-04T08:22:02Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTMyMTc2NDYw",
          "commit": {
            "abbreviatedOid": "eb854af"
          },
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-11-17T09:34:17Z",
          "updatedAt": "2020-11-17T09:34:17Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "I thought those capitalized SHOULDs, MUSTs, etc are only used for actual instructions. I use it later on in cases where I describe what the committer SHOULD do. I'm happy to change it here, as well, though.",
              "createdAt": "2020-11-17T09:34:17Z",
              "updatedAt": "2021-03-04T08:22:02Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTcyMTkxMTMz",
          "commit": {
            "abbreviatedOid": "0d90b8d"
          },
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-01-20T12:55:15Z",
          "updatedAt": "2021-01-20T12:55:15Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzI2OTI0OTM1",
          "commit": {
            "abbreviatedOid": "4d6dde9"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2021-08-10T23:31:33Z",
          "updatedAt": "2021-08-10T23:31:43Z",
          "comments": [
            {
              "originalPosition": 26,
              "body": "I still object to this requirement, on the same grounds as before.  Namely, multi-device cases will result in multiple appearances of the same identity with high probability.\r\n\r\nI thought we had agreed to make the prohibition on duplication of signature keys.  If that's the case, then let's make that change and merge.",
              "createdAt": "2021-08-10T23:31:33Z",
              "updatedAt": "2021-08-10T23:31:43Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzI3MDc1Mzk0",
          "commit": {
            "abbreviatedOid": "4d6dde9"
          },
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-08-11T05:51:10Z",
          "updatedAt": "2021-08-11T05:51:11Z",
          "comments": [
            {
              "originalPosition": 26,
              "body": "Is there a particular reason why you wouldn't want to use different identities for the devices? They will have to be distinguished at some point. Even if you use X509 certificates, you could still use the fingerprint as identity.\r\n\r\nThis change would allow us to address group members by their identity as opposed to their leaf index, which makes for a more intuitive API and allows us to hide the fact that we're using a tree underneath.\r\n\r\n(Updated the PR description to reflect this rationale.)",
              "createdAt": "2021-08-11T05:51:11Z",
              "updatedAt": "2021-08-11T05:53:50Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzI3ODc1MTE2",
          "commit": {
            "abbreviatedOid": "4d6dde9"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-08-11T19:37:36Z",
          "updatedAt": "2021-08-11T19:37:36Z",
          "comments": [
            {
              "originalPosition": 26,
              "body": "Well, if you define \"identity\" in the right way, sure :)  \r\n\r\nPart of the challenge here is that we don't really have a well-defined notion of \"identity\" on which to hang requirements such as these.  And I would argue that we should not have such a notion at this level -- it's up to the application to define how the credentials in MLS are used to authenticate application-level identities.  \"Identity\" is also a bad API concept, because you're going to have different cases; think \"remove this specific device\" vs. \"remove all participants with this phone number\".\r\n\r\nYour X.509 example seems like it points back to my suggestion of focusing this on signature keys.  Aside from serial numbers, public keys are the major reason that two certificates would be different.",
              "createdAt": "2021-08-11T19:37:36Z",
              "updatedAt": "2021-08-11T19:37:36Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzI4MjIzMjA3",
          "commit": {
            "abbreviatedOid": "4d6dde9"
          },
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-08-12T06:29:45Z",
          "updatedAt": "2021-08-12T06:29:45Z",
          "comments": [
            {
              "originalPosition": 26,
              "body": "I'm less concerned about concrete API schemes, and more about the fact that we can't abstract the tree away.\r\n\r\nI see that signature keys would allow us to hide the tree under an abstraction. However, signature keys of a given client, even if they are unique, (potentially) change over the time of that client's group membership, so if we used that to address individual group members, we would have to have an additional mapping that keeps track of changing signature keys, which is not ideal.\r\n\r\n(I realize now that that means that my fingerprint example wouldn't work, either.)\r\n\r\nYou are right in that we should probably talk a bit about what \"identity\" really means in the context of MLS. As you said, it's the job of the application layer to verify credentials, so what is verified by the AS could be something more than the `identity` field that the spec currently requires. Looking at it from that angle: does the `identity` field currently serve any purpose in the spec other than that it's verified as part of the credential and that it doesn't change through updates?\r\n\r\nIf that is not the case, we could require the identity field to be something unique, while leaving other fields in the credential (that MLS doesn't have to know about) as the \"user-facing\" identity, which (also) gets verified by the AS as part of the credential and which the user can base their for authentication decision on. Thus, for MLS, the `identity` field, would be mostly administrative.",
              "createdAt": "2021-08-12T06:29:45Z",
              "updatedAt": "2021-08-12T06:29:45Z"
            }
          ]
        }
      ]
    },
    {
      "number": 441,
      "id": "MDExOlB1bGxSZXF1ZXN0NTI0MTQwMjQ4",
      "title": "remove references to nonexistent key_package field in Commit message",
      "url": "https://github.com/mlswg/mls-protocol/pull/441",
      "state": "MERGED",
      "author": "uhoreg",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "It looks like `key_package`  in Commit was moved to `leaf_key_package` in UpdatePath, but some docs didn't get updated.",
      "createdAt": "2020-11-19T18:11:29Z",
      "updatedAt": "2020-11-20T17:35:12Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "57bb2954265c57896249dcb2bbb04788205fb466",
      "headRepository": "uhoreg/mls-protocol",
      "headRefName": "no_key_package_in_commit",
      "headRefOid": "92246be0634bac1d1ff37a09bb3bee3fc40e04c4",
      "closedAt": "2020-11-20T17:35:12Z",
      "mergedAt": "2020-11-20T17:35:12Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "a3b424e8ae7440052f0c1fe5f7fbf15fc93230aa"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM1NjM4MDU2",
          "commit": {
            "abbreviatedOid": "92246be"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-11-20T17:35:06Z",
          "updatedAt": "2020-11-20T17:35:06Z",
          "comments": []
        }
      ]
    },
    {
      "number": 442,
      "id": "MDExOlB1bGxSZXF1ZXN0NTI1MTg1NTg4",
      "title": "Add an \"AppAck\" proposal",
      "url": "https://github.com/mlswg/mls-protocol/pull/442",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "We had longstanding issue #160 to allow the participants in an MLS group to detect when the DS drops messages.  That issue was closed because it had been open for a long time without a concrete proposed solution.  More recently, however, @raphaelrobert and @beurdouche suggested using a Proposal for this, and it made a lot of sense to me when I looked into the details.  So this PR should be considere joint work between, @raphaelrobert, @beurdouche, and me.\r\n\r\nThis PR adds an `AppAck` Proposal that any member of the group can send to advertise the last generation it sent, and acknowledge the receipt of application messages from other members.  As a Proposal, it is included in the transcript via Commits, providing a pretty strong defence against message suppression -- the DS basically has to stop the group progressing at all if it wants to drop applications without the group being aware of it.",
      "createdAt": "2020-11-21T20:26:19Z",
      "updatedAt": "2020-12-14T15:56:40Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "9afdd386ecaf391a948ec3e0de79991a683c89fc",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "appack",
      "headRefOid": "747a96d5a460537c389ce1c7a2b62c6dc2ece328",
      "closedAt": "2020-12-14T15:56:40Z",
      "mergedAt": "2020-12-14T15:56:40Z",
      "mergedBy": "raphaelrobert",
      "mergeCommit": {
        "oid": "12beb366b68d59d6b7e41699915c4f03ce776e70"
      },
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "BTW, there are a *bunch* of ways to go about [expressing what a member did and did not receive](https://en.wikipedia.org/wiki/Acknowledgement_(data_networks)).  Most of these schemes are designed for 1:1 connections like TCP or QUIC, but adapt in a straightforward way to groups.  Which one is most efficient depends on what you assume about losses.  Some examples:\r\n\r\n1. List of received messages (the most na\u00efve approach; efficient only if losses dominate)\r\n2. List of received message ranges (implemented here, more efficient for infrequent losses)\r\n3. Highest received generation, plus list of generations not received (more efficient for even more infrequent losses)\r\n\r\nFWIW, scheme (2) is effectively [what QUIC does](https://tools.ietf.org/html/draft-ietf-quic-transport-32#section-19.3).  TCP does something like (3), but because it is synchronous, doesn't include generations not received.  The [\"selective acknowledgement\"](https://tools.ietf.org/html/rfc2018#section-3) option for TCP is basically the same as option (2), reporting ranges of received packets.",
          "createdAt": "2020-11-21T20:39:25Z",
          "updatedAt": "2020-11-21T20:39:25Z"
        },
        {
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Great idea! Two comments:\r\n\r\nTo make sure that the DS doesn't drop any Commit that has an AppAck extension (to cover up their dropping of Application messages), either one has to encrypt Commit messages or AppAcks need to be mandatory for Commits by policy. Otherwise the DS can just drop any Commit that has an AppAck in it (without impeding the sending of messages in the group).\r\n\r\nA cheaper, although functionally less powerful version would be to simply send a hash of the SecretTree. The other group members would then know if they received the same messages as the sender (but not more than that).",
          "createdAt": "2020-11-23T07:05:11Z",
          "updatedAt": "2020-11-23T07:05:11Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "@kkohbrok good point about addressing suppression of AppAck itself.  I added a paragraph. \r\n\r\nSending a hash of the SecretTree seems both less powerful and way more complicated, since we would have to define a hashing scheme.  So I'm gonna pass :)",
          "createdAt": "2020-12-12T20:16:12Z",
          "updatedAt": "2020-12-12T20:16:12Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM2MDA3NTM4",
          "commit": {
            "abbreviatedOid": "81c99ef"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-11-21T20:42:18Z",
          "updatedAt": "2020-11-21T20:42:18Z",
          "comments": []
        }
      ]
    },
    {
      "number": 444,
      "id": "MDExOlB1bGxSZXF1ZXN0NTI1MzcwNDE5",
      "title": "Fix typo",
      "url": "https://github.com/mlswg/mls-protocol/pull/444",
      "state": "MERGED",
      "author": "Bren2010",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-11-22T22:46:18Z",
      "updatedAt": "2020-11-23T07:57:24Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "9afdd386ecaf391a948ec3e0de79991a683c89fc",
      "headRepository": "Bren2010/mls-protocol",
      "headRefName": "brendan/asdf1",
      "headRefOid": "01ca54faa9527cd0281937835bbb50a9d5a2f9b8",
      "closedAt": "2020-11-23T07:57:14Z",
      "mergedAt": "2020-11-23T07:57:14Z",
      "mergedBy": "beurdouche",
      "mergeCommit": {
        "oid": "b3e4c00084d254ce2c127da8fafe762f6f4ad4ba"
      },
      "comments": [
        {
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "body": "Thanks !",
          "createdAt": "2020-11-23T07:57:24Z",
          "updatedAt": "2020-11-23T07:57:24Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 445,
      "id": "MDExOlB1bGxSZXF1ZXN0NTI1NzE4NDAw",
      "title": "Fix typo Derive-Secret",
      "url": "https://github.com/mlswg/mls-protocol/pull/445",
      "state": "MERGED",
      "author": "franziskuskiefer",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "There's only `DeriveSecret`.",
      "createdAt": "2020-11-23T13:06:43Z",
      "updatedAt": "2020-11-23T13:54:50Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "b3e4c00084d254ce2c127da8fafe762f6f4ad4ba",
      "headRepository": "franziskuskiefer/mls-protocol",
      "headRefName": "patch-2",
      "headRefOid": "929e4bd120e2e38e298357655530580697aab84b",
      "closedAt": "2020-11-23T13:54:43Z",
      "mergedAt": "2020-11-23T13:54:43Z",
      "mergedBy": "beurdouche",
      "mergeCommit": {
        "oid": "6603c78258a5376e8132ceafb1ba8af27a406841"
      },
      "comments": [
        {
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "body": "Thanks!",
          "createdAt": "2020-11-23T13:54:50Z",
          "updatedAt": "2020-11-23T13:54:50Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 446,
      "id": "MDExOlB1bGxSZXF1ZXN0NTI4OTM5ODc3",
      "title": "Move joiner_secret to the end of the first KDF cycle in the Key Schedule",
      "url": "https://github.com/mlswg/mls-protocol/pull/446",
      "state": "MERGED",
      "author": "ericcornelissen",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "This is a small suggestion to move the definition of the `joiner_secret` to the\r\nend of the first Extract-Expand (KDF) cycle of the [key schedule]. This makes\r\nmore sense from a cryptographic perspective as we would not be using anything\r\nfrom the middle of a KDF cycle.\r\n\r\nA related suggestion is to remove the `member_secret` from the document. I\r\nremoved it from the key schedule, removed all the mentions to forget it as soon\r\nas possible and updated the description of deriving the `welcome_key` and\r\n`welcome_nonce` from the [welcoming new members] section.\r\n\r\n[key schedule]: https://github.com/mlswg/mls-protocol/blob/master/draft-ietf-mls-protocol.md#key-schedule\r\n[welcoming new members]: https://github.com/mlswg/mls-protocol/blob/master/draft-ietf-mls-protocol.md#welcoming-new-members\r\n",
      "createdAt": "2020-11-28T12:11:18Z",
      "updatedAt": "2020-12-12T21:02:05Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "6603c78258a5376e8132ceafb1ba8af27a406841",
      "headRepository": null,
      "headRefName": "move-joiner-secret",
      "headRefOid": "f83984b73b5479e6a6f258e2144e24ed4c84a0ca",
      "closedAt": "2020-12-12T20:04:38Z",
      "mergedAt": "2020-12-12T20:04:38Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "11d344041f9933998a1a4506d980872165990e7c"
      },
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks for the quick fix, @ericcornelissen !",
          "createdAt": "2020-12-12T20:04:33Z",
          "updatedAt": "2020-12-12T20:04:33Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTUwNTkxODY1",
          "commit": {
            "abbreviatedOid": "31bee95"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-12-11T21:32:58Z",
          "updatedAt": "2020-12-11T21:33:02Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "Nit: Either this should be `member` or the label above should be `joiner`",
              "createdAt": "2020-12-11T21:32:58Z",
              "updatedAt": "2020-12-12T11:25:32Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTUwNzEyMjU0",
          "commit": {
            "abbreviatedOid": "f83984b"
          },
          "author": "ericcornelissen",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-12-12T11:26:34Z",
          "updatedAt": "2020-12-12T11:26:34Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "Changed it to `joiner` as I think calling this the _\"joiner_secret\"_ makes more sense, but would be happy to do the change the other way as well.",
              "createdAt": "2020-12-12T11:26:34Z",
              "updatedAt": "2020-12-12T11:26:34Z"
            }
          ]
        }
      ]
    },
    {
      "number": 449,
      "id": "MDExOlB1bGxSZXF1ZXN0NTQxMjAzNTY0",
      "title": "Pin HPKE to -07.",
      "url": "https://github.com/mlswg/mls-protocol/pull/449",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "cc @bifurcation ",
      "createdAt": "2020-12-16T14:27:09Z",
      "updatedAt": "2020-12-16T15:30:01Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "12beb366b68d59d6b7e41699915c4f03ce776e70",
      "headRepository": "chris-wood/mls-protocol",
      "headRefName": "caw/pin-hpke",
      "headRefOid": "b5001529319dae841d0d33225641f03698dcdbc8",
      "closedAt": "2020-12-16T14:37:04Z",
      "mergedAt": "2020-12-16T14:37:04Z",
      "mergedBy": "beurdouche",
      "mergeCommit": {
        "oid": "5cedaf1ec905e046b86f057499f01a0259829278"
      },
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "NONE",
          "body": "@beurdouche is the build expected to fail?",
          "createdAt": "2020-12-16T14:34:49Z",
          "updatedAt": "2020-12-16T14:34:49Z"
        },
        {
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "body": "No, but the problem seem unrelated to your change, so we are all good.",
          "createdAt": "2020-12-16T14:36:27Z",
          "updatedAt": "2020-12-16T14:36:27Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Looks like it was a transient failure.  Re-running resulted in success.",
          "createdAt": "2020-12-16T15:30:01Z",
          "updatedAt": "2020-12-16T15:30:01Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTUzNzM4Mzc4",
          "commit": {
            "abbreviatedOid": "b500152"
          },
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-12-16T14:28:10Z",
          "updatedAt": "2020-12-16T14:28:10Z",
          "comments": []
        }
      ]
    },
    {
      "number": 450,
      "id": "MDExOlB1bGxSZXF1ZXN0NTQyMTc1MzEz",
      "title": "Editorial changes",
      "url": "https://github.com/mlswg/mls-protocol/pull/450",
      "state": "MERGED",
      "author": "uhoreg",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "- use `AEAD.Nh` and `AEAD.Nk` instead of `nonce_length` and `key_length`, for consistency with the rest of the spec\r\n- the key and nonce are now derived from the `joiner_secret` rather than randomly chosen",
      "createdAt": "2020-12-17T22:36:27Z",
      "updatedAt": "2020-12-18T16:48:06Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "5cedaf1ec905e046b86f057499f01a0259829278",
      "headRepository": "uhoreg/mls-protocol",
      "headRefName": "misc_fixes2",
      "headRefOid": "e68eeeeda1068d095683f0cdf930f72077282cd7",
      "closedAt": "2020-12-18T16:48:06Z",
      "mergedAt": "2020-12-18T16:48:06Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "6e4582881c931edb59e31508c8d45467c14bb646"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU1NjQ5MjI3",
          "commit": {
            "abbreviatedOid": "e68eeee"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-12-18T16:47:58Z",
          "updatedAt": "2020-12-18T16:47:58Z",
          "comments": []
        }
      ]
    },
    {
      "number": 451,
      "id": "MDExOlB1bGxSZXF1ZXN0NTQzNzQ2OTI3",
      "title": "Remove contradictory initialization of transcript hashes",
      "url": "https://github.com/mlswg/mls-protocol/pull/451",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "While reviewing #436, I noticed that in one place, we define the initial `interim_transcript_hash` to be the all-zero vector, and in another, we define it to be the empty octet string.  In keeping with the idea of starting chained hashes with the empty octet string, this PR normalizes on the empty octet string for the transcript hashes as well.",
      "createdAt": "2020-12-21T21:59:08Z",
      "updatedAt": "2020-12-22T13:42:37Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "10df4266e4733134decdcc6cfa80f2d480674261",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "zero-length",
      "headRefOid": "a353055a246062a969593c9c9af17ba05d7bab41",
      "closedAt": "2020-12-22T13:42:37Z",
      "mergedAt": "2020-12-22T13:42:37Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "1f8c8b17ef8679b444302adb8f605f15f3938557"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU2NzMwNjUz",
          "commit": {
            "abbreviatedOid": "a353055"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-12-21T23:41:37Z",
          "updatedAt": "2020-12-21T23:41:37Z",
          "comments": []
        }
      ]
    },
    {
      "number": 452,
      "id": "MDExOlB1bGxSZXF1ZXN0NTQ0MTk5MDE1",
      "title": "Add changelog for draft-11",
      "url": "https://github.com/mlswg/mls-protocol/pull/452",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Immediately after I published draft-11, @raphaelrobert noticed that I had failed to update the change log.  This PR adds it to the editor's copy, so that it will be included in future versions.",
      "createdAt": "2020-12-22T15:37:57Z",
      "updatedAt": "2020-12-22T15:39:16Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "1f8c8b17ef8679b444302adb8f605f15f3938557",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "changelog-11",
      "headRefOid": "b807592899cc088cc41a44c7e00114b0e0985e74",
      "closedAt": "2020-12-22T15:39:16Z",
      "mergedAt": "2020-12-22T15:39:16Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "96efaf0633b2d0e861f06f4ba489c6193dea6052"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU3MTcwMDc2",
          "commit": {
            "abbreviatedOid": "b807592"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-12-22T15:38:37Z",
          "updatedAt": "2020-12-22T15:38:37Z",
          "comments": []
        }
      ]
    },
    {
      "number": 453,
      "id": "MDExOlB1bGxSZXF1ZXN0NTQ3MzUzMDE2",
      "title": "Use the GroupContext to derive the joiner_secret",
      "url": "https://github.com/mlswg/mls-protocol/pull/453",
      "state": "MERGED",
      "author": "ericcornelissen",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "This is a proposal to change how the `joiner_secret` is derived. Before, it was derived simply by derivation with a label. This Pull Request updates this step to include the GroupContext, similar to how the `epoch_secret` is derived. Including the GroupContext will give stronger uniqueness guarantees on the `joiner_secret` cryptographically speaking. I think the GroupContext in the derivation of the `epoch_secret` should be kept as it proves that joiners have learned the GroupContext through the Welcome message as well.",
      "createdAt": "2020-12-31T12:59:41Z",
      "updatedAt": "2021-08-19T21:17:59Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "96efaf0633b2d0e861f06f4ba489c6193dea6052",
      "headRepository": null,
      "headRefName": "context-for-joiner_secret",
      "headRefOid": "522a3d7d604a13b6338b4d41b376e4d6370e70a6",
      "closedAt": "2021-08-19T21:08:37Z",
      "mergedAt": "2021-08-19T21:08:37Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "a89ebee622ce3dcd44fe220d3313cf101baaaa01"
      },
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "I have a couple of problems with this PR:\r\n\r\n> I think the GroupContext in the derivation of the epoch_secret should be kept as it proves that joiners have learned the GroupContext through the Welcome message as well.\r\n\r\nI don't see how this follows -- joiners are told the `joiner_secret` directly in the GroupSecrets message, they don't compute it themselves.  (It's also doesn't prove anything useful about the existing members, since their knowledge of the `init_secret` proves that they knew the GroupContext for the last epoch.)  If you wanted this property, you would have to instead send the output of `KDF.Extract` in GroupSecrets.\r\n\r\nBut there's a bigger problem here: This would create a circular dependency.  The joiner doesn't know the group context until they decrypt the Welcome message, which they do with the `welcome_secret`.  So you can't inject anything about the GroupContext in between the thing you hand to the joiner and the `welcome_secret`.\r\n\r\nIn other words, the injection of GroupContext is already done as early as it can be.  So we should close this PR",
          "createdAt": "2021-03-08T00:36:59Z",
          "updatedAt": "2021-03-08T00:36:59Z"
        },
        {
          "author": "ericcornelissen",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> I don't see how this follows -- joiners are told the joiner_secret directly in the GroupSecrets message, they don't compute it themselves.\r\n\r\nApologies for the confusion but that is not quite what I intended to say. Yes, joiners are told the `joiner_secret`, so what I meant to say is this: as joiners provided with the `joiner_secret` directly they don't need to use the `GroupContext` in the first `ExpandWithLabel` call, hence the `GroupContext` should be **kept** in the second `ExpandWithLabel` call.\r\n\r\n\r\n> It's also doesn't prove anything useful about the existing members, since their knowledge of the init_secret proves that they knew the GroupContext for the last epoch.\r\n\r\nI (intuitively) agree with that, but as per the Pull Request description: I added the `GroupContext` in the first `ExpandWithLabel` call for stronger uniqueness guarantees on the `joiner_secret` only.\r\n\r\n\r\n\r\n> But there's a bigger problem here: This would create a circular dependency. The joiner doesn't know the group context until they decrypt the Welcome message, which they do with the welcome_secret. So you can't inject anything about the GroupContext in between the thing you hand to the joiner and the welcome_secret.\r\n\r\nI'm not sure if I follow, I'm not proposing we change anything about how joiners are added to the group, they would still receive the `joiner_secret` as they do now. Therefore I'm not injecting anything about the `GroupContext` in between the thing we hand to the joiner (i.e. the `joiner_secret`) and the `welcome_secret`.\r\n\r\nAgain, my apologies if the Pull Request description wasn't clear. The change I'm proposing is primarily for uniqueness guarantees on the `joiner_secret`. I included the last sentence of the Pull Request description only as a motivation for keeping the `GroupContext` in the second `ExpandWithLabel` call.",
          "createdAt": "2021-03-08T11:56:19Z",
          "updatedAt": "2021-03-08T11:56:19Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks for clarifying @ericcornelissen.  Good that we agree w.r.t. joiners.  If we're not aiming at that, then this seems pretty innocuous to me.  Would it be correct to say that this ensures that parties that don't agree on the GroupContext diverge as soon as possible?\r\n\r\nI'm not sure I see a ton of value in that, since the `joiner_secret` is only used ephemerally by existing members -- for them, the meaningful transition is `init_secret + commit_secret + psk_secret -> epoch_secret`, and that already includes the GroupContext.\r\n\r\nThat said, as long as we're not trying to address joiners, this seems innocuous, so if others are keen, I can go along with it.",
          "createdAt": "2021-03-08T12:39:51Z",
          "updatedAt": "2021-03-08T12:39:51Z"
        },
        {
          "author": "ericcornelissen",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> Would it be correct to say that this ensures that parties that don't agree on the GroupContext diverge as soon as possible?\r\n\r\nThat is correct, but not the only way of looking at it as per the below.\r\n\r\n\r\n> I'm not sure I see a ton of value in that, since the `joiner_secret` is only used ephemerally by existing members -- for them, the meaningful transition is `init_secret + commit_secret + psk_secret -> epoch_secret`, and that already includes the GroupContext.\r\n\r\nPractically speaking I would (intuitively) agree. That said, if a collision on the `joiner_secret` where to happen (and no PSK is used) everything up to and including the `welcome_secret` would collide and since the `GroupSecrets` are encrypted with keys derived (deterministically) from the `welcome_secret`, a collision _would_ be a problem.\r\n\r\nNamely, in a cryptographic analysis this would mean that the adversary may know a `welcome_secret` that it is not supposed to know. In a game-based setting, the adversary can first derive a (malicious) `welcome_secret` that they know, and than a colliding one they're not supposed to know. If I recall correctly, this \"problematic scenario\" may result from the fact that the `commit_secret` is not chained between epochs (a feature like https://mailarchive.ietf.org/arch/msg/mls/ZR84smU5xeLrziNTk5W1P1Z1nQI/ would likely give the same level of uniqueness to the `joiner_secret`, but this Pull Request is a far simpler solution for this particular problem).",
          "createdAt": "2021-03-08T14:22:05Z",
          "updatedAt": "2021-03-08T14:22:05Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks for the explanation, @ericcornelissen.  Makes sense to me.",
          "createdAt": "2021-03-08T14:29:22Z",
          "updatedAt": "2021-03-08T14:29:22Z"
        },
        {
          "author": "seanturner",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Discussed at 20210526 Interim. No downsides noted at this point. @kkohbrok agreed to review and provide any additional input.",
          "createdAt": "2021-05-26T15:35:35Z",
          "updatedAt": "2021-05-26T15:35:35Z"
        },
        {
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "All the info was really already provided by @ericcornelissen in the conversation above. I'll summarize:\r\n\r\nUpsides of merging: The `joiner_secret` will enjoy better uniqueness guarantees, because the added context leads to it being _unique per group_. This improved uniqueness is also enjoyed by the derived `welcome_secret`.\r\n\r\nDownsides of merging: None. The `group_context` has to be used in the derivation of the `joiner_secret`, but it's the same amount of `HMAC` operations and the `group_context` has to be serialized anyway for the derivation of the `epoch_secret`.",
          "createdAt": "2021-08-10T12:06:20Z",
          "updatedAt": "2021-08-10T12:06:20Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTYwODg4Nzkw",
          "commit": {
            "abbreviatedOid": "522a3d7"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-01-04T09:36:36Z",
          "updatedAt": "2021-01-04T09:36:36Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTYxMzMyNjk1",
          "commit": {
            "abbreviatedOid": "522a3d7"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-01-04T20:46:29Z",
          "updatedAt": "2021-01-04T20:46:29Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzI2OTIzMDA3",
          "commit": {
            "abbreviatedOid": "522a3d7"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "One note I'll leave here for posterity: I briefly thought that because we are now injecting the GroupContext into the `joiner_secret`, we could remove the context from the `epoch_secret` derivation.  However, including the context there confirms that the joiner computed the same GroupContext as the Welcome sender, so it's important to keep it.",
          "createdAt": "2021-08-10T23:27:02Z",
          "updatedAt": "2021-08-10T23:27:02Z",
          "comments": []
        }
      ]
    },
    {
      "number": 454,
      "id": "MDExOlB1bGxSZXF1ZXN0NTU5NjAyMjMz",
      "title": "more editorial changes",
      "url": "https://github.com/mlswg/mls-protocol/pull/454",
      "state": "MERGED",
      "author": "uhoreg",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "- add the missing `authenticated_data` field to `MLSPlaintextCommitContent`\r\n- the sections for the `Commit` sender and `Commit` receiver seem to have gotten out of sync.  I tried to sync them up (but let me know if I messed something up)\r\n- fix a typo",
      "createdAt": "2021-01-21T23:21:53Z",
      "updatedAt": "2021-10-04T14:29:43Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "05fe1daacd66006f600869f6bc05bc9efb1530ed",
      "headRepository": "uhoreg/mls-protocol",
      "headRefName": "editorial-changes-2021-01-21",
      "headRefOid": "a352fa19217e237df27865a0f604ce29ea62eecf",
      "closedAt": "2021-10-04T14:29:43Z",
      "mergedAt": "2021-10-04T14:29:43Z",
      "mergedBy": "raphaelrobert",
      "mergeCommit": {
        "oid": "cb45ce3654b04596f740f5d74bb4f1cdf0f611fe"
      },
      "comments": [
        {
          "author": "uhoreg",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I've tried to align with the current mlspp code for how to process commits.  If the current mlspp code is incorrect, or if I'm reading it incorrectly, I'm more than happy to fix my changes to reflect the correct behaviour.",
          "createdAt": "2021-03-26T22:37:38Z",
          "updatedAt": "2021-03-26T22:37:38Z"
        },
        {
          "author": "seanturner",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@bifurcation @raphaelrobert took action item to review editorial changes.",
          "createdAt": "2021-05-26T15:38:25Z",
          "updatedAt": "2021-05-26T15:38:25Z"
        },
        {
          "author": "uhoreg",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think I've addressed all the comments.  I also realized that the calculation of the new GroupContext was in the wrong spot (it has to be done after the MLSPlaintext is created (sans confirmation_tag), and then the confirmed transcript hash is created, then the new GroupContext, then the secrets, then the confirmation tag -- that's what mlspp does AFAICT), so I've fixed that up as well.",
          "createdAt": "2021-08-12T03:49:16Z",
          "updatedAt": "2021-08-12T03:49:16Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "@raphaelrobert I think if you're OK with this, we're clear to merge.",
          "createdAt": "2021-08-19T21:07:36Z",
          "updatedAt": "2021-08-19T21:07:36Z"
        },
        {
          "author": "seanturner",
          "authorAssociation": "CONTRIBUTOR",
          "body": "As discussed at interim. @raphaelrobert review. If good, then merge.",
          "createdAt": "2021-10-04T14:18:43Z",
          "updatedAt": "2021-10-04T14:18:43Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTc1Njc0OTYz",
          "commit": {
            "abbreviatedOid": "1b4b1c6"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-01-25T18:12:06Z",
          "updatedAt": "2021-01-25T18:15:09Z",
          "comments": [
            {
              "originalPosition": 19,
              "body": "You say use the provisional GroupContext, but the original text says to use the original GroupContext",
              "createdAt": "2021-01-25T18:12:07Z",
              "updatedAt": "2021-03-26T22:30:46Z"
            },
            {
              "originalPosition": 40,
              "body": "Again, mixing epochs seems bad",
              "createdAt": "2021-01-25T18:13:27Z",
              "updatedAt": "2021-03-26T22:30:46Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTc1NjkxNzk5",
          "commit": {
            "abbreviatedOid": "1b4b1c6"
          },
          "author": "uhoreg",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-01-25T18:30:50Z",
          "updatedAt": "2021-01-25T18:30:50Z",
          "comments": [
            {
              "originalPosition": 19,
              "body": "The \"A member of the group applies a Commit message by taking the following steps:\" section says\r\n\r\n> * If the `path` value is populated: Process the `path` value using the new ratchet tree and the provisional GroupContext, to update the ratchet tree and generate the `commit_secret`:\r\n\r\nSo this change is to make the two sections consistent",
              "createdAt": "2021-01-25T18:30:50Z",
              "updatedAt": "2021-03-26T22:30:46Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTc1Njk0NzUz",
          "commit": {
            "abbreviatedOid": "1b4b1c6"
          },
          "author": "uhoreg",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-01-25T18:33:34Z",
          "updatedAt": "2021-01-25T18:33:34Z",
          "comments": [
            {
              "originalPosition": 40,
              "body": "This is how it works in the \"A member of the group applies a Commit message by taking the following steps:\" section.  It verifies the signature before doing any modifications, and uses the `confirmation_key` from the new epoch.",
              "createdAt": "2021-01-25T18:33:34Z",
              "updatedAt": "2021-03-26T22:30:46Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjAxODY5NjE3",
          "commit": {
            "abbreviatedOid": "1b4b1c6"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2021-03-02T14:23:24Z",
          "updatedAt": "2021-03-02T14:48:06Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "The authenticated data is not part of the content of an `MLSPlaintext`, it only exists when `MLSCiphertext` is used",
              "createdAt": "2021-03-02T14:23:25Z",
              "updatedAt": "2021-03-26T22:30:46Z"
            },
            {
              "originalPosition": 19,
              "body": "I agree it looks a bit inconsistent here indeed. I think this part is however the correct one and what you quote is confusing and should be changed instead.\r\nThe reason for my thinking is that the provisional group context is not known at this point in time and therefore the existing one should be used.",
              "createdAt": "2021-03-02T14:34:27Z",
              "updatedAt": "2021-03-26T22:30:46Z"
            },
            {
              "originalPosition": 35,
              "body": "This paragraph explains how the key schedule should be computed, but it omits quite a few steps (joiner secret, welcome secret, etc.) and the values are in the wrong chronologic order.",
              "createdAt": "2021-03-02T14:44:04Z",
              "updatedAt": "2021-03-26T22:30:46Z"
            },
            {
              "originalPosition": 51,
              "body": "See comment from above. I think this part is indeed wrong and the broken syntax might be a hint that it's the result of a copy & pasta job gone wrong.",
              "createdAt": "2021-03-02T14:47:53Z",
              "updatedAt": "2021-03-26T22:30:46Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjA2MzI1Nzg5",
          "commit": {
            "abbreviatedOid": "1b4b1c6"
          },
          "author": "uhoreg",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-08T14:13:06Z",
          "updatedAt": "2021-03-08T14:13:06Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "I don't understand this comment.  `MLSPlaintext` does have an `authenticated_data` field, and the messages that are used here come from a Commit, which is encrypted, it would also use an `MLSCiphertext`.\r\n\r\nAnyways, I had asked @bifurcation about this earlier, and he said that it was accidentally omitted and should be added, which is why I did this.  If it in fact should be omitted, then I can revert the change, but I think that we should either add the field, or else explain why it isn't there because every other field from the beginning of `MLSPlaintext` up to the `signature` field is included.",
              "createdAt": "2021-03-08T14:13:06Z",
              "updatedAt": "2021-03-26T22:30:46Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjA2NDI5MjI3",
          "commit": {
            "abbreviatedOid": "1b4b1c6"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-08T15:46:11Z",
          "updatedAt": "2021-03-08T15:46:11Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "You are absolutely right, apologies for the confusion. The two should be aligned of course.",
              "createdAt": "2021-03-08T15:46:11Z",
              "updatedAt": "2021-03-26T22:30:46Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjIyNTU0MTkw",
          "commit": {
            "abbreviatedOid": "1b4b1c6"
          },
          "author": "uhoreg",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-26T21:47:25Z",
          "updatedAt": "2021-03-26T21:47:26Z",
          "comments": [
            {
              "originalPosition": 19,
              "body": "If I'm reading the mlspp sources right, it looks like it uses the provisional GroupContext for this: https://github.com/cisco/mlspp/blob/main/src/state.cpp#L347-L359\r\n\r\n> The reason for my thinking is that the provisional group context is not known at this point in time and therefore the existing one should be used.\r\n\r\nThe provisional group context is created two steps before this step.\r\n\r\nI personally don't care which one is used, but they should be consistent.  For now, I'm going to follow what mlspp does, but if the consensus is that the original text here is correct, then I'm happy to change it.",
              "createdAt": "2021-03-26T21:47:26Z",
              "updatedAt": "2021-03-26T22:30:46Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjIyNTYyMDAy",
          "commit": {
            "abbreviatedOid": "1b4b1c6"
          },
          "author": "uhoreg",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-26T22:06:12Z",
          "updatedAt": "2021-03-26T22:06:12Z",
          "comments": [
            {
              "originalPosition": 35,
              "body": "This was basically a copy-and-paste from the other section.  I can update both sections to be more accurate.",
              "createdAt": "2021-03-26T22:06:12Z",
              "updatedAt": "2021-03-26T22:30:46Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjIyNTcxNTg0",
          "commit": {
            "abbreviatedOid": "93ff197"
          },
          "author": "uhoreg",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-26T22:32:28Z",
          "updatedAt": "2021-03-26T22:32:28Z",
          "comments": [
            {
              "originalPosition": 59,
              "body": "Alternatively, I can say \"Use the ... and the new GroupContext to advance the key schedule.\"  if we want to be less verbose.",
              "createdAt": "2021-03-26T22:32:28Z",
              "updatedAt": "2021-03-26T22:32:28Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjIyNTcyMzQ5",
          "commit": {
            "abbreviatedOid": "93ff197"
          },
          "author": "uhoreg",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-26T22:34:45Z",
          "updatedAt": "2021-03-26T22:34:45Z",
          "comments": [
            {
              "originalPosition": 61,
              "body": "It looks like DirectPath was renamed to UpdatePath, and the UpdatePath is already applied in a previous step (as part of the step where it's actually created), so this looks to me like an obsolete leftover.",
              "createdAt": "2021-03-26T22:34:45Z",
              "updatedAt": "2021-03-26T22:34:45Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjIyNTcyNzAz",
          "commit": {
            "abbreviatedOid": "93ff197"
          },
          "author": "uhoreg",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-26T22:35:50Z",
          "updatedAt": "2021-03-26T22:35:50Z",
          "comments": [
            {
              "originalPosition": 66,
              "body": "I'm not entirely sure why it takes the `confirmation_key` from the new epoch, but the `membership_key` from the old epoch, but that's what the current mlspp code does.",
              "createdAt": "2021-03-26T22:35:50Z",
              "updatedAt": "2021-03-26T22:35:50Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjIyNjAxNjA3",
          "commit": {
            "abbreviatedOid": "93ff197"
          },
          "author": "uhoreg",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-27T00:44:00Z",
          "updatedAt": "2021-03-27T00:44:01Z",
          "comments": [
            {
              "originalPosition": 66,
              "body": "Oh, actually, I do know, I think.  The `confirmation_tag` allows the other group members to check that they derived the same tree/secrets as the sender.  The `membership_tag` allows other group members to ensure that it was sent by a group member before processing the message.  I think this is mentioned in other parts of the document, but I can reiterate here if necessary.",
              "createdAt": "2021-03-27T00:44:00Z",
              "updatedAt": "2021-03-27T00:44:01Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjY5MTkzMjIx",
          "commit": {
            "abbreviatedOid": "93ff197"
          },
          "author": "seanturner",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-05-26T15:37:40Z",
          "updatedAt": "2021-05-26T15:37:40Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "Discussed at 20210526 Interim. Will split out authenticated_data change to another PR so it can be merged. Editorial changes continue to be reviewed.",
              "createdAt": "2021-05-26T15:37:40Z",
              "updatedAt": "2021-05-26T15:37:40Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzI2OTI4NDEy",
          "commit": {
            "abbreviatedOid": "2f4e8a6"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-08-10T23:39:40Z",
          "updatedAt": "2021-08-10T23:46:44Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "```suggestion\r\nWhen creating or processing a Commit, three different GroupContexts are used:\r\n```",
              "createdAt": "2021-08-10T23:39:40Z",
              "updatedAt": "2021-08-10T23:46:44Z"
            },
            {
              "originalPosition": 19,
              "body": "I think \"provisional\" is the right answer here.  The idea of the GroupContext used with TreeKEM is to capture the tree to which the secrets are encapsulated.  That tree is the one in the provisional GroupContext, to which the proposals have been applied.",
              "createdAt": "2021-08-10T23:43:32Z",
              "updatedAt": "2021-08-10T23:46:44Z"
            },
            {
              "originalPosition": 51,
              "body": "This should be \"provisional\" in both cases -- the tree after applying proposals but before applying the UpdatePath.",
              "createdAt": "2021-08-10T23:46:31Z",
              "updatedAt": "2021-08-10T23:46:44Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzI3ODMwNjY4",
          "commit": {
            "abbreviatedOid": "03a7617"
          },
          "author": "uhoreg",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-08-11T18:52:58Z",
          "updatedAt": "2021-08-11T18:52:58Z",
          "comments": [
            {
              "originalPosition": 51,
              "body": "Uhm, yes.  Obviously it can't be the \"new\" ratchet tree, since this is the step that creates the \"new\" ratchet tree.  Not sure why I put \"new\" there.",
              "createdAt": "2021-08-11T18:52:58Z",
              "updatedAt": "2021-08-11T18:52:58Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzI3ODM0ODE2",
          "commit": {
            "abbreviatedOid": "03a7617"
          },
          "author": "uhoreg",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-08-11T18:57:45Z",
          "updatedAt": "2021-08-11T18:57:46Z",
          "comments": [
            {
              "originalPosition": 35,
              "body": "I think I've addressed this comment",
              "createdAt": "2021-08-11T18:57:45Z",
              "updatedAt": "2021-08-11T18:57:46Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzI3ODM3NTkw",
          "commit": {
            "abbreviatedOid": "03a7617"
          },
          "author": "uhoreg",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-08-11T19:00:58Z",
          "updatedAt": "2021-08-11T19:00:58Z",
          "comments": [
            {
              "originalPosition": 51,
              "body": "Oh, it's because we've only defined \"old\", \"provisional\", and \"new\" for GroupContext, and not for the ratchet tree.  I'll adjust the wording to fix that up.",
              "createdAt": "2021-08-11T19:00:58Z",
              "updatedAt": "2021-08-11T19:00:58Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzM0NDY5MTk5",
          "commit": {
            "abbreviatedOid": "a352fa1"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-08-19T21:07:54Z",
          "updatedAt": "2021-08-19T21:07:54Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOBoyH6c4t12p6",
          "commit": {
            "abbreviatedOid": "a352fa1"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "CHANGES_REQUESTED",
          "body": "One more comment about the 3 ratcheting trees",
          "createdAt": "2021-10-01T15:13:54Z",
          "updatedAt": "2021-10-01T15:19:36Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "I'm still struggling with the fact that there are 3 ratcheting trees. In my mind there are only 2:\r\n - The ratcheting tree *before* applying proposals and the (potential) UpdatePath\r\n - The ratcheting tree *after* applying proposals and the (potential) UpdatePath\r\n\r\nThe ratcheting trees described here as \"provisional\" and \"new\" are in fact identical. It's just that they exist at different times. I think it would be good to make that clear, i.e. a \"provisional\" ratcheting tree becomes a \"new\" ratcheting tree when a Commit is applied.",
              "createdAt": "2021-10-01T15:13:54Z",
              "updatedAt": "2021-10-01T15:19:36Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c4t6k88",
          "commit": {
            "abbreviatedOid": "a352fa1"
          },
          "author": "uhoreg",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-04T13:55:25Z",
          "updatedAt": "2021-10-04T13:55:25Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "The \"provisional\" ratchet tree is the tree after applying the proposals, but before applying the UpdatePath.  We could probably do without a \"provisional\" ratchet tree, but I think it helps with clarity to give it a name since applying the proposals and applying the UpdatePath are different steps.",
              "createdAt": "2021-10-04T13:55:25Z",
              "updatedAt": "2021-10-04T13:55:25Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c4t6rlk",
          "commit": {
            "abbreviatedOid": "a352fa1"
          },
          "author": "seanturner",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-04T14:16:12Z",
          "updatedAt": "2021-10-04T14:16:13Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "Discussed at 20211004 MLS interim.",
              "createdAt": "2021-10-04T14:16:13Z",
              "updatedAt": "2021-10-04T14:16:13Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c4t6s9Y",
          "commit": {
            "abbreviatedOid": "a352fa1"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-04T14:20:24Z",
          "updatedAt": "2021-10-04T14:20:25Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "Fine, that makes sense to me!",
              "createdAt": "2021-10-04T14:20:25Z",
              "updatedAt": "2021-10-04T14:20:25Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c4t6tUd",
          "commit": {
            "abbreviatedOid": "a352fa1"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "Ready to be merged from my side.",
          "createdAt": "2021-10-04T14:21:32Z",
          "updatedAt": "2021-10-04T14:21:32Z",
          "comments": []
        }
      ]
    },
    {
      "number": 455,
      "id": "MDExOlB1bGxSZXF1ZXN0NTcxODM0MDMw",
      "title": "Make PreSharedKeys non optional in GroupSecrets",
      "url": "https://github.com/mlswg/mls-protocol/pull/455",
      "state": "MERGED",
      "author": "raphaelrobert",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Currently the `psks` field in `GroupSecrets` is optional. `PreSharedKeys` only contains an array, which can be empty, even if the option is not empty. To avoid undefined behavior, I removed the option. In case no PSKs are used, the array should simply be empty.",
      "createdAt": "2021-02-11T13:52:59Z",
      "updatedAt": "2021-10-08T22:20:15Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "96efaf0633b2d0e861f06f4ba489c6193dea6052",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "raphaelrobert/optional-group-secrets",
      "headRefOid": "480022ba441d1ee9aacad1f140d402d309839da0",
      "closedAt": "2021-05-26T15:39:57Z",
      "mergedAt": "2021-05-26T15:39:57Z",
      "mergedBy": "raphaelrobert",
      "mergeCommit": {
        "oid": "d1e067f98158342a950f514ea76e13abc357b59c"
      },
      "comments": [
        {
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "body": "I don't think the semantics of what you are suggesting is correct with respect to the TLS syntax. If you want to remove the option then the value has to be something, zeros for example.",
          "createdAt": "2021-02-11T18:12:42Z",
          "updatedAt": "2021-02-11T18:12:42Z"
        },
        {
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "body": "This is not a strong objection though...",
          "createdAt": "2021-02-11T18:16:46Z",
          "updatedAt": "2021-02-11T18:16:46Z"
        },
        {
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "body": "@beurdouche Can you point to the TLS syntax for that one? What I'm concerned about is specifically the UB, there has to be a better way to define this.",
          "createdAt": "2021-03-02T14:19:49Z",
          "updatedAt": "2021-03-02T14:19:49Z"
        },
        {
          "author": "seanturner",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Discussed at 20210526 Interim: As long as there is some input you can have an empty list. No impact on security.",
          "createdAt": "2021-05-26T15:39:37Z",
          "updatedAt": "2021-05-26T15:39:37Z"
        },
        {
          "author": "seanturner",
          "authorAssociation": "CONTRIBUTOR",
          "body": "merge",
          "createdAt": "2021-05-26T15:40:07Z",
          "updatedAt": "2021-05-26T15:40:07Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTg4ODQ0MDc3",
          "commit": {
            "abbreviatedOid": "480022b"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-02-11T18:06:44Z",
          "updatedAt": "2021-02-11T18:06:44Z",
          "comments": []
        }
      ]
    },
    {
      "number": 456,
      "id": "MDExOlB1bGxSZXF1ZXN0NTczODgwODc0",
      "title": "Update name for this particular key",
      "url": "https://github.com/mlswg/mls-protocol/pull/456",
      "state": "MERGED",
      "author": "claucece",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "I think this word was left from previous changes to the name of this particular key..\r\n\r\ncc./ @raphaelrobert @beurdouche ",
      "createdAt": "2021-02-16T02:13:04Z",
      "updatedAt": "2021-02-16T07:04:20Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "96efaf0633b2d0e861f06f4ba489c6193dea6052",
      "headRepository": "claucece/mls-protocol",
      "headRefName": "master",
      "headRefOid": "dc20a145fc7205fcbb119ffda030463c5240f3a4",
      "closedAt": "2021-02-16T07:04:07Z",
      "mergedAt": "2021-02-16T07:04:07Z",
      "mergedBy": "beurdouche",
      "mergeCommit": {
        "oid": "487cb3784da1cd5240918a95ba796bcfff67e3d1"
      },
      "comments": [
        {
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "body": "Thanks Sof\u00eda\r\n!",
          "createdAt": "2021-02-16T07:04:20Z",
          "updatedAt": "2021-02-16T07:04:20Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTkwOTI5NTAx",
          "commit": {
            "abbreviatedOid": "dc20a14"
          },
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-02-16T07:03:09Z",
          "updatedAt": "2021-02-16T07:03:09Z",
          "comments": []
        }
      ]
    },
    {
      "number": 458,
      "id": "MDExOlB1bGxSZXF1ZXN0NTgzMTAzODI3",
      "title": "Fix the protocol overview section",
      "url": "https://github.com/mlswg/mls-protocol/pull/458",
      "state": "MERGED",
      "author": "raphaelrobert",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Fixes #440 (see issue for details).",
      "createdAt": "2021-03-02T15:05:36Z",
      "updatedAt": "2021-10-08T22:20:08Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "487cb3784da1cd5240918a95ba796bcfff67e3d1",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "raphaelrobert/remove-old-welcome-mechanism",
      "headRefOid": "6d4725974ea87e0d9652e813a893a9c0c2a6973b",
      "closedAt": "2021-03-04T21:33:44Z",
      "mergedAt": "2021-03-04T21:33:44Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "a92a2690b630333c493ff111408054ee3161c793"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjAyMDQ4MzQ5",
          "commit": {
            "abbreviatedOid": "6d47259"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-03-02T16:57:38Z",
          "updatedAt": "2021-03-02T16:57:38Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjAyMDcxNzg1",
          "commit": {
            "abbreviatedOid": "6d47259"
          },
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-03-02T17:20:08Z",
          "updatedAt": "2021-03-02T17:20:08Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjA0NTgwNjE5",
          "commit": {
            "abbreviatedOid": "6d47259"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-03-04T21:33:36Z",
          "updatedAt": "2021-03-04T21:33:36Z",
          "comments": []
        }
      ]
    },
    {
      "number": 460,
      "id": "MDExOlB1bGxSZXF1ZXN0NTg1NTY0NjIy",
      "title": "Fix typo in Parent Hash verification.",
      "url": "https://github.com/mlswg/mls-protocol/pull/460",
      "state": "MERGED",
      "author": "psyoptix",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Add a missing word. Fail on *blank* leaf.",
      "createdAt": "2021-03-05T12:29:03Z",
      "updatedAt": "2021-03-08T05:59:08Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "a92a2690b630333c493ff111408054ee3161c793",
      "headRepository": "psyoptix/mls-protocol",
      "headRefName": "fix_parent_hash_typo",
      "headRefOid": "7e8a6cfb16b2d3c2841b82a69c9c76c28841e91c",
      "closedAt": "2021-03-08T05:59:08Z",
      "mergedAt": "2021-03-08T05:59:07Z",
      "mergedBy": "beurdouche",
      "mergeCommit": {
        "oid": "da9333b8227e969f56b6c20d63b9ff836eb79dd5"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjA1OTA1ODIx",
          "commit": {
            "abbreviatedOid": "7e8a6cf"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-03-08T00:42:19Z",
          "updatedAt": "2021-03-08T00:42:19Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjA1OTI4ODg4",
          "commit": {
            "abbreviatedOid": "7e8a6cf"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-03-08T02:34:19Z",
          "updatedAt": "2021-03-08T02:34:19Z",
          "comments": []
        }
      ]
    },
    {
      "number": 461,
      "id": "MDExOlB1bGxSZXF1ZXN0NTg2MjEwOTQ2",
      "title": "Truncate tree size on removal",
      "url": "https://github.com/mlswg/mls-protocol/pull/461",
      "state": "MERGED",
      "author": "suhasHere",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "This PR adds text to truncate the tree to perform garbage collection on removal. [ref: https://github.com/mlswg/mls-protocol/pull/84/files]",
      "createdAt": "2021-03-07T08:34:07Z",
      "updatedAt": "2021-03-08T05:56:37Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "master",
      "baseRefOid": "a92a2690b630333c493ff111408054ee3161c793",
      "headRepository": "suhasHere/mls-protocol",
      "headRefName": "truncate",
      "headRefOid": "46a06fe8eefae91a326fd68a7682be2da054419b",
      "closedAt": "2021-03-08T05:56:36Z",
      "mergedAt": "2021-03-08T05:56:36Z",
      "mergedBy": "beurdouche",
      "mergeCommit": {
        "oid": "2988304c45def53ac338045bcb7b49d5bb002365"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjA1OTM0NDE4",
          "commit": {
            "abbreviatedOid": "46a06fe"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-03-08T02:55:47Z",
          "updatedAt": "2021-03-08T02:55:47Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjA1OTgyNjMz",
          "commit": {
            "abbreviatedOid": "46a06fe"
          },
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-03-08T05:56:20Z",
          "updatedAt": "2021-03-08T05:56:20Z",
          "comments": []
        }
      ]
    },
    {
      "number": 462,
      "id": "MDExOlB1bGxSZXF1ZXN0NTg2NDc0Mzgz",
      "title": "Make ratchet tree section clearer.",
      "url": "https://github.com/mlswg/mls-protocol/pull/462",
      "state": "MERGED",
      "author": "Bren2010",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2021-03-08T06:00:39Z",
      "updatedAt": "2021-10-04T17:32:19Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "da9333b8227e969f56b6c20d63b9ff836eb79dd5",
      "headRepository": "Bren2010/mls-protocol",
      "headRefName": "brendan/asdf2",
      "headRefOid": "278f54d1b38c085a0371c64b6af8066b9d477ab9",
      "closedAt": "2021-10-04T17:32:19Z",
      "mergedAt": "2021-10-04T17:32:18Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "b9b6fa73e3973cf132d04bc125d1db4c5bff6076"
      },
      "comments": [
        {
          "author": "seanturner",
          "authorAssociation": "CONTRIBUTOR",
          "body": "202105 Interim: To be reviewed by editors.",
          "createdAt": "2021-05-26T15:40:48Z",
          "updatedAt": "2021-05-26T15:40:48Z"
        },
        {
          "author": "seanturner",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Ready to merge modulo one nit.",
          "createdAt": "2021-10-04T14:20:11Z",
          "updatedAt": "2021-10-04T14:20:11Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzI2OTI3NTg1",
          "commit": {
            "abbreviatedOid": "be5f887"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "One minor fix, otherwise ready to go.",
          "createdAt": "2021-08-10T23:37:41Z",
          "updatedAt": "2021-08-10T23:38:30Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "```suggestion\r\ncontaining a set of public keys and encrypted path secrets\r\nfor intermediate nodes in the direct path of its leaf. The\r\n```",
              "createdAt": "2021-08-10T23:37:41Z",
              "updatedAt": "2021-08-10T23:38:30Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c4t14gc",
          "commit": {
            "abbreviatedOid": "be5f887"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-10-01T15:21:20Z",
          "updatedAt": "2021-10-01T15:21:20Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOBoyH6c4t6s2z",
          "commit": {
            "abbreviatedOid": "be5f887"
          },
          "author": "seanturner",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-04T14:20:05Z",
          "updatedAt": "2021-10-04T14:20:05Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "minor correctness fix.",
              "createdAt": "2021-10-04T14:20:05Z",
              "updatedAt": "2021-10-04T14:20:05Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c4t7iHF",
          "commit": {
            "abbreviatedOid": "278f54d"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-10-04T17:31:47Z",
          "updatedAt": "2021-10-04T17:31:47Z",
          "comments": []
        }
      ]
    },
    {
      "number": 463,
      "id": "MDExOlB1bGxSZXF1ZXN0NTg2NDc1NzEy",
      "title": "Remove AppAck proposal.",
      "url": "https://github.com/mlswg/mls-protocol/pull/463",
      "state": "CLOSED",
      "author": "Bren2010",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2021-03-08T06:03:01Z",
      "updatedAt": "2021-10-04T14:27:17Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "da9333b8227e969f56b6c20d63b9ff836eb79dd5",
      "headRepository": "Bren2010/mls-protocol",
      "headRefName": "brendan/no-app-ack",
      "headRefOid": "2bc2722d83c4de5ef0c8ad00d24d3bbc05c6917f",
      "closedAt": "2021-10-04T14:27:16Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "seanturner",
          "authorAssociation": "CONTRIBUTOR",
          "body": "(briefly) Discussed at 20210526 Interim: Debate about whether this is required at the protocol level. @grittygrease @seanturner to review discussion on list and determine way forward.",
          "createdAt": "2021-05-26T15:43:18Z",
          "updatedAt": "2021-05-26T15:43:18Z"
        },
        {
          "author": "seanturner",
          "authorAssociation": "CONTRIBUTOR",
          "body": "As discussed at 20211004 interim, will retain text.",
          "createdAt": "2021-10-04T14:27:16Z",
          "updatedAt": "2021-10-04T14:27:16Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 464,
      "id": "MDExOlB1bGxSZXF1ZXN0NTg3ODU5NTc3",
      "title": "Clarify which extensions should go into the group context",
      "url": "https://github.com/mlswg/mls-protocol/pull/464",
      "state": "CLOSED",
      "author": "kkohbrok",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Just a small editorial change to clarify which extensions should be included in the `GroupContext`. There is a paragraph explaining that the `RatchetTreeExtension` should not go in, but I think the section on the `GroupContext` should be precise about what _does_ go in.\r\n\r\nI did notice, though, that we currently don't have a way of actually changing extensions during the lifetime of the group. If someone wanted to change an extensions, they would currently have to re-init the whole group. Of course, this could be solved by an extension, but maybe it would be sensible to have an `Extension` proposal for that purpose?",
      "createdAt": "2021-03-09T11:50:17Z",
      "updatedAt": "2021-08-13T05:18:06Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "da9333b8227e969f56b6c20d63b9ff836eb79dd5",
      "headRepository": "kkohbrok/mls-protocol",
      "headRefName": "extension_clarification",
      "headRefOid": "3f90a68824b686580f25f8807169221e64d78d92",
      "closedAt": "2021-08-13T05:18:06Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "We should decide if we want to tackle #473 before discussing this further.",
          "createdAt": "2021-05-26T15:45:51Z",
          "updatedAt": "2021-05-26T15:45:51Z"
        },
        {
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Closing in favor of the approach decided upon in #473.",
          "createdAt": "2021-08-13T05:18:06Z",
          "updatedAt": "2021-08-13T05:18:06Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 465,
      "id": "MDExOlB1bGxSZXF1ZXN0NTg5MTI3MjQ1",
      "title": "Rename add-only Commit to partial Commit.",
      "url": "https://github.com/mlswg/mls-protocol/pull/465",
      "state": "MERGED",
      "author": "Bren2010",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2021-03-10T06:17:11Z",
      "updatedAt": "2021-05-26T15:45:04Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "da9333b8227e969f56b6c20d63b9ff836eb79dd5",
      "headRepository": "Bren2010/mls-protocol",
      "headRefName": "brendan/asdf3",
      "headRefOid": "3a7d2aea12e678c4c5691fcc97b520623cabb0f6",
      "closedAt": "2021-05-26T15:45:04Z",
      "mergedAt": "2021-05-26T15:45:04Z",
      "mergedBy": "raphaelrobert",
      "mergeCommit": {
        "oid": "7a698d46c83b57f5cb2097eec8ffaa58875e7000"
      },
      "comments": [
        {
          "author": "seanturner",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Discussed at 20210526 Interim. Merge.",
          "createdAt": "2021-05-26T15:45:02Z",
          "updatedAt": "2021-05-26T15:45:02Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjA4NTExNzg0",
          "commit": {
            "abbreviatedOid": "3a7d2ae"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "Good point about allowing PSKs in a partial Commit!",
          "createdAt": "2021-03-10T09:43:00Z",
          "updatedAt": "2021-03-10T09:43:00Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjA4NTEzMDEw",
          "commit": {
            "abbreviatedOid": "3a7d2ae"
          },
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-03-10T09:44:17Z",
          "updatedAt": "2021-03-10T09:44:17Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjA5NDUxNDM0",
          "commit": {
            "abbreviatedOid": "3a7d2ae"
          },
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-03-11T07:17:01Z",
          "updatedAt": "2021-03-11T07:17:01Z",
          "comments": []
        }
      ]
    },
    {
      "number": 466,
      "id": "MDExOlB1bGxSZXF1ZXN0NTk2ODg1MzMz",
      "title": "Minor fixes to message formats",
      "url": "https://github.com/mlswg/mls-protocol/pull/466",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This PR fixes a few small issues I noticed while reviewing mlspp for compliance with the spec:\r\n\r\n* The size of the `Extension.extension_data` vector needs to expand `2^32-1` to support trees for large groups\r\n* The content of the `parent_hash` extension is specified\r\n* `authenticated_data` is included in `MLSPlaintextCommitContent` so that it goes into the transcript\r\n* `MLSPlaintextAuthData` now carries an `optional<MAC>` even though the value is always present, so that the transcript matches the data on the wire",
      "createdAt": "2021-03-19T21:24:37Z",
      "updatedAt": "2021-05-26T15:47:05Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "da9333b8227e969f56b6c20d63b9ff836eb79dd5",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "message-fixes",
      "headRefOid": "b5c460460070b2e8aed9d6620c056c913c4739d0",
      "closedAt": "2021-05-26T15:47:04Z",
      "mergedAt": "2021-05-26T15:47:04Z",
      "mergedBy": "raphaelrobert",
      "mergeCommit": {
        "oid": "ba6614efc4c2bc44cdc11c9914b2a37d4b340b84"
      },
      "comments": [
        {
          "author": "seanturner",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Discussed at 20210526 Interim. Merge",
          "createdAt": "2021-05-26T15:46:59Z",
          "updatedAt": "2021-05-26T15:46:59Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjE3MDYyMjA5",
          "commit": {
            "abbreviatedOid": "b5c4604"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-03-21T21:12:35Z",
          "updatedAt": "2021-03-21T21:12:35Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjE3MjI2MTIw",
          "commit": {
            "abbreviatedOid": "b5c4604"
          },
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-03-22T07:54:09Z",
          "updatedAt": "2021-03-22T07:54:09Z",
          "comments": []
        }
      ]
    },
    {
      "number": 467,
      "id": "MDExOlB1bGxSZXF1ZXN0NjAzNDUwODcw",
      "title": "An entropy pool design for MLS",
      "url": "https://github.com/mlswg/mls-protocol/pull/467",
      "state": "CLOSED",
      "author": "kkohbrok",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "This PR mandates the use of an entropy pool for MLS and proposes a design that is modeled after the key schedule such that it\r\n1) allows the extraction of entropy when needed,\r\n2) allows the repeated injection of entropy originating from the system's RNG such that the entropy pool gets refreshed after a full state compromise,\r\n3) gathers entropy over time while maintaining forward-secrecy,\r\n4) allows the safe injection of entropy originating from other parties.\r\n\r\nIn particular, the design is such that we achieve what we believe are the best possible security guarantees from any injection operation:\r\n* if the entropy from the system's RNG is good, the result is good independent of any other input to the pool\r\n* if the entropy from one of the groups is good, the result is good independent of any other input to the pool\r\n\r\nTODO:\r\n* allow the injection of auxiliary randomness, for example a signature using a long term signature key as suggested by https://eprint.iacr.org/2018/1057",
      "createdAt": "2021-03-30T07:24:37Z",
      "updatedAt": "2021-08-13T05:20:10Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "da9333b8227e969f56b6c20d63b9ff836eb79dd5",
      "headRepository": "psyoptix/mls-protocol",
      "headRefName": "improving_entropy",
      "headRefOid": "03563f74e59eb4ac9f100550ad27a9195ec32c4d",
      "closedAt": "2021-08-13T05:20:09Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Closing this PR as the entropy pool specification is moved to an \"implementation-considerations\" document.",
          "createdAt": "2021-08-13T05:20:09Z",
          "updatedAt": "2021-08-13T05:20:09Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 469,
      "id": "MDExOlB1bGxSZXF1ZXN0NjMwNzI2ODk3",
      "title": "Fix typos in the \"IANA Considerations\" section",
      "url": "https://github.com/mlswg/mls-protocol/pull/469",
      "state": "MERGED",
      "author": "TWal",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "I noticed a bunch of typos in the \"IANA Considerations\" section: the \"ciphersuites\" and \"credentials\" were probably copy-pasted from the \"extension\" one, and some parts were not changed correctly.\r\n\r\nThis PR fixes these typos.",
      "createdAt": "2021-05-05T16:11:11Z",
      "updatedAt": "2021-06-23T10:22:09Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "da9333b8227e969f56b6c20d63b9ff836eb79dd5",
      "headRepository": "TWal/mls-protocol",
      "headRefName": "twal_iana_typos",
      "headRefOid": "a7e2fec4adc29fc2d7b05b4f6d580ea92b311174",
      "closedAt": "2021-06-23T10:22:02Z",
      "mergedAt": "2021-06-23T10:22:02Z",
      "mergedBy": "beurdouche",
      "mergeCommit": {
        "oid": "8216b7904caa54a822202863f38f3a9956e30388"
      },
      "comments": [
        {
          "author": "seanturner",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Discussed 20210526 Interim: editorial will be taken up by editors.",
          "createdAt": "2021-05-26T15:48:02Z",
          "updatedAt": "2021-05-26T15:48:02Z"
        },
        {
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "body": "Thanks!",
          "createdAt": "2021-06-23T10:22:09Z",
          "updatedAt": "2021-06-23T10:22:09Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 471,
      "id": "MDExOlB1bGxSZXF1ZXN0NjQ2NzMzNjc2",
      "title": "Use HPKE draft-08",
      "url": "https://github.com/mlswg/mls-protocol/pull/471",
      "state": "MERGED",
      "author": "franziskuskiefer",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "draft-08 is the latest HPKE draft, which should be stable. It is also what's being used for interop testing right now.",
      "createdAt": "2021-05-18T13:03:50Z",
      "updatedAt": "2021-05-26T15:48:32Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "da9333b8227e969f56b6c20d63b9ff836eb79dd5",
      "headRepository": "franziskuskiefer/mls-protocol",
      "headRefName": "patch-3",
      "headRefOid": "4e4bd1eb168c1165bbfdec7203ebe29334a70c2f",
      "closedAt": "2021-05-26T15:48:27Z",
      "mergedAt": "2021-05-26T15:48:27Z",
      "mergedBy": "raphaelrobert",
      "mergeCommit": {
        "oid": "05fe1daacd66006f600869f6bc05bc9efb1530ed"
      },
      "comments": [
        {
          "author": "seanturner",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Discussed 20210526 Interim: Merge.",
          "createdAt": "2021-05-26T15:48:32Z",
          "updatedAt": "2021-05-26T15:48:32Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjY5MjA1Njcx",
          "commit": {
            "abbreviatedOid": "4e4bd1e"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-05-26T15:48:31Z",
          "updatedAt": "2021-05-26T15:48:31Z",
          "comments": []
        }
      ]
    },
    {
      "number": 474,
      "id": "MDExOlB1bGxSZXF1ZXN0NjkyNjk5MTQ4",
      "title": "Explicit blank cases in MLSPlaintextTBS",
      "url": "https://github.com/mlswg/mls-protocol/pull/474",
      "state": "MERGED",
      "author": "eiqo",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "The  `select` based on `MLSPlaintextTBS.sender.sender_type` seems ambiguous, as it does not state what happens to cases other than `member`. The TLS presentation language does not say anything on the matter.",
      "createdAt": "2021-07-19T15:16:10Z",
      "updatedAt": "2021-07-19T15:46:19Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "5c5663ca170c7a7bee73395cee42468e271479b7",
      "headRepository": "eiqo/mls-protocol",
      "headRefName": "blank",
      "headRefOid": "88de926913e2add40e4ee320925b220752998d29",
      "closedAt": "2021-07-19T15:46:19Z",
      "mergedAt": "2021-07-19T15:46:19Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "3c690fdc85114061b98ec56e3a6c605de0706d4d"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzA5Njc2MzM0",
          "commit": {
            "abbreviatedOid": "88de926"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-07-19T15:17:28Z",
          "updatedAt": "2021-07-19T15:17:28Z",
          "comments": []
        }
      ]
    },
    {
      "number": 475,
      "id": "MDExOlB1bGxSZXF1ZXN0NjkzNTMyNzc4",
      "title": "Clarify signature encoding",
      "url": "https://github.com/mlswg/mls-protocol/pull/475",
      "state": "MERGED",
      "author": "franziskuskiefer",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "The spec doesn't say anything about the signature encoding yet.\r\nThis PR adds a paragraph clarifying that signature encoding is done like in TLS.",
      "createdAt": "2021-07-20T14:50:03Z",
      "updatedAt": "2021-08-19T21:09:59Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "3c690fdc85114061b98ec56e3a6c605de0706d4d",
      "headRepository": "franziskuskiefer/mls-protocol",
      "headRefName": "patch-4",
      "headRefOid": "e0b3a4ac91756e29d5277bf3654b2308be250177",
      "closedAt": "2021-08-19T21:09:59Z",
      "mergedAt": "2021-08-19T21:09:59Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "e374686f64915720914f3f663c98b47530edc039"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzEwNzY1MDY1",
          "commit": {
            "abbreviatedOid": "e2d4c76"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-07-20T16:07:51Z",
          "updatedAt": "2021-07-20T16:07:51Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzEwNzY5NTU1",
          "commit": {
            "abbreviatedOid": "e2d4c76"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-07-20T16:09:49Z",
          "updatedAt": "2021-07-20T16:10:00Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "I think the CI error we're getting might require this to be `{{!RFC8446}}` (`? -> !`)\r\n",
              "createdAt": "2021-07-20T16:09:49Z",
              "updatedAt": "2021-07-20T16:10:00Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzExMzE0Mzc0",
          "commit": {
            "abbreviatedOid": "e0b3a4a"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-07-21T06:55:45Z",
          "updatedAt": "2021-07-21T06:55:45Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "There is still a '?' here.",
              "createdAt": "2021-07-21T06:55:45Z",
              "updatedAt": "2021-07-21T06:55:45Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzExMzE0OTY2",
          "commit": {
            "abbreviatedOid": "e0b3a4a"
          },
          "author": "franziskuskiefer",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-07-21T06:56:35Z",
          "updatedAt": "2021-07-21T06:56:35Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "yeah, that should be fine",
              "createdAt": "2021-07-21T06:56:35Z",
              "updatedAt": "2021-07-21T06:56:35Z"
            }
          ]
        }
      ]
    },
    {
      "number": 476,
      "id": "MDExOlB1bGxSZXF1ZXN0NzEyMzIzMDEw",
      "title": "Revisit the notion of identity in MLS groups",
      "url": "https://github.com/mlswg/mls-protocol/pull/476",
      "state": "MERGED",
      "author": "kkohbrok",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "After a discussion with @bifurcation and @raphaelrobert, this PR is a new spin on and an extension of #439.\r\n\r\nThis PR adds the `endpoint_id` field to KeyPackages. The `endpoint_id` field serves to distinguish KeyPackages with Credentials that share the value of their `identity` field.\r\n\r\nThis PR also introduces a set of restrictions for KeyPackages that introduced to the group via Adds and Updates.\r\n\r\nGenerally, for both Adds and Updates, the committer has to ensure that\r\n- signature keys are unique within a group (this is so that the sender of a message can be determined uniquely within a group),\r\n- `(identity, endpoint_id)` tuples are unique in a group,\r\n- `hpke_init_key`s are unique in a group.\r\n\r\nAdditionally, Updates have to ensure that\r\n- the new and the old key package have the same `identity` (in the Credential), `endpoint_id`, `version` and `cipher_suite` as the key package they replace,\r\n- the new and the old key package do not share the same `hpke_init_key`.\r\n\r\nI didn't extend the section indicating that the processor of a commit has to check all these things in the same way that the committer has to. I think, here we should probably restructure the section, so that we can just reference the part where it is specified how to determine if a given proposal is valid in the context of a given group.",
      "createdAt": "2021-08-13T12:33:51Z",
      "updatedAt": "2021-10-04T17:35:55Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "b9b6fa73e3973cf132d04bc125d1db4c5bff6076",
      "headRepository": "kkohbrok/mls-protocol",
      "headRefName": "konrad/identity_and_endpoint_id",
      "headRefOid": "f16da5a4ead63315881d938a7f8624ac1484524c",
      "closedAt": "2021-10-04T17:35:55Z",
      "mergedAt": "2021-10-04T17:35:55Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "f85e2487888703cc48e177f94878361f61e08480"
      },
      "comments": [
        {
          "author": "br-hale",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thank for proposing this PR, Konrad. The changes look beneficial.\r\n\r\nI have one question about the requirement for updates that the ciphersuite matches the prior ciphersuite. Currently, all group members are required to use the same ciphersuite so this requirement does not seem necessary in most cases. There is one case worth considering though that this restricts - namely that it limits the option for the entire group to roll the ciphersuite simultaneously. It would be advantageous for us to support changing of the identity key ciphersuite for the entire group, if necessary, without a full tear-down of the state. I do not think we currently specify options for this in the spec, but a ciphersuite matching requirement would inhibit the possibility.\r\n\r\n",
          "createdAt": "2021-08-16T18:49:44Z",
          "updatedAt": "2021-08-16T18:49:44Z"
        },
        {
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thanks for the feedback @br-hale!\r\n\r\nI agree that the requirement for all group members to use matching ciphersuites was there before, but I couldn't find it anywhere explicitly, so I added it just to be sure. If it turns out to be redundant, I'm happy to remove it again.\r\n\r\nIf I understand your proposal correctly, rolling the ciphersuite simultaneously would require a few more changes, for a example an additional proposal to coordinate the change. If that is the case, I'd say we leave it in and remove the requirement once we add the capability for the ciphersuite rolling. A problem I see with ciphersuite rolling is that it would require everyone to change their Credential simultaneously. Although maybe we could overcome that by coordinating Update proposals? Do you want to open a new GH issue/PR so you can outline your idea and we can continue the discussion there?",
          "createdAt": "2021-08-17T05:42:33Z",
          "updatedAt": "2021-08-17T05:42:33Z"
        },
        {
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "body": "On the topic of ciphersuite change: we have a mechanism for that in 10.1:\r\n\r\n> Re-initializing an existing group may be used, for example, to restart the group with a different ciphersuite or protocol version.\r\n\r\nI would assume that the binary tree wouldn't be re-usable anyway if different crypto primitives are used so it's only a matter of preserving existing entropy and carry over group secrets to the new group which can be done through the PSK mechanism. Am I missing something here?",
          "createdAt": "2021-08-17T09:42:47Z",
          "updatedAt": "2021-08-17T09:42:47Z"
        },
        {
          "author": "br-hale",
          "authorAssociation": "CONTRIBUTOR",
          "body": "What @raphaelrobert mentions is where my comment was vectored towards. The concern would be if locking in the ciphersuite per this PR blocks that option entirely. However, it is correct that the PSK mechanism can be used for creating a new group (with new ciphersuite) that ties to the prior group and therefore bypasses the need need to roll a ciphersuite within a group. It may be a heavier change mechanism than rolling a ciphersuite would be, but it works. \r\n\r\nSince this is specifically about rolling identity keys, the rest of the tree should still be usable following a roll of the ciphersuite (signatures properties active after the next update of leaf node keys of course). But @raphaelrobert you make a good point that any such handling would then need to prevent rolling of other ciphersuite elements aside from the identity. Such changes would need careful consideration - at this point in the process, it is best not to introduce something too nuanced. So, all that said, I think we can close the question on ciphersuite matching.",
          "createdAt": "2021-08-17T18:26:41Z",
          "updatedAt": "2021-08-17T18:26:41Z"
        },
        {
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I just realized that one corollary of this change is that we can now use the `(identity, endpoint_id)` tuple in the message structs and thus further reduce our dependency on any specific binary tree implementation. Something like this:\r\n\r\n```\r\nstruct {\r\n    SenderType sender_type;\r\n    opaque sender_identity;\r\n    opaque sender_endpoint_id;\r\n} Sender;\r\n```\r\nAnd similarly for the case of `MLSSenderData`, the `Remove` proposal, `MessageRange`, `PublicGroupState`, `GroupInfo` and anything else that's not immediately part of the tree primitives, at least for now.",
          "createdAt": "2021-09-15T06:47:22Z",
          "updatedAt": "2021-09-15T06:47:22Z"
        },
        {
          "author": "seanturner",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Discussed at 20211004 Interim, merge. @kkohbrok also to submit new Issue he noted.",
          "createdAt": "2021-10-04T14:36:52Z",
          "updatedAt": "2021-10-04T14:36:52Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOBoyH6c4tzIqL",
          "commit": {
            "abbreviatedOid": "4033b10"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Thanks, @kkohbrok this is a useful clarification.  It seems fine to handle the receiver processing in a separate PR; consolidating it as you suggest is a good idea.",
          "createdAt": "2021-09-30T21:54:26Z",
          "updatedAt": "2021-09-30T21:56:38Z",
          "comments": [
            {
              "originalPosition": 31,
              "body": "Rather than say \"share\" here, it would be clearer to say that the values MUST be equal.",
              "createdAt": "2021-09-30T21:54:26Z",
              "updatedAt": "2021-09-30T21:56:38Z"
            },
            {
              "originalPosition": 31,
              "body": "Likewise below, instead of \"MUST NOT share\", \"MUST be different\".",
              "createdAt": "2021-09-30T21:54:50Z",
              "updatedAt": "2021-09-30T21:56:38Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c4t15EU",
          "commit": {
            "abbreviatedOid": "4033b10"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-01T15:23:35Z",
          "updatedAt": "2021-10-01T15:23:36Z",
          "comments": [
            {
              "originalPosition": 31,
              "body": "Agreed",
              "createdAt": "2021-10-01T15:23:35Z",
              "updatedAt": "2021-10-01T15:23:36Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c4t15eq",
          "commit": {
            "abbreviatedOid": "4033b10"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "Looks good, modulo @bifurcation's remarks",
          "createdAt": "2021-10-01T15:25:13Z",
          "updatedAt": "2021-10-01T15:25:13Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOBoyH6c4t6v52",
          "commit": {
            "abbreviatedOid": "bdccfab"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-10-04T14:29:13Z",
          "updatedAt": "2021-10-04T14:29:13Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOBoyH6c4t7i62",
          "commit": {
            "abbreviatedOid": "f16da5a"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-10-04T17:35:10Z",
          "updatedAt": "2021-10-04T17:35:10Z",
          "comments": []
        }
      ]
    },
    {
      "number": 477,
      "id": "MDExOlB1bGxSZXF1ZXN0NzEzNjc0OTU0",
      "title": "Signal the intended wire format for MLS messages",
      "url": "https://github.com/mlswg/mls-protocol/pull/477",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": " @kkohbrok pointed out to me that there's currently no way for a DS to distinguish between MLSPlaintext and MLSCiphertext messages.  Obviously, an application could provide a flag on the outside of a message, but there are a few relatively minor benefits to including a flag in MLS:\r\n \r\n * Signing the flag authenticates the sender's intent\r\n * Including the flag in the transcript confirms that all group members got it in the same format\r\n * Including the flag in the struct provides a clear signal as to whether the `membership_tag` needs to be present/verified\r\n\r\nSince these benefits are pretty minor, I could kind of go either way on whether to make this change.  But it seemed worth writing up a PR to see what the change would look like.",
      "createdAt": "2021-08-16T19:04:01Z",
      "updatedAt": "2021-10-04T17:38:06Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "3c690fdc85114061b98ec56e3a6c605de0706d4d",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "wire-format",
      "headRefOid": "09cab5e68e4f61bded85be5a41940fbc8d4e0c74",
      "closedAt": "2021-10-04T17:38:06Z",
      "mergedAt": "2021-10-04T17:38:06Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "b49d1567b2560f8d2ce3b36e29f0db4b59b27d94"
      },
      "comments": [
        {
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "My original intention was not for the DS to distinguish the message types, but also for a receiving client. Even if there's a group policy that dictates whether to encrypt handshake messages, the client won't know how to parse a message, because the `content_type` fields on plaintext and ciphertext are not aligned in the two structs. So I think fixing that would be the low-hanging fruit.\r\n\r\nThat being said, I agree with @bifurcation that it would be neat to have a flag that signals the encryption status, but also communicates the sender's intent in a cryptographically authenticated manner.",
          "createdAt": "2021-08-17T05:51:07Z",
          "updatedAt": "2021-08-17T05:54:30Z"
        },
        {
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "body": "I agree with your reasoning and I think it's worthwhile doing.\r\n\r\nThe only part that is not straight forward for me is this:\r\n\r\n> Including the flag in the struct provides a clear signal as to whether the membership_tag needs to be present/verified\r\n\r\nIf the sender is of type `external` the `membership_tag` also doesn't need to be present for an `MLSPlaintext`. This should either be clarified, or we could have a third wire format for external senders.",
          "createdAt": "2021-08-17T09:34:39Z",
          "updatedAt": "2021-08-17T09:34:39Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Re: `external` -- there isn't an `external` sender type, but there are `new_member` and `preconfigured`.  You're correct that in both of those cases, the `membership_tag` shouldn't be populated.  The signal in this PR helps distinguish the two cases when `sender_type == member`.",
          "createdAt": "2021-08-19T21:04:41Z",
          "updatedAt": "2021-08-19T21:04:41Z"
        },
        {
          "author": "seanturner",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Discussed at 20211004 interim, merge.",
          "createdAt": "2021-10-04T14:40:04Z",
          "updatedAt": "2021-10-04T14:40:04Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOBoyH6c4tRQpr",
          "commit": {
            "abbreviatedOid": "09cab5e"
          },
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-09-21T09:15:41Z",
          "updatedAt": "2021-09-21T09:15:41Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOBoyH6c4t16Ev",
          "commit": {
            "abbreviatedOid": "09cab5e"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-10-01T15:27:38Z",
          "updatedAt": "2021-10-01T15:27:38Z",
          "comments": []
        }
      ]
    },
    {
      "number": 478,
      "id": "MDExOlB1bGxSZXF1ZXN0NzE2MjcxNjUz",
      "title": "Inject GroupContext as HPKE info instead of AAD",
      "url": "https://github.com/mlswg/mls-protocol/pull/478",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #470 ",
      "createdAt": "2021-08-19T21:22:48Z",
      "updatedAt": "2021-10-04T17:38:24Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "e374686f64915720914f3f663c98b47530edc039",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "aad-to-info",
      "headRefOid": "a42cdaaed2aa6dcc8b5a7a77c93074105c197c10",
      "closedAt": "2021-10-04T17:38:24Z",
      "mergedAt": "2021-10-04T17:38:24Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "0262671c433cc468c01f860c42c14d7830d94e35"
      },
      "comments": [
        {
          "author": "seanturner",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Discussed at 20211004 interim, merge.",
          "createdAt": "2021-10-04T14:42:06Z",
          "updatedAt": "2021-10-04T14:42:06Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzM0NzMwOTgz",
          "commit": {
            "abbreviatedOid": "a42cdaa"
          },
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-08-20T07:04:03Z",
          "updatedAt": "2021-08-20T07:04:03Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOBoyH6c4t16Pk",
          "commit": {
            "abbreviatedOid": "a42cdaa"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-10-01T15:28:17Z",
          "updatedAt": "2021-10-01T15:28:17Z",
          "comments": []
        }
      ]
    },
    {
      "number": 479,
      "id": "MDExOlB1bGxSZXF1ZXN0NzE2MjgyODI1",
      "title": "Clarify extension handling and make extension updatable",
      "url": "https://github.com/mlswg/mls-protocol/pull/479",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #473 ",
      "createdAt": "2021-08-19T21:44:15Z",
      "updatedAt": "2021-10-04T19:47:55Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "28195f529017a726f6f3c34700176f6e3f44f9ae",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "separate-extensions",
      "headRefOid": "75707ea95d6d0f6376b347b2c17f3303dec23f29",
      "closedAt": "2021-10-04T19:47:55Z",
      "mergedAt": "2021-10-04T19:47:55Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "2eb85927d4159c59c4b5ca1efc2de9142ddaa282"
      },
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "@kkohbrok r?",
          "createdAt": "2021-08-19T21:44:43Z",
          "updatedAt": "2021-08-19T21:44:43Z"
        },
        {
          "author": "seanturner",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Discussed at 20211004 interim, ready to merge after adding some additional detail about when to use one or the other.",
          "createdAt": "2021-10-04T14:53:04Z",
          "updatedAt": "2021-10-04T14:53:04Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzM0NzMyMTAw",
          "commit": {
            "abbreviatedOid": "8a39486"
          },
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-08-20T07:05:51Z",
          "updatedAt": "2021-08-20T07:13:56Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "Something seems to be missing here.",
              "createdAt": "2021-08-20T07:05:51Z",
              "updatedAt": "2021-08-20T07:13:56Z"
            },
            {
              "originalPosition": 109,
              "body": "```suggestion\r\n      `confirmed_transcript_hash`, and `group_context_extensions` fields from\r\n```",
              "createdAt": "2021-08-20T07:12:23Z",
              "updatedAt": "2021-08-20T07:13:57Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzUwNjg0ODI0",
          "commit": {
            "abbreviatedOid": "8a39486"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-09-09T18:23:06Z",
          "updatedAt": "2021-09-09T18:23:06Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "\"interim transcript hash\", apparently.",
              "createdAt": "2021-09-09T18:23:06Z",
              "updatedAt": "2021-09-09T18:23:06Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c4tRQW-",
          "commit": {
            "abbreviatedOid": "dc9a186"
          },
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-09-21T09:14:32Z",
          "updatedAt": "2021-09-21T09:14:32Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOBoyH6c4t18MH",
          "commit": {
            "abbreviatedOid": "dc9a186"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-10-01T15:36:04Z",
          "updatedAt": "2021-10-01T15:36:04Z",
          "comments": []
        }
      ]
    },
    {
      "number": 480,
      "id": "MDExOlB1bGxSZXF1ZXN0NzE2MjkxOTkx",
      "title": "Improve extensibility of Proposals",
      "url": "https://github.com/mlswg/mls-protocol/pull/480",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "@psyoptix pointed out to me some improvements that could be made in the extensibility of proposals.  This PR makes a few changes to smooth out deployment of new proposals:\r\n\r\n* Extends `ProposalType` to two bytes, creates an IANA registry, and reserves some space for private use\r\n* Extends the `capabilities` extension so that clients can indicate which proposal types they support\r\n* Forbids committers from including proposals that some people don't support",
      "createdAt": "2021-08-19T22:03:48Z",
      "updatedAt": "2021-10-04T18:02:20Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "e374686f64915720914f3f663c98b47530edc039",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "vendor-space",
      "headRefOid": "fc217c7ae29d7bfd6754074849ffc04167a9303e",
      "closedAt": "2021-10-04T18:02:20Z",
      "mergedAt": "2021-10-04T18:02:20Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "32014e605898b23b10622d8074958861ffe002b1"
      },
      "comments": [
        {
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "body": "Just for context: This PR addresses the second part of #473.",
          "createdAt": "2021-10-01T15:40:46Z",
          "updatedAt": "2021-10-01T15:40:46Z"
        },
        {
          "author": "br-hale",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Agreed. Looks good.",
          "createdAt": "2021-10-04T14:40:00Z",
          "updatedAt": "2021-10-04T14:40:00Z"
        },
        {
          "author": "seanturner",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Discussed at 20211004 interim, merge.",
          "createdAt": "2021-10-04T14:52:39Z",
          "updatedAt": "2021-10-04T14:52:39Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzM0NzM5MjYy",
          "commit": {
            "abbreviatedOid": "fc217c7"
          },
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Looks good to me!",
          "createdAt": "2021-08-20T07:16:39Z",
          "updatedAt": "2021-08-20T07:16:39Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOBoyH6c4t19IP",
          "commit": {
            "abbreviatedOid": "fc217c7"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-10-01T15:39:46Z",
          "updatedAt": "2021-10-01T15:39:46Z",
          "comments": []
        }
      ]
    },
    {
      "number": 481,
      "id": "MDExOlB1bGxSZXF1ZXN0NzE2MzIyNjg2",
      "title": "Constrain proposal in External Commit",
      "url": "https://github.com/mlswg/mls-protocol/pull/481",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #443 ",
      "createdAt": "2021-08-19T23:12:45Z",
      "updatedAt": "2021-10-11T19:25:36Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "e277f4187aa8e2af9da5b57fbbf7b909faf1edc8",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "constrain-external-commit",
      "headRefOid": "73e0ad7154c8d3f108460489ab22e974231f4277",
      "closedAt": "2021-10-11T19:25:36Z",
      "mergedAt": "2021-10-11T19:25:36Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "2bc4ae1f4ba1a4fe81852e101e17ac0550897a91"
      },
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "@br-hale @kkohbrok r?",
          "createdAt": "2021-08-19T23:13:05Z",
          "updatedAt": "2021-08-19T23:13:05Z"
        },
        {
          "author": "seanturner",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Discussed at 20211004 interim, remove resynch with a single op (external join + remove in one op).\r\n\r\n@bifurcation research why resynch was dropped.",
          "createdAt": "2021-10-04T15:13:57Z",
          "updatedAt": "2021-10-04T15:13:57Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzM0NTc3NDUz",
          "commit": {
            "abbreviatedOid": "6276990"
          },
          "author": "br-hale",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-08-20T00:43:48Z",
          "updatedAt": "2021-08-20T00:43:48Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "I am not adverse to a resync option. However, this was in the original PR for PSKs, discussed by the group then removed. At that time it was called \"recover\" (original WG brief) and later \"resumption\". There was fairly extensive discussion on it, so we should probably double-check what was kept/removed and why in the mailinglist and meeting notes before re-introducing this. @kkohbrok do you recall why the WG moved against that?",
              "createdAt": "2021-08-20T00:43:48Z",
              "updatedAt": "2021-08-20T00:54:32Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzM0NTgwODAy",
          "commit": {
            "abbreviatedOid": "6276990"
          },
          "author": "br-hale",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-08-20T00:53:58Z",
          "updatedAt": "2021-08-20T00:53:59Z",
          "comments": [
            {
              "originalPosition": 41,
              "body": "We would need to require that the prior identity (if there was prior membership) is removed. The proposer should do this - so maybe mandating a \"must\" for including a remove proposal if resyncing. Basically, the group should not end up with duplication of the identity (and potential backdoor). It is also inefficient for healing as Alice needs to replace keys at both nodes if both of the \"Alice\" identities are allowed to stay.\r\n\r\nThis is presents a question for handling sub-identities (if Alice has multiple devices and the identity is linked to Alice vs. a device). In that case an Add proposal for extra devices could include a PSK derived from the group, but the group will never know which device Alice is using (since the identity is the same). So what is the assumption here with respect to multi-device handling? ",
              "createdAt": "2021-08-20T00:53:58Z",
              "updatedAt": "2021-08-20T00:53:59Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzM0NTgzMTMz",
          "commit": {
            "abbreviatedOid": "6276990"
          },
          "author": "br-hale",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-08-20T01:01:31Z",
          "updatedAt": "2021-08-20T01:01:31Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "Actually (after tracing through PRs/issue comments) the \"resumption\" part was kept as a separate key from the key schedule, but downgraded from use as group \"recovery\" and applied strictly to branch/reinit. PR #421 shows the changed text. I recall the decision being made in the WG after discussion, with reasons presented by @raphaelrobert and @bifurcation. I do not recall the reasons, unfortunately, but maybe someone else does. ",
              "createdAt": "2021-08-20T01:01:31Z",
              "updatedAt": "2021-08-20T16:48:45Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzM0NzQ3Mzk4",
          "commit": {
            "abbreviatedOid": "6276990"
          },
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-08-20T07:27:46Z",
          "updatedAt": "2021-08-20T07:30:01Z",
          "comments": [
            {
              "originalPosition": 41,
              "body": "I believe PR #476 would allow us to check both user _and_ device identity. But of course this depends on how the application implements multi-device. They could user a different `identity` for each device, or a different `endpoint_id` or both.",
              "createdAt": "2021-08-20T07:27:46Z",
              "updatedAt": "2021-08-20T07:30:01Z"
            },
            {
              "originalPosition": 15,
              "body": "I'm afraid, I can't recall the reasons either. I still think this might be useful to have, though.",
              "createdAt": "2021-08-20T07:29:05Z",
              "updatedAt": "2021-08-20T07:30:01Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c4t1-6O",
          "commit": {
            "abbreviatedOid": "4121e93"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2021-10-01T15:47:19Z",
          "updatedAt": "2021-10-01T15:48:14Z",
          "comments": [
            {
              "originalPosition": 80,
              "body": "Maybe worth noting that resumption secrets can be optionally used to mitigate the signature key compromise in the \"resync\" scenario.",
              "createdAt": "2021-10-01T15:47:19Z",
              "updatedAt": "2021-10-01T15:48:14Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c4uEfSJ",
          "commit": {
            "abbreviatedOid": "73e0ad7"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-06T15:54:45Z",
          "updatedAt": "2021-10-06T15:54:45Z",
          "comments": [
            {
              "originalPosition": 80,
              "body": "This is suggested (with trade-offs) in the latest commit.",
              "createdAt": "2021-10-06T15:54:45Z",
              "updatedAt": "2021-10-06T15:54:45Z"
            }
          ]
        }
      ]
    },
    {
      "number": 483,
      "id": "MDExOlB1bGxSZXF1ZXN0NzE2MzI1NjA0",
      "title": "Remove OPEN ISSUEs and TODOs",
      "url": "https://github.com/mlswg/mls-protocol/pull/483",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Most of these were stale; see comments for more specifics.  I opened #482 as a general issue arising from the final TODO.",
      "createdAt": "2021-08-19T23:20:13Z",
      "updatedAt": "2021-10-04T18:40:48Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "e374686f64915720914f3f663c98b47530edc039",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "open-issues",
      "headRefOid": "f1b49e7c8ef3400f88802d3a26d3107c96a65daa",
      "closedAt": "2021-10-04T18:40:48Z",
      "mergedAt": "2021-10-04T18:40:48Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "28195f529017a726f6f3c34700176f6e3f44f9ae"
      },
      "comments": [
        {
          "author": "seanturner",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Discussed at 20211004 interim, will merge after adding text in comment.\r\n\r\n@kkohbrok create new issue for multiple PSKs and PR for cascading HKDF.",
          "createdAt": "2021-10-04T15:27:34Z",
          "updatedAt": "2021-10-04T15:27:34Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzM0NTQ3MzAw",
          "commit": {
            "abbreviatedOid": "75bfe61"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-08-19T23:21:19Z",
          "updatedAt": "2021-09-09T18:20:33Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "There's no notion of a PSK lifetime in the spec, so I'm not sure what this one is talking about.",
              "createdAt": "2021-08-19T23:21:19Z",
              "updatedAt": "2021-09-09T18:20:33Z"
            },
            {
              "originalPosition": 20,
              "body": "Same here for \"security level\".",
              "createdAt": "2021-08-19T23:21:40Z",
              "updatedAt": "2021-09-09T18:20:33Z"
            },
            {
              "originalPosition": 30,
              "body": "A combination algorithm is given above.  If we don't believe it has this property, we should fix it.",
              "createdAt": "2021-08-19T23:22:03Z",
              "updatedAt": "2021-09-09T18:20:33Z"
            },
            {
              "originalPosition": 40,
              "body": "Nobody has asked for this feature, and it can be added in an extension.",
              "createdAt": "2021-08-19T23:22:27Z",
              "updatedAt": "2021-09-09T18:20:33Z"
            },
            {
              "originalPosition": 50,
              "body": "The text already talks about keeping key/nonce pairs (not secrets), which is the right way to do it.  Beyond that, there's not much to say; reordering policy is up to the application.",
              "createdAt": "2021-08-19T23:23:24Z",
              "updatedAt": "2021-09-09T18:20:33Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c4tROp4",
          "commit": {
            "abbreviatedOid": "75bfe61"
          },
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-09-21T09:07:32Z",
          "updatedAt": "2021-09-21T09:12:47Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "It's not in the spec per-se, but external PSKs can have a lifetime (as mentioned in the paragraph above) and this TODO suggests that we might want to clarify that there is a difference in the security guarantees of injecting a PSK vs. doing an update, depending on the lifetime of the PSK.",
              "createdAt": "2021-09-21T09:07:32Z",
              "updatedAt": "2021-09-21T09:12:47Z"
            },
            {
              "originalPosition": 20,
              "body": "\"security level\" is actually mentioned in the spec as a property of the ciphersuite.",
              "createdAt": "2021-09-21T09:08:38Z",
              "updatedAt": "2021-09-21T09:12:47Z"
            },
            {
              "originalPosition": 30,
              "body": "I don't think the security of the algorithm above an be reduced to a \"standard assumption\". This would be what the nKDF approach by @chrisbrzuska was for. I believe we discussed this in the group as a general approach for the key schedule, but then decided against it. There is a (somewhat) standard assumption for doing this with two keys (which we need for key schedule security), but I don't think anyone has claimed this for `n` keys.",
              "createdAt": "2021-09-21T09:12:09Z",
              "updatedAt": "2021-09-21T09:12:47Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c4t1gmx",
          "commit": {
            "abbreviatedOid": "75bfe61"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-01T13:55:31Z",
          "updatedAt": "2021-10-01T13:55:31Z",
          "comments": [
            {
              "originalPosition": 20,
              "body": "Proposed additional paragraph: \r\n\r\n> Unlike the key pairs injected in an Update or Commit, which always freshly generated, PSKs may be pre-distributed and stored.  This creates the risk that a PSK may be compromised in the process of distribution and storage.   The security that the group gets from injecting a PSK thus depends on both the entropy of the PSK and the risk of compromise.  These factors are outside of the scope of this document, but should be considered by application designers relying on PSKs.",
              "createdAt": "2021-10-01T13:55:31Z",
              "updatedAt": "2021-10-01T13:55:31Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c4t1gsg",
          "commit": {
            "abbreviatedOid": "75bfe61"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-01T13:55:53Z",
          "updatedAt": "2021-10-01T13:55:53Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "This should be addressed by the below proposed paragraph.",
              "createdAt": "2021-10-01T13:55:53Z",
              "updatedAt": "2021-10-01T13:55:53Z"
            }
          ]
        }
      ]
    },
    {
      "number": 484,
      "id": "MDExOlB1bGxSZXF1ZXN0NzE2MzMzMjcz",
      "title": "Clarify node vs. leaf indices",
      "url": "https://github.com/mlswg/mls-protocol/pull/484",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #432 ",
      "createdAt": "2021-08-19T23:43:02Z",
      "updatedAt": "2021-10-04T19:50:48Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "e374686f64915720914f3f663c98b47530edc039",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "node-type",
      "headRefOid": "a9ab8f675e0a050a606fa05e66f5b9ceb29a1382",
      "closedAt": "2021-10-04T19:50:48Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "seanturner",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Discussed at 20211004 interim, will be reworked to remove leaf indices. And, be consistent through I-D.",
          "createdAt": "2021-10-04T15:35:23Z",
          "updatedAt": "2021-10-04T15:35:23Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Replaced by #487 ",
          "createdAt": "2021-10-04T19:50:48Z",
          "updatedAt": "2021-10-04T19:50:48Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzM0NzQxMjM2",
          "commit": {
            "abbreviatedOid": "d54dcfe"
          },
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "This certainly helps making thinks a bit clearer. I'd still feel better if we got rid of the notion of a \"leaf index\" entirely, though.",
          "createdAt": "2021-08-20T07:19:32Z",
          "updatedAt": "2021-08-20T07:23:26Z",
          "comments": [
            {
              "originalPosition": 96,
              "body": "Could you elaborate what hat are \"i\" and \"n\" supposed to mean here? Or are those just typos?",
              "createdAt": "2021-08-20T07:19:32Z",
              "updatedAt": "2021-08-20T07:23:26Z"
            },
            {
              "originalPosition": 130,
              "body": "Maybe mark the `sender` field in `MLSSenderData` as of type `// leaf index`?",
              "createdAt": "2021-08-20T07:20:57Z",
              "updatedAt": "2021-08-20T07:23:26Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzUwNjgxNjQx",
          "commit": {
            "abbreviatedOid": "d54dcfe"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-09-09T18:19:24Z",
          "updatedAt": "2021-09-09T18:19:25Z",
          "comments": [
            {
              "originalPosition": 130,
              "body": "Good idea.  I think this paragraph is unnecessary anyway.",
              "createdAt": "2021-09-09T18:19:24Z",
              "updatedAt": "2021-09-09T18:19:25Z"
            }
          ]
        }
      ]
    },
    {
      "number": 487,
      "id": "PR_kwDOBoyH6c4sqIva",
      "title": "Remove the notion of a 'leaf index'",
      "url": "https://github.com/mlswg/mls-protocol/pull/487",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "After discussion at the interim 2021-10-04, there seemed to be agreement to move from having two sets of indices (leaf and node indices) to just using node indices.  The main impact of this is that wherever there is a node index in the protocol that is only ever supposed to refer to a leaf node (`Remove.removed`, `GroupInfo.signer_index`, `MLSPlaintext.sender.sender`, `PublicGroupState.signer_index`), the recipient of the message needs to verify that the node index is actually a leaf.  However, implementations already needed to check that these fields were populated leaves, so the change should be minor.\r\n\r\nImplementations that were using typed message structures to separate node and leaf indices can continue to use those types to assure that validation is done.  They'll just have to multiply by two on serialize and divide on deserialize if they use leaf indices as before internally.\r\n\r\nThere are also a couple of small, unrelated, \"drive-by\" fixes in here:\r\n* Clean up of notation in the ratchet tree section\r\n* Including PublicGroupState signer index in signature (in parallel with GroupInfo)\r\n\r\nReplaces #484 \r\nFixes #432 ",
      "createdAt": "2021-10-04T19:32:25Z",
      "updatedAt": "2021-10-11T19:11:28Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "28195f529017a726f6f3c34700176f6e3f44f9ae",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "only-node-index",
      "headRefOid": "508e8a302a631969285d31140f0887441312006c",
      "closedAt": "2021-10-11T19:11:21Z",
      "mergedAt": "2021-10-11T19:11:21Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "c54fedf5191c0a427a12e8fc257d4841eff22d63"
      },
      "comments": [
        {
          "author": "rohan-wire",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think we should still use \"node index\" instead of just \"index\" for clarity.",
          "createdAt": "2021-10-05T13:37:59Z",
          "updatedAt": "2021-10-05T13:37:59Z"
        },
        {
          "author": "rohan-wire",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I am concerned that concatenating the children to get the name of a node becomes awkward with blank nodes. As we already have the node index, why not just use it to identify non-leaf nodes?\r\n~~~~~\r\n           7 (root)\r\n           /      \\\r\n          /        \\\r\n         /          \\\r\n      3              11\r\n    /    \\          /  \\\r\n   /      \\        /    |\r\n  1       5       9     |\r\n / \\     / \\     / \\    |\r\nA   B   _   D   E   F   G\r\n\r\n                    1 1 1\r\n0 1 2 3 4 5 6 7 8 9 0 1 2\r\n~~~~~\r\n\r\nThis prevents node 5 from being D or _D\r\n",
          "createdAt": "2021-10-05T13:44:41Z",
          "updatedAt": "2021-10-05T13:44:41Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Fair enough.  It also helps emphasize that parent nodes are of a different character than leaf nodes.  Just pushed a commit with numeric parent node labels and otherwise improved ASCII art.",
          "createdAt": "2021-10-05T14:34:36Z",
          "updatedAt": "2021-10-05T14:34:36Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOBoyH6c4t9Ix6",
          "commit": {
            "abbreviatedOid": "efa1dd8"
          },
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-10-05T05:49:49Z",
          "updatedAt": "2021-10-05T05:49:49Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOBoyH6c4uMwzY",
          "commit": {
            "abbreviatedOid": "7a28c80"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "LGTM in general! It might be worth specifying in the tree math section that the number of leaves in a tree is `(n_nodes + 1) / 2`, where `n_nodes` is the total number of nodes in the tree. Some functions like `root` take the number of leaves as an argument and this might now be confusing.",
          "createdAt": "2021-10-08T14:38:00Z",
          "updatedAt": "2021-10-08T14:38:00Z",
          "comments": []
        }
      ]
    },
    {
      "number": 488,
      "id": "PR_kwDOBoyH6c4sqMdF",
      "title": "Add group_context_extensions proposal ID",
      "url": "https://github.com/mlswg/mls-protocol/pull/488",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Accidental omission in #479 ",
      "createdAt": "2021-10-04T19:56:47Z",
      "updatedAt": "2021-10-04T19:57:51Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "2eb85927d4159c59c4b5ca1efc2de9142ddaa282",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "group-context-extensions",
      "headRefOid": "570320df72c932e80109a8296efd94c2f242e35d",
      "closedAt": "2021-10-04T19:57:51Z",
      "mergedAt": "2021-10-04T19:57:51Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "b7a741e3d2b48252d3f005274d93d2e4212bcf12"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 489,
      "id": "PR_kwDOBoyH6c4sqSFX",
      "title": "Add RequiredCapabilities extension",
      "url": "https://github.com/mlswg/mls-protocol/pull/489",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This PR adds a RequiredCapabilities extension that allows the members of a group to impose a requirement that new joiners support certain capabilities.  The extension is carried in the GroupContext and verified at Add time (including on external commits).\r\n\r\nIn the interim 2021-10-04, we briefly discussed whether this mechanism needed to be included in the core protocol.  Because of its interactions with Add and GroupContextExtensions proposals, it seems worth having in the main protocol.\r\n\r\nFixes #485 ",
      "createdAt": "2021-10-04T20:26:48Z",
      "updatedAt": "2021-10-11T19:25:20Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "b7a741e3d2b48252d3f005274d93d2e4212bcf12",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "required-extensions",
      "headRefOid": "7f4be72694eea252f54cddab1fb0b141e47a7c4f",
      "closedAt": "2021-10-11T19:25:20Z",
      "mergedAt": "2021-10-11T19:25:19Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "fb1043e8699af9562a1ba0a6d0d0210072c252bf"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOBoyH6c4uM5TW",
          "commit": {
            "abbreviatedOid": "bd1a633"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-08T15:09:35Z",
          "updatedAt": "2021-10-08T15:15:40Z",
          "comments": [
            {
              "originalPosition": 33,
              "body": "```suggestion\r\nall members of the group.  For new members, it is enforced by existing members during the\r\n```",
              "createdAt": "2021-10-08T15:09:35Z",
              "updatedAt": "2021-10-08T15:15:40Z"
            }
          ]
        }
      ]
    },
    {
      "number": 490,
      "id": "PR_kwDOBoyH6c4sqTVa",
      "title": "Use cascaded KDF instead of concatenation to consolidate PSKs",
      "url": "https://github.com/mlswg/mls-protocol/pull/490",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "In #483, @kkohbrok noted that the concatenation approach used to combine multiple PSKs is not well validated.  At the 2021-10-04 interim, we discussed moving from this approach to a \"cascaded HKDF\" approach, with the idea of doing the same thing here as the main key schedule.  This PR implements that suggestion.\r\n\r\nOne nice implication of the algorithm here is that when there are no PSKs, it produces the zero vector as a degenerate case.  So you could implement it pretty cleanly:\r\n\r\n```\r\npsk_secret = 0\r\nfor psk in psks:\r\n    psk_secret = kdf.extract(psk_secret, extract_expand_psk(psk))\r\n\r\n# Inject psk_secret into key schedule\r\n```",
      "createdAt": "2021-10-04T20:34:00Z",
      "updatedAt": "2021-10-11T19:02:20Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "b7a741e3d2b48252d3f005274d93d2e4212bcf12",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "cascade-hkdf",
      "headRefOid": "3e677773c60836d901c6ed431a342e7b2cd94ce6",
      "closedAt": "2021-10-11T19:02:20Z",
      "mergedAt": "2021-10-11T19:02:20Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "16d8d64a06a7dbc469c90b09d821e00140eed11a"
      },
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixes #493 ",
          "createdAt": "2021-10-11T14:29:57Z",
          "updatedAt": "2021-10-11T14:29:57Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOBoyH6c4t9Hp0",
          "commit": {
            "abbreviatedOid": "20801e5"
          },
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "Looks good with a small proposed addition.",
          "createdAt": "2021-10-05T05:40:04Z",
          "updatedAt": "2021-10-05T05:44:41Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "```suggestion\r\npsk_input_[i] = ExpandWithLabel(psk_extracted_[i], sprintf(\"derived psk %i\", i), PSKLabel, KDF.Nh)\r\n```\r\nTo err on the side of caution, I'd like to bake the structure of the cascade into the keys themselves. This ensures that you can't \"extend\" a cascade by taking the result of a cascade and use it to start a new one. Not something that would happen in the wild, I think, but it makes proofs easier and doesn't cost anything. The simple implementation you suggest would still work, you just have to add a counter.\r\n\r\n(Not sure if the suggested line above is probably not what we want in the spec, but I think you understand what I mean.)",
              "createdAt": "2021-10-05T05:40:05Z",
              "updatedAt": "2021-10-05T05:44:41Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c4t-1lq",
          "commit": {
            "abbreviatedOid": "20801e5"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-05T13:28:44Z",
          "updatedAt": "2021-10-05T13:28:44Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "`n` and `i` are actually already included here, via the PSKLabel struct.  So I think we already have this property.",
              "createdAt": "2021-10-05T13:28:44Z",
              "updatedAt": "2021-10-05T13:28:44Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c4t_P0b",
          "commit": {
            "abbreviatedOid": "20801e5"
          },
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-05T14:47:31Z",
          "updatedAt": "2021-10-05T14:47:31Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "Ah, you are right, of course. Feel free to mark as resolved.",
              "createdAt": "2021-10-05T14:47:31Z",
              "updatedAt": "2021-10-05T14:48:19Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c4uGiO5",
          "commit": {
            "abbreviatedOid": "20801e5"
          },
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-10-07T05:44:56Z",
          "updatedAt": "2021-10-07T05:44:56Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOBoyH6c4uNMUP",
          "commit": {
            "abbreviatedOid": "20801e5"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-10-08T16:30:33Z",
          "updatedAt": "2021-10-08T16:30:33Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOBoyH6c4uRaVu",
          "commit": {
            "abbreviatedOid": "3e67777"
          },
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "One brief comment, otherwise looks good!",
          "createdAt": "2021-10-11T14:38:02Z",
          "updatedAt": "2021-10-11T14:38:52Z",
          "comments": [
            {
              "originalPosition": 19,
              "body": "... of length `KDF.n`. (?)",
              "createdAt": "2021-10-11T14:38:03Z",
              "updatedAt": "2021-10-11T14:38:52Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c4uRde9",
          "commit": {
            "abbreviatedOid": "3e67777"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-11T14:49:25Z",
          "updatedAt": "2021-10-11T14:49:26Z",
          "comments": [
            {
              "originalPosition": 19,
              "body": "We specify the length just a couple of paragraphs above (\"Here `0` represents...\"), so I thought it was clear enough to leave it out here.",
              "createdAt": "2021-10-11T14:49:25Z",
              "updatedAt": "2021-10-11T14:49:26Z"
            }
          ]
        }
      ]
    },
    {
      "number": 491,
      "id": "PR_kwDOBoyH6c4srU9H",
      "title": "Use key package hash to index clients in message structs",
      "url": "https://github.com/mlswg/mls-protocol/pull/491",
      "state": "MERGED",
      "author": "kkohbrok",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "This PR changes the message structs such that clients are now represented by the following struct instead of leaf indices:\r\n\r\n```\r\nstruct {\r\n    opaque sender_identity;\r\n    opaque sender_endpoint_id;\r\n} Client\r\n```\r\n\r\nI called the struct `Client`, as opposed to `Member` or `GroupMember`, since there are places where group membership first needs to be verified. Let me know what your thoughts are! \r\n\r\nFixes #486.",
      "createdAt": "2021-10-05T06:38:15Z",
      "updatedAt": "2021-10-11T19:21:47Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "c54fedf5191c0a427a12e8fc257d4841eff22d63",
      "headRepository": "kkohbrok/mls-protocol",
      "headRefName": "identity_in_msg_structs",
      "headRefOid": "ab1e23ae57a7699e097fea160268bcdc7d19c09d",
      "closedAt": "2021-10-11T19:21:47Z",
      "mergedAt": "2021-10-11T19:21:47Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "df3d41e4b6a02401b0a9d9d08bad1c81de8bc60f"
      },
      "comments": [
        {
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I've made another pass, integrating a lot of your feedback and suggestions. I did not touch the proposal processing restriction yet. We could mandate that one can't update and then remove, but I think a cleaner way would be to say that the KeyPackageID always refers to the tree of the last epoch, not the provisional tree. Let me know what you think!",
          "createdAt": "2021-10-07T10:06:00Z",
          "updatedAt": "2021-10-07T10:06:00Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOBoyH6c4t-_9s",
          "commit": {
            "abbreviatedOid": "002cf1b"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-05T14:00:22Z",
          "updatedAt": "2021-10-05T14:09:35Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "The bloat induced by this makes me pretty sad, and relying on just these two fields seems a little brittle.\r\n\r\nAs an alternative, what about using a hash of the leaf KeyPackage?:\r\n* We only care about exact equality of these things, so we could use a hash of these values.  That also has the benefit of revealing less information on the wire.\r\n* We only care about populated leaves, which contain a KeyPackage\r\n* We already need `KeyPackage.hash()` for purposes of building/processing Welcome messages\r\n\r\nThat would get you down to the more compact:\r\n\r\n```\r\nuint8 KeyPackageID<0..255>;\r\n```\r\n\r\nI would be slightly happier if it were a fixed-length value and shorter than a hash output.  It's tempting to propose truncating the hash down to 128 bits, which seems unlikely to result in collisions in any practical scenario.  If it is fixed-length, you could have a nice compact value:\r\n\r\n```\r\nuint8 KeyPackageID[16];\r\n```",
              "createdAt": "2021-10-05T14:00:22Z",
              "updatedAt": "2021-10-05T14:09:35Z"
            },
            {
              "originalPosition": 12,
              "body": "I don't think this quite works.  Remember that we have multiple sender types to accommodate: `member`, `preconfigured`, and `new_member`.  This covers the `member` case.  We should probably have a switch/variant struct here (probably always should have).\r\n\r\n```\r\nstruct {\r\n    SenderType sender_type;\r\n    switch (sender_type) {\r\n        case member:        Client client;\r\n        case preconfigured: opaque key_id<0..255>;\r\n        case new_member:    struct{};\r\n    }\r\n} Sender;\r\n```\r\n",
              "createdAt": "2021-10-05T14:05:27Z",
              "updatedAt": "2021-10-05T14:09:35Z"
            },
            {
              "originalPosition": 34,
              "body": "```suggestion\r\nMUST verify that the `Client` indicated in the `sender` field is a member of the\r\n```",
              "createdAt": "2021-10-05T14:07:05Z",
              "updatedAt": "2021-10-05T14:09:35Z"
            },
            {
              "originalPosition": 12,
              "body": "Note that you can still use `Client` in MLSSenderData, because that always corresponds to the `member` case.",
              "createdAt": "2021-10-05T14:07:42Z",
              "updatedAt": "2021-10-05T14:09:35Z"
            },
            {
              "originalPosition": 92,
              "body": "I actually think the old wording is clearer.  In general, I would still talk about these `Client` values as indices, since you need to look up leaves in the tree to get credentials, signature keys, etc.",
              "createdAt": "2021-10-05T14:09:18Z",
              "updatedAt": "2021-10-05T14:09:35Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c4t_DXL",
          "commit": {
            "abbreviatedOid": "002cf1b"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-05T14:10:42Z",
          "updatedAt": "2021-10-05T14:10:43Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "Note also that if we make a smaller-than-hash-KeyPackage-ID thing here, we should also use it in Welcome.",
              "createdAt": "2021-10-05T14:10:42Z",
              "updatedAt": "2021-10-05T14:10:43Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c4uBzoZ",
          "commit": {
            "abbreviatedOid": "002cf1b"
          },
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-06T06:06:52Z",
          "updatedAt": "2021-10-06T06:06:52Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "I like the idea, although I'm always a bit skeptical when it comes to shortening hashes. In this case it doesn't serve much of a security purpose, but I'd still prefer the full hash.",
              "createdAt": "2021-10-06T06:06:52Z",
              "updatedAt": "2021-10-06T06:06:52Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c4uB0kB",
          "commit": {
            "abbreviatedOid": "002cf1b"
          },
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-06T06:13:15Z",
          "updatedAt": "2021-10-06T06:13:16Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "Any suggestions for a name, though? The KeyPackage hash does not really represent the client anymore, but rather the client's presence in this particular group. (Calling it `MemberId` for now, although I thought there were cases where the specified party is not (yet) a member.)",
              "createdAt": "2021-10-06T06:13:16Z",
              "updatedAt": "2021-10-06T06:17:58Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c4uB00V",
          "commit": {
            "abbreviatedOid": "002cf1b"
          },
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-06T06:14:56Z",
          "updatedAt": "2021-10-06T06:14:56Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "Good point! I'll change it as suggested.",
              "createdAt": "2021-10-06T06:14:56Z",
              "updatedAt": "2021-10-06T06:14:56Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c4uELPP",
          "commit": {
            "abbreviatedOid": "0e1675b"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-06T15:10:48Z",
          "updatedAt": "2021-10-06T15:10:48Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "I kind of like `KeyPackageID`, as above.",
              "createdAt": "2021-10-06T15:10:48Z",
              "updatedAt": "2021-10-06T15:10:48Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c4uEL_D",
          "commit": {
            "abbreviatedOid": "0e1675b"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-06T15:13:04Z",
          "updatedAt": "2021-10-06T15:33:35Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "It would be cleaner just to add something like the following to the end of the `{{key-packages}}`:\r\n\r\nWhen it is necessary to refer to KeyPackage, protocol messages incorporate a KeyPackageHash:\r\n\r\n```\r\nopaque KeyPackageHash<0..255>;\r\n```\r\n\r\nThis value is the hash of the KeyPackage, using the hash indicated by the `cipher_suite` field.  KeyPackage hashes are used in a Welcome message to indicate which KeyPackage is being used to include the new member.  Since members of a group are uniquely identified by their leaf KeyPackages, messages within a group use the hash of this key package to refer group members, e.g., to specify the target of a Remove proposal or the signer of an MLSPlaintext.",
              "createdAt": "2021-10-06T15:25:30Z",
              "updatedAt": "2021-10-06T15:33:35Z"
            },
            {
              "originalPosition": 6,
              "body": "Then we should clean up the `Welcome` section so that the `EncryptedGroupSecrets` refers to `KeyPackageHash` and the corresponding text is more succinct.",
              "createdAt": "2021-10-06T15:26:27Z",
              "updatedAt": "2021-10-06T15:33:35Z"
            },
            {
              "originalPosition": 6,
              "body": "In any case, I don't think this extra layer of `struct` wrapping is needed.",
              "createdAt": "2021-10-06T15:26:44Z",
              "updatedAt": "2021-10-06T15:33:35Z"
            },
            {
              "originalPosition": 48,
              "body": "Nit: I would not use backticks around MemberId / KeyPackageHash / whatever.  (The style rule I'm generally trying to follow is that words with initial caps are not backticked, while lowercase words are.)",
              "createdAt": "2021-10-06T15:27:56Z",
              "updatedAt": "2021-10-06T15:33:35Z"
            },
            {
              "originalPosition": 76,
              "body": "I would revert this change.  I think \"the removed leaf\" is clearer.",
              "createdAt": "2021-10-06T15:28:22Z",
              "updatedAt": "2021-10-06T15:33:35Z"
            },
            {
              "originalPosition": 76,
              "body": "You could also break this out into three steps:\r\n\r\n* Identify a leaf node containing a key package matching `removed`.  Let `removed_index` be the node index of this leaf node.\r\n* Replace the leaf node at `index` with a blank node\r\n* Blank the intermediate nodes along the path from `index` to the root",
              "createdAt": "2021-10-06T15:30:02Z",
              "updatedAt": "2021-10-06T15:33:35Z"
            },
            {
              "originalPosition": 141,
              "body": "\"leaf node index\"",
              "createdAt": "2021-10-06T15:33:25Z",
              "updatedAt": "2021-10-06T15:33:35Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c4uEevp",
          "commit": {
            "abbreviatedOid": "0e1675b"
          },
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-06T15:52:53Z",
          "updatedAt": "2021-10-06T15:52:54Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "Sounds like a good approach. I'll also note, that while we use a KeyPackage hash to identify members, these hashes change when the key package is updated, whereas the identity of the member does not. This could lead to errors, for example, when processing a `remove` right after an `update` for the same member was processed. I'm not entirely sure that's actually possible, but maybe you understand my concern. I don't want people to thing that KeyPackage hashes are static mappings to members.",
              "createdAt": "2021-10-06T15:52:53Z",
              "updatedAt": "2021-10-06T15:52:54Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c4uEgVJ",
          "commit": {
            "abbreviatedOid": "0e1675b"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-06T15:58:17Z",
          "updatedAt": "2021-10-06T15:58:17Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "Good point.  And to make it worse, we have the following:\r\n\r\n> Update proposals are applied first, followed by Remove proposals\r\n\r\nMaybe we should just declare that a single Commit containing an Update and a Remove for the same leaf is invalid.",
              "createdAt": "2021-10-06T15:58:17Z",
              "updatedAt": "2021-10-06T15:58:17Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c4uGioF",
          "commit": {
            "abbreviatedOid": "0e1675b"
          },
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-07T05:48:28Z",
          "updatedAt": "2021-10-07T05:48:28Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "That would make sense, since updating and then immediately removing is rather pointless. Alternatively, we could make the KeyPackageID relative to the tree of the last epoch.",
              "createdAt": "2021-10-07T05:48:28Z",
              "updatedAt": "2021-10-07T05:48:28Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c4uGkAt",
          "commit": {
            "abbreviatedOid": "0e1675b"
          },
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-07T05:59:54Z",
          "updatedAt": "2021-10-07T05:59:55Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "> In any case, I don't think this extra layer of `struct` wrapping is needed.\r\n\r\nThe advantage of keeping the struct layer is that the type is more expressive. If we don't have the struct, we end up with, for example, \r\n\r\n```\r\n~~~~~\r\nstruct {\r\n     opaque removed<0..255>;\r\n} Remove;\r\n~~~~~\r\n```\r\nwithout any indication what `removed` actually is. ",
              "createdAt": "2021-10-07T05:59:55Z",
              "updatedAt": "2021-10-07T05:59:55Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c4uIhuV",
          "commit": {
            "abbreviatedOid": "ce48f19"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-07T14:26:58Z",
          "updatedAt": "2021-10-07T14:26:58Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "We are getting a little deep in the minutiae of TLS syntax expression, but I was thinking you could do something like:\r\n\r\n```\r\nopaque KeyPackageHash<0..255>;\r\n\r\nstruct {\r\n    KeyPackageHash removed;\r\n} Remove;\r\n```\r\n\r\nBut since there's no actual overhead to the struct wrapping, I'm fine to keep it.",
              "createdAt": "2021-10-07T14:26:58Z",
              "updatedAt": "2021-10-07T14:26:58Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c4uIidv",
          "commit": {
            "abbreviatedOid": "ce48f19"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-07T14:29:04Z",
          "updatedAt": "2021-10-07T14:29:04Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "> That would make sense, since updating and then immediately removing is rather pointless. Alternatively, we could make the KeyPackageID relative to the tree of the last epoch.\r\n\r\nThe latter suggestion seems a little neater to me.  It avoids the need for more complex validation of the proposal list.  It does requires you keep a reference to the old tree (or at least a `KeyPackageID -> node index` map), but that doesn't seem as  bad to me.",
              "createdAt": "2021-10-07T14:29:04Z",
              "updatedAt": "2021-10-07T14:29:04Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c4uI2sn",
          "commit": {
            "abbreviatedOid": "ce48f19"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-07T15:30:19Z",
          "updatedAt": "2021-10-07T15:42:18Z",
          "comments": [
            {
              "originalPosition": 77,
              "body": "```suggestion\r\n* Replace the leaf node at `removed_index` with a blank node\r\n\r\n* Blank the intermediate nodes along the path from `removed_index` to the root\r\n```",
              "createdAt": "2021-10-07T15:30:20Z",
              "updatedAt": "2021-10-07T15:42:18Z"
            },
            {
              "originalPosition": 6,
              "body": "```suggestion\r\nstruct {\r\n    opaque key_package_hash<0..255>;\r\n} KeyPackageID\r\n```\r\n\r\nStill some issues here:\r\n1. It would be good if we could use a phrase other than \"ID\" here, because we already have the `key_id` extension.  KeyPackageHash if you want to be concrete, or KeyPackageRef if you want to be parallel with ProposalOrRef (which also refers to objects by hash).\r\n2. You don't define what this value is.  You need to specify that it is the hash of the KP with the ciphersuite.\r\n3. You haven't updated EncryptedGroupSecrets to use this instead of its own struct.  \r\n\r\nFor (2), suggest adding the following to the \"Key Packages\" section:\r\n\r\nWhen it is necessary to refer to KeyPackage, protocol messages incorporate a KeyPackageID:\r\n\r\n```suggestion\r\nstruct {\r\n    opaque key_package_hash<0..255>;\r\n} KeyPackageID\r\n```\r\n\r\nThis value is the hash of the KeyPackage, using the hash indicated by the cipher_suite field. KeyPackage hashes are used in a Welcome message to indicate which KeyPackage is being used to include the new member. Since members of a group are uniquely identified by their leaf KeyPackages, messages within a group use the hash of this key package to refer group members, e.g., to specify the target of a Remove proposal or the signer of an MLSPlaintext.",
              "createdAt": "2021-10-07T15:37:45Z",
              "updatedAt": "2021-10-07T15:42:18Z"
            },
            {
              "originalPosition": 73,
              "body": "```suggestion\r\n* Identify a leaf node containing a key package matching `removed`.  This \r\n  lookup MUST be done on the tree before any non-Remove proposals have\r\n  been applied (the \"old\" tree in the terminology of {{commit}}), since \r\n  proposals such as Update can change the KeyPackage stored at a leaf. \r\n  Let `removed_index` be the node index of this leaf node.\r\n```",
              "createdAt": "2021-10-07T15:41:31Z",
              "updatedAt": "2021-10-07T15:42:18Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c4uLAqo",
          "commit": {
            "abbreviatedOid": "d7be495"
          },
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-08T06:30:39Z",
          "updatedAt": "2021-10-08T06:30:39Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "Thanks for the suggestions! Regarding (1): Do I understand correctly, that you want to rename `KeyPackageID`? While I agree that `KeyPackageID` could be confused with the `key_id` extension, if anything, I think we should rename `key_id` to `external_key_id`. Even in the `KeyPackage Identifiers` section it states that KeyPackages are identified by their hash and that `key_id` is a way to have some extra, external identifier for a key package. So the canonical KeyPackageID should be the hash.",
              "createdAt": "2021-10-08T06:30:39Z",
              "updatedAt": "2021-10-08T06:30:39Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c4uMjSx",
          "commit": {
            "abbreviatedOid": "10953ef"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Thanks for the work on this @kkohbrok.  Looks good to me!",
          "createdAt": "2021-10-08T13:54:20Z",
          "updatedAt": "2021-10-08T13:54:20Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOBoyH6c4uNN4V",
          "commit": {
            "abbreviatedOid": "10953ef"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "CHANGES_REQUESTED",
          "body": "I think `EncryptedGroupSecrets` could also benefit from this:\r\n\r\n```\r\nstruct {\r\n  KeyPackageID new_member<1..255>;\r\n  HPKECiphertext encrypted_group_secrets;\r\n} EncryptedGroupSecrets;\r\n```\r\n\r\nBefore we merge this, it would be good to try and implement it first. We lose the 1:1 mapping with indices because of the hash and that might lead to UB potentially.",
          "createdAt": "2021-10-08T16:38:09Z",
          "updatedAt": "2021-10-08T16:42:25Z",
          "comments": [
            {
              "originalPosition": 178,
              "body": "This re-introduces leaf node indices.",
              "createdAt": "2021-10-08T16:38:09Z",
              "updatedAt": "2021-10-08T16:42:25Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c4uRRcD",
          "commit": {
            "abbreviatedOid": "f28460a"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-10-11T14:06:22Z",
          "updatedAt": "2021-10-11T14:06:22Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOBoyH6c4uRRzH",
          "commit": {
            "abbreviatedOid": "f28460a"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-11T14:07:40Z",
          "updatedAt": "2021-10-11T14:07:40Z",
          "comments": [
            {
              "originalPosition": 178,
              "body": "I understood \"leaf node index\" to mean \"the node index of this leaf node\".  This may be confusing for those of us who still have the idea of \"leaf indices\" in cache, but for new readers (and once our cache expires), it seems clear.",
              "createdAt": "2021-10-11T14:07:40Z",
              "updatedAt": "2021-10-11T14:07:40Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c4uRTC1",
          "commit": {
            "abbreviatedOid": "f28460a"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-10-11T14:12:07Z",
          "updatedAt": "2021-10-11T14:12:07Z",
          "comments": []
        }
      ]
    },
    {
      "number": 492,
      "id": "PR_kwDOBoyH6c4stH5E",
      "title": "Add a 'reserved' field to WireFormat",
      "url": "https://github.com/mlswg/mls-protocol/pull/492",
      "state": "MERGED",
      "author": "raphaelrobert",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "The `WireFormat` `enum` was not aligned with other enums in that it did not contain the mandatory `reserved` field.",
      "createdAt": "2021-10-05T16:07:55Z",
      "updatedAt": "2021-10-08T22:19:51Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "b7a741e3d2b48252d3f005274d93d2e4212bcf12",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "wireformat-fix",
      "headRefOid": "ba39087ab50579a0294313f06eb22524453fc40d",
      "closedAt": "2021-10-06T15:08:28Z",
      "mergedAt": "2021-10-06T15:08:28Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "e277f4187aa8e2af9da5b57fbbf7b909faf1edc8"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOBoyH6c4uBFzE",
          "commit": {
            "abbreviatedOid": "ba39087"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-10-05T22:23:04Z",
          "updatedAt": "2021-10-05T22:23:04Z",
          "comments": []
        }
      ]
    },
    {
      "number": 494,
      "id": "PR_kwDOBoyH6c4s5M3S",
      "title": "Don't require PublicGroupState for external init",
      "url": "https://github.com/mlswg/mls-protocol/pull/494",
      "state": "MERGED",
      "author": "kkohbrok",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "There is really no benefit in requiring the whole PublicGroupState, inclucing signer and signature. Instead, this complicates things, since upon receiving a commit with an external init, the client has to fetch the PGS that was used for the external init, since they need it to compute the external init secret.\r\n\r\nFrom what I can see, the only thing we really gain from using the signed PGS is a degree of attribution, where upon an external init, every group member knows who authored the PGS that was used for the external init. Feel free to disagree, but I don't think that's a property we really need here.\r\n\r\nThis PR makes it such that the `PublicGroupStateTBS` is used to compute the external init secret instead of the `PublicGroupState`.",
      "createdAt": "2021-10-07T13:33:23Z",
      "updatedAt": "2021-10-11T19:02:50Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "e277f4187aa8e2af9da5b57fbbf7b909faf1edc8",
      "headRepository": "kkohbrok/mls-protocol",
      "headRefName": "improve_ext_init",
      "headRefOid": "428d50efd2cfcb8e8c38ae8aba72fe36beb9bd86",
      "closedAt": "2021-10-11T19:02:50Z",
      "mergedAt": "2021-10-11T19:02:50Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "323ea9418d38b3964345903184d49fa0794df9c9"
      },
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "IIUC the idea here is that the recipient of an external commit has what they need to compute everything in the PublicGroupStateTBS, but not the PublicGroupState (with signature).  So if the context is PublicGroupState, the receiver has to be provided the specific PGS that the joiner is using, but if the context is just PublicGroupStateTBS, then they can just recompute it locally.\r\n\r\nIt's a good idea, but unfortunately, it doesn't actually work.  PublicGroupStateTBS still has an `other_extensions` field, which holds any data that the creator of the PublicGroupState wants to send to the external joiner -- and the other members of the group may or may not be aware of.\r\n\r\nI would suggest that adding the PublicGroupState isn't actually necessary here.  PublicGroupState is analogous to GroupInfo, and we don't put GroupInfo into the transcript.  Instead, the group agreement properties of the key schedule guard against a rogue GroupInfo creator putting false information in.  The same applies here.  If we look at the fields in PublicGroupState, everything up to `group_context_extensions` is covered by the GroupContext agreement, as is `external_pub` (since a different public key will lead to a different `init_secret`).  So for both GroupInfo and PublicGroupState, the only field the sender can manipulate is `other_extensions`, which is the intended semantic of the field; indeed, it has no other semantic than \"anything the sender wants to put here\".\r\n\r\nNet of all that, I would suggest we just leave the `info` input to `SetupBaseS` empty.\r\n\r\n(Conveniently, this matches what [mlspp does today](https://github.com/cisco/mlspp/blob/99748b808919be687f560ae55a4c781b0014ea2b/src/key_schedule.cpp#L497), which is why our development/testing didn't catch this problem.  Thanks for reading more carefully, @kkohbrok!)",
          "createdAt": "2021-10-07T14:22:38Z",
          "updatedAt": "2021-10-07T14:22:38Z"
        },
        {
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "body": "Good point about the `other_extensions` field. You could argue that members should roughly agree on what should go in there, but there is no guarantee that they can recreate the exact content down to the last byte locally.",
          "createdAt": "2021-10-08T14:21:30Z",
          "updatedAt": "2021-10-08T14:21:30Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOBoyH6c4uIQmc",
          "commit": {
            "abbreviatedOid": "f2be874"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-10-07T13:35:42Z",
          "updatedAt": "2021-10-07T13:35:42Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOBoyH6c4uIgWY",
          "commit": {
            "abbreviatedOid": "f2be874"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-07T14:22:59Z",
          "updatedAt": "2021-10-07T14:23:38Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "```suggestion\r\nkem_output, context = SetupBaseS(external_pub, \"\")\r\n```",
              "createdAt": "2021-10-07T14:22:59Z",
              "updatedAt": "2021-10-07T14:23:38Z"
            },
            {
              "originalPosition": 14,
              "body": "```suggestion\r\ncontext = SetupBaseR(kem_output, external_priv, \"\")\r\n```",
              "createdAt": "2021-10-07T14:23:13Z",
              "updatedAt": "2021-10-07T14:23:38Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c4uMrml",
          "commit": {
            "abbreviatedOid": "428d50e"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-10-08T14:21:42Z",
          "updatedAt": "2021-10-08T14:21:42Z",
          "comments": []
        }
      ]
    },
    {
      "number": 495,
      "id": "PR_kwDOBoyH6c4s8y1W",
      "title": "Affiliation change",
      "url": "https://github.com/mlswg/mls-protocol/pull/495",
      "state": "MERGED",
      "author": "raphaelrobert",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2021-10-08T15:17:38Z",
      "updatedAt": "2021-10-08T22:20:16Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "e277f4187aa8e2af9da5b57fbbf7b909faf1edc8",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "raphaelrobert-affiliation",
      "headRefOid": "6730b1c22878e6afe6c95f215b04797f22e2d853",
      "closedAt": "2021-10-08T15:49:41Z",
      "mergedAt": "2021-10-08T15:49:41Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "87035094cc4ccd38c975d9fb0a688758a55495d3"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOBoyH6c4uNDGv",
          "commit": {
            "abbreviatedOid": "6730b1c"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-10-08T15:49:35Z",
          "updatedAt": "2021-10-08T15:49:35Z",
          "comments": []
        }
      ]
    },
    {
      "number": 496,
      "id": "PR_kwDOBoyH6c4tCRVP",
      "title": "Normalize the description of the zero vector",
      "url": "https://github.com/mlswg/mls-protocol/pull/496",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Right now, the vector `0` is described in a couple of ways.  This PR standardizes on \"of length `KDF.Nh`\".",
      "createdAt": "2021-10-11T19:33:55Z",
      "updatedAt": "2021-10-11T19:34:49Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "2bc4ae1f4ba1a4fe81852e101e17ac0550897a91",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "nh",
      "headRefOid": "e7b1426de2092ddbecc9653c140da661d8f3df31",
      "closedAt": "2021-10-11T19:34:48Z",
      "mergedAt": "2021-10-11T19:34:48Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "7d4cbc4e5c9bb835649ec7a3b8ef29c2edb6be8e"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 497,
      "id": "PR_kwDOBoyH6c4tCUoV",
      "title": "Add changelog for draft-12",
      "url": "https://github.com/mlswg/mls-protocol/pull/497",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2021-10-11T19:59:32Z",
      "updatedAt": "2021-10-11T20:02:10Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "7d4cbc4e5c9bb835649ec7a3b8ef29c2edb6be8e",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "changelog-12",
      "headRefOid": "384d08ba52a19524201805a4a75a392fdb347b54",
      "closedAt": "2021-10-11T20:02:10Z",
      "mergedAt": "2021-10-11T20:02:10Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "fefeaf0a5ae3c4daebcacf8ac752aefebf867842"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 501,
      "id": "PR_kwDOBoyH6c4tfxic",
      "title": "Add ciphersuite field to `PublicGroupStateTBS`",
      "url": "https://github.com/mlswg/mls-protocol/pull/501",
      "state": "MERGED",
      "author": "kkohbrok",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #498.",
      "createdAt": "2021-10-21T13:54:01Z",
      "updatedAt": "2021-11-19T20:22:47Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "fefeaf0a5ae3c4daebcacf8ac752aefebf867842",
      "headRepository": "kkohbrok/mls-protocol",
      "headRefName": "add_ciphersuite_to_pgs",
      "headRefOid": "d5b5954a813852b20a90aba1b41edb8283bfe097",
      "closedAt": "2021-11-19T20:22:47Z",
      "mergedAt": "2021-11-19T20:22:47Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "0aa8fce7086292984c40d55c629d99ef0c78a881"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOBoyH6c4v6dq0",
          "commit": {
            "abbreviatedOid": "0f6fb0e"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "CHANGES_REQUESTED",
          "body": "Good point! The protocol version was also missing. New joiners learn this from the `Welcome` message normally, that's why it wasn't included in the `GroupInfo` again.\r\n\r\nThe protocol version should also be repeated in the `PublicGroupState`.",
          "createdAt": "2021-11-11T14:26:42Z",
          "updatedAt": "2021-11-11T14:29:35Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "```suggestion\r\n    ProtocolVersion version = mls10;\r\n    CipherSuite cipher_suite;\r\n```",
              "createdAt": "2021-11-11T14:26:42Z",
              "updatedAt": "2021-11-11T14:29:35Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c4v6kgK",
          "commit": {
            "abbreviatedOid": "0f6fb0e"
          },
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-11-11T14:50:55Z",
          "updatedAt": "2021-11-11T14:50:56Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "Can't the ProtocolVersion be inferred from the Ciphersuite?",
              "createdAt": "2021-11-11T14:50:55Z",
              "updatedAt": "2021-11-11T14:50:56Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c4wYLab",
          "commit": {
            "abbreviatedOid": "0f6fb0e"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-11-19T20:21:24Z",
          "updatedAt": "2021-11-19T20:21:24Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "No.  That's why they're separate fields in KeyPackage.",
              "createdAt": "2021-11-19T20:21:24Z",
              "updatedAt": "2021-11-19T20:21:24Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c4wYLqk",
          "commit": {
            "abbreviatedOid": "d5b5954"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-11-19T20:22:41Z",
          "updatedAt": "2021-11-19T20:22:41Z",
          "comments": []
        }
      ]
    },
    {
      "number": 507,
      "id": "PR_kwDOBoyH6c4uiF4t",
      "title": "Getting rid of the array representation",
      "url": "https://github.com/mlswg/mls-protocol/pull/507",
      "state": "CLOSED",
      "author": "franziskuskiefer",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Filing this on behalf of @TWal after discussions with @kkohbrok and @karthikbhargavan.\r\n\r\nThe idea behind it is that the array representation is only one possible implementation for the tree. This PR removes the reliance on nodes indices to address nodes in the tree.\r\n\r\nI'll leave it to @TWal to write a more detailed description.",
      "createdAt": "2021-11-15T13:20:37Z",
      "updatedAt": "2021-12-07T14:51:39Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "fefeaf0a5ae3c4daebcacf8ac752aefebf867842",
      "headRepository": "TWal/mls-protocol",
      "headRefName": "twal_tree_math",
      "headRefOid": "7b4704ef4b79ec7e80f5ebc690620eadcad32723",
      "closedAt": "2021-12-07T14:49:31Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "TWal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thank you Franziskus!\r\n\r\nThe array representation is used in three places:\r\n- in the tree hash (section 7.6),\r\n- in the secret tree (section 8.3) and in the ratchet (section 8.4),\r\n- in the ratchet_tree extension (section 11.3).\r\n\r\nIn the tree hash, we remove the node index in `ParentNodeTreeHashInput`, but keep a leaf index in `LeafNodeHashInput`. The leaf index is actually not needed if we only use the tree hash of the root, but if the protocol evolves later to use tree hashes of subtrees, it is actually important since they give information about where the subtree is located in the whole tree.\r\n\r\nIn the secret tree, we replace the node indices in the KDF by some \"left\" and \"right\" information which are sufficient.\r\n\r\nFor the ratchet_tree extension, we state that the order in which the nodes are serialized is the in-order traversal of the tree.\r\n\r\nThis allows us to remove the whole tree-math section.",
          "createdAt": "2021-11-16T10:27:59Z",
          "updatedAt": "2021-11-16T10:27:59Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "One thing that I noticed working on #513 -- On Remove we truncate the tree to remove unused leaves from the right side.  That algorithm is clear when we're talking about an array representation; just find the rightmost non-blank leaf and remove every node (leaf or not) to the right of that index.  It seems like we should redefine that algorithm with this change.",
          "createdAt": "2021-11-19T22:58:22Z",
          "updatedAt": "2021-11-19T22:58:22Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Suggested text for truncation:\r\n\r\n* Truncate the tree:\r\n    * Remove any blank leaf nodes to the right of the rightmost non-blank leaf\r\n    * Perform the following steps until all parent nodes have two children:\r\n        * If an intermediate node has no children, remove it\r\n        * If an intermediate node N has one child C, remove the node and place C into the same child role with regard to N.\r\n        * If the root node R of the tree has only one child C, remove R and assign C as the root of the tree\r\n\r\nFor example, suppose we had a tree with six leaves, of which (0, 1, 2, 5) were populated, (3, 4) blank, and in this situation a Remove was issued for the member at leaf 5.  Then the Remove would result in the following changes to the tree, resulting in a tree with three leaves, with root node `V`:\r\n\r\n~~~~~\r\n                         X                                    X\r\n                   ______|___                           ______|___\r\n                  /          \\       Blank             /          \\  \r\nStart:           V           |       path             V           |  \r\n               __|__         |       =====>         __|__         |  \r\n              /     \\        |                     /     \\        | \r\n             U       W       Y                    U       W       Y  \r\n            / \\     / \\     / \\                  / \\     / \\     / \\ \r\n           A   B   C   _   _   F                A   B   C   _   _   F\r\n\r\n\r\n                         _                                    _\r\nRemove             ______|___                           ______|   \r\nblank             /          \\       No                /             \r\nleaves           V           |       children         V              \r\n=====>         __|__         |       =====>         __|__            \r\n              /     \\        |                     /     \\          \r\n             U       W       _                    U       W          \r\n            / \\     /                            / \\     / \\         \r\n           A   B   C                            A   B   C   _        \r\n\r\n\r\n                                                               \r\nOne                                                               \r\nchild                                One                             \r\nroot             V                   child            V              \r\n=====>         __|__                 =====>         __|_             \r\n              /     \\                              /    \\           \r\n             U       W                            U     |            \r\n            / \\     /                            / \\    |            \r\n           A   B   C                            A   B   C            \r\n~~~~~\r\n\r\nNote that if a batch of Removes is being processed, the truncation operation can be done once after all paths have been blanked.",
          "createdAt": "2021-11-21T15:09:29Z",
          "updatedAt": "2021-11-21T15:09:29Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "We may need a similar description of how you extend the tree to the right on Add.  I think the algorithm to add a leaf node `N` would be:\r\n\r\n* We say that the subtree rooted at a node is \"full\" if the number of leaves under it is a power of 2.\r\n* Let X = the parent of the rightmost leaf.  While X is full and X is not the root, let X = parent(X)\r\n* If X is the root, add a new root node Y with left child X and right child N\r\n* If X is not the root (and thus X is not full):\r\n    * Let L = left(X) and R = right(X)\r\n    * Set right(X) to a new node with left child R and right child N\r\n \r\nIt might be better to put these algorithms up in the tree section, as opposed to down here in the protocol.",
          "createdAt": "2021-11-21T15:21:56Z",
          "updatedAt": "2021-11-21T15:21:56Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "It makes me a little sad that these are so much more complicated than \"truncate the array\" and \"add two slots to the array\".  I guess I can understand the desire to make clear what happens to the logical tree, but it seems like we're introducing a lot of complexity.",
          "createdAt": "2021-11-21T15:23:36Z",
          "updatedAt": "2021-11-21T15:23:36Z"
        },
        {
          "author": "TWal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The Add algorithm doesn't work on the following tree:\r\n\r\n          V  \r\n        __|_ \r\n       /    \\\r\n      U     |\r\n     / \\    |\r\n    A   B   C\r\n\r\nAfter the While, we would have X = V and take the \"If X is the root\" step, which is wrong because X is not full.\r\n\r\nHere is a corrected Add algorithm:\r\n- Let X = the parent of the rightmost leaf. While X is full and X is not the root, let X = parent(X)\r\n- If X is not full:\r\n  - Let L = left(X) and R = right(X)\r\n  - Set right(X) to a new node with left child R and right child N\r\n- If X is full (and thus X is the root): add a new root node Y with left child X and right child N\r\n\r\nI'm wondering if these algorithms are really necessary. It doesn't hurt to include them as an example on how to do things, but I think we can do simpler explanations using the fact that there is a unique left-balanced tree shape for every number of leaves.\r\n\r\nInformally, we could say:\r\n- for Add: \"add enough blank parent node to have a valid left-balanced tree with n+1 leaves\"\r\n- for Remove: \"remove all leaves to the right of the right-most non-blank leaf, and remove parents nodes to have a valid left-balanced tree\".\r\n\r\nI think explaining what is the expected output of the procedure, rather than explaining one way to do the procedure is easier to understand.\r\n\r\n> It makes me a little sad that these are so much more complicated than \"truncate the array\" and \"add two slots to the array\". I guess I can understand the desire to make clear what happens to the logical tree, but it seems like we're introducing a lot of complexity.\r\n\r\nIt looks like added complexity, but for a new reader trying to understand MLS, I think it is easier to understand changes on the tree explained this way than understanding what happens to the tree when we do modifications on the underlying array representation.",
          "createdAt": "2021-11-22T13:45:14Z",
          "updatedAt": "2021-11-22T13:45:14Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "@TWal \r\n\r\n> I'm wondering if these algorithms are really necessary. It doesn't hurt to include them as an example on how to do things, but I think we can do simpler explanations using the fact that there is a unique left-balanced tree shape for every number of leaves.\r\n\r\nThat defines the *structure* of the tree, but not the *content* of the leaves.  We need to do both, so we need the transformation algorithms.  (In principle, you could write it starting from the structure, mapping old tree to new, but it would be an even more invasive rewrite.)\r\n\r\n",
          "createdAt": "2021-11-30T23:09:21Z",
          "updatedAt": "2021-11-30T23:09:21Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "OK, to build some intuition here, I tried implementing a non-array-based variant tree structure that maintained the right structure.  [Quick draft in Go](https://go.dev/play/p/d6MW1vlc0oa).\r\n\r\nThe bad news is: I'm pretty convinced that there's no intuitive way to just say \"make the unique left-balanced tree with these contents\".  At best, we would need some way to define \"Corresponding nodes\" so that things could be copied over, which ultimately just turns into reinventing node indices.\r\n\r\nThe good news is: The above Go code validates two algorithms for extending and truncating the tree by one node, and they're pretty simple.  The add algorithm is effectively what @TWal proposed; the remove algorithm just excises and patches around the rightmost leaf's parent node.\r\n\r\nIt seems like we need to either add the algorithms or give up and close the PR.\r\n\r\n@TWal @franziskuskiefer -- preferences between those two options?\r\n\r\n",
          "createdAt": "2021-12-02T00:49:52Z",
          "updatedAt": "2021-12-02T00:49:52Z"
        },
        {
          "author": "franziskuskiefer",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> It seems like we need to either add the algorithms or give up and close the PR.\r\n\r\nI'm not entirely decided on this. I agree with @TWal that the array representation isn't very intuitive for new readers and it's an implementation detail that's not good for the readability of the spec.\r\nOn the other hand do the algorithms get a pretty unwieldy and I'm not sure if they're really easier to understand than the array representation. And with the algorithms in the spec they aren't much better than the array representation in telling implementations what to do.\r\n\r\nIn an implementation of MLS that doesn't use the array representation underneath it is pretty easy to compute leaf indices for the few places they are needed.  So maybe another option is to leave the array representation in and only take the changes from this PR that remove the node index.\r\nIf the spec makes clear that the array representation is only one way of implementing the tree we could get the best of both worlds, a simple description of the left balanced tree without telling everyone what to implement as well as algorithms that only require leaf indices that can be easily retrieved from other implementations.\r\n",
          "createdAt": "2021-12-02T08:50:01Z",
          "updatedAt": "2021-12-02T08:50:01Z"
        },
        {
          "author": "TWal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I propose the following definition for \"correspond\":\r\n\r\n    A node n1 in a tree t1 corresponds to a node n2 in a tree t2\r\n    iff. the index of their leftmost leaf is the same, and they have the same height\r\n\r\nThis definition seems simple enough, while exactly capturing what nodes \"are the same\" in t1 and t2. It introduces the concept of \"height\" which is not currently defined in MLS, but I think it's fine.\r\nAlso, we can easily see that with this definition, two nodes \"correspond\" iff. they have the same node index in the array representation.\r\n\r\nIn fact, we can have the following alternate definition:\r\n\r\n    A node n1 in a tree t1 corresponds to a node n2 in a tree t2\r\n    iff. they have the same position in the in-order traversal\r\n\r\nThis is somewhat equivalent to re-introducing node-indexes, but in any case I find this definition less easy to understand than the first one.\r\n\r\nMy preferences are the following:\r\n1. Only give a declarative description for Add and Remove, introducing the previous definition, and maybe put the algorithms in the implementation document.\r\n2. Give the declarative description in a non-formal way (e.g. without defining \"corresponds\") and say afterward in the appendix \"okay, here is the real algorithm which is the ground truth about what you should do\".\r\n3. Franziskus' proposition.\r\n\r\nI prefer the first option, because then the intuition of the readers would actually be what is the ground truth. People working with trees are happy because they can work with a simple description on trees, and people working with arrays are happy because the \"corresponds\" definition is equivalent to \"n1 corresponds to n2 iff. they have the same node index\".\r\n\r\nThen I prefer the second option, because I still think the tree algorithms are easier to understand than the bit-tricks used in tree math. With this option, the readers could gain an intuition about what happens to the tree using the declarative description, then read the \"ground truth\" algorithms and convince themselves that they indeed do what their intuition said. This option is great for people working with trees, but is a bit disappointing for people working with arrays.\r\n\r\nThen the third option keep things as they are now, but implementations are not forced to implement tree math if they want to use another tree representation. This option is great for people working with arrays, but is a disappointing for people working with trees.\r\n\r\nI'd like to go with the first option, since it is the only one where tree people and array people are happy. What do you think? @franziskuskiefer @bifurcation ",
          "createdAt": "2021-12-02T15:57:53Z",
          "updatedAt": "2021-12-02T15:57:53Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "I think @franziskuskiefer is on the right track here -- let's phrase the structure of the tree in terms of node indices but be really clear that nodes don't have to use an array implementation.  So we would do something like:\r\n\r\n* Keep node indices\r\n* Truncate algorithm (in {{remove}}):\r\n    * Identify the rightmost non-blank leaf node\r\n    * Remove all nodes from the tree with an index higher than the rightmost non-blank leaf\r\n* Extend algorithm (in {{add}}):\r\n    * Let `n` be the index of the rightmost leaf node\r\n    * Add a blank parent node with index `n+1` and a blank leaf node with index `n+2`\r\n    * As a result, node `n+1` will have node `n+2` as its right child, and its left child and parent will be defined by the left-balanced binary tree structure.\r\n\r\n@TWal - Could you live with that?  It's sort of implicitly declarative, since node indexing encodes the left-balanced binary tree structure.\r\n\r\nNow that we have the tree-wise algorithms, it actually seems like a fine idea to add them in an appendix, parallel to the tree math appendix.  Then we could have a note in the Ratchet Tree section that says \"if you want to use node indices to compute relations, see that appendix for some helpful detail; if you want to use pointers, see the other one\".  That would make it abundantly clear that indices don't prescribe implementation.  I'll write a PR for that.",
          "createdAt": "2021-12-03T14:21:59Z",
          "updatedAt": "2021-12-03T14:23:07Z"
        },
        {
          "author": "franziskuskiefer",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Getting the link based description in is a great first step.\r\nThe other change that's uncontroversial I think is to make clear throughout the spec that there are two different (obvious) ways of implementing the tree.\r\n\r\nThen I we are left with one more question\r\n> Keep node indices\r\n\r\nWith the two changes mentioned above I don't have strong feelings on this. Either way is fine with me. Only working with leaf indices instead of node indices is the more generic description, but also creates some churn in the algorithms that is also security relevant.",
          "createdAt": "2021-12-06T10:31:27Z",
          "updatedAt": "2021-12-06T10:31:27Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Right, that's why I'm inclined to keep node indices -- Avoid churning the algorithms (since they seem to have been clear enough for at least two interoperable implementations), while making clear that any algorithm that produces the same tree is acceptable.",
          "createdAt": "2021-12-06T14:39:48Z",
          "updatedAt": "2021-12-06T14:39:48Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing this since we seem to be converging on #522.",
          "createdAt": "2021-12-07T14:49:31Z",
          "updatedAt": "2021-12-07T14:49:31Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOBoyH6c4wIrzd",
          "commit": {
            "abbreviatedOid": "54a2b97"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "I can understand the impulse here, and I think this is probably OK, especially for the ratchet tree parts.  The main concern I have is whether this leaves us with something clearly enough specified that the secret tree will work interoperably.  Maybe @psyoptix could opine here?",
          "createdAt": "2021-11-16T16:55:07Z",
          "updatedAt": "2021-11-16T20:59:08Z",
          "comments": [
            {
              "originalPosition": 169,
              "body": "Just to confirm that I understand: You are removing the context `N` from the derivation.  The idea is that that's OK because the index is \"baked into\" `tree_node_[N]_secret` by virtue of the sequence of \"left\"/\"right\" derivations by which it was derived?",
              "createdAt": "2021-11-16T16:55:07Z",
              "updatedAt": "2021-11-16T20:59:08Z"
            },
            {
              "originalPosition": 193,
              "body": "```suggestion\r\n    ExpandWithLabel(Secret, Label, Generation, Length)\r\n\r\nWhere Generation is encoded as a uint32.\r\n```",
              "createdAt": "2021-11-16T16:56:19Z",
              "updatedAt": "2021-11-16T20:59:08Z"
            },
            {
              "originalPosition": 225,
              "body": "\"the leaf with node `N`\" doesn't really parse for me.  Suggest \"the leaf node `L`\", removing \"with\" and using `L` as elsewhere.",
              "createdAt": "2021-11-16T16:58:01Z",
              "updatedAt": "2021-11-16T20:59:08Z"
            },
            {
              "originalPosition": 322,
              "body": "We probably need to provide more elaboration here to be explicit about the relations, and that probably requires re-importing a little bit of the tree math.  Suggested:\r\n\r\nThe nodes are listed in the order specified by a left-to-right in-order traversal of the rachet tree.  Each node is listed between its left subtree and its right subtree.  The leaves of the tree are stored in even-numbered entries in the array (the leaf with index `L` in array position `2*L`).  The root node of the tree is at position `2^k - 1` of the array, where `k` is the largest number such that `2^k` is smaller than the length of the array.  Intermediate parent nodes can be identified by performing the same calculation to the subarrays to the left and right of the root, following something like the following algorithm:\r\n\r\n```\r\n# Assuming a class Node that has left and right members\r\ndef subtree_root(nodes):\r\n    # If there is only one node in the array return it\r\n    if len(nodes) == 1:\r\n        return Node(nodes[0])\r\n\r\n    # Otherwise, the length of the array MUST be odd\r\n    if len(nodes) % 2 == 0:\r\n        raise Exception(\"Malformed node array {}\", len(nodes))\r\n    \r\n    # Identify the root of the subtree\r\n    k = 1\r\n    while (1 << k) < len(nodes):\r\n       k += 1\r\n    R = (1 << (k-1)) - 1\r\n    root = Node(nodes[R])\r\n    root.left = subtree_root(nodes[:R])\r\n    root.right = subtree_root(nodes[(R+1):])\r\n    return root\r\n```\r\n\r\nThe example tree in {{tree-computation-terminology}} would be represented as an array of nodes in the following form, where `R` represents the \"subtree root\" for a given subarray of the node array:\r\n\r\n```\r\n              7\r\n        ______|______\r\n       /             \\\r\n      3              11\r\n    __|__           __|\r\n   /     \\         /   \\\r\n  1       5       9     |\r\n / \\     / \\     / \\    |\r\nA   B   C   D   E   F   G\r\n\r\n                    1 1 1\r\n0 1 2 3 4 5 6 7 8 9 0 1 2\r\n<-----------> P <------->\r\n<---> P <--->   <---> P -\r\n- P -   - P -   - P -\r\n```",
              "createdAt": "2021-11-16T20:45:59Z",
              "updatedAt": "2021-11-16T20:59:08Z"
            },
            {
              "originalPosition": 333,
              "body": "I might keep this appendix, but change the emphasis:\r\n\r\n# Array-Based Tree Representation\r\n\r\nThe ratchet tree extension defined in {{ratchet-tree-extension}} provides a way to transport a ratchet tree as an array of nodes, such that relationships among the nodes correspond to certain numerical relationships between the indices of the nodes in the array.  These numerical relationship can be used to enable an array-based in-memory representation (in addition to the on-the-wire representation) or to facilitate decoding of the wire-format array into another in-memory representation.  In this appendix, we provide provide Python example code for computing several common relationships among nodes, for example mapping between parents and left/right children.",
              "createdAt": "2021-11-16T20:53:32Z",
              "updatedAt": "2021-11-16T20:59:08Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c4wMaAy",
          "commit": {
            "abbreviatedOid": "54a2b97"
          },
          "author": "TWal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-11-17T13:04:35Z",
          "updatedAt": "2021-11-17T13:04:35Z",
          "comments": [
            {
              "originalPosition": 169,
              "body": "That's right!",
              "createdAt": "2021-11-17T13:04:35Z",
              "updatedAt": "2021-11-17T13:04:35Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c4wMfao",
          "commit": {
            "abbreviatedOid": "9dfd741"
          },
          "author": "TWal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-11-17T13:24:21Z",
          "updatedAt": "2021-11-17T13:24:21Z",
          "comments": [
            {
              "originalPosition": 225,
              "body": "Fixed it in a new commit.",
              "createdAt": "2021-11-17T13:24:21Z",
              "updatedAt": "2021-11-17T13:24:21Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c4wMjtt",
          "commit": {
            "abbreviatedOid": "9dfd741"
          },
          "author": "TWal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-11-17T13:39:20Z",
          "updatedAt": "2021-11-17T13:39:21Z",
          "comments": [
            {
              "originalPosition": 322,
              "body": "It looks good, however I think the `R` (that \"represents the subtree root\") and the `P` in the drawing should be the same letter?",
              "createdAt": "2021-11-17T13:39:20Z",
              "updatedAt": "2021-11-17T13:39:21Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c4wMmFL",
          "commit": {
            "abbreviatedOid": "9dfd741"
          },
          "author": "TWal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-11-17T13:47:34Z",
          "updatedAt": "2021-11-17T13:47:34Z",
          "comments": [
            {
              "originalPosition": 322,
              "body": "Also I suggest the following change to the code, so that the `k` in the code and the `k` in the text above it are the same:\r\n```\r\n    k = 0\r\n    while (1 << (k+1)) < len(nodes):\r\n       k += 1\r\n    R = (1 << k) - 1",
              "createdAt": "2021-11-17T13:47:34Z",
              "updatedAt": "2021-11-17T13:47:34Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c4wMoBH",
          "commit": {
            "abbreviatedOid": "9dfd741"
          },
          "author": "TWal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-11-17T13:53:55Z",
          "updatedAt": "2021-11-17T13:53:55Z",
          "comments": [
            {
              "originalPosition": 333,
              "body": "Keeping it with a different emphasis seems fine, however I think it would better be located in a separate \"implementation recommendation\" document and not in the \"protocol\" document?",
              "createdAt": "2021-11-17T13:53:55Z",
              "updatedAt": "2021-11-17T13:53:55Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c4wYL7W",
          "commit": {
            "abbreviatedOid": "9dfd741"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-11-19T20:24:07Z",
          "updatedAt": "2021-11-19T20:24:08Z",
          "comments": [
            {
              "originalPosition": 333,
              "body": "I can live with that.  @kkohbrok I think you were going to start an \"implementation considerations\" document?",
              "createdAt": "2021-11-19T20:24:07Z",
              "updatedAt": "2021-11-19T20:24:08Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c4wYNek",
          "commit": {
            "abbreviatedOid": "9dfd741"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "@TWal If you could add the ratchet tree description I provided, I'm OK to merge this.",
          "createdAt": "2021-11-19T20:33:02Z",
          "updatedAt": "2021-11-19T20:33:02Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOBoyH6c4wZRWt",
          "commit": {
            "abbreviatedOid": "9dfd741"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-11-21T14:55:31Z",
          "updatedAt": "2021-11-21T14:55:31Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "I would consider using single letters, from the end of the alphabet, for these.  For example:\r\n\r\n```\r\n              X\r\n        ______|______\r\n       /             \\\r\n      V               Z\r\n    __|__           __|\r\n   /     \\         /   \\\r\n  U       W       Y     |\r\n / \\     / \\     / \\    |\r\nA   B   C   D   E   F   G\r\n```",
              "createdAt": "2021-11-21T14:55:31Z",
              "updatedAt": "2021-11-21T14:56:34Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c4wbruE",
          "commit": {
            "abbreviatedOid": "d8e279b"
          },
          "author": "TWal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-11-22T13:55:32Z",
          "updatedAt": "2021-11-22T13:55:33Z",
          "comments": [
            {
              "originalPosition": 322,
              "body": "I added the description you provided, and additionally replaced `1 << k` by `2**k` as I think it is more readable.",
              "createdAt": "2021-11-22T13:55:32Z",
              "updatedAt": "2021-11-22T13:55:33Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c4wbtin",
          "commit": {
            "abbreviatedOid": "7b4704e"
          },
          "author": "TWal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-11-22T14:01:44Z",
          "updatedAt": "2021-11-22T14:01:44Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "That's indeed better like this, I commited it.",
              "createdAt": "2021-11-22T14:01:44Z",
              "updatedAt": "2021-11-22T14:01:44Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c4w7cwF",
          "commit": {
            "abbreviatedOid": "7b4704e"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "Marking this as \"Request changes\" until we get algorithms in place for truncate and add.\r\n\r\n@TWal - Maybe as a compromise, we could do something like the following:\r\n\r\n1. Present brief truncate and add algorithms of roughly the following form:\r\n    * Truncate or extend the list of leaf nodes\r\n    * Construct the unique left-balanced binary tree on the leaves, where each nodes' value is the value of the corresponding node in the old tree.\r\n2. Present the full algorithms in an appendix\r\n\r\nThe key thing here is that truncate only deletes nodes and add only adds blank nodes, so there's not a ton of complexity in specifying the content of the nodes.  (Basically, we take the content of nodes from the old tree and the structure from the new.)  The thing that makes me queasy here is \"corresponding node\", since we don't have a definition for that.  Suggestions welcome.",
          "createdAt": "2021-12-01T22:59:25Z",
          "updatedAt": "2021-12-01T22:59:25Z",
          "comments": []
        }
      ]
    },
    {
      "number": 508,
      "id": "PR_kwDOBoyH6c4uitKX",
      "title": "Add value for required_capabilities extension",
      "url": "https://github.com/mlswg/mls-protocol/pull/508",
      "state": "MERGED",
      "author": "franziskuskiefer",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2021-11-15T16:18:22Z",
      "updatedAt": "2021-11-19T20:20:21Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "fefeaf0a5ae3c4daebcacf8ac752aefebf867842",
      "headRepository": "franziskuskiefer/mls-protocol",
      "headRefName": "patch-5",
      "headRefOid": "3c240274dd2bebb0d96eba3a3bba00e844343863",
      "closedAt": "2021-11-19T20:20:21Z",
      "mergedAt": "2021-11-19T20:20:21Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "bbab27dbd82adcde5a7d61b6ee1d6db36be8ec73"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOBoyH6c4wYLJS",
          "commit": {
            "abbreviatedOid": "3c24027"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-11-19T20:20:16Z",
          "updatedAt": "2021-11-19T20:20:16Z",
          "comments": []
        }
      ]
    },
    {
      "number": 509,
      "id": "PR_kwDOBoyH6c4unpqC",
      "title": "Be explicit that Credentials can attest to multiple identities",
      "url": "https://github.com/mlswg/mls-protocol/pull/509",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "The specification currently assumes that a Credential provides a singular identity for a client, when in reality that is not the case.  For example, X509Credential can provide a whole collection of identities, and it's up to the application to decide if its preferred identity is among them.  Just like in TLS, a server can send a cert with 100 domains, but the TLS client knows which one it's looking for.\r\n\r\nThis PR refactors the parts of the spec that refer to identity to be consistent with this idea.  The main impacts are to processing of Update and Remove-within-External-Commit, both cases in which you want the new KeyPackage to logically represent the same identity as the old one.\r\n\r\nThis PR also removes the `endpoint_id` field from KeyPackage.  Since we now reference KeyPackages by KeyPackageID, there's no longer a need for a separate identifier.  (Unless we want an identifier that's stable across epochs, but (a) it's not clear to me that that is needed in general and (b) it can easily be added in an extension, as in fact we have done in Webex.)",
      "createdAt": "2021-11-16T22:20:20Z",
      "updatedAt": "2022-01-28T18:38:13Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "9ddcd5a33832a0f65084af0531dabb20067fcde1",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "ref-id",
      "headRefOid": "a01b5ef76ab44e0ce4d62ba2e0366341311bada1",
      "closedAt": "2022-01-28T18:38:13Z",
      "mergedAt": "2022-01-28T18:38:13Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "0e1096b9b4754ca71cc4b9c1028d84865db48b95"
      },
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "How appropriate that this is PR (X.)#509 !",
          "createdAt": "2021-11-16T22:20:45Z",
          "updatedAt": "2021-11-16T22:21:34Z"
        },
        {
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The advantage of keeping an `endpoint_id` is that we can mandate in the spec that it can't change across epochs. While if we have a proprietary extension that contains an identifier, every implementation would have to be aware of that extension and enforce that it doesn't change across updates. So I'd be in favor of keeping it.",
          "createdAt": "2021-11-25T09:42:10Z",
          "updatedAt": "2021-11-25T09:42:10Z"
        },
        {
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "body": "This softens the requirements quite a bit, namely:\r\n - There is no more requirement for identities to be unique across the group, e.g. Alice can double-join the tree by occupying two leaves, simply by issuing an Update.\r\n -  An identity can completely change in the course of an Update if the application allows it. \r\n\r\nI'm worried the proposed solution can lead to UB, when clients try to remove a certain member that potentially occupies more than one leaf.",
          "createdAt": "2021-12-01T15:14:39Z",
          "updatedAt": "2021-12-01T15:14:39Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "@kkohbrok - We already have an identifier that is stable across epochs -- the leaf index!  We don't have a use for it now (as evidenced by the `KeyPackageID` PR), but it's still there.\r\n\r\n@raphaelrobert - I don't think those concerns hold up.  There's no new risk of double-join; a client can only present an identity for which it can obtain a Credential that is acceptable to other clients.  If a client presents a legitimate identity twice, that's not harm; it might be multiple devices, which we can still uniquely reference by KeyPackageID.  If a client can get Credentials for identities they don't own, that's a bug in the authentication system, not MLS.\r\n\r\nAs far as identities completely changing -- one could consider that a feature, not a bug.  TLS has had to go to [a fair bit of trouble](https://datatracker.ietf.org/doc/draft-ietf-tls-exported-authenticator/) to allow servers to assert additional identities over the course of a connection.  It seems like we have an elegant solution to the problem here.  Applications can of course always be stricter.",
          "createdAt": "2021-12-01T18:13:19Z",
          "updatedAt": "2021-12-01T18:13:19Z"
        },
        {
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "It's stable across epochs until you remove the party in that leaf and add another one into it. \r\n\r\nThe options that have been suggested are the following:\r\n- leaf index: is not tied to any particular identity/key package\r\n- key package (id/hash): potentially changes across epochs\r\n- identity in the credential: not unique per group \r\n\r\nNone of these variables/indices/identifiers really does the trick of uniquely and consistently (across epochs) identifying a client in a group. The endpoint id/identity tuple does all of the above. We don't have to use it in message structs, where the key package ids are just fine, as messages are tied to an epoch anyway. I'm just in favor of keeping the endpoint id so it can serve as a consistent identifier for group members for use by the application.",
          "createdAt": "2021-12-01T20:20:43Z",
          "updatedAt": "2021-12-01T20:20:43Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "@kkohbrok - I can live with re-adding `endpoint_id`.  I can imagine scenarios where it would be troublesome, but in the worst case, you just fill in some long random junk there.  I have re-added.\r\n\r\nAny other issues, or are we good to merge?",
          "createdAt": "2021-12-06T17:01:33Z",
          "updatedAt": "2021-12-06T17:01:33Z"
        },
        {
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'm ok with this approach, but I think this changes the concept of identity enought that we should not merge this without previous discussion either in a meeting or on the mailing list. Is there an interim planned before the WGLC?",
          "createdAt": "2021-12-07T13:48:55Z",
          "updatedAt": "2021-12-07T13:50:02Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "There is no interim planned.  I'll send a ping to the mailing list.",
          "createdAt": "2021-12-07T14:28:40Z",
          "updatedAt": "2021-12-07T14:28:40Z"
        },
        {
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "body": "I thought about this some more and I managed to convince myself that the `endpoint_id` is not strictly needed. Not having it however puts a higher burden on either the implementation or on the AS to track changes across epochs in order to ensure continuity. \r\nIn practical terms, the only constant thing about member X is that it occupies leaf node i between the time it was added and removed (regardless of updates during that time). If however X gets removed and a new member Y gets added at the same leaf node, i now references Y and not X, which makes leaf node indices useless across epochs.\r\n\r\nFor me this means one of the following two things must be true:\r\n\r\n a) Implementations emulate the concept of an `endpoint_id`. They assign it to a member at the point in time when the member gets added and delete it when the member gets removed. In between the two events, this `endpoint_id` is used as the only unique identifier for a member.\r\n \r\n b) We put more load on the AS and mandate the AS must be able to correlate two KeyPackages from two different epochs to ascertain the two KeyPackages belong to the same user. For example, member X gets added in epoch A, and updates its KeyPackage (including its credential, HPKE init key, and signature key) in epoch B. The AS must then be able to tell in epoch C whether it's still the same member X or a new member Y, just by looking at the two KeyPackages.",
          "createdAt": "2021-12-07T15:08:24Z",
          "updatedAt": "2021-12-07T15:08:24Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "@raphaelrobert Yeah, I think I'm about in the same place as you.  As I think I've said before, to use MLS in Webex, we needed to add a KeyPackage extension for the application unique identifer anyway.  With `endpoint_id`, we could have just used that field.\r\n\r\nBut note that the PR has already been updated to re-add `endpoint_id`.  So are you good with the PR in its current state?",
          "createdAt": "2021-12-07T15:21:00Z",
          "updatedAt": "2021-12-07T15:21:00Z"
        },
        {
          "author": "br-hale",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Zooming out on this problem, I will make a couple remarks about options for identifying parties. First, it seems that the above alternatives (and adding some not discussed) can generally be grouped into one of the following categories (for these, 'persistence' implies over the duration of the session/group, and 'directly authenticated' implies either as a credential or an identifier signed through use of a credential):\r\n\r\n1. endpoint identifiers change across epochs and directly authenticated along with that change\r\n2. endpoint identifiers are persistent across epochs and directly authenticated once\r\n3. endpoint identifiers are not persistent across epochs, but directly authenticated only once \r\n4. endpoint identifiers are persistent across epochs, but unauthenticated\r\n\r\nI note the above differentiators, since the role of endpoint identifiers begins to factor in when assessing E2EE. @chelseakomlo and I are working on some of the 'ends' aspect of E2EE and I think the current PR change could prove non-trivial with respect to justifying E2EE in MLS. Option 3 is what Signal does and, throughout the development of MLS, Signal as been used as a guidepost for 'at least equivalent' security. Naturally, if credentials are used directly, we meet Option 2 or 1, dependent on handling. Please correct me if I am wrong, but it appears that the current PR would lead us into Option 4.\r\n\r\nI support keeping credentials, at least in the sense of keys. Actually, in this respect, it is a little confusing with regard the issue with x509. Since early on, \"credential\" in MLS has been used as denoting a signature key, not a certificate that may contain more. Maybe I am not quite seeing the issue as to why the application cannot handle interpreting the certificate as separate to the credential in the spec.\r\n\r\n \r\n",
          "createdAt": "2021-12-10T23:30:02Z",
          "updatedAt": "2021-12-10T23:30:02Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "@br-hale Strongly disagree with 'Since early on, \"credential\" in MLS has been used as denoting a signature key, not a certificate that may contain more.'  The notion of a Credential has always included at least an identifier as well as the signature key, in order to address the Unknown Key Share / Identity Misbinding attacks that occur in Signal and elsewhere.  If you put that together with the idea that Credentials are verifiable using some AS, you basically arrive at certificates.\r\n\r\nIn your taxonomy, only option (1) actually works for MLS, assuming that by \"endpoint identifiers\", you mean the authenticated ones, and not just the opaque `endpoint_id`, which just has to be unique.  Option (4) is clearly unacceptable, because the whole point of these identifiers is that they're authenticated by the AS.  Options (2) and (3) don't make sense because members can be added to the group and need to be able to authenticate the other members when they join (so \"directly authenticate once\" doesn't work).  Note that MLS is unlike Signal in that the membership is multi-party and dynamic, and that we seek to address UKS issues that Signal explicitly disclaims.\r\n\r\n> @chelseakomlo and I are working on some of the 'ends' aspect of E2EE and I think the current PR change could prove non-trivial with respect to justifying E2EE in MLS.\r\n\r\nCould you describe more what the issue is here?  Just because the endpoints can change the set of identities they express doesn't seem like it undermines the notion of E2EE.",
          "createdAt": "2021-12-14T16:08:27Z",
          "updatedAt": "2021-12-14T16:08:27Z"
        },
        {
          "author": "br-hale",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@bifurcation I agree that option (1) is what is needed for MLS. The discussion above seems to advocate for a variant of option (4) though. This variant question also seems to be the crux of the matter @kkohbrok was pointing out above, so if something is being miscommunicated here it would help if you could clarify that, i.e. that we are at least on the same page regarding (1) being the goal. The 'Signal alignment' only holds as a baseline, i.e. if you are advocating for (4) then I would say that we can and should do better. The claim about options (2) and (3) is incorrect though, since direct authentication occurs at time of group join. \r\n\r\nTo avoid diverging down side discussion points and to keep this PR decision on track, it is essential to establish clarity on the claim that MLS (with the current PR) would be able to offer option (1). Copying from @kkohbrok notes above, we have that (quote):\r\n- leaf index: is not tied to any particular identity/key package\r\n- key package (id/hash): potentially changes across epochs\r\n- identity in the credential: not unique per group\r\n(end quote)\r\n\r\nand as @bifurcation you say, the opaque endpoint_id is by no means sufficient. By elimination, this does not leave many options. So what aspect are you referring ref. \"the authenticated ones\"? I.e. what persistent or rotated endpoint identifier is there which consistently links authenticity throughout the lifespan of the group? Anything that is not persistent is insufficient as is anything that is authenticated in a disconnected manner (e.g. can be replaced and authenticated with a new key that is not linked to the prior one). \r\n",
          "createdAt": "2021-12-15T02:45:56Z",
          "updatedAt": "2021-12-15T02:45:56Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "@br-hale What I mean by \"the authenticated ones\" is the identifier(s) in the Credential, in the KeyPackage, which are supposed to be authenticated with the AS.  To be specific: For BasicCredential, the `identity` field, and for X509Credential, identifiers in the `subject` or `subjectAltName` fields.\r\n\r\nSo yes, we have a number of identifiers for endpoints:\r\n\r\n1. Identifiers in credentials (as above)\r\n2. Leaf index: Unique within a group; constant for a member's lifetime in the group, by virtue of tree math\r\n3. `endpoint_id`: Unique within a group; constant for a member's lifetime in the group, by fiat\r\n4. KeyPackageID (==hash): Unique within a group; changes on Commit/Update by the member\r\n\r\nThe point of this PR is just to clarify that the identifiers authenticated in credentials are neither unique within a group nor constant across Commit/Update by the member.  (And to clarify what must remain constant across Commit/Update.)  Does that seem problematic to you?",
          "createdAt": "2021-12-15T15:59:12Z",
          "updatedAt": "2021-12-15T15:59:12Z"
        },
        {
          "author": "br-hale",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The issue of credentials not being unique or constant is at the heart of this. Other items here are not authenticated or are reliant on those credentials and therefore the consistency of e.g. the leaf index does not actually imply consistency of identity. \r\n\r\nIf credentials were not unique/constant in the sense that a prior one signs off on the next one, then we would inherit consistency from that (which is different from the case here). Similarly, if a single root identity (\"identity\") were to forward to other sub-identities, then there is consistency in the meaning of identity. \r\n\r\nWhat we have here is a backdoor on switching out identities which would be allowed by the spec - yes, they are subcomponents of a credential, but any sender is not actually assured of which identity they are conversing with. For example, Alice may trust a domain name / email address from Bob, but when that switches part-way through the conversation, there is no opt-out point or notification to Alice. There is considerable drift available to Bob (either unintentionally or maliciously) that could occur without knowledge from other group members. This is noticeably different from the case that Bob simply maliciously forwards messages externally, as the drift occurs internally to the group.",
          "createdAt": "2021-12-17T06:43:15Z",
          "updatedAt": "2021-12-17T06:43:15Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "You might think the simplest thing we could do here is just require that a Credential be stable for the lifetime of a member's presence in the group.  If you want to change the Credential, you have to be removed and re-added.  But (a) that seems like throwing out a bunch of useful functionality, and (b) it doesn't actually remove the risk, just moves it over to the remove/re-add case, making it harder for the application to track continuity.",
          "createdAt": "2022-01-20T13:07:02Z",
          "updatedAt": "2022-01-20T13:07:02Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "(Force-pushed to address failed merge)\r\n",
          "createdAt": "2022-01-26T14:40:39Z",
          "updatedAt": "2022-01-26T14:40:39Z"
        },
        {
          "author": "tomleavy",
          "authorAssociation": "CONTRIBUTOR",
          "body": "+1 to this change. I think this clarifies how to handle application layer identity, and that is particularly helpful when using X509 as the credential where `credential.identity` is a bit complicated.",
          "createdAt": "2022-01-27T02:39:27Z",
          "updatedAt": "2022-01-27T02:50:30Z"
        },
        {
          "author": "br-hale",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@bifurcation shifted this discussion offline and it has been discussed extensively there with some of the issues more clearly outlined. To avoid copying it all into this PR, I suggest discussion at the next WG informal interim on 27 Jan., or as seen suitable by the authors.",
          "createdAt": "2022-01-27T04:10:16Z",
          "updatedAt": "2022-01-27T04:10:16Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks @br-hale for some offline discussion here to help me understand your concerns.\r\n\r\nIIUC the core of your concern is that the spec doesn't clearly require that new credentials be validated with the AS whenever they appear.  I can see how if you believe credentials are only validated on Add, then you need everything to chain back to the Add, and changes are problematic.\r\n\r\nI don't think the spec is actually broken in this way, since it says in `# Credentials` that \"each new credential that has not already been validated by the application MUST be validated against the Authentication Service\" (and has for 2 years according to `git blame`).  But I agree the spec should be clearer and more consistent on this point, and would be happy to make the edits required.",
          "createdAt": "2022-01-27T12:38:33Z",
          "updatedAt": "2022-01-27T12:38:33Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Latest commit attempts to address @br-hale's concerns by explicitly requiring credential validation on Update/full-Commit.",
          "createdAt": "2022-01-27T14:22:00Z",
          "updatedAt": "2022-01-27T14:22:00Z"
        },
        {
          "author": "br-hale",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Given the push to shift the key points of discussion here, I am copying them avoid paraphrasing confusions: \r\n\r\n[Responding to @bifurcation regarding the sufficiency of text that suggests developers determine whether identifiers should be constant based on whether they feel they have knowledge to make changes]\r\n\r\nA recommendation for consistency of identifiers will likely be insufficient; I suspect that this decision point underpins being able to show this as an AKE at all. It would be like making certs optional and changeable during TLS\u2019s handshake. What TLS does once, MLS does continuously (the handshake). It is not a \u2018different\u2019 handshake per epoch, but all links through all back to the initialization. Proving security of an AKE is in part conditioned on the identities (and commitment to those identities) of the entities involved (\u2018identity\u2019 being generic, not a specific term in MLS here). So if that changes part way through the handshake (= session in MLS), then one of the key properties of an AKE is likely going to break down. Relying on the group key state to fill the consistency check gap that is created would be circular logic.\r\n \r\nSome options are: 1) have a consistent identifier (regardless of whether that is a cert, endpoint_id, or other), 2) have a logically linked chain of identifiers (e.g. the last one signs the next as some type of cert chain if the identifier is taken to be a cert, or hash the last identifier to make the next in the chain, etc.), or 3) remove the member and add a \u2018new\u2019 member whenever the identifier changes. This really is not an optional piece of a protocol or something that can passably be left up to how the developer is feeling \u2013 we are really dealing with the fundamental question of whether MLS will be an AKE or not.\r\n \r\nI do not really see an advantage with us being loosie and shifting MLS to a KE vs an AKE at this point. It may be worthwhile instead to clarify the use case so we can see what the need is and then we can see how that may be solved. For example, if you want multiple identities/credentials for an entity, then we could require that those all be present somehow at the start of the protocol. Note that switching among a pre-announced set of identities for a member or removing an old identifier if the next one is already in the set could potentially be alright \u2013 it is the introduction of some new identifier or credential that carries no explicit, persistent link from prior ones that is a problem. Unsurprisingly, the consequence of fixing side case uses is that the protocol gets more complex, but if it is meaningful for some development case then that is the reality.\r\n ",
          "createdAt": "2022-01-27T14:50:15Z",
          "updatedAt": "2022-01-27T14:50:15Z"
        },
        {
          "author": "br-hale",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Also:\r\n\r\n[In response to @bifurcation regarding the assertion that MLS authenticates in each epoch with credentials and via AS, making it a fresh AKE per epoch.]\r\n\r\nThe analogy of TLS authenticators is misconstruing the spec, since that is a single session \u2013 you see, using alternative identifiers for any given session is not a problem, but switching them out mid-session is. While it is true that ratcheted key exchange is normally looked at as epoch-level mini-sessions as far as key establishment goes, the \u2018A\u2019 part stretches the length of the entire session and ties to the very start (\u2018Add\u2019). This is intuitively noticeable in that the spec requires that the key package be validated and the credential verified only at an Add (pg 54) and not every epoch. The credential (issuer, keys, or identity) could effectively change without group members even verifying the new credential (and that is without touching on the legitimacy of the \u2018chain\u2019 between the two). That is why Updating/Committing cannot be regarded as a remove and Add: the required operations for each differ.\r\n \r\n(example on E2EE identities changing maliciously given that the verification requirements at the Add step differ from at the Update step when the cert changes)\r\n \r\nIn short, no, the identifiers are not authenticated in each epoch, only at the start. Confidentiality ratchets per epoch, but authenticity does not. That said, if you can require that every time there is a change in a credential then all of the prescribed steps in an Add are also followed (with respect to verifying identities) then my concerns are addressed and I would also agree that we have at least authentication per change (although not per epoch).\r\n \r\n \r\n ----\r\n \r\nAs an aside note, the source of this challenge for MLS is that, unlike TLS, we do not prescribe credentials from a certifying authority. In TLS the certificate authority and therefore means of verifying authenticity of identities is very explicit \u2013 no matter when those are verified, a certificate authority will always be listed. Thus TLS can easily require checks. In MLS (section 6.2) we only say \u2018MAY verify identities\u2019 (MLS requires any credential not validated by members to be validated by the AS by an unspecified method). If I recall correctly this choice was made early on to capture the loophole for \u2018trust on first use\u2019 type applications. For that case the game changes entirely though since both the initial authentication and any subsequent authentication both suffer the same challenge of needing an OOB solution for authenticating identity (in other words, cert changes are no worse off than at the start).\r\nHowever, for MLS using normal certificates, the fact that this loophole exists creates a challenge on how to ensure that the same authentication functionality is being used when certs change (the wording is simply harder to formulate while still allowing for the loophole). TLS in contrast is very explicit about certificate verification, but it can be because 1) there is only one point were this is done in the protocol as a single session and 2) there is really only one main method of handling cert authorities with x509, with explicit exceptions given by e.g. the export exemption you name.\r\n \r\nIn short, if you authenticate OOB the first time, OOB after certificate change is persistent. If you authenticate with cert authorities the first time, then changing the certificate should imply a re-validation of the new cert\u2019s chain. What we cannot do is allow a functionality method that is not persistent (i.e. the current problem) where we verify once but allow changes later without equivalent oversight.",
          "createdAt": "2022-01-27T14:57:09Z",
          "updatedAt": "2022-01-27T14:57:09Z"
        },
        {
          "author": "br-hale",
          "authorAssociation": "CONTRIBUTOR",
          "body": "With the provided background context for the WG above, I will address the latest question from @bifurcation and the changes.\r\n\r\nFirst - thank you for the edits to the PR. \r\n\r\nThe proposed changes do not fully address the above however. The key gap is on what is being required to be done for verification of identity at the point of change. We need to explicitly enforce that the same process at the Add needs to be done at the change. Right now there is still a bailout option, where credentials can be verified directly at the Add, but are slipped into a background/AS option. This is mixing and matching.",
          "createdAt": "2022-01-27T15:07:54Z",
          "updatedAt": "2022-01-27T15:07:54Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "DIscussion on working call:\r\n\r\n* Need to make sure we have consistent validation logic across Add/Update/Commit\r\n",
          "createdAt": "2022-01-27T15:23:32Z",
          "updatedAt": "2022-01-27T15:23:32Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "@br-hale The latest commit adds a consolidated \"KeyPackage validation\" section that describes the common rules that are applied across Add, Update, and Commit, including credential validation in particular.\r\n\r\nThe only difference between those cases now is that only Update and Commit have a requirement to check that the new set of identifiers is OK.  It seems like that check doesn't make sense for Add.\r\n\r\nLet me know if that looks good to you!",
          "createdAt": "2022-01-27T19:06:12Z",
          "updatedAt": "2022-01-27T19:06:12Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOBoyH6c4zJMs2",
          "commit": {
            "abbreviatedOid": "ee54cbd"
          },
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-01-20T10:27:13Z",
          "updatedAt": "2022-01-20T10:27:13Z",
          "comments": [
            {
              "originalPosition": 207,
              "body": "In other words, this gives us a new requirement for the AS, namely that it has to be able to tell us if a given credential is the valid successor of another credential. With fixed identities, this would not be necessary. Of course one way of implementing this check for the AS is to check if some notion of identity that arises from a given credential type is indeed the same for both certificates.",
              "createdAt": "2022-01-20T10:27:13Z",
              "updatedAt": "2022-01-20T10:27:13Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c4zJ1Xx",
          "commit": {
            "abbreviatedOid": "ee54cbd"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-01-20T13:04:35Z",
          "updatedAt": "2022-01-20T13:04:35Z",
          "comments": [
            {
              "originalPosition": 207,
              "body": "I wouldn't frame this as an AS requirement, but regardless, you have to do *something* here: The application has to either (1) verify that the \"identity\" is the same (for some definition thereof), or (2) verify that the identity is acceptable. \r\n\r\n(2) is the state of the art basically everywhere right now.  See, e.g., [RFC 6125](https://datatracker.ietf.org/doc/html/rfc6125).  Doing (1) for an X.509 certificate is actually pretty complex -- or even defining it -- given all the notions of \"identity\" lurking around in there.  For example, we could enumerate the subjectAltName, but then someone defines [a new way of embedding telephone numbers](https://datatracker.ietf.org/doc/html/rfc8226).  The only way to be sure is to require that the whole certificate be the same, but you probably also want to allow signature key rotation, so really you want the whole cert to be the same except for the public key.  This is not functionality provided by any X.509 library that I'm aware of.\r\n\r\nI think the underlying confusion here is around what layers are responsible for what.  Compare to HTTPS:\r\n\r\n* The application layer provides the identifier you're supposed to be authenticating (host name in the URL)\r\n* TLS only provides a *set of identifiers* that are authenticated\r\n* It's up the the application layer to verify that the authenticated identifiers are acceptable\r\n\r\n(This is true even with extensions like [exported authenticators](https://datatracker.ietf.org/doc/draft-ietf-tls-exported-authenticator/) that allow the set of identifiers to change.) All this PR is proposing is a similar division of labor in the MLS case.",
              "createdAt": "2022-01-20T13:04:35Z",
              "updatedAt": "2022-01-20T13:04:35Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c4zmUUX",
          "commit": {
            "abbreviatedOid": "86815d1"
          },
          "author": "br-hale",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-01-28T04:27:11Z",
          "updatedAt": "2022-01-28T04:27:11Z",
          "comments": [
            {
              "originalPosition": 125,
              "body": "I suggest adding:\r\nThe authentication service validity check steps and client's local policy MUST be the same for all verification stages (KeyPackage download, Add, Update, Commit, or KeyPackage receipt).\r\n",
              "createdAt": "2022-01-28T04:27:11Z",
              "updatedAt": "2022-01-28T04:27:11Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c4zmUeB",
          "commit": {
            "abbreviatedOid": "86815d1"
          },
          "author": "br-hale",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-01-28T04:28:46Z",
          "updatedAt": "2022-01-28T04:28:47Z",
          "comments": [
            {
              "originalPosition": 125,
              "body": "@bifurcation the updated changes look very good. I made a suggestion above. With that addition (or equivalent), it looks good to me.",
              "createdAt": "2022-01-28T04:28:46Z",
              "updatedAt": "2022-01-28T04:28:47Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c4znFfG",
          "commit": {
            "abbreviatedOid": "d3285fb"
          },
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-01-28T09:22:35Z",
          "updatedAt": "2022-01-28T09:22:36Z",
          "comments": [
            {
              "originalPosition": 125,
              "body": "I would suggest do go slightly further and require that on top of the verification you do in case of an Add (i.e. asking the AS \"Is this credential Ok?\"), the AS should also answer the question \"Is this credential OK as the successor to this previous credential?\".",
              "createdAt": "2022-01-28T09:22:35Z",
              "updatedAt": "2022-01-28T09:22:36Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c4zpaSF",
          "commit": {
            "abbreviatedOid": "86815d1"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-01-28T18:00:03Z",
          "updatedAt": "2022-01-28T18:00:04Z",
          "comments": [
            {
              "originalPosition": 125,
              "body": "Thanks @br-hale.  @kkohbrok I think that's covered down in the Update section.",
              "createdAt": "2022-01-28T18:00:03Z",
              "updatedAt": "2022-01-28T18:00:04Z"
            }
          ]
        }
      ]
    },
    {
      "number": 510,
      "id": "PR_kwDOBoyH6c4uny9j",
      "title": "Use smaller, fixed-size hash-based identifiers",
      "url": "https://github.com/mlswg/mls-protocol/pull/510",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #506 \r\nFixes #504",
      "createdAt": "2021-11-16T22:43:47Z",
      "updatedAt": "2021-12-01T18:21:19Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "fefeaf0a5ae3c4daebcacf8ac752aefebf867842",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "hash-id",
      "headRefOid": "3c337444df2d889deb27994ea349cde3ed7a48d5",
      "closedAt": "2021-12-01T18:21:19Z",
      "mergedAt": "2021-12-01T18:21:18Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "f9de42c97223a99a9587a9fc92f8b748a9beb2d7"
      },
      "comments": [
        {
          "author": "franziskuskiefer",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Fixes #504",
          "createdAt": "2021-11-17T07:59:45Z",
          "updatedAt": "2021-11-17T07:59:45Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOBoyH6c4wLJwW",
          "commit": {
            "abbreviatedOid": "3c33744"
          },
          "author": "franziskuskiefer",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-11-17T07:57:24Z",
          "updatedAt": "2021-11-17T07:57:43Z",
          "comments": [
            {
              "originalPosition": 29,
              "body": "Should the `Commit` section then use `ProposalRef` rathen than `opaque hash<0..255>` for the `reference`?",
              "createdAt": "2021-11-17T07:57:25Z",
              "updatedAt": "2021-11-17T07:57:43Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c4wMvNw",
          "commit": {
            "abbreviatedOid": "3c33744"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-11-17T14:14:55Z",
          "updatedAt": "2021-11-17T14:14:56Z",
          "comments": [
            {
              "originalPosition": 29,
              "body": "This is done via the changes to ProposalOrRef further down.",
              "createdAt": "2021-11-17T14:14:56Z",
              "updatedAt": "2021-11-17T14:14:56Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c4wMwqX",
          "commit": {
            "abbreviatedOid": "3c33744"
          },
          "author": "franziskuskiefer",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-11-17T14:19:23Z",
          "updatedAt": "2021-11-17T14:19:23Z",
          "comments": [
            {
              "originalPosition": 29,
              "body": "Ah missed that, never mind \ud83e\udd26\ud83c\udffb ",
              "createdAt": "2021-11-17T14:19:23Z",
              "updatedAt": "2021-11-17T14:19:23Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c4wnX0F",
          "commit": {
            "abbreviatedOid": "3c33744"
          },
          "author": "franziskuskiefer",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-11-25T07:20:25Z",
          "updatedAt": "2021-11-25T07:20:25Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOBoyH6c4w5YEA",
          "commit": {
            "abbreviatedOid": "3c33744"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-12-01T14:40:54Z",
          "updatedAt": "2021-12-01T14:40:54Z",
          "comments": []
        }
      ]
    },
    {
      "number": 511,
      "id": "PR_kwDOBoyH6c4un28S",
      "title": "Remove the requirement for Add in external commit",
      "url": "https://github.com/mlswg/mls-protocol/pull/511",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #505 ",
      "createdAt": "2021-11-16T23:10:47Z",
      "updatedAt": "2021-12-01T18:21:53Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "fefeaf0a5ae3c4daebcacf8ac752aefebf867842",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "no-add-ext-commit",
      "headRefOid": "5a244893cd48393d091743f9533da1eb15326e84",
      "closedAt": "2021-12-01T18:21:52Z",
      "mergedAt": "2021-12-01T18:21:52Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "aba6ccfc29f8ed368121f0985620e51e0aba3e2b"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOBoyH6c4w5YlZ",
          "commit": {
            "abbreviatedOid": "5a24489"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "Approved, but see my comment in https://github.com/mlswg/mls-protocol/issues/505#issuecomment-974637916",
          "createdAt": "2021-12-01T14:42:30Z",
          "updatedAt": "2021-12-01T14:42:30Z",
          "comments": []
        }
      ]
    },
    {
      "number": 512,
      "id": "PR_kwDOBoyH6c4uymDz",
      "title": "Remove explicit version pin on HPKE",
      "url": "https://github.com/mlswg/mls-protocol/pull/512",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "HPKE is in the RFC Editor queue, so there shouldn't be any further changes.\r\n\r\nFixes #500 ",
      "createdAt": "2021-11-19T20:39:01Z",
      "updatedAt": "2021-11-30T22:51:50Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "0aa8fce7086292984c40d55c629d99ef0c78a881",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "hpke-version",
      "headRefOid": "d371e31e8fc737a6823f9f6a38372b89b6d4d9d6",
      "closedAt": "2021-11-30T22:51:50Z",
      "mergedAt": "2021-11-30T22:51:49Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "944ad181dfec5915ade68ec5ba484933b3247ef0"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOBoyH6c4wY3Jk",
          "commit": {
            "abbreviatedOid": "d371e31"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-11-20T11:51:17Z",
          "updatedAt": "2021-11-20T11:51:17Z",
          "comments": []
        }
      ]
    },
    {
      "number": 513,
      "id": "PR_kwDOBoyH6c4uywxD",
      "title": "Two editorial issues",
      "url": "https://github.com/mlswg/mls-protocol/pull/513",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #447 \r\nFixes #468 ",
      "createdAt": "2021-11-19T22:06:36Z",
      "updatedAt": "2021-12-01T18:22:27Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "944ad181dfec5915ade68ec5ba484933b3247ef0",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "editorial",
      "headRefOid": "f95b9d1d96fc4598aaa42e1ad11bfa0118ac2e05",
      "closedAt": "2021-12-01T18:22:26Z",
      "mergedAt": "2021-12-01T18:22:26Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "2de18dce6939cf7cbb619d5824e2560c6e5efd57"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOBoyH6c4wY3M5",
          "commit": {
            "abbreviatedOid": "5f86ddd"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2021-11-20T11:54:13Z",
          "updatedAt": "2021-11-20T11:58:39Z",
          "comments": [
            {
              "originalPosition": 19,
              "body": "```suggestion\r\nThis remove operation allows MLS to efficiently achieve\r\n```",
              "createdAt": "2021-11-20T11:54:13Z",
              "updatedAt": "2021-11-20T11:58:39Z"
            },
            {
              "originalPosition": 20,
              "body": "```suggestion\r\npost-compromise security.  In an Update proposal or a full Commit message, an old, possibly\r\n```",
              "createdAt": "2021-11-20T11:54:38Z",
              "updatedAt": "2021-11-20T11:58:40Z"
            },
            {
              "originalPosition": 49,
              "body": "```suggestion\r\nprivate keys of the tree held by each participant would be as follows, where `_`\r\n```",
              "createdAt": "2021-11-20T11:55:41Z",
              "updatedAt": "2021-11-20T11:58:40Z"
            },
            {
              "originalPosition": 96,
              "body": "Thi reintroduces HPKE draft-08. I guess #512 should be merged after this PR.",
              "createdAt": "2021-11-20T11:58:19Z",
              "updatedAt": "2021-11-20T11:58:40Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c4w2rpm",
          "commit": {
            "abbreviatedOid": "f95b9d1"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-11-30T22:54:32Z",
          "updatedAt": "2021-11-30T22:54:33Z",
          "comments": [
            {
              "originalPosition": 96,
              "body": "I merged #512 so this got fixed as a conflict resolution.",
              "createdAt": "2021-11-30T22:54:33Z",
              "updatedAt": "2021-11-30T22:54:33Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c4w5ZA2",
          "commit": {
            "abbreviatedOid": "f95b9d1"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-12-01T14:43:47Z",
          "updatedAt": "2021-12-01T14:43:47Z",
          "comments": []
        }
      ]
    },
    {
      "number": 514,
      "id": "PR_kwDOBoyH6c4uyzzj",
      "title": "384 Ciphersuite Addition",
      "url": "https://github.com/mlswg/mls-protocol/pull/514",
      "state": "MERGED",
      "author": "br-hale",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #503 ",
      "createdAt": "2021-11-19T22:30:12Z",
      "updatedAt": "2021-12-01T18:22:10Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "0aa8fce7086292984c40d55c629d99ef0c78a881",
      "headRepository": "br-hale/mls-protocol",
      "headRefName": "master",
      "headRefOid": "5f6b5f272a7ef641a34772d232a70c604cd9e7d6",
      "closedAt": "2021-12-01T18:22:10Z",
      "mergedAt": "2021-12-01T18:22:10Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "43a6dcdbc04aeff809e460e3773b25a19be08ade"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOBoyH6c4wYh9J",
          "commit": {
            "abbreviatedOid": "57c5883"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "@br-hale I may have been over-optimistic when I said this was a one-line PR :)  Could you please update the tables below the change you made? You need a row of the following form:\r\n\r\n```\r\n| Value  | KEM    | KDF    | AEAD   | Hash   | Signature              |\r\n|:-------|:-------|:-------|:-------|:-------|:-----------------------|\r\n| 0x0007 | 0x0011 | 0x0002 | 0x0002 | SHA384 | ecdsa_secp384r1_sha384 |\r\n```\r\n\r\n... and to update this text:\r\n\r\n>  In the ciphersuites defined above, \"SHA256\" and \"SHA512\" refer to the SHA-256 and SHA-512 functions defined in {{SHS}}.\r\n\r\nWith those two changes, I think this is good to merge.",
          "createdAt": "2021-11-19T22:46:29Z",
          "updatedAt": "2021-11-19T22:51:32Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "```suggestion\r\n| 0x0007          | MLS10_256_DHKEMP384_AES256GCM_SHA384_P384.            | Y           | RFC XXXX  |\r\n```",
              "createdAt": "2021-11-19T22:46:29Z",
              "updatedAt": "2021-11-19T22:51:32Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c4wYj5A",
          "commit": {
            "abbreviatedOid": "eda75ba"
          },
          "author": "br-hale",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-11-19T23:05:05Z",
          "updatedAt": "2021-11-19T23:05:05Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "You committed to a one-line change! \r\nNo problem - changes made, as well as a typo correction that was lingering in the spec.",
              "createdAt": "2021-11-19T23:05:05Z",
              "updatedAt": "2021-11-19T23:05:05Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c4w2rKJ",
          "commit": {
            "abbreviatedOid": "5f6b5f2"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-11-30T22:51:29Z",
          "updatedAt": "2021-11-30T22:51:29Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOBoyH6c4w5Zpq",
          "commit": {
            "abbreviatedOid": "5f6b5f2"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "If this is needed for the reasons mentioned in the issue, I have no objections.",
          "createdAt": "2021-12-01T14:45:42Z",
          "updatedAt": "2021-12-01T14:45:42Z",
          "comments": []
        }
      ]
    },
    {
      "number": 515,
      "id": "PR_kwDOBoyH6c4uzS2Z",
      "title": "Add protocol version to PGS",
      "url": "https://github.com/mlswg/mls-protocol/pull/515",
      "state": "MERGED",
      "author": "raphaelrobert",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "This is a follow-up to #501 (which was merged before all comments were addressed).",
      "createdAt": "2021-11-20T11:39:00Z",
      "updatedAt": "2021-12-01T06:51:45Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "0aa8fce7086292984c40d55c629d99ef0c78a881",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "pgs-follow-up",
      "headRefOid": "e8a6d08f6f64c09cc1cc297265da3d2c2239de3c",
      "closedAt": "2021-11-30T22:50:25Z",
      "mergedAt": "2021-11-30T22:50:25Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "3e35dbb41921826ad98c2fdb71cf9340146be0b8"
      },
      "comments": [
        {
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Sorry for chiming in so late, but isn't this redundant, as the version is included in the ciphersuite? Same for the `Welcome` message.",
          "createdAt": "2021-12-01T06:51:45Z",
          "updatedAt": "2021-12-01T06:51:45Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOBoyH6c4w2q-B",
          "commit": {
            "abbreviatedOid": "e8a6d08"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-11-30T22:50:15Z",
          "updatedAt": "2021-11-30T22:50:15Z",
          "comments": []
        }
      ]
    },
    {
      "number": 517,
      "id": "PR_kwDOBoyH6c4vN01T",
      "title": "Recommend against self-Update proposals in Commit",
      "url": "https://github.com/mlswg/mls-protocol/pull/517",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #516 ",
      "createdAt": "2021-11-30T23:26:49Z",
      "updatedAt": "2021-12-01T13:44:42Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "944ad181dfec5915ade68ec5ba484933b3247ef0",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "no-self-update",
      "headRefOid": "e6fc5b5e1c6db41c83d8662c7d753ea00f75fcb2",
      "closedAt": "2021-12-01T13:44:41Z",
      "mergedAt": "2021-12-01T13:44:41Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "22511303091bc68165a5208686ad252837f96b3e"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOBoyH6c4w2035",
          "commit": {
            "abbreviatedOid": "e6fc5b5"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-12-01T00:02:17Z",
          "updatedAt": "2021-12-01T00:02:17Z",
          "comments": []
        }
      ]
    },
    {
      "number": 518,
      "id": "PR_kwDOBoyH6c4vN3Iw",
      "title": "Consolidate resumption PSK cases",
      "url": "https://github.com/mlswg/mls-protocol/pull/518",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #502 ",
      "createdAt": "2021-11-30T23:49:26Z",
      "updatedAt": "2021-12-15T16:30:30Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "944ad181dfec5915ade68ec5ba484933b3247ef0",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "consolidate-psk",
      "headRefOid": "a03e84ac1226797c6740eb584a3484d618489b68",
      "closedAt": "2021-12-15T16:30:30Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "br-hale",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Comments in associated #502 discussion.",
          "createdAt": "2021-12-10T22:26:09Z",
          "updatedAt": "2021-12-10T22:26:09Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing in favor of #525 ",
          "createdAt": "2021-12-15T16:30:30Z",
          "updatedAt": "2021-12-15T16:30:30Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOBoyH6c4xaE--",
          "commit": {
            "abbreviatedOid": "a03e84a"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-12-10T13:55:58Z",
          "updatedAt": "2021-12-10T13:55:58Z",
          "comments": []
        }
      ]
    },
    {
      "number": 519,
      "id": "PR_kwDOBoyH6c4vQTbr",
      "title": "Forbid self-Update entirely",
      "url": "https://github.com/mlswg/mls-protocol/pull/519",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #516 ",
      "createdAt": "2021-12-01T15:06:27Z",
      "updatedAt": "2021-12-01T18:13:54Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "22511303091bc68165a5208686ad252837f96b3e",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "no-self-update-2",
      "headRefOid": "073cfc62b2084fbe45e56c67f8a347a743daec4f",
      "closedAt": "2021-12-01T18:13:54Z",
      "mergedAt": "2021-12-01T18:13:54Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "7ae42740abd5576b45a11ecbf378d38a95fe993b"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOBoyH6c4w6dSd",
          "commit": {
            "abbreviatedOid": "073cfc6"
          },
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-12-01T17:59:53Z",
          "updatedAt": "2021-12-01T17:59:53Z",
          "comments": []
        }
      ]
    },
    {
      "number": 520,
      "id": "PR_kwDOBoyH6c4vQznm",
      "title": "Revamp overview sections",
      "url": "https://github.com/mlswg/mls-protocol/pull/520",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "First part of fixing #409 ",
      "createdAt": "2021-12-01T17:06:11Z",
      "updatedAt": "2021-12-15T16:29:35Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "22511303091bc68165a5208686ad252837f96b3e",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "doc-structure",
      "headRefOid": "023f047737d63e2a3a05f2ae8bbe2082587bc2fb",
      "closedAt": "2021-12-15T16:29:35Z",
      "mergedAt": "2021-12-15T16:29:35Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "500f8d670bc73c7e276209ffbc0dd2b0758f452a"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOBoyH6c4xOx_s",
          "commit": {
            "abbreviatedOid": "3654dc6"
          },
          "author": "zouhuan1215",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "some comments on the overview section from a beginner's point of view.",
          "createdAt": "2021-12-08T02:44:01Z",
          "updatedAt": "2021-12-09T13:15:18Z",
          "comments": [
            {
              "originalPosition": 18,
              "body": "`MLS message` is undefined.  How about `..... message carrying information about group operations` ?",
              "createdAt": "2021-12-08T02:44:01Z",
              "updatedAt": "2021-12-09T13:15:18Z"
            },
            {
              "originalPosition": 18,
              "body": "I'm not sure if it is proper to further explain the `proposal`, `commit`, and `welcome` messages used in the handshake protocols here. ",
              "createdAt": "2021-12-08T02:49:13Z",
              "updatedAt": "2021-12-09T13:15:18Z"
            },
            {
              "originalPosition": 55,
              "body": "DS is explained much clear in this way \ud83c\udf7b ",
              "createdAt": "2021-12-08T03:00:21Z",
              "updatedAt": "2021-12-09T13:15:18Z"
            },
            {
              "originalPosition": 115,
              "body": "I love this figure. It explains the relationship of various trees and ratchets much clear. From the beginner's point of view, I think it would be nice to add more functional behavior specifications of the ratchet trees and secret trees here. ",
              "createdAt": "2021-12-08T03:11:49Z",
              "updatedAt": "2021-12-09T13:15:18Z"
            },
            {
              "originalPosition": 115,
              "body": "I'm not sure if I understand MLS correctly: in the handshake protocol, the ratchet tree (as described in section 5) allows group members to efficiently agree on a shared `epoch_secret`; in the application protocol, the secret tree (section 8.3) initiated by `encryption_secret` allows each member to have its own sending secret $s$, furthermore, to achieve forward secrecy, a symmetric key ratchet (section 8.4 and 8.5) initiated by $s$ is maintained per group member. ",
              "createdAt": "2021-12-08T03:26:47Z",
              "updatedAt": "2021-12-09T13:15:18Z"
            },
            {
              "originalPosition": 120,
              "body": "It seems like that the `KeyPackage` and `PublicGroupState` **objects** are not at the same level as the other three **messages**. For example, the `KeyPackage` of a newly added member will be included in an `Add Proposal` message and `PublicGroupState` of the current epoch will be included in a `Welcome` message. ",
              "createdAt": "2021-12-08T06:55:09Z",
              "updatedAt": "2021-12-09T13:15:18Z"
            },
            {
              "originalPosition": 134,
              "body": "It might be more clearer to explain the creation of an MLS message explicitly. For example:\r\n\r\n*To prepare a Proposal message, Commit message or an Application message sent to other members, the sender needs to perform two steps: (1) determine the message content; (2) embed the message content into a common message framing structure. Different message types have different content fields to be filled, as shown in Section 11.1 for proposal messages, Section 11.2 for commit messages. With filled up message content,  the message framing section (Section 9) speficies ways to authenticate and encrypt the message content, as well as ways to assemble the possibly encrypted message content, its authenticate tags and other associated data into an MLS message.*\r\n\r\n*When a member receives an MLS message, it performs two steps accordingly: (1) verifies, decrypts and extracts the message content from the message framing; (2) processes the message content. e.g., if the message content type is Application data, it just forwards the decrypted content to the application; if the message is a Proposal, it may cache this Proposal for future commit; if the message is a Commit, it extracts the committed proposals, applies these proposals to updating its current cryptographic state in order to keep a consistent groups state with the committer.* ",
              "createdAt": "2021-12-08T08:59:38Z",
              "updatedAt": "2021-12-09T13:15:18Z"
            },
            {
              "originalPosition": 134,
              "body": "How about the `Welcome message` ? It seems like that the `Welcome message` is not arranged in the `message framing`?",
              "createdAt": "2021-12-08T09:00:57Z",
              "updatedAt": "2021-12-09T13:15:18Z"
            },
            {
              "originalPosition": 162,
              "body": "Not all commit messages have their corresponding Welcome messages. Only Commit message that commits Add proposals has corresponding Welcome messages?",
              "createdAt": "2021-12-08T11:35:16Z",
              "updatedAt": "2021-12-09T13:15:18Z"
            },
            {
              "originalPosition": 93,
              "body": "`A group represents a linear sequence of epochs` seems somewhat weird to me \ud83d\ude05 ",
              "createdAt": "2021-12-08T11:47:34Z",
              "updatedAt": "2021-12-09T13:15:18Z"
            },
            {
              "originalPosition": 93,
              "body": "The following sentences are from Tijana Klimovic master thesis: [Modular Design of the Messaging\r\nLayer Security (MLS) Protocol](https://ethz.ch/content/dam/ethz/special-interest/infk/inst-infsec/appliedcrypto/education/theses/Modular_Design_of_the_Messaging_Layer_Security__MLS__TijanaKlimovic.pdf)\r\n\r\n*The time frame within which the group members use the same group data to perform sends and receives of application data is called an epoch. Each epoch has a so called epoch number associated to\r\nit, which is equal to the number of commits processed since the group\u2019s creation until this epoch started. Within each epoch, each group member also has their own local message counter, responsible for counting the number of messages sent by this group member within the epoch.*",
              "createdAt": "2021-12-08T12:26:38Z",
              "updatedAt": "2021-12-09T13:15:18Z"
            },
            {
              "originalPosition": 93,
              "body": "How about this?\r\n\r\n*The time frame within which the group members use the same group data to perform sends and receives of application data is called an epoch. The group will enter into a new epoch once group changes (e.g., add/remove/update a member). When a Commit message indicating group changes have taken effect is processed, the epoch number associated to current epoch will increment by 1. In each epoch, a set of authenticated members agree on an epoch secret and MLS assures that only the members in the current epoch have access to the epoch secret. To achieves this, each group member privately maintains a ratchet tree which allows group members to efficiently agree on a shared new epoch secret once group changes. To reflect group changes in the epoch_secret, each group member first applies the Commit message to update its own ratchet tree. Using this updated ratchet tree, group members can compute a shared secret commit_secret which is consistent across the group. With this consistent commit_secret, the epoch secret for this new epoch can be computed via key schedule. From this epoch secret, members derive further shared secrets for this new epoch which will be used for message encryption, group membership authentication, etc. Specifically, within each epoch, each group member has their own local message counter, responsible for counting the number of messages sent by this group member and received from other members within the epoch. To achieve forward-secrecy of messages within the epoch, each group member privately maintains a Secret Tree which initializes the sending and receiving state for the group member as well as symmetric key ratchets to track the sending and receiving state.*",
              "createdAt": "2021-12-09T03:23:49Z",
              "updatedAt": "2021-12-09T13:15:18Z"
            },
            {
              "originalPosition": 257,
              "body": "`A member can update this message by ......` what does `this message` refer to? Or `A member can update its corresponding leaf secret by .......`?",
              "createdAt": "2021-12-09T11:42:35Z",
              "updatedAt": "2021-12-09T13:15:18Z"
            },
            {
              "originalPosition": 257,
              "body": "To say the `leaf secret` of a `member`, it is better to explicitly declare that `a member is associated with a leaf node in the ratchet tree and only this member knows the secret of the leaf node` in the previous Ratchet Tree part.",
              "createdAt": "2021-12-09T11:47:19Z",
              "updatedAt": "2021-12-09T13:15:18Z"
            },
            {
              "originalPosition": 261,
              "body": "I think the core idea of *ratchet tree* is the same as the *sender key*. i.e., when committing a new group change, the committer will re-sample a new group secret $gs$ for the group. But the difficult part is how do the committer efficiently distributes $gs$ to other group members. In *sender key*, the committer simply encrypts $gs$ $N$ times (where N is the number of group members in this group) using each member's public key and delivers each $gs$'s ciphertext to its corresponding group member. In *ratchet tree*, group members are organized into a tree and each member is associated with a leaf node in the tree (i.e., there are $N$ leaf nodes). Furthermore, *ratchet tree* ensures that the secret key of a non-leaf node is known to the members whose corresponding leaf nodes are in the subtree rooted at that non-leaf node. In particular, the secret key of the root node is known by all group members. When the committer needs to distribute the newly sampled group secret $gs$ to the leaf nodes under a non-leaf node $k$, the committer can use the public key of $k$ to encrypt $gs$ instead of individually encrypting $gs$ using each leaf node's public keys. In this way, the ratchet tree achieves a more efficient group key distribution.",
              "createdAt": "2021-12-09T13:10:44Z",
              "updatedAt": "2021-12-09T13:15:18Z"
            },
            {
              "originalPosition": 261,
              "body": "In ratchet tree, the the group secret $gs$ can be viewed as the `secret` of the root node. To sample a new group secret (i.e., the root node secret $rs$) for the group, the committer first updates the ratchet tree by resampling a new leaf secret for its corresponding leaf node. With the updated ratchet tree, the root node secret $rs$ is updated. When distributing this updated ratchet tree to other group members, the committer needs to keep the `tree invariant`, that is, `the secret of a non-leaf node $k$ should be known by all leaf nodes under $k$`.",
              "createdAt": "2021-12-09T13:11:08Z",
              "updatedAt": "2021-12-09T13:15:18Z"
            },
            {
              "originalPosition": 261,
              "body": "To remove a member $m$, the committer simply does not send any information of the updated ratchet tree to $m$, so that $m$ won't know the updated group secret $gs$. \r\nFor post-compromise security, that is, for a client $s$ to quickly recover from a compromised state (e.g., its corresponding leaf secret $ls$ is leaked to an attacker), the client $c$ can send a Commit message asking for resampling its leaf secret as $ls'$. As long as the updated leaf secret $ls'$ is unknown to the attacker, the attacker cannot learn any information regarding the newly updated group secret $gs'$. ",
              "createdAt": "2021-12-09T13:13:32Z",
              "updatedAt": "2021-12-09T13:15:18Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c4xpurS",
          "commit": {
            "abbreviatedOid": "3654dc6"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-12-15T16:03:36Z",
          "updatedAt": "2021-12-15T16:03:36Z",
          "comments": [
            {
              "originalPosition": 18,
              "body": "Updated to refer to Proposal/Commit.  I think it's fine to use them here before their definitions.",
              "createdAt": "2021-12-15T16:03:36Z",
              "updatedAt": "2021-12-15T16:03:36Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c4xpvcD",
          "commit": {
            "abbreviatedOid": "3654dc6"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-12-15T16:06:08Z",
          "updatedAt": "2021-12-15T16:06:08Z",
          "comments": [
            {
              "originalPosition": 115,
              "body": "That understanding is correct!",
              "createdAt": "2021-12-15T16:06:08Z",
              "updatedAt": "2021-12-15T16:06:08Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c4xpwA8",
          "commit": {
            "abbreviatedOid": "3654dc6"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-12-15T16:07:57Z",
          "updatedAt": "2021-12-15T16:07:58Z",
          "comments": [
            {
              "originalPosition": 120,
              "body": "KeyPackage is a little unique in that it is both something that is handled by the application and something that appears within other objects (like `Add` and `Commit`). Other things that are handled by the application are don't appear within other objects (`PublicGroupState`, but also `Welcome`, `MLSPlaintext`, and `MLSCiphertext`)",
              "createdAt": "2021-12-15T16:07:57Z",
              "updatedAt": "2021-12-15T16:07:58Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c4xpxjL",
          "commit": {
            "abbreviatedOid": "3654dc6"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-12-15T16:13:02Z",
          "updatedAt": "2021-12-15T16:13:02Z",
          "comments": [
            {
              "originalPosition": 134,
              "body": "Your proposed text is a bit more detail that I'd like for this section.  But I have revised to clarify that MLSPlaintext/Ciphertext are for messages *within* a group, where as KeyPackage/Welcome/PublicGroupState are *outside* a group.",
              "createdAt": "2021-12-15T16:13:02Z",
              "updatedAt": "2021-12-15T16:13:02Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c4xpyS6",
          "commit": {
            "abbreviatedOid": "3654dc6"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-12-15T16:15:29Z",
          "updatedAt": "2021-12-15T16:15:30Z",
          "comments": [
            {
              "originalPosition": 162,
              "body": "Technically, you can generate a Welcome message with no recipients, in which case you can have a Welcome corresponding to every Commit.  But I can see how that's confusing at this level.  Revised to say \"each Commit that adds member(s) to the group\".",
              "createdAt": "2021-12-15T16:15:29Z",
              "updatedAt": "2021-12-15T16:15:30Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c4xpztp",
          "commit": {
            "abbreviatedOid": "3654dc6"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-12-15T16:20:11Z",
          "updatedAt": "2021-12-15T16:20:11Z",
          "comments": [
            {
              "originalPosition": 93,
              "body": "Agree that this is unclear.  Flipped it around to start with groups and say that a group's history is divided into a linear sequence of epochs. ",
              "createdAt": "2021-12-15T16:20:11Z",
              "updatedAt": "2021-12-15T16:20:11Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c4xp0bj",
          "commit": {
            "abbreviatedOid": "3654dc6"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-12-15T16:22:32Z",
          "updatedAt": "2021-12-15T16:22:33Z",
          "comments": [
            {
              "originalPosition": 257,
              "body": "`can update this message` -- this is just a typo, and we shouldn't mention leaf secrets here.  Reworded.\r\n\r\n",
              "createdAt": "2021-12-15T16:22:32Z",
              "updatedAt": "2021-12-15T16:22:33Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c4xp2It",
          "commit": {
            "abbreviatedOid": "3654dc6"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-12-15T16:27:54Z",
          "updatedAt": "2021-12-15T16:27:55Z",
          "comments": [
            {
              "originalPosition": 261,
              "body": "The differences to sender keys are larger than you say.  With sender keys, each sender has an independent key `k_i`; there is no shared group state.  To remove someone (including PCS updates), each sender needs to distribute a new key `k'_i` to the remaining `N-1` participants.  This results in `(N-1)^2` messages of size `O(1)`.\r\n\r\nIn MLS, because there is shared group state, you only need some entropy that is not sent to the evicted member, as you say.  So you only need a single message of size `O(N-1)` in the worst case and `O(log(N-1))` with a populated tree.",
              "createdAt": "2021-12-15T16:27:54Z",
              "updatedAt": "2021-12-15T16:27:55Z"
            }
          ]
        }
      ]
    },
    {
      "number": 521,
      "id": "PR_kwDOBoyH6c4vXl8j",
      "title": "Add algorithms for link-based trees",
      "url": "https://github.com/mlswg/mls-protocol/pull/521",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "As discussed in #507, having algorithms for a \"link-based\" representation of the tree would help emphasize that the array-based tree representation is not required.  This PR adds them in an appendix.",
      "createdAt": "2021-12-03T15:58:09Z",
      "updatedAt": "2021-12-06T16:39:27Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "2de18dce6939cf7cbb619d5824e2560c6e5efd57",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "algo",
      "headRefOid": "919234f014a9fd611eb643d058d07e8fd3e8c0a9",
      "closedAt": "2021-12-06T16:39:27Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "cc @TWal @franziskuskiefer ",
          "createdAt": "2021-12-03T15:58:25Z",
          "updatedAt": "2021-12-03T15:58:25Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Subsumed by #522 ",
          "createdAt": "2021-12-06T16:39:27Z",
          "updatedAt": "2021-12-06T16:39:27Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOBoyH6c4xGcb3",
          "commit": {
            "abbreviatedOid": "919234f"
          },
          "author": "franziskuskiefer",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "lgtm",
          "createdAt": "2021-12-06T10:23:41Z",
          "updatedAt": "2021-12-06T10:24:18Z",
          "comments": [
            {
              "originalPosition": 31,
              "body": "Do we need both, pseudo code and python code? I'd be fine with the python code only and some of this as comments if you feel like it.",
              "createdAt": "2021-12-06T10:23:41Z",
              "updatedAt": "2021-12-06T10:24:18Z"
            }
          ]
        }
      ]
    },
    {
      "number": 522,
      "id": "PR_kwDOBoyH6c4vctWX",
      "title": "Generalize tree extend/truncate algorithms",
      "url": "https://github.com/mlswg/mls-protocol/pull/522",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This PR builds on #507 and #521.  It adds the following:\r\n\r\n* An explicit note in `Ratchet Tree Terminology` that implementations may use any representation\r\n* A general description of how nodes are added to / removed from the tree\r\n* Specific algorithms for \"array-based trees\" and \"link-based trees\"\r\n\r\n(I also made a few minor editorial revisions.)\r\n\r\n@TWal @franziskuskiefer - I think this hits the right balance of specificity and generality.  Interested in your thoughts here.",
      "createdAt": "2021-12-06T16:30:14Z",
      "updatedAt": "2021-12-15T16:30:09Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "2de18dce6939cf7cbb619d5824e2560c6e5efd57",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "descriptive",
      "headRefOid": "05fdeee5ad6cd808d774b7ccd46e77d46284d8a2",
      "closedAt": "2021-12-15T16:30:08Z",
      "mergedAt": "2021-12-15T16:30:08Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "6754a8edc9d77c902643d37a519b9a546ab00b4e"
      },
      "comments": [
        {
          "author": "TWal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "This looks good!\r\n\r\nIf I am understanding everything well, the normative description for extention / truncation is the section \"Adding and Removing Leaves\", which is a tree-based description?\r\n",
          "createdAt": "2021-12-07T11:45:04Z",
          "updatedAt": "2021-12-07T11:45:04Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOBoyH6c4xKryF",
          "commit": {
            "abbreviatedOid": "3533678"
          },
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-12-07T07:41:33Z",
          "updatedAt": "2021-12-07T07:41:33Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOBoyH6c4xLu0X",
          "commit": {
            "abbreviatedOid": "3533678"
          },
          "author": "TWal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-12-07T11:38:59Z",
          "updatedAt": "2021-12-07T11:39:00Z",
          "comments": [
            {
              "originalPosition": 348,
              "body": "```suggestion\r\nempty leaf to the right, etc. If no empty leaf exists, the tree is extended to\r\n```",
              "createdAt": "2021-12-07T11:38:59Z",
              "updatedAt": "2021-12-07T11:39:00Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c4xK6nu",
          "commit": {
            "abbreviatedOid": "3533678"
          },
          "author": "franziskuskiefer",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-12-07T08:35:46Z",
          "updatedAt": "2021-12-07T11:39:16Z",
          "comments": [
            {
              "originalPosition": 97,
              "body": "`CD` -> `Z`?",
              "createdAt": "2021-12-07T08:35:47Z",
              "updatedAt": "2021-12-07T11:39:16Z"
            },
            {
              "originalPosition": 135,
              "body": "I think this description can lead to confusion. This reads as if only the right most member in the tree could be removed from the group, i.e. removing a member from a group is equal to truncating the tree.",
              "createdAt": "2021-12-07T08:39:06Z",
              "updatedAt": "2021-12-07T11:39:16Z"
            },
            {
              "originalPosition": 348,
              "body": "\"If no empty leaf exists\"",
              "createdAt": "2021-12-07T09:37:37Z",
              "updatedAt": "2021-12-07T11:39:16Z"
            },
            {
              "originalPosition": 417,
              "body": "KeyPackageRef",
              "createdAt": "2021-12-07T11:33:33Z",
              "updatedAt": "2021-12-07T11:39:16Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c4xMNye",
          "commit": {
            "abbreviatedOid": "3533678"
          },
          "author": "TWal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-12-07T13:39:08Z",
          "updatedAt": "2021-12-07T14:28:31Z",
          "comments": [
            {
              "originalPosition": 167,
              "body": "It is a bit weird because it is not clear that `D` is a blank leaf. But then we also have to blank Z and Y if we really want to represent what happens in the protocol. And in the example afterward we would also need to blank C.\r\n\r\nI'm not sure what is the best thing to do here, but there can definitely be a confusion here (somehow the same as the one pointed by @franziskuskiefer)",
              "createdAt": "2021-12-07T13:39:08Z",
              "updatedAt": "2021-12-07T14:28:31Z"
            },
            {
              "originalPosition": 632,
              "body": "```suggestion\r\n        X = self.root.rightmost_leaf()\r\n        assert(X.value == \"_\") # We can only truncate blank leaves\r\n```",
              "createdAt": "2021-12-07T13:53:55Z",
              "updatedAt": "2021-12-07T14:28:31Z"
            },
            {
              "originalPosition": 145,
              "body": "I suggest giving names to make it easier to read. Also add emphasis that there is a unique way to incorporate the new parent in the tree that keeps it left-balanced (-> \" [\u2026] as the only appropriate node [\u2026]\").\r\n\r\n```suggestion\r\nTo add a new leaf: Add leaf L as the new rightmost leaf of the tree.  Add\r\na blank parent node P whose right child is L.  P is attached to the\r\ntree as the right child of the only appropriate node to make the updated tree\r\nleft-balanced (or set it as a new root).  The former right child of the P's\r\nparent becomes P's left child (or the old root becomes the P's left child if\r\nP is the new root).\r\n```",
              "createdAt": "2021-12-07T14:10:47Z",
              "updatedAt": "2021-12-07T14:28:31Z"
            },
            {
              "originalPosition": 159,
              "body": "I also suggest giving names to nodes. Also removing \"(formerly the parent itself)\" because I don't see what that means.\r\nIn the first example, the leaf is D, the parent is Z, the parent's parent is Y, so the sentence says that Y's right child is now Z's left child (so C). I don't get what \"former parent\" means here.\r\n```suggestion\r\nTo remove the rightmost leaf: Remove the rightmost leaf node L and its parent\r\nnode P.  If P was the root of the tree, P's left child\r\nis now the root of the tree.  Otherwise, set the right child of P's parent\r\nto be the P's left child.\r\n```",
              "createdAt": "2021-12-07T14:26:44Z",
              "updatedAt": "2021-12-07T14:28:31Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c4xMfqA",
          "commit": {
            "abbreviatedOid": "3533678"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-12-07T14:32:51Z",
          "updatedAt": "2021-12-07T14:32:52Z",
          "comments": [
            {
              "originalPosition": 97,
              "body": "```suggestion\r\n* The resolution of root node is the list \\[A, Z, C\\]\r\n```",
              "createdAt": "2021-12-07T14:32:51Z",
              "updatedAt": "2021-12-07T14:32:52Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c4xMgJw",
          "commit": {
            "abbreviatedOid": "3533678"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-12-07T14:34:22Z",
          "updatedAt": "2021-12-07T14:34:24Z",
          "comments": [
            {
              "originalPosition": 135,
              "body": "```suggestion\r\nnecessary to add and remove leaves of the tree in order to reflect changes to the\r\nmembership of the group (see {{add}} and {{remove}}).  Leaves are always added and removed at the\r\n```",
              "createdAt": "2021-12-07T14:34:23Z",
              "updatedAt": "2021-12-07T14:34:24Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c4xMhXi",
          "commit": {
            "abbreviatedOid": "3533678"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-12-07T14:37:59Z",
          "updatedAt": "2021-12-07T14:38:00Z",
          "comments": [
            {
              "originalPosition": 167,
              "body": "`D` isn't necessarily a blank leaf.   In principle, one can remove the rightmost leaf even if it's populated.  This section is just describing the structure modifications; the later sections deal with what's in the tree when it gets update.",
              "createdAt": "2021-12-07T14:38:00Z",
              "updatedAt": "2021-12-07T14:38:00Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c4xMhqW",
          "commit": {
            "abbreviatedOid": "3533678"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-12-07T14:38:50Z",
          "updatedAt": "2021-12-07T14:38:51Z",
          "comments": [
            {
              "originalPosition": 417,
              "body": "```suggestion\r\n      the member with KeyPackageRef `GroupInfo.signer`. Set the private key for\r\n```",
              "createdAt": "2021-12-07T14:38:50Z",
              "updatedAt": "2021-12-07T14:38:51Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c4xMjFV",
          "commit": {
            "abbreviatedOid": "3533678"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-12-07T14:43:08Z",
          "updatedAt": "2021-12-07T14:43:57Z",
          "comments": [
            {
              "originalPosition": 458,
              "body": "```suggestion\r\n\r\n(Note that this is the same ordering of nodes as in the array-based tree representation\r\ndescribed in {{array-based-trees}}.  The algorithms in that section may be used to \r\nsimplify decoding this extension into other representations.)\r\n\r\n```",
              "createdAt": "2021-12-07T14:43:08Z",
              "updatedAt": "2021-12-07T14:43:57Z"
            },
            {
              "originalPosition": 458,
              "body": "```suggestion\r\n\r\n(Note that this is the same ordering of nodes as in the array-based tree representation\r\ndescribed in {{array-based-trees}}.  The algorithms in that section may be used to \r\nsimplify decoding this extension into other representations.)\r\n\r\n```",
              "createdAt": "2021-12-07T14:43:56Z",
              "updatedAt": "2021-12-07T14:43:57Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c4xMj2R",
          "commit": {
            "abbreviatedOid": "3533678"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-12-07T14:45:18Z",
          "updatedAt": "2021-12-07T14:45:18Z",
          "comments": [
            {
              "originalPosition": 632,
              "body": "As above, not true that we can only truncate blank leaves.",
              "createdAt": "2021-12-07T14:45:18Z",
              "updatedAt": "2021-12-07T14:45:18Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c4xMqd8",
          "commit": {
            "abbreviatedOid": "3925732"
          },
          "author": "TWal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-12-07T15:04:49Z",
          "updatedAt": "2021-12-07T15:04:58Z",
          "comments": [
            {
              "originalPosition": 178,
              "body": "Even if this only describe the structure modification, I think it is valuable to give hints to the reader that in practice only blank leaves will be removed. If here the reader thinks that we can truncate any leaf and only afterward the reader discovers that only blank leaves can be truncated, I think it can be confusing.\r\nAlso it might look like a violation of the tree invariant, since in the second tree, D knows Y's secret without being its descendant.\r\n\r\n```suggestion\r\n\r\nNote: in the rest of the protocol, the rightmost leaf will be removed only when it is blank.\r\n\r\n```",
              "createdAt": "2021-12-07T15:04:49Z",
              "updatedAt": "2021-12-07T15:04:58Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c4xPYM-",
          "commit": {
            "abbreviatedOid": "05fdeee"
          },
          "author": "franziskuskiefer",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Thanks lgtm now",
          "createdAt": "2021-12-08T08:06:21Z",
          "updatedAt": "2021-12-08T08:06:21Z",
          "comments": []
        }
      ]
    },
    {
      "number": 523,
      "id": "PR_kwDOBoyH6c4vgvGO",
      "title": "Move `wire_format` to a separate tagged-union structure MLSMessage",
      "url": "https://github.com/mlswg/mls-protocol/pull/523",
      "state": "MERGED",
      "author": "TWal",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "The current use of `wire_format` is a bit weird to me: it is the first value of both `MLSPlaintext` and `MLSCiphertext` which allows the implementations to differentiate between them. Then it looks like it should be implemented as a regular tagged union, which is what this pull request does.\r\n\r\nThis does not imply any changes to existing implementations.\r\n\r\nOne thing that this pull-request changes is that `MLSPlaintext` is forced to have `wire_format = mls_plaintext`, but I don't see why it would have any other values in this case?",
      "createdAt": "2021-12-07T16:50:20Z",
      "updatedAt": "2022-02-11T20:53:12Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "838f0e15951b49af438bad501f3bd787798c2f4d",
      "headRepository": "TWal/mls-protocol",
      "headRefName": "twal_wire_format",
      "headRefOid": "79c5624f413dfc9ce8c174a28cbd39262b2bcdab",
      "closedAt": "2022-02-11T20:53:11Z",
      "mergedAt": "2022-02-11T20:53:11Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "5c43b592e51d0b0a500b9cc321920b949eb703b8"
      },
      "comments": [
        {
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "body": "I think this problematic, because it implies that the wire format of an `MLSPlaintext` is always `mls_plaintext` (which is true for the final format on the wire, but not when handling things internally). Since the wire format is part of `MLSPlaintextTBS`, this would be confusing for a decrypted `MLSCiphertext` for example. The way it is now is also really nice from an implementation standpoint, because the wire format field essentially tracks whether an `MLSPlaintext` was previously an `MLSCiphertext`.",
          "createdAt": "2021-12-10T14:03:38Z",
          "updatedAt": "2021-12-10T14:03:38Z"
        },
        {
          "author": "TWal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thank you, now I understand better why `MLSPlaintext` doesn't have `wire_format = mls_plaintext` like in `MLSCiphertext`.\r\n\r\nI didn't think that `MLSCiphertext` were decoded to a `MLSPlaintext`. In fact, the document never mentions this, however it mentions the converse at the end of section 9.0 (but doesn't talk about `wire_format` though).\r\nIn the rest of the document, messages are named as `MLSPlaintext` (e.g. \"The MLSPlaintext MUST be signed\" and not \"The message MUST be signed\"), so implicitly `MLSCiphertext` have been converted to `MLSPlaintext` (which is a bit weird I think, especially regarding the `membership_tag` that exists in `MLSPlaintext` and not in `MLSCiphertext`).\r\n\r\nI think it would be valuable to refactor the part of the document related to message framing to remove such ambiguities.\r\n\r\nThe easiest way would be to be explicit about the conversion between `MLSPlaintext` and `MLSCiphertext`.\r\n\r\nI spent a lot of time thinking about the nicest way to handle these structures when I implemented these things in the F* implementation of MLS, and I think it could lead to a refactorization of this document.\r\n\r\nWe can define the content of a message (so really, meta-data + the real content) like this:\r\n\r\n    struct {\r\n        opaque group_id<0..255>;\r\n        uint64 epoch;\r\n        Sender sender;\r\n        opaque authenticated_data<0..2^32-1>;\r\n    \r\n        ContentType content_type;\r\n        select (MLSPlaintext.content_type) {\r\n            case application:\r\n              opaque application_data<0..2^32-1>;\r\n    \r\n            case proposal:\r\n              Proposal proposal;\r\n    \r\n            case commit:\r\n              Commit commit;\r\n        }\r\n    } MLSMessageContent;\r\n\r\nAnd the authentication of a message like this:\r\n\r\n    struct {\r\n        opaque signature<0..2^16-1>;\r\n        optional<MAC> confirmation_tag;\r\n    } MLSMessageAuth;\r\n\r\nIf you have a `MLSMessageContent`, you can compute `MLSMessageAuth` (using a signing key, `confirmation_key`, `interim_transcript_hash` and `GroupContext`).\r\nThis would be done by filling correctly the structures `MLSMessageContentTBS` and `MLSMessageContentTBM` (previously `MLSPlaintextTB.`)\r\n\r\nYou can then do the following conversions:\r\n* `MLSPlaintext` to `(MLSMessageContent, MLSMessageAuth)`\r\n* `(MLSMessageContent, MLSMessageAuth)` to `MLSPlaintext` (using `membership_key` and `GroupContext` to compute `membership_tag`)\r\n* `MLSCiphertext` to `(MLSMessageContent, MLSMessageAuth)` (using `sender_data_secret`, and the current state of the Secret Tree)\r\n* `(MLSMessageContent, MLSMessageAuth)` to `MLSCiphertext` (using `sender_data_secret`, and the current state of the Secret Tree)\r\n\r\nThen the rest of the document can then talk about `MLSMessageContent` instead of `MLSPlaintext`.\r\n\r\nI would understand if you want to do the minimal possible changes, however I think doing this kind of big refactor would make this document a lot easier to understand for a first-time reader.\r\n",
          "createdAt": "2021-12-10T16:24:46Z",
          "updatedAt": "2021-12-10T16:24:46Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "@TWal - That proposal actually seems like it could make the programming easier, in addition to making the text clearer.  I would be game for a PR if you'd like to write one up.\r\n\r\nGoing back to the original point about `wire_format`: Note that the signature in the MLSMessageAuth is specific to a wire format, so the conversions you note might not be quite as decoupled as you think.  But you still end up with something nicer than what we have today. \r\n\r\n```\r\n# Signing + Encryption\r\n\r\nMLSMessageContent \r\n  --(GroupContext, wire_format, sig_priv, confirmation_key)--> \r\n  (wire_format, MLSMessageContent, MLSMessageAuth)\r\n\r\n  * Compute message signature\r\n  * Update confirmed transcript hash\r\n  * Compute confirmation tag\r\n  * Update interim transcript hash\r\n\r\n\r\n(mls_plaintext, MLSMessageContent, MLSMessageAuth) \r\n  --(GroupContext, membership_key)--> \r\n  MLSPlaintext\r\n\r\n  * Compute membership_tag\r\n  * Assemble MLSPlaintext\r\n\r\n\r\n(mls_ciphertext, MLSMessageContent, MLSMessageAuth) \r\n  --(sender_data_secret, Secret Tree)-->\r\n  MLSCiphertext\r\n\r\n  * Encode and encrypt content\r\n  * Encode and encrypt sender data\r\n  * Assemble MLSCiphertext\r\n\r\n\r\n# Decryption + Verification\r\n\r\nMLSPlaintext \r\n  --(GroupContext, membership_key)-->\r\n  (mls_plaintext, MLSMessageContent, MLSMessageAuth)\r\n\r\n  * Verify membership_tag\r\n  * Parse MLSPlaintext into MLSMessageContent, MLSMessageAuth\r\n\r\n\r\nMLSCiphertext\r\n  --(sender_data_secret, Secret Tree)-->\r\n  (mls_ciphertext, MLSMessageContent, MLSMessageAuth)\r\n\r\n  * Decrypt and decode sender data\r\n  * Decrypt and decode content\r\n  * Parse MLSCiphertext and decrypted values into MLSMessageContent, MLSMessageAuth\r\n\r\n\r\n(wire_format, MLSMessageContent, MLSMessageAuth)\r\n  --(GroupContext, wire_format, sig_pub, confirmation_key)-->\r\n  MLSMessageContent\r\n\r\n  * Verify message signature\r\n  * Update confirmed transcript hash\r\n  * Verify confirmation tag\r\n  * Update interim transcript hash\r\n```",
          "createdAt": "2021-12-14T20:06:07Z",
          "updatedAt": "2021-12-14T20:06:07Z"
        },
        {
          "author": "TWal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Okay, I'll start working on a PR that uses this decomposition!",
          "createdAt": "2021-12-16T16:37:42Z",
          "updatedAt": "2021-12-16T16:37:42Z"
        },
        {
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "body": "I'm not against attempting to refactor this. It has grown organically over time and could certainly benefit from a holistic overhaul. (@TWal not that you omitted the membership tag in your proposal above)",
          "createdAt": "2021-12-16T18:11:24Z",
          "updatedAt": "2021-12-16T18:11:24Z"
        },
        {
          "author": "TWal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I made a first draft on how the Message Framing section would look like after the refactor. If you agree about these changes I'll change the mentions to `MLSPlaintext` everywhere in the document. What do you think about it? I'm not used to write RFC-like documents so I'm not 100% sure about the formulation I used.\r\n\r\n@raphaelrobert the membership tag is present only in the plaintext and not is the ciphertext, so is it is not part of `MLSMessageAuth`, but only part of `MLSPlaintext`.",
          "createdAt": "2021-12-17T16:40:20Z",
          "updatedAt": "2021-12-17T16:40:20Z"
        },
        {
          "author": "rohan-wire",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I independently was working on a rewrite of the definition of MLSPlaintext as follows. Note that this makes the presence of the confirmation_tag and membership_tag more explicit.\r\n\r\nI am also not a fan of the name `authenticated_data` because all the data in MLSPlaintextTBS is authenticated. I am open to other suggestions.\r\n\r\n    struct {\r\n        WireFormat wire_format;\r\n        opaque group_id<0..255>;\r\n        uint64 epoch;\r\n        Sender sender;\r\n        opaque extra_authenticated_data<0..2^32-1>;\r\n        ContentType content_type;\r\n        select (MLSPlaintext.content_type) {\r\n            case application:\r\n              opaque application_data<0..2^32-1>;\r\n            case proposal:\r\n              Proposal proposal;\r\n            case commit:\r\n              Commit commit;\r\n        }\r\n    } MLSPlaintextTBS;\r\n    \r\n    struct {\r\n        WireFormat wire_format = mls_plaintext;\r\n        opaque group_id<0..255>;\r\n        uint64 epoch;\r\n        Sender sender;\r\n        opaque extra_authenticated_data<0..2^32-1>;\r\n        ContentType content_type;\r\n        select (MLSPlaintext.content_type) {\r\n            case proposal:\r\n              Proposal proposal;\r\n            case commit:\r\n              Commit commit;\r\n        }\r\n        opaque mls_plaintext_signature<Signature_length>;\r\n        select (MLSPlaintext.content_type) {\r\n            case commit:\r\n                opaque confirmation_tag<MAC_length>;\r\n        }\r\n        select (MLSPlaintext.sender.sender_type) {\r\n            case member:\r\n                opaque membership_tag<MAC_length>;\r\n        }\r\n    } MLSPlaintext;\r\n\r\n",
          "createdAt": "2022-01-10T19:37:09Z",
          "updatedAt": "2022-01-10T19:37:09Z"
        },
        {
          "author": "TWal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "About `authenticated_data`: I agree with you, `extra_authenticated_data` is indeed a better name!\r\n\r\nAbout putting things into `select`s:\r\n- From a specification point of view, I agree it is appealing to constrain the message format instead of saying that \"some optional MUST contain a value when [...]\" in the prose below.\r\n- From an implementation point of view, it makes the message parsing/serializing a bit more difficult to do. I'm guessing in most TLS parsing/serializing libraries, it's easy to do tagged-union-like parsing but a bit annoying to do more complex things.\r\n\r\nAbout using `MAC_length` instead of variable-length arrays: I think this is a bad idea, because it means the parser has to know which ciphersuite is in use. We typically don't know this when parsing the `MLSPlaintext` or `MLSCiphertext` since we don't know which group it is for before parsing it. We could technically parse the beginning of the message to extract the `group_id` and then parse the rest of the message, but I think it's a bit ugly to do it like this instead of having a variable-length field.\r\n",
          "createdAt": "2022-01-12T12:47:56Z",
          "updatedAt": "2022-01-12T12:47:56Z"
        },
        {
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "If we're changing the name of `authenticated_data`, I'd suggest `associated_authenticated_data` (`aad`), matching the terminology from AEAD (authenticated encryption with associated data), which is where it ends up being used.",
          "createdAt": "2022-01-12T13:08:20Z",
          "updatedAt": "2022-01-12T13:08:20Z"
        },
        {
          "author": "rohan-wire",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@TWal have you made any more progress on this refactor?\r\n\r\nI am definitely still partial to using `select`s. Your comment about MAC_size makes sense to me.",
          "createdAt": "2022-01-27T13:53:02Z",
          "updatedAt": "2022-01-27T13:53:02Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Discussion on working call:\r\n\r\n* General agreement that this approach is good\r\n* Holding this PR until after section rearrangement\r\n* @rohan-wire suggests extending the `wire_format` idea to other types\r\n    * e.g., Welcome, PublicGroupState\r\n    * @kkohbrok notes that this could help with unambiguous signatures as well\r\n    * Let's handle as a follow-on once this merges",
          "createdAt": "2022-01-27T15:40:07Z",
          "updatedAt": "2022-01-27T15:40:07Z"
        },
        {
          "author": "TWal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I just made the merge post-section rearranging (it was an ugly one, it was easier to re-do it from scratch).\r\n\r\n@rohan-wire I opened the issue #574 to talk about it, since I feel it belong to a separate discussion.\r\n\r\nAbout adding `Welcome` and `PublicGroupState` in `wire_format`, that means we should add them in the `select` for `MLSMessage`?",
          "createdAt": "2022-02-02T18:20:22Z",
          "updatedAt": "2022-02-02T18:20:22Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Discussion on virtual interim:\r\n\r\n* Re: @TWal's question - Yes, let's cover all the types\r\n    * @rohan-wire notes that we should also cover KeyPackage",
          "createdAt": "2022-02-03T16:01:03Z",
          "updatedAt": "2022-02-03T16:01:03Z"
        },
        {
          "author": "rohan-wire",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> @rohan-wire I opened the issue #574 to talk about it, since I feel it belong to a separate discussion.\r\nThanks. Good call.\r\n \r\n> About adding `Welcome` and `PublicGroupState` in `wire_format`, that means we should add them in the `select` for `MLSMessage`?\r\nYes. And also KeyPackage.\r\n",
          "createdAt": "2022-02-03T23:32:19Z",
          "updatedAt": "2022-02-03T23:32:53Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "@TWal - Also happy to merge this and do the extra content types in a follow-up.  Up to you.",
          "createdAt": "2022-02-07T21:19:37Z",
          "updatedAt": "2022-02-07T21:19:37Z"
        },
        {
          "author": "TWal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "We still need to change the references to `MLSPlaintext` everywhere. I'll handle this tomorrow, and handle the extra content types at the same time",
          "createdAt": "2022-02-07T22:16:32Z",
          "updatedAt": "2022-02-07T22:16:32Z"
        },
        {
          "author": "TWal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I just updated it, however I noticed something a bit weird when removing the mentions to `MLSPlaintext`:\r\n```\r\nProposalRef, the `value` input is the MLSPlaintext carrying the proposal, and\r\nthe KDF is determined by the group's ciphersuite.\r\n```\r\nWhy do we make a hashref of the `MLSPlaintext` and not the `Proposal`?\r\nIn any case it looks like we need to do a non-editorial change here.",
          "createdAt": "2022-02-08T15:09:47Z",
          "updatedAt": "2022-02-08T15:09:47Z"
        },
        {
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "body": "I think this goes in the right direction, but I'm wondering about the authentication of the `wire_format` field in `MLSMessage`:\r\n - It is authenticated as part of `MLSMessageContentTBS` for `MLSPlaintext`/MLSCiphertext`\r\n - It is not authenticated for all other message types\r\n\r\nI'd like to propose the following changes:\r\n - the `wire_format` filed should also be authenticated for other messages, it can simply be part of `KeyPackageTBS` etc.\r\n - we have a `protocol_version` field in all messages except `MLSPlaintext`/`MLSCiphertext`: we should extract it and add it right after the `wire_format` field for all messages. This would increase the size by two bytes in some cases, but I think that's tolerable. Obviously we can also authenticate that field.\r\n - with the above, there is no need for the optional version number proposed in #581. I think having it in the message would be much more robust and future-proof.",
          "createdAt": "2022-02-08T20:32:08Z",
          "updatedAt": "2022-02-08T20:32:08Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Discussion on virtual interim:\r\n\r\n* Why is MLSPlaintext hashed?\r\n    * To capture the sender in the transcript, important for Update\r\n    * Probably want some struct that captures (wire format, MLSMessageContent, MLSMessageAuth)\r\n* Changing option to select\r\n    * Already have the cross-message problem in MLSCiphertextContent\r\n    * Could do a template-like thing, \u00e0 la C++\r\n    * Having the cross-message dependency seems OK\r\n    * For transcript hash input of MLSMessageAuth, just don't have optional/select\r\n* Sign wire format?  Replace labeled signature?\r\n    * Leave this for later, including leaving inconsistency between wire format and label as distinguishers\r\n    * See #589\r\n* Protocol version in MLSMessage?\r\n    * Labeled signing already adds MLS version\r\n    * Might need an explicit version, e.g., to aid in parsing, could replace the version in the labeled signing\r\n    * Filed as #590 \r\n* TODO(@TWal) Update to use select with cross-message dependency, then clear to merge",
          "createdAt": "2022-02-10T16:06:35Z",
          "updatedAt": "2022-02-10T16:06:35Z"
        },
        {
          "author": "TWal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think this is now mergable, I introduced a new structure `MLSMessageContentAuth` for `ProposalRef`.",
          "createdAt": "2022-02-11T14:05:02Z",
          "updatedAt": "2022-02-11T14:05:02Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOBoyH6c4z_9HG",
          "commit": {
            "abbreviatedOid": "66a1775"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Looks good to me, once the additional MLSMessageType values are in.",
          "createdAt": "2022-02-03T20:57:35Z",
          "updatedAt": "2022-02-03T20:57:35Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOBoyH6c40fe7c",
          "commit": {
            "abbreviatedOid": "79c5624"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-02-11T20:52:55Z",
          "updatedAt": "2022-02-11T20:52:55Z",
          "comments": []
        }
      ]
    },
    {
      "number": 524,
      "id": "PR_kwDOBoyH6c4v0_cY",
      "title": "Careful truncation",
      "url": "https://github.com/mlswg/mls-protocol/pull/524",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "As @kkohbrok noted [on the mailing list](https://mailarchive.ietf.org/arch/msg/mls/P8CiOeQy3lev7s5vbnaRkPwRa1Q/), the current truncation algorithm breaks parent hashes.  This PR implements the \"careful truncation\" algorithm he proposes.",
      "createdAt": "2021-12-14T14:45:18Z",
      "updatedAt": "2022-01-20T20:49:57Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "2de18dce6939cf7cbb619d5824e2560c6e5efd57",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "ph-trunc",
      "headRefOid": "15d265dc830e8a7848937f1f63ef91d17ed5d131",
      "closedAt": "2022-01-20T20:49:56Z",
      "mergedAt": "2022-01-20T20:49:56Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "28489f2c85c9bee07b0d4aff3b81b5fb59572e8f"
      },
      "comments": [
        {
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "body": "I think this should be good to go?",
          "createdAt": "2022-01-10T20:37:47Z",
          "updatedAt": "2022-01-10T20:37:47Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Merging this for now to un-break the spec.  I will work with Marta to see if we can make a follow-up that removes redundant nodes, so that we can get back to more aggressive truncation.",
          "createdAt": "2022-01-20T20:49:35Z",
          "updatedAt": "2022-01-20T20:49:35Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOBoyH6c4xkqqA",
          "commit": {
            "abbreviatedOid": "43c82e5"
          },
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-12-14T15:50:55Z",
          "updatedAt": "2021-12-14T15:50:56Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "If the parent node is the root node, it can be removed even if it is non-blank, since removing the root node doesn't destroy any valid parent hash chains.",
              "createdAt": "2021-12-14T15:50:56Z",
              "updatedAt": "2021-12-14T15:50:56Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c4xlBIt",
          "commit": {
            "abbreviatedOid": "16add2e"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-12-14T16:59:35Z",
          "updatedAt": "2021-12-14T16:59:35Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "Good point.  Updated to reflect this.",
              "createdAt": "2021-12-14T16:59:35Z",
              "updatedAt": "2021-12-14T16:59:35Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c4xlZvo",
          "commit": {
            "abbreviatedOid": "16add2e"
          },
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-12-14T18:31:00Z",
          "updatedAt": "2021-12-14T18:31:00Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOBoyH6c4xvAWk",
          "commit": {
            "abbreviatedOid": "16add2e"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-12-16T17:34:12Z",
          "updatedAt": "2021-12-16T17:34:13Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "```suggestion\r\n  as all of the following conditions hold (since non-blank intermediate nodes hold\r\n```",
              "createdAt": "2021-12-16T17:34:12Z",
              "updatedAt": "2021-12-16T17:34:13Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c4y3TrW",
          "commit": {
            "abbreviatedOid": "15d265d"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-01-14T20:33:57Z",
          "updatedAt": "2022-01-14T20:33:57Z",
          "comments": []
        }
      ]
    },
    {
      "number": 525,
      "id": "PR_kwDOBoyH6c4v5flh",
      "title": "Tighten up branch and reinit; define ResumptionPSKUsage",
      "url": "https://github.com/mlswg/mls-protocol/pull/525",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This PR reflects further discussion on #502 and replaces #518.  The high-level impacts are:\r\n\r\n* Add clearer, more prescriptive definitions of the re-init and branch operations\r\n* Use a single syntax for all resumption PSKs, but also have a `usage` parameter to distinguish cases\r\n* Allow an `application` usage to cover any other cases defined by applications\r\n\r\nOnce #520 lands, we should also add some text to the protocol overview to describe these operations.  Pasting some text here for usage in that future PR...\r\n\r\n```\r\n## Relationships Between Epochs\r\n\r\nA group comprises a single linear sequence of epochs. However, it can sometimes\r\nbe useful to express relationships between epochs, either within a group or\r\nacross groups.  MLS derives a resumption pre-shared key (PSK) from each epoch to\r\nallow a entropy extracted from one epoch to be injected into a future epoch,\r\neffectively creating a causal link between the two epochs.\r\n\r\nMLS supports two ways to tie a new group to an existing group. Re-initialization\r\ncloses one group and creates a new group comprising the same members with\r\ndifferent parameters. Branching starts a new group with a subset of the original\r\ngroup's participants (with no effect on the original group).  In both cases,\r\nthe new group is linked to the old group via a resumption PSK.\r\n\r\n~~~~~\r\nepoch_A_[n-1]\r\n     |\r\n     |\r\n     |<-- ReInit\r\n     |\r\n     V\r\nepoch_A_[n]           epoch_B_[0]\r\n     .                     |\r\n     .  PSK(usage=reinit)  |\r\n     .....................>|\r\n                           |\r\n                           V\r\n                      epoch_B_[1]\r\n~~~~~\r\n{: title=\"Reinitializing a group\" }\r\n\r\n\r\n~~~~~\r\nepoch_A_[n-1]\r\n     |\r\n     |\r\n     |<-- ReInit\r\n     |\r\n     V\r\nepoch_A_[n]           epoch_B_[0]\r\n     |                     |\r\n     |  PSK(usage=branch)  |\r\n     |....................>|\r\n     |                     |\r\n     V                     V\r\nepoch_A_[n+1]         epoch_B_[1]\r\n~~~~~\r\n{: title=\"Branching a group\" }\r\n\r\nApplications may also choose to use resumption PSKs to link epochs in other\r\nways.  For example, the following figure shows a case where a resumption PSK\r\nfrom epoch `n` is injected into epoch `n+k`.  This demonstrates that the members\r\nof the group at epoch `n+k` were also members at epoch `n` (irrespective of any\r\nchanges to these members' keys due to Updates or Commits.\r\n\r\n~~~~~\r\nepoch_A_[n-1]\r\n     |\r\n     |\r\n     |<-- ReInit\r\n     |\r\n     V\r\nepoch_A_[n]\r\n     |                     \r\n     |  PSK(usage=application)  \r\n     |.....................\r\n     |                    . \r\n     |                    . \r\n    ...                  ...\r\n     |                    . \r\n     |                    . \r\n     V                    .\r\nepoch_A_[n+k-1]           .\r\n     |                    . \r\n     |                    . \r\n     |<.................... \r\n     |                      \r\n     V                     \r\nepoch_A_[n+k]       \r\n~~~~~\r\n{: title=\"Reinjecting entropy from an earlier epoch\" }\r\n```",
      "createdAt": "2021-12-15T15:45:11Z",
      "updatedAt": "2022-01-26T13:56:32Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "4e3bf741c54764d266ed7065e1a6e8507eaf332e",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "psk-usages",
      "headRefOid": "9e6b0595a83be8f34c25699ce6f3882c5271e525",
      "closedAt": "2022-01-26T13:56:32Z",
      "mergedAt": "2022-01-26T13:56:32Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "0093b047461246b89b2ba72682ef00213df52851"
      },
      "comments": [
        {
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "One question regarding the diagram in the PR description. In the re-init case, shouldn't the \"B\" group start at epoch `n+1`? At least that's what the PR specifies in the spec.",
          "createdAt": "2021-12-16T07:20:05Z",
          "updatedAt": "2021-12-16T07:20:05Z"
        },
        {
          "author": "TWal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think the re-init diagram is fine because the spec says\r\n\r\n    The `epoch` in the Welcome message MUST be 1\r\n\r\nHowever in the branch case (and application case) diagram I don't think there should be a ReInit proposal? (At least it is not said in the spec).\r\n\r\nAlso, it is not entirely clear how to construct a `PreSharedKeyID` in the branch case (or application case): what values should have `psk_group_id` and `psk_epoch`?",
          "createdAt": "2021-12-16T13:32:51Z",
          "updatedAt": "2021-12-16T13:32:51Z"
        },
        {
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Ah, sorry I misread. You are right and the re-init diagram is fine the way it is.",
          "createdAt": "2021-12-16T13:55:29Z",
          "updatedAt": "2021-12-16T13:55:29Z"
        },
        {
          "author": "br-hale",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Minor typo in the text above: \"allow a entropy\" -> \"allow entropy\".",
          "createdAt": "2021-12-17T06:16:33Z",
          "updatedAt": "2021-12-17T06:16:33Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOBoyH6c4xsV07",
          "commit": {
            "abbreviatedOid": "5b9590b"
          },
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "Looks good! Although I'm not sure in the branching keys we want to have the exact same key packages as in the main group.",
          "createdAt": "2021-12-16T07:01:28Z",
          "updatedAt": "2021-12-16T07:04:48Z",
          "comments": [
            {
              "originalPosition": 173,
              "body": "Do we really want the KeyPackages to be identical? This seems to constitute key-reuse across groups. This is where a (identity,endpoint_id) tuple would come in handy ;-) But I think going with the new multi-identity credentials, we could mandate here that the application has to ensure that the participants in the new group are a subset of the participants in the old group",
              "createdAt": "2021-12-16T07:01:28Z",
              "updatedAt": "2021-12-16T07:04:48Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c4xvGQv",
          "commit": {
            "abbreviatedOid": "5b9590b"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "I think this looks fine generally (just one comment)",
          "createdAt": "2021-12-16T17:57:54Z",
          "updatedAt": "2021-12-16T18:01:16Z",
          "comments": [
            {
              "originalPosition": 143,
              "body": "I wonder if we can be a bit more firm on the fact that the Welcome message should be provided at the same time as the Commit. Because if not, there's an attack vector where malicious members can shut down a group without an obvious way to recover from it.",
              "createdAt": "2021-12-16T17:57:54Z",
              "updatedAt": "2021-12-16T18:01:16Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c4zGE1V",
          "commit": {
            "abbreviatedOid": "5b9590b"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-01-19T19:05:20Z",
          "updatedAt": "2022-01-19T19:05:21Z",
          "comments": [
            {
              "originalPosition": 143,
              "body": "I might go the other way, allowing any member of the group to send the Welcome.  That way as long as anyone is behaving properly, they can revive the closed group.  Up to the application to decide who does it.",
              "createdAt": "2022-01-19T19:05:20Z",
              "updatedAt": "2022-01-19T19:05:21Z"
            }
          ]
        }
      ]
    },
    {
      "number": 526,
      "id": "PR_kwDOBoyH6c4v8b_5",
      "title": "Unambiguous signatures",
      "url": "https://github.com/mlswg/mls-protocol/pull/526",
      "state": "MERGED",
      "author": "TWal",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Signatures as specified in the MLS protocol document are ambiguous, in the sense that signatures produced for one purpose in the protocol can be (maliciously) used in a different place of the protocol.\r\nIndeed, we found that for example, a `KeyPackage` can have the same serialization as `MLSPlaintextTBS`, which proves that one signature could be accepted for different structures.\r\n\r\nThe collisions we have found so far are quite artificial, so it is not super clear how to exploit this, but at least it makes it impossible to have provable security.\r\n\r\nThe solution is pretty simple, we simply prefix each signed value with a label, in a fashion similar to `ExpandWithLabel`.\r\nThat way, when calling `SignWithLabel` you can give the structure name in the `Label` argument.",
      "createdAt": "2021-12-16T11:56:57Z",
      "updatedAt": "2022-01-26T12:43:52Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "28489f2c85c9bee07b0d4aff3b81b5fb59572e8f",
      "headRepository": "TWal/mls-protocol",
      "headRefName": "twal_signature",
      "headRefOid": "55ad81138bc6eb43e92b036b4142cb87362b8263",
      "closedAt": "2022-01-26T12:43:52Z",
      "mergedAt": "2022-01-26T12:43:52Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "ced24321bd52a912e45a6e4bf221fd426ed100b0"
      },
      "comments": [
        {
          "author": "TWal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Something that is still bothering me is the `MLSPlaintextTBS` structure:\r\n\r\n    struct {\r\n        select (MLSPlaintextTBS.sender.sender_type) {\r\n            case member:\r\n                GroupContext context;\r\n    \r\n            case preconfigured:\r\n            case new_member:\r\n                struct{};\r\n        }\r\n    \r\n        WireFormat wire_format;\r\n        opaque group_id<0..255>;\r\n        uint64 epoch;\r\n        Sender sender;\r\n        opaque authenticated_data<0..2^32-1>;\r\n    \r\n        ContentType content_type;\r\n        select (MLSPlaintextTBS.content_type) {\r\n            case application:\r\n              opaque application_data<0..2^32-1>;\r\n    \r\n            case proposal:\r\n              Proposal proposal;\r\n    \r\n            case commit:\r\n              Commit commit;\r\n        }\r\n    } MLSPlaintextTBS;\r\n\r\nSince the first `select` is done on a field defined after it, this structure is not parsable. We could say that's not a problem since we only need to serialize it, but for security purposes I would recommend to put it at the end, like this:\r\n\r\n    struct {\r\n        WireFormat wire_format;\r\n        opaque group_id<0..255>;\r\n        uint64 epoch;\r\n        Sender sender;\r\n        opaque authenticated_data<0..2^32-1>;\r\n    \r\n        ContentType content_type;\r\n        select (MLSPlaintextTBS.content_type) {\r\n            case application:\r\n              opaque application_data<0..2^32-1>;\r\n    \r\n            case proposal:\r\n              Proposal proposal;\r\n    \r\n            case commit:\r\n              Commit commit;\r\n        }\r\n\r\n        select (MLSPlaintextTBS.sender.sender_type) {\r\n            case member:\r\n                GroupContext context;\r\n    \r\n            case preconfigured:\r\n            case new_member:\r\n                struct{};\r\n        }\r\n    } MLSPlaintextTBS;\r\n\r\nWhat do you think about it?\r\n",
          "createdAt": "2021-12-16T13:18:46Z",
          "updatedAt": "2021-12-16T13:18:46Z"
        },
        {
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "body": "Nice one! Crafting collisions is probably not straightforward, but eliminating the the risk altogether is the way to go.",
          "createdAt": "2021-12-16T18:14:19Z",
          "updatedAt": "2021-12-16T18:14:19Z"
        },
        {
          "author": "TWal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "It is actually quite easy to craft collisions, I made a script do find them: https://github.com/TWal/TLSCollisionFinder\r\n(I wanted to check whether there was accidentally a way do disambiguate the structures)",
          "createdAt": "2021-12-18T18:52:00Z",
          "updatedAt": "2021-12-18T18:52:00Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOBoyH6c4xtoAJ",
          "commit": {
            "abbreviatedOid": "666e267"
          },
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Great catch and a neat solution!",
          "createdAt": "2021-12-16T12:46:34Z",
          "updatedAt": "2021-12-16T12:46:34Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOBoyH6c4ya_5r",
          "commit": {
            "abbreviatedOid": "4c0c8bf"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2022-01-06T18:36:40Z",
          "updatedAt": "2022-01-06T18:48:37Z",
          "comments": [
            {
              "originalPosition": 80,
              "body": "I don't love the aesthetics here.  Maybe we could solve this a little more elegantly by having a `context` input to `SignWithLabel`/`VerifyWithLabel`?\r\n\r\nAlternatively: Do we even need this field any more?  This field was added before `membership_tag`, and now the `membership_tag` already (a) demonstrates knowledge of the GroupContext and (b) prevents a non-member from synthesizing a valid MLSPlaintext.",
              "createdAt": "2022-01-06T18:36:40Z",
              "updatedAt": "2022-01-06T18:48:37Z"
            },
            {
              "originalPosition": 103,
              "body": "I would prefer that we put these descriptions with the structs they belong to, as opposed to down here in the instructions.  We already have prose that says what the signature covers; that should just specify the label as well.  You could also include it as a comment in the syntax specification:\r\n\r\n```\r\nstruct {\r\n    ...\r\n    // SignWithLabel(., \"MLSPlaintextTBS\", MLSPlaintextTBS)\r\n    opaque signature<0..2^16-1>;\r\n} KeyPackage;\r\n\r\nstruct {\r\n    ...\r\n    // SignWithLabel(., \"GroupInfoTBS\", GroupInfoTBS)\r\n    opaque signature<0..2^16-1>;\r\n} GroupInfo;\r\n\r\nstruct {\r\n    ...\r\n    // SignWithLabel(., \"PublicGroupStateTBS\", PublicGroupStateTBS)\r\n    opaque signature<0..2^16-1>;\r\n} PublicGroupState;\r\n\r\nstruct {\r\n    ...\r\n    // SignWithLabel(., \"MLSPlaintextTBS\", MLSPlaintextTBS)\r\n    opaque signature<0..2^16-1>;\r\n\r\n    // MAC(confirmation_key, GroupContext.confirmed_transcript_hash)\r\n    optional<MAC> confirmation_tag;\r\n\r\n    // MAC(membership_key, MLSPlaintextTBM);\r\n    optional<MAC> membership_tag;\r\n} MLSPlaintext;\r\n```\r\n\r\n(Note: I don't think GroupInfoTBS exists, but it probably should.)",
              "createdAt": "2022-01-06T18:47:04Z",
              "updatedAt": "2022-01-06T18:48:37Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c4yjicE",
          "commit": {
            "abbreviatedOid": "4c0c8bf"
          },
          "author": "TWal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-01-10T18:15:16Z",
          "updatedAt": "2022-01-10T18:15:17Z",
          "comments": [
            {
              "originalPosition": 80,
              "body": "I not sure the alternative is a good idea for several reasons, for example the `membership_tag` is present only in `MLSPlaintext` and not in `MLSCiphertext`, also I'm not confident in removing things from the signature without a solid proof that it is not necessary (for example, signing the tree hash seems like a reasonable thing to do?).\r\n\r\nI feel like adding a `context` input is a bit weird. What do you think about this third option: adding an `option<GroupContext> group_context;` and say something like \"group_context MUST contain a value if sender_type = ...\" below? This pattern already exists for `confirmation_tag` for example.",
              "createdAt": "2022-01-10T18:15:16Z",
              "updatedAt": "2022-01-10T18:15:17Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c4yleKw",
          "commit": {
            "abbreviatedOid": "4c0c8bf"
          },
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-01-11T06:57:18Z",
          "updatedAt": "2022-01-11T06:57:19Z",
          "comments": [
            {
              "originalPosition": 103,
              "body": "(#529 adds a `GroupInfoTBS`) ",
              "createdAt": "2022-01-11T06:57:19Z",
              "updatedAt": "2022-01-11T06:57:19Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c4ymHzl",
          "commit": {
            "abbreviatedOid": "4c0c8bf"
          },
          "author": "TWal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-01-11T08:52:46Z",
          "updatedAt": "2022-01-11T08:52:46Z",
          "comments": [
            {
              "originalPosition": 103,
              "body": "If every structure has a `TBS` associated with it, this seems like a nice formatting of how you must compute the signatures, however for `KeyPackage` there is no `TBS` (yet), it is said in the text above that the TBS contains \"all of the fields except for the signature field\".\r\n\r\nShould we add a `TBS` for every structure that we sign? This is for example done for `PublicGroupState` where a `TBS` is explicitly described even if it contains all fields except the signature field in `PublicGroupState`.",
              "createdAt": "2022-01-11T08:52:46Z",
              "updatedAt": "2022-01-11T08:52:46Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c4zd8e2",
          "commit": {
            "abbreviatedOid": "55ad811"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-01-26T12:43:47Z",
          "updatedAt": "2022-01-26T12:43:47Z",
          "comments": []
        }
      ]
    },
    {
      "number": 527,
      "id": "PR_kwDOBoyH6c4v8na2",
      "title": "Stronger parent hashes for authenticated identities",
      "url": "https://github.com/mlswg/mls-protocol/pull/527",
      "state": "MERGED",
      "author": "TWal",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "work in progress"
      ],
      "body": "Our proposal\r\n============\r\n\r\nThe parent hash construction currently authenticates only the public keys in the ratchet tree and does not protect other tree contents, notably the credentials at the leaves.\r\nConsequently, a malicious member can tamper with the credentials before sending a Welcome package to a new member, even if it cannot tamper with the public keys.\r\n\r\nInstead of using the tree resolution in the parent hash computation, we propose to use the tree hash.\r\n\r\nThe last time this was discussed on the list, it was agreed that it would be better to use tree hashes from a security point of view, but it was felt that complexity-wise that the recipient of a Welcome message would have to do O(n^2) work.\r\nA more thorough analysis shows that processing a Welcome message can be done in O(n*log(log(n))).\r\nThe result is that each signature captures the full tree contents including leaf credentials, which provides better authentication guarantees for member identities.\r\n\r\nEfficient algorithm to process a Commit\r\n=======================================\r\n\r\nWhen processing Commits, the implementation can store the tree hashes of every subtree.\r\nThat way, with n being the number of leaves, you can process each proposal in O(log(n)) and each UpdatePath in O(log(n)).\r\nThen you can check the parent hash when processing a Commit in O(p*log(n)) where p is the number of proposals.\r\n\r\nEfficient (enough) algorithm to process a Welcome\r\n=================================================\r\n\r\nWhen processing a Welcome message, we need to do the parent hash verification procedure.\r\nTo do it with the new parent hash, we need to compute tree hashes of subtrees at the last time they were updated.\r\nThis can be done using the following modified tree hash:\r\n\r\n    OldTreeHash(leaf, excluded_leaves) = Hash(leaf) if leaf not in excluded_leaves\r\n    OldTreeHash(leaf, excluded_leaves) = Hash(blank leaf) if leaf in excluded_leaves\r\n    OldTreeHash(node, excluded_leaves) = Hash(node.content | OldTreeHash(node.left, left_excluded_leaves) | OldTreeHash(node.right, right_excluded_leaves))\r\n    where left_excluded_leaves = leaves that are in excluded_leaves and in node.left (same for right_excluded_leaves).\r\n    and `excluded_leaves` are removed from `node.content.unmerged_leaves`.\r\n\r\nThen we can compute the parent hash for a node `N` with child `C` and sibling `S` using `OldTreeHash(S, N.content.unmerged_leaves)`: this old tree hash don't change when Adds are applied to the tree.\r\n\r\nIn the next paragraph, we will see that we can compute the parent hash for every node in `O(n*log(n))`.\r\n\r\nLet `h` be the height of the tree (so `h = log(n)`). There are `O(2^{h-i})` nodes at height `i`, and computing the parent hash for a node at height `i` is done in `O(2^i)`.\r\nHence, the complexity for the parent hash verification procedure is:\r\n\r\n      \\sum_{i=1}^h O(2^i 2^{h-i})\r\n    = \\sum_{i=1}^h O(2^h)\r\n    = O(h 2^h)\r\nAnd since `h = log(n)`, the complexity is `O(n*log(n))`.\r\n\r\nEfficient algorithm to process a Welcome\r\n========================================\r\n\r\nImagine we have the following tree:\r\n\r\n                  W\r\n            ______|______\r\n           /             \\\r\n          U               Y [E, G]\r\n        __|__           __|__\r\n       /     \\         /     \\\r\n      T       V       X [E]   Z [G, H]\r\n     / \\     / \\     / \\     / \\\r\n    A   B   C   D   E   F   G   H\r\n\r\nFor each node `N`, `OldTreeHash(N, excluded_leaves)` will be called with different values for `excluded_leaves`.\r\n\r\nFor example, if the sibling is always the right child, then:\r\n- `OldTreeHash(H, .)` will be called with 1 time with `. = [H]` (when computing the parent hash of `Z`) and 2 times with `. = []` (when computing the parent hash of `Y` and `W`)\r\n- `OldTreeHash(Z, .)` will be called with 1 time with `. = [G]` (when computing the parent hash of `Y`) and 1 time with `. = []` (when computing the parent hash of `W`)\r\n\r\nIf the sibling is always the left child, then:\r\n- `OldTreeHash(A, .)` will be called 3 times with `. = []` (when computing the parent hash of `T`, `U`, `W`)\r\n- `OldTreeHash(T, .)` will be called 2 times with `. = []` (when computing the parent hash of `U`, `W`)\r\n\r\nWe can see that some values are computed several times, which means that the whole computation could be sped up using memoization.\r\n\r\nTo estimate the speedup, we will estimate with how many values for `excluded_leaves` is called `OldTreeHash(N, .)` for each node `N`. Summing up these values will give a complexity, which will be `O(n*log(log(n)))`.\r\n\r\nLet `node.parent[k]` be the `k`th parent of `node`, and `node.leaves` be the set of leaves in the subtree rooted at `node`.\r\nThen, each call of `OldTreeHash(node, excluded_leaves)` will have `excluded_leaves = Intersection(node.parent[k].unmerged_leaves, node.leaves)` for some `k`.\r\nLet's note this set `excluded_leaves_k`.\r\nThe tree has the invariant that if `i <= j` then `excluded_leaves_j` is a subset of `excluded_leaves_i` (i.e. the sets `excluded_leaves_k` are decreasing).\r\n\r\nLet d be the depth of `node` (with the root being at depth 1). Then, the set `excluded_leaves_set := {excluded_leaves_1, ..., excluded_leaves_{d-1}}` corresponds to the values for `excluded_leaves` in the calls to `OldTreeHash(N, .)`.\r\n\r\nFirst bound: `|excluded_leaves_set| <= d-1 <= d` because it is defined using `d-1` values.\r\nSecond bound: `|excluded_leaves_set| <= 2^{h-d}+1` because `|excluded_leaves_0| <= 2^{h-d}` and the sets `excluded_leaves_k` are decreasing.\r\nTherefore: for a node at depth d, `|excluded_leaves_set| <= min(d, 2^{h-d}+1)`\r\n\r\nThe complexity to do the parent hash verification procedure is therefore in `O(sum_{i=1}^h 2^i min(i, 2^{h-i}+1))`.\r\n\r\nLet's estimate this complexity more explicitly:\r\n\r\n       sum_{i=1}^h 2^i min(i, 2^{h-i}+1)\r\n    <= (sum_{i=1}^t i 2^i) + (sum_{i=t+1}^h 2^i (2^{h-i}+1)) [for all t]\r\n    =  (2 (t-1) 2^t + 2) + ((h-t) 2^h + 2^{h+1} - 2^{t+1}) [for all t]\r\n\r\nFor the first inequality, we split the sum in two parts and use `min(i, 2^{h-i}+1) <= i` in the left part and `min(i, 2^{h-i}+1) <= 2^{h-i}+1` in the right part.\r\nFor the second equality, it can be derived using the formula for geometric sum.\r\n\r\nIf we take `t = h - log(h)`, we can compute that the left part is `O(2^h)` and the right part is `O(log(h)*2^h)`.\r\n\r\nTherefore, the parent hash verification procedure complexity is `O(log(h)*2^h) = O(n*log(log(n)))`.\r\n\r\nOne might say that adding memoization has a cost and isn't in O(1), but here it is: using the fact that `excluded_leaves_k` are decreasing, if you process the tree in a bottom-up or top-down way, you only have to compare the length of the current `excluded_leaves` to the length of the previous one, and it tells you if you need to recompute the tree hash.\r\n\r\nThe current parent hash is not super fast\r\n=========================================\r\n\r\nIn the worst case, if most internal nodes are blank, then computing the parent hash for a node is in O(size of its subtree), which give an O(n*log(n)) complexity as we saw in the section about the naive algorithm.\r\n\r\nWhen processing a Commit, if most of the internal nodes are blank, then computing the new parent hashes is in O(n) which is quite slow.",
      "createdAt": "2021-12-16T12:54:02Z",
      "updatedAt": "2022-02-28T18:52:18Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "866cbbc050e68901b8156fe8fef36da2f851dbf1",
      "headRepository": "TWal/mls-protocol",
      "headRefName": "twal_parent_hash",
      "headRefOid": "f7fab60ce87323e33e39617d2fab8be8047c0dda",
      "closedAt": "2022-02-28T18:52:18Z",
      "mergedAt": "2022-02-28T18:52:18Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "3e62ef9b0a7ebb4d810d293b4c955cc33a9e2b7b"
      },
      "comments": [
        {
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "body": "@psyoptix Since you worked on this last, it would be great if you could have a look at this.",
          "createdAt": "2021-12-16T18:28:54Z",
          "updatedAt": "2021-12-16T18:28:54Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "I agree that this scheme seems strictly stronger than the current scheme, and it\r\nprobably has the same operational properties given that the original sibling\r\ntree hash changes when the original sibling resolution changes, and vice\r\nversa.\r\n\r\nThe main thing that seems trickier about this version is the \"reversing\"\r\noperation, i.e., the process of computing the earlier state from the current\r\nstate.  With the resolution approach, it's just a question of removing some\r\nvalues from a list of public keys.  With this approach, you need to replicate\r\nthe actual structure of the tree.\r\n\r\nAs usual, the trouble is at the right edge of the tree.  For a parent node along\r\nthe right edge of the tree with unmerged leaves added to the right edge of the\r\ntree, you can't just replace the blanks with blanks, you need to remove the\r\nintermediate nodes that were added as well.  \r\n\r\nLooking at your example case, I think you've actually drawn an impossible tree!\r\nFor the node Z to be populated, it has to have been set by either G or H.  If H\r\nhad done it, then obviously H wouldn't be unmerged.  If G did it, then it would\r\nhave encrypted Z to H if H were present, or if it were absent, then G's parent\r\nwould be Y and Z would still be blank from H being added.\r\n\r\nSo the more realistic case is something like:\r\n\r\n~~~~~\r\n              W [H]\r\n        ______|_____\r\n       /             \\\r\n      U               Y [F, H]\r\n    __|__           __|__\r\n   /     \\         /     \\\r\n  T       V       X [F]   _\r\n / \\     / \\     / \\     / \\\r\nA   B   C   D   E   F   G   H\r\n~~~~~\r\n\r\nJust to be confirm this is realistic: This could arise via the following sequence of operations:\r\n\r\n1. Start with A, B, C, D\r\n2. A adds E, F', G; commit-path\r\n3. A removes F'; commit+path\r\n4. E commits without proposal => path sets X, Y, W\r\n5. A adds F; commit+path\r\n6. A adds H; commit-path\r\n\r\nNow suppose H as a new joiner wants to verify this tree.  The parent hash of U was last set at 5, at which point the tree looked like this:\r\n\r\n~~~~~\r\n              W\r\n        ______|_____\r\n       /             \\\r\n      U               Y [F]\r\n    __|__           __|_\r\n   /     \\         /    \\\r\n  T       V       X [F] |\r\n / \\     / \\     / \\    |\r\nA   B   C   D   E   F   G \r\n~~~~~\r\n\r\nSo in your case `P=W`, `S=Y`, the \"original tree hash\" for Y needs to be the hash of the tree *without the parent node above G and H*.\r\n\r\nIn other words, the original tree hash reconstruction algorithm needs to truncate the tree in addition to replacing leaves with blanks.  From an implementation POV, that starts to sound quite a bit more challenging, since I'm now doing computing tree hashes over a tree I don't otherwise have.\r\n\r\nIt seems like there are a few ways forward here:\r\n\r\n1. Do nothing; use the original sibling resolution.\r\n2. Use the original tree hash, but truncate the tree for rightmost-added unmerged leaves.\r\n3. Use the original tree hash, but update so that the tree always expands by doubling, instead of adding one leaf at a time.  This allows the leaf-blanking algorithm to work, at the expense of some other inefficiencies.\r\n4. Use the tree hash, but remove the notion of unmerged leaves altogether (so there's no \"original\" tree hash).\r\n\r\nAmong those, my favorite option might actually be (4).  At this point, it kind of seems like unmerged leaves are more trouble than they're worth.  Their best-case efficiencies arise only in kinda weird cases, and they're making it hard to get good guarantees.\r\n\r\n@raphaelrobert @kkohbrok thoughts?",
          "createdAt": "2022-01-06T21:30:09Z",
          "updatedAt": "2022-01-06T21:30:09Z"
        },
        {
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I agree that an \"upgrade\" to using the tree hash rather than the public key would be a good idea. I'm also leaning towards (4), but I'm not convinced that unmerged leaves are more trouble than they're worth. But at this point, I don't have any data on how unmerged leaves impact performance and I also don't have a better idea, so I'd be Ok with (4) (although it would also be interesting to see what the truncation algorithm for (2) would look like).",
          "createdAt": "2022-01-10T14:43:17Z",
          "updatedAt": "2022-01-10T14:43:17Z"
        },
        {
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "body": "Thanks @TWal! I've been trying to wrap my head around this, because it is a major change with a lot of subtle nuances.\r\nI think it's important to differentiate the concerns:\r\n\r\n*Security* \r\n\r\nYou mention that \"a malicious member can tamper with the credentials before sending a Welcome package to a new member, even if it cannot tamper with the public keys\". This makes it sound like a bigger problem than it is (unless I missed something). A malicious member can only tamper with credentials if it also has the corresponding private key material to do so. If that's the case, a wealth of new attacks become possible because authentication is obviously broken. There might be some more subtle attacks where a malicious member could do cross-group attacks without actually changing the credential. For example, the malicious member could pretend that member X is part of the new group, when member X is really only part of a totally different group. This would trick the new joiner Y into believing two things:\r\n\r\na) Member X is a member of the new group (this attack has always been possible with empty trees)\r\nb) Member X has previously sent a full commit and therefore proven it's aware that it is in the group (this attack is currently possible)\r\n\r\nAttack b) would become impossible by using the tree hash as you propose, and therefore it's obviously strictly more secure. If you thought of other types of attacks (that are maybe not so niche), it would be interesting to hear about it.\r\n\r\nIf the definition you propose is also motivated by better probability, this would be another reason to go for it.\r\n\r\n*Efficiency*\r\n\r\nThis is harder to reasons about. As always, one has to make a number of assumptions about concrete scenarios. Dropping unmerged leaves would certainly make a lot of things easier and cleaner, but so far I've always assumed that they make things more efficient. My reasoning was the following: Without unmerged leaves, adding multiple new members in different locations of the tree (wherever the leftmost blanks are) would quickly blank most parent nodes in the tree and we'd go back to a linear effort. It's been mentioned that unmerged leaves can also be slower when there is a lot of them, however I find that an unlikely scenario to occur. You only get a lot of unmerged leaves if the tree is densely populated, which in turn means that members issue full commits frequently. Because of the latter, it is unlikely that the new members (that caused the unmerged leaves to appear) would not update just as frequently. I know this is a bit hand wavy, I guess running MC simulations in different scenarios would help.\r\n\r\nWith all that, I'm wondering if the current parent hash definition couldn't be extended by covering the whole key packages at the leaf level instead of just the keys (by modifying the `ParentHashInput`)? Maybe I'm missing something, but I think it would just be a small change in the spec that should address the security concern and not affect the efficiency at all.",
          "createdAt": "2022-01-10T21:30:15Z",
          "updatedAt": "2022-01-10T21:30:15Z"
        },
        {
          "author": "TWal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@bifurcation Thanks for noticing the bug, indeed since `Add`s can make the tree grow, we need to truncate it when checking the parent hash.\r\nThere is two things to notice for option (2):\r\n- we only have to do these complex computations when receiving a Welcome message, not when processing a commit\r\n- truncating the tree doesn't affect the O(n log log n) complexity, since computing the tree hash of a subtree can still be done in linear time\r\nOption (4) is appealing because reasoning about unmerged leaves is surprisingly hard. I would be interested in an analysis on the performance impact of removing them (we could easily do an empirical analysis by doing random changes to a group and compare the size of the resolution in the trees with and without unmerged leaves, however I don't know what realistic changes to a group would look like).\r\nIf we expect new members to quickly commit once they arrived in a group, this should not cause too many performance issues I guess.\r\n\r\n@raphaelrobert \r\nTo be honest, I didn't find of highly convincing attacks. However what motivates me for this change is that with the current parent hash, there is a some room for tree modification which makes my gut feeling tell me that if someone think hard enough about this a convincing attack can be discovered. If we include the sibling tree hash in the parent hash then the parent hash makes everything super rigid and I don't see any starting point for an attack where the parent hash would be the weak link.\r\n(In fact we can tamper the tree when the last tree modification is an Add-only commit, because in every parent hash the added leaf is removed from the tree hash, so we can tamper its KeyPackage)\r\n\r\nI'm not sure to understand your last paragraph, do you suggest to keep the resolution but include the whole `ParentNode` and `KeyPackage` instead of only their `hpke_public_key`?\r\n\r\nAbout cross-group attacks: we can easily avoid such attacks by including the group id in the signature of key packages. In the current design, this means adding a mandatory-when-comitting-with-path extension (like the ParentHash extension).",
          "createdAt": "2022-01-11T10:46:06Z",
          "updatedAt": "2022-01-11T10:46:06Z"
        },
        {
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "body": "> @raphaelrobert To be honest, I didn't find of highly convincing attacks. However what motivates me for this change is that with the current parent hash, there is a some room for tree modification which makes my gut feeling tell me that if someone think hard enough about this a convincing attack can be discovered. If we include the sibling tree hash in the parent hash then the parent hash makes everything super rigid and I don't see any starting point for an attack where the parent hash would be the weak link. (In fact we can tamper the tree when the last tree modification is an Add-only commit, because in every parent hash the added leaf is removed from the tree hash, so we can tamper its KeyPackage)\r\n> \r\n> I'm not sure to understand your last paragraph, do you suggest to keep the resolution but include the whole `ParentNode` and `KeyPackage` instead of only their `hpke_public_key`?\r\n\r\nThinking about it again, it would only partially solve the problem. The tree hash would be stronger indeed.\r\n\r\n> About cross-group attacks: we can easily avoid such attacks by including the group id in the signature of key packages. In the current design, this means adding a mandatory-when-comitting-with-path extension (like the ParentHash extension).\r\n\r\nI think that's a good idea! Given the group ID is immutable, new joiners should not have issues verifying the signatures.\r\n\r\n",
          "createdAt": "2022-01-11T11:51:28Z",
          "updatedAt": "2022-01-11T11:51:28Z"
        },
        {
          "author": "TWal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I fixed the \"right edge to the tree problems\", I believe the procedure is now correct. The naive O(n log n) algorithm to process a Welcome message still works, I believe the O(n log log n) algorithm can be adapted but that's not 100% trivial.\r\n\r\nAs asked yesterday, here is in more details the algorithm to process a Commit\r\n\r\n# Complexity to process a Commit\r\n\r\nI believe we can expect from any efficient implementation to cache the tree hash of every subtree of the ratchet tree, because if this is not cached, then computing the tree hash at each epoch is in O(n), which is slow.\r\n\r\nWe have to recompute some of these cached values when processing a Proposal or an UpdatePath. When doing so, O(log n) of these values change, and by computing them bottom-up, we can compute each of them in O(1) giving a O(log n) complexity in total.\r\nTherefore, updating these cached values when processing a Commit with p proposals is in O(p log n) which is fast.\r\n\r\nThe parent hash of a node has to be updated when processing an UpdatePath. We notice that doing so, every node that need parent hash recomputation has no unmerged leaves. Therefore every parent hash can be computed in O(1) by using the cached sibling tree hash, and updating the parent hashes is therefore in O(log n).",
          "createdAt": "2022-01-21T16:59:47Z",
          "updatedAt": "2022-01-21T16:59:47Z"
        },
        {
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Since this also came up, here's a situation that showcases the benefits from including credentials in the parent hash.\r\n\r\nAlice is in a group with Bob and some others. Bob has already made a commit in the course of the group's history, thus and signing a parent hash extension in this leaf KeyPackage.\r\n\r\nAlice now adds Charly to the group.\r\n\r\nWith the parent hash mechanism as-is, Charly can see that Bob has at some point made a commit and with his parent hash attested to the fact that a certain set of public keys were in the tree when Bob made the commit. However, Charly can not rule out the possibility that Alice has generated a bunch of credentials, and used them to sign KeyPackages that include the public keys that Bob attested to (although of course she does not own the corresponding private keys).\r\n\r\nWith the proposed parent hash mechanism, Charly can rule out this possibility, since Bob attested not only to the public keys, but also to the credentials in the leaf KeyPackages.\r\n\r\nSome notes on this scenario (and parent hashes in general):\r\n* Alice's ability to forge meaningful KeyPackages should be limited, since Charly can verify them with the AS. So while Alice might not be able to make it look like Bob is in a group of clients of Alice's choosing, Charly still has no way of asserting who Bob thinks is actually in the group.\r\n* Including Credentials in the parent hash could limit the amount deniability that can be achieved by vanilla MLS, although, for example, an extension could in theory change the way the parent hash works.\r\n* In both scenarios, Charly's ability to figure out what Bob thinks the group looks like is best-effort, since Bob's direct path might have been overwritten to any degree by others since his last (full) commit.\r\n* Ways to get more attestation, disregarding deniability completely:\r\n  * have Bob (in addition to parent hashes) put the group id, epoch and some form of the roster (e.g. full credentials or just hashes) in a KeyPackage extension upon commit\r\n  * cut the time until a new group member learns about who is actually in the group on a best-effort basis: Demand that after processing a commit that contains an Add, a group member must send an (empty) application message as a way of attesting to the current state of the group",
          "createdAt": "2022-01-24T07:48:27Z",
          "updatedAt": "2022-01-24T07:48:27Z"
        },
        {
          "author": "MartaMularczyk",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I was going through some examples to verify that the procedure is correct. I think I found two cases where it may be incorrect. @TWal could you check the examples?\r\n1. What happens if some nodes in the subtree of the sibling (Y in your examples) have been truncated since the commit?\r\n2.  See this file [parent_hash.txt](https://github.com/mlswg/mls-protocol/files/7927786/parent_hash.txt) (the trees get large)",
          "createdAt": "2022-01-24T18:04:46Z",
          "updatedAt": "2022-01-24T18:04:46Z"
        },
        {
          "author": "TWal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Hi Marta, thank you for checking this! Indeed there are correctness problems that I completely overlooked\u2026\r\n\r\n1. I'm not sure to understand the problem? The tree is truncated when there is a Remove, which will blank the nodes so the parent hash won't be checked?\r\n2. This is a good counter-example.\r\n\r\nI see several solutions:\r\n- remove unmerged leaves as suggested by @bifurcation (doing some analysis beforehand would be useful, but my guess is that it's not too bad if we say that new members SHOULD do a full commit as soon as possible)\r\n- next to the parent hash, store how many leaves contained the sibling tree when the tree hash was computed, like this you know which nodes were truncated or not (this option is the least invasive)\r\n- modify the tree hash in a way that would correspond to doing the current tree hash in a complete tree, which would solve the problem since we have the property Complete(Truncate(tree)) == Complete(tree)",
          "createdAt": "2022-01-25T17:48:58Z",
          "updatedAt": "2022-01-25T17:48:58Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "@kkohbrok I'm not sure I follow the case you present.  In particular: \r\n\r\n> However, Charly can not rule out the possibility that Alice has generated a bunch of credentials, and used them to sign KeyPackages that include the public keys that Bob attested to (although of course she does not own the corresponding private keys).\r\n\r\nTo be clear, you mean that Alice controls the signature keys, but not the HPKE private keys, right?  So she can control the KeyPackage content, including for example the parent hash. Maybe to put this a little more directly: If the parent hash doesn't cover the credential (or at least the signature public key), then Alice can replace anyone in the group with:\r\n\r\n* A sock puppet, for which she controls the signing key\r\n* An appearance of a client in another group that happens to have a parent hash that matches an HPKE public key in the resolution\r\n* A pre-published KeyPackage that happens to have the right HPKE public key for the resolution\r\n\r\nI don't think there's anything we can do about the sock puppet case anyway.  And it seems debatable whether any of these are problematic, in the sense that the parent hash is supposed to validate that the tree invariant holds, and in all of these cases, the client in question actually does hold the required private key, modulo hash collisions.\r\n\r\nSo if I've got the analysis right here, the main benefit of signing more of the tree structure is to guard against collisions among public keys and their hashes.\r\n\r\n\r\n",
          "createdAt": "2022-01-26T15:59:47Z",
          "updatedAt": "2022-01-26T15:59:47Z"
        },
        {
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yes, I think you got it right. Alice can make Charly think that they are in a group with Bob and because Bob only attested to the HPKE public keys, Alice can potentially mess around with the credentials and Charly has only the AS to protect her from that. Depending on the AS that can be more or less helpful. If you have a weak AS, Charly cannot really know if Bob attested to being in a group with these group members. With the tree hash variant, Charly could do that.\r\n\r\nI think @psyoptix got it right by saying that the current parent hash covers the confidentiality guarantees, whereas the tree hash approach gets some authentication guarantees as well.\r\n\r\nI don't have a strong opinion either way, I just wanted to make sure we agree on the gap we're discussing.",
          "createdAt": "2022-01-26T17:25:34Z",
          "updatedAt": "2022-01-26T17:25:34Z"
        },
        {
          "author": "MartaMularczyk",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Let me add a bit to the discussion about security. I hope it clarifies a bit parent hashes in general.\r\n\r\nIn our security analysis with @psyoptix we used the parent hash mechanism (only) to prove that MLS provides the following security property. \r\n\r\n> In any epoch where the credentials (i.e. signature keys) of all group members are \u201cgood\u201d, i.e., not leaked to or chosen by the adversary, then the messages sent in this epoch are confidential and authentic.\r\n\r\nAn example scenario: A malicious insider Alice invites honest Charlie to a fake group with honest Bob, then Charlie adds Dave and removes Alice. Since all members use good credentials, the messages they sends to  each other are confidential and authentic. Note that Bob may not be aware of the fake group with Charlie and Dave. \r\n\r\nThis guarantee is provably achieved both by the current parent hash and by the tree hash. So to motivate the tree hash, we need to find a different security property, outside our model, which it adds.\r\n\r\n@kkohbrok proposed such a guarantee. The way I understand it is that a member Charlie can deduce additional facts about the group. For instance, if Bob attested to the credential of Emma via his parent hash, then Charlie knows that Bob was in a group with Emma. (This doesn\u2019t mean that Emma actually was in a group with Bob; she may have been added but never joined.)\r\n\r\nI agree that this is an additional goal one can aim for. But a couple of comments:\r\n- Such guarantees are relatively hard to explain to the end user. So do we actually want them?\r\n- The current parent hash also allows to deduce such statements, but fewer of them. For example, if Emma attested to an HPKE key _pk_ she chose during her commit, _pk_ happens to be on Bob's copath and Bob attested to _pk_ via the parent hash, then Charlie can deduce that Bob was in a group with Emma (just like in the example above).\r\n- MLS doesn\u2019t expose to higher level apps any interface that allows them to check the additional facts deduced from the parent hash. The only to get these facts is to dig into the details of the ratchet tree. This is not at the abstraction level apps typically work on. So if we introduce tree hash, we should think of exposing an interface that allows to take advantage of it.\r\n",
          "createdAt": "2022-01-27T09:16:22Z",
          "updatedAt": "2022-01-27T09:16:22Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Elaborating on the idea I had on the call today:\r\n\r\nIt seems like @TWal's idea of using the tree hash as the input to the parent hash gets complicated in the following situation:\r\n\r\n* Let P be an intermediate node\r\n* Let L and R be the left and right children of P, respectively\r\n* Consider the case where we are computing the parent hash that will be stored at L\r\n* `parent_hash = H(P, original_tree_hash(R))`\r\n* If R has no `unmerged_leaves`, then `original_tree_hash(R) == tree_hash(R)`\r\n* If R has `unmerged_leaves`, but the addition of the leaves did not change the structure of the tree (i.e., they went into existing blank leaves), `original_tree_hash(R)` can be recomputed just by blanking out those leaves and following the current tree structure.\r\n* If R has `unmerged_leaves`, and some of those leaves changed the tree structure, you end up in the hard situation that @TWal has been trying to address\r\n\r\nRemoving `unmerged_leaves` entirely would eliminate the latter two cases.  What I'm wondering is whether we can eliminate only the last, challenging case.  I think the change would look something like the following:\r\n\r\n* When adding a new member:\r\n    * If the member is occupying an existing slot, proceed as currently specified\r\n    * If the member occupies a new slot added to the right of the tree, blank their direct path instead of adding `unmerged_leaves`.\r\n* When computing parent hash, instead of the original resolution of the non-updated child, include the \"original tree hash\" == tree hash with unmerged leaves set to blanks.\r\n\r\nThat way, you never end up in the difficult situation above, because you never have unmerged leaves when the tree structure below you has changed since the last parent_hash -- in fact, you don't have a parent node at all when the subtree structure has changed.\r\n\r\n(I think there are some elegant algorithms for computing original tree hash at the same time, but no need to get into that optimization now.)\r\n\r\nThis will remove some of the efficiency of `unmerged_leaves`, but it affects at worst a log-size number of parent nodes per Commit.  That could still cause some big jumps in Commit size, if one of these \"leading-edge\" parent nodes has a mostly-empty subtree.  But maybe the circumstances here are constrained enough that it's worth the extra assurance.",
          "createdAt": "2022-01-27T18:48:18Z",
          "updatedAt": "2022-01-27T18:48:18Z"
        },
        {
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@MartaMularczyk thanks for the example on the guarantees we get from the current parent hash scheme. I think those are already great and I'm not convinced we should jump through a lot of hoops to close what seems to be a relatively slight gap. But again, not a strong opinion.\r\n\r\nOne thought regarding the surfacing of any sort of security guarantee to the user, though. While it would be nice to communicate these guarantees to the user, not being able to do that doesn't mean the guarantees are not worth having in the first place. Whether the user realizes it or not, they are protected against certain types of attacks. If the parent hash doesn't check out, the Add will fail due to an invalid group state. The way I understand it, both parent hash approaches give use best-effort guarantees that may only hold for parts of the tree in any case, so we have that problem with the current parent hash version already. The user will always have to assume that the tree in a group they are joining is as trustworthy as the client that added them to the group.",
          "createdAt": "2022-01-28T09:41:54Z",
          "updatedAt": "2022-01-28T09:41:54Z"
        },
        {
          "author": "psyoptix",
          "authorAssociation": "CONTRIBUTOR",
          "body": "TL;DR : To justify adopting a new (\"tree-hash\" or \"leaf-hash\" based)  parent hash construction I'd hope for efficiency, simplicity and/or engineering arguments because I'm not (yet?) seeing the security ones (at least, under the premise we won't communicate the added security guarantees to users).\r\n\r\n@kkohbrok I'm struggling a bit with what you wrote about un-communicated guarantees still being worth it. Abstractly stated: I get that users dont need to (understand or) be aware of the *conditions* under which a security guarantee holds. But I have a hard time justifying a *guarantee itself* that user wont be aware of; at least when its easy for the adversary to create honest looking executions where the guarantee doesn't hold.\r\n\r\nConcretely for this PR: Suppose we implement \"tree-hash based\" parent hash. The new guarantees we get (relative to \"resolution parent hash\") form some space of guarantees. A point in the space might be \"C attested to being in the group with D at some point. A more recently attested to being in the group with B, C and D.\" or something along those lines...\r\n\r\nHere's what bothers me if we don't communicate to users where they are in this space. At one end of the space (corresponding to ratchet trees looking like a freshly created group with few, if any, commits beyond group creation) we get diminishing (if any) new guarantees over resolution parent hash. Moreover, such states are both common in honest executions and the easiest for an adversary to create. So my question is: why would an adversary bother trying to mount an attack using a ratchet tree encoding guarantees deeper into the space if A) building such a ratchet tree is never easier and likely harder B) the extra guarantees can't make the attack easier but might make it harder yet C) the user can't tell the difference from being given a ratchet tree with fewer guarantees? \r\n\r\nYet, if the answer to the question is \"the adversary wouldnt bother\" then I wonder what the point is of (a mechanism to provide) said guarantees.",
          "createdAt": "2022-01-28T13:41:52Z",
          "updatedAt": "2022-01-28T13:51:34Z"
        },
        {
          "author": "psyoptix",
          "authorAssociation": "CONTRIBUTOR",
          "body": "If we had some language to talk about the guarantees encoded in a ratchet-tree T that is:\r\n - clean, succinct & simple\r\n - communicates significant and meaningful amount of information about the guarantees\r\n - clearly conveys an intuition that accurately reflects (parts of) the formal guarantee in T\r\n\r\nthen I'd probably change my mind about the security benefits of the new parent hash (assuming we also give MLS an interface for applications to extract statements in this language about the current epoch; especially for welcome msgs).",
          "createdAt": "2022-01-28T13:44:46Z",
          "updatedAt": "2022-01-28T13:46:59Z"
        },
        {
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@psyoptix good points. If there is indeed an easier-to-create ratchet tree that would be equally plausible (as is the case here), then I agree that the guarantees are not worth much. In principle, however, I still think that guarantees might be worth having even if the user isn't aware of it. One example could be that the application could consider the effective guarantees that we get from a ratchet tree and then, for example, hide the group from the user until enough members have updated, such that group membership was sufficiently attested to (for some degree of \"sufficiently\"). Although for usability purposes that might not be an option, so in this particular point, it probably means that it's not worth having if we can't communicate it to the user.\r\n\r\nRegarding the interface: I don't believe MLS as specified right now has any sort of interface. It's really only specified how clients communicate with one-another. They way I understand it, an MLS implementation can then decide what information about their state they make available to the application or what actions the application can take.\r\n\r\nRegarding language: I'm not sure I understand what you have in mind, but let's give it a try. (Of course this is all going to be a bit vague, but maybe it's a starting point for further discussions.)\r\n\r\n# Security Model\r\n\r\nLet T be a ratchet tree freshly received by user U. Then let M_T be an array in the state of user U indexed by the members of the tree T, where for each member m, M_T[m] contains the set of identities attested to by m. We can now create an oracle that allows the adversary to query this store. \r\n\r\nIn the real world, the store is filled by checking which leaves are covered by the individual parent hashes present in the member's key packages. In the ideal world, each sender maintains a log (per tree) containing the members to which they attest and the receiver just copies the information from there upon receiving a ratchet tree. (Similar to log-decryption in real-vs.-ideal AE models.)\r\n\r\n# Resolution Based Parent Hash\r\n\r\nI would now claim that with resolution based parent hashes, there is an attack that goes as follows:\r\n\r\nThe adversary takes a valid tree, where a user A has already made a commit. The adversary generates a credential and replaces the credential of one of the users attested to by A (let's call the user B), before re-signing the corresponding key package. The adversary then sends it to their victim V as part of a Welcome message. V validates the parent hashes, which should be fine, since we didn't touch any hpke keys. The adversary then queries the oracle defined above using the gid of the new group, as well as the cids of V and A. If the user B shows up in M_T[A] then the adversary knows it's the ideal world, otherwise it's the real world.\r\n\r\n# Tree-Hash Based Parent Hash \r\n\r\nIf we have tree-hash based parent hash, the attack described above will not work. This is because upon receiving the Welcome message, V will fail to verify the parent hashes since the tree hash covers the credential as well.\r\n\r\n# Caveat: AS\r\n\r\nThe above attack will _not_ work in the first scenario if the AS (which V will consult upon receiving the Welcome) rejects the tampered-with key package (or the credential within) created by the adversary. I still think there is some relevance to the attack, since for many messengers in use today, the AS essentially requires users to verify identities OOB (\"safety numbers\", etc.), which I would claim is not done in most cases.",
          "createdAt": "2022-01-31T08:12:33Z",
          "updatedAt": "2022-01-31T08:13:27Z"
        },
        {
          "author": "TWal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "When working through the proof, I came up with another interesting pathological case, which has nothing to do with unmerged leaves:\r\n```\r\n_____________\r\n             \\\r\n              X\r\n        ______|______\r\n       /             \\\r\n      V               _\r\n    __|__           __|__\r\n   /     \\         /     \\\r\n  U       _       _       _\r\n / \\     / \\     / \\     / \\\r\nA   B   C   _   _   _   _   H\r\n```\r\nIf A did the last commit in this subtree, and someone in the left part of the tree (hidden) removes H, the tree will be truncated up to C so the sibling tree hash will change for V.\r\n\r\nHopefully the fixes I proposed earlier work against this pathological case.",
          "createdAt": "2022-02-07T16:32:05Z",
          "updatedAt": "2022-02-07T16:32:05Z"
        },
        {
          "author": "TWal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I am trying to abstract a bit how the parent hash is constructed, and when it is correct (i.e. participants processing a Welcome will accept a non-tampered tree).\r\n\r\n# A proof framework for parent hash\r\n\r\nWe will consider separately the following operations on the tree:\r\n- Blanking internal nodes along a path (and optionally the leaf): Update and first phase of Remove\r\n- UpdatePath: full commit\r\n- Adding a leaf in a blank leaf (add-only commit, add the leaf in the unmerged_leaves list along a path): second phase of Add\r\n- Truncation: second phase of Remove\r\n- Extension: first part of Add\r\n\r\nThe last three operations (adding a leaf, truncation, extension) will be called non-updating operations (because they don't update the `parent_hash` values in the nodes of the tree).\r\n\r\nAll parent hash design we came up so far revolve around two functions:\r\n- a function `compute_sibling_data(sibling)` that is used when processing a Commit\r\n- a function `compute_original_sibling_data(parent.content, sibling)` that is used when processing a Welcome\r\nFor the result to be meaningful, to use these functions we require that `sibling` is a descendant of the node `parent`.\r\n(I'm using an abuse of notation, the function should be `compute_original_sibling_data(parent, sibling)` but I'm using `parent.content` instead of `parent` to say that only the content of the parent is inspected.)\r\n\r\nOn these two functions, if we have the following properties:\r\n1. after an UpdatePath goes through P with sibling S, `compute_sibling_data(S) == compute_original_sibling_data(P.content, S)` (with P and S corresponding the values after the UpdatePath)\r\n2. when a non-updating operation is applied to the tree, if P is modified then `compute_original_sibling_data(P_old.content, S_old) == compute_orginal_sibling_data(P_new.content, S_new)`\r\n\r\nWith these properties, we can prove the following theorem: if the parent hash verification procedure passes before applying an operation, then it passes after applying the operation.\r\n\r\nThe parent hash verification procedure works by computing an \"expected parent hash\" and \"computed parent hash\" for each node. The computed parent hash uses the `compute_original_sibling_data` function, and the expected parent hash is retrieved in a descendent of the node.\r\n\r\n## Blanking internal nodes along a path\r\n\r\n### Modification on the tree\r\n\r\nGiven a non-blank leaf L, every parent node on the path from L to the root becomes blank. L can either become blank (first phase of Remove) or get a new non-blank value (Update).\r\n\r\n### Correctness argument\r\n\r\nThe key property for this operation is: for all internal node N, if N's subtree changes then N.content becomes blank.\r\nFrom this we deduce that if the parent hash verification procedure validated the tree before the operation, it will validate the tree after the operation.\r\nThis is because for all non-blank nodes in the new tree, their subtree is not changed by this procedure.\r\n\r\n## UpdatePath\r\n\r\n### Modification on the tree\r\n\r\nGiven a non-blank leaf L, L get a new non-blank value, every node N on the path from L to the root are modified the following way:\r\n- `N.content.unmerged_leaves` becomes empty\r\n- `N.content.public_key` gets a new value\r\n- `N.content.parent_hash` is updated with its parent parent-hash using `compute_sibling_data(N.sibling)`\r\n\r\n### Correctness argument\r\n\r\nThe key property for this operation is: for all internal node N, if N's subtree changes then N is on the path (with child C and sibling S), N.content becomes non-blank, and C.parent_hash is computed using `compute_sibling_data(S)`.\r\nUsing this key property and property 1, we can deduce that for all node N, either N's subtree is unchanged, or N's expected parent hash and computed parent hash are identical.\r\nTherefore the parent hash verification procedure still verifies the new tree.\r\n\r\n## Adding an unmerged leaf in a blank leaf\r\n\r\n### Modification on the tree\r\n\r\nGiven a blank leaf L, L gets a new non-blank value, and L is added to `N.content.unmerged_leaves` for every parent node N in the path from L to the root.\r\n\r\n### Correctness argument\r\n\r\nFor all node N, the computed parent hash don't change using property 2. The expected parent hash is not changed by this operation.\r\n\r\n## Truncating the tree\r\n\r\n### Modification on the tree\r\n\r\nThe rightmost leaf and its parent are removed. As described in the section Remove, it happens only if the leaf is blank and its parent is either blank or is the root.\r\n\r\n### Correctness argument\r\n\r\nFor all node N, the computed parent hash don't change using property 2.\r\nWith the \"careful truncation\", we can prove that the expected parent hash value do not change.\r\nTwo nodes are removed: the rightmost leaf R and its parent P.\r\nThe removal of the rightmost leaf don't change any expected parent hash since it is blank.\r\nIf P is the root then removing P don't change any expected parent hash.\r\nOtherwise P is blank, therefore the only way for the removal of P to interfere with the computation of the expected parent hash for some node is if P is on the \"left-blank path\" in the \"right node\" case.\r\nRemoving P will simply shorten the \"left-blank path\" by one node and the expected parent hash will therefore stay the same.\r\n\r\n## Extending the tree\r\n\r\n### Modification on the tree\r\n\r\nAdd a blank leaf and a blank parent as described in the Adding and Removing Leaves section.\r\n\r\n### Correctness argument\r\n\r\nThis operation adds one blank leaf L and one blank internal node P.\r\nThe key property for this operation is: P is either the root or P is a right node.\r\nThis is deduced by the fact that we manipulate left-balanced trees.\r\n\r\nFrom this key property, we deduce that for each node, the expected parent hash value do not change:\r\n- if P is the root then this is obvious\r\n- if P in a right node, only the expected parent hash from P.parent can change, but actually it will stay the same thanks to the \"left-blank path\" procedure.\r\nUsing property 2, we deduce that for each node, the computed parent hash value do not change.\r\n\r\n# Complexity\r\n\r\nIf `compute_original_sibling_data(parent.content, sibling)` has complexity O(|sibling|) then processing a Welcome for a tree with n leaves can be done in O(n log n).\r\nLet P be a node, L and R be its children. If `compute_sibling_data(S)` can be computed in O(1) from `compute_sibling_data(L)`, `compute_sibling_data(R)` and `P.content` then processing a Commit can be done in O(log n).\r\nLet P be a node, L and R be its children. If `compute_original_sibling_data` only uses `parent.content.unmerged_leaves` and `compute_original_sibling_data(excluded_leaves, P)` can be computed in O(1) using `compute_original_sibling_data(intersection(excluded_leaves, L.leaves), L)` and `compute_original_sibling_data(intersection(excluded_leaves, R.leaves), R)`, then processing a Welcome for a tree with n leaves can be done in O(n log log n).\r\n\r\n# Actual procedures for `compute_original_sibling_data`\r\n\r\n## The resolution approach\r\n\r\n### Definition\r\nThe current implementation of parent hash uses:\r\n- `compute_sibling_data(sibling) = resolution(sibling)`\r\n- `compute_original_sibling_data(parent.content, sibling) = resolution(sibling) - hpke_keys(parent.content.unmerged_leaves)`\r\n\r\n### Proof\r\n\r\nWe can easily prove property 1 and 2, therefore making the current parent hash correct.\r\n\r\n### Complexity\r\n\r\nThe complexity to process a Welcome is O(n log n) and the complexity to process a Commit is in O(n).\r\n\r\n## The full-extension + tree hash approach\r\n\r\n### Definition\r\n\r\n```\r\nfunction full_extension(tree):\r\n    extend `tree` until its number of leaves is a power of 2\r\n\r\nfunction remove_leaves(tree, leaves):\r\n    change the leaves `leaves` to a blank leaves, and remove `leaves` in every internal node's unmerged_leaves list\r\n```\r\n\r\nWe define:\r\n- `compute_sibling_data(sibling) = tree_hash(full_extension(sibling))`\r\n- `compute_original_sibling_data(parent.content, sibling) = tree_hash(remove_leaves(full_extension(sibling), parent.content.unmerged_leaves))`\r\n\r\n### Proofs\r\n\r\nProperty 1 is given by the fact that `remove_leaves(tree, []) == tree`.\r\nFor property 2:\r\n- if a blank leaf is populated under `parent`, it is populated either in:\r\n  - its `child` node, therefore the only modification in the pair `(parent.content, sibling)` is a leaf from `child` being added to `parent.content.unmerged_leaves`, and this doesn't change the value computed by `remove_leaves`\r\n  - its `sibling` node, and in this case the addition of the leaf in `parent.content.unmerged_leaves` makes `remove_leaves` undo the changes done by the addition\r\n- if a truncation or extension changes `parent`, this doesn't change `full_extension(sibling)` so `compute_original_sibling_data(parent.content, sibling)` stays the same.\r\n\r\n### Complexity\r\n\r\nWe can use the fact that `remove_leaves(full_extension(tree), leaves) == full_extension(remove_leaves(tree, leaves))`.\r\nThe complexity to process a Welcome is in O(n log log n) and the complexity to process a Commit is in O(log n).\r\n\r\n",
          "createdAt": "2022-02-10T16:24:29Z",
          "updatedAt": "2022-02-10T16:24:29Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Discussion on virtual interim:\r\n\r\n* @TWal and @bifurcation to get to a merge-able state, then make decision on mailing list",
          "createdAt": "2022-02-17T15:38:18Z",
          "updatedAt": "2022-02-17T15:38:18Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOBoyH6c406lwf",
          "commit": {
            "abbreviatedOid": "337bbaa"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "I suggested some text to point people toward more efficient implementations.  Other than that, I think this is good to go.",
          "createdAt": "2022-02-18T21:30:45Z",
          "updatedAt": "2022-02-18T21:38:49Z",
          "comments": [
            {
              "originalPosition": 28,
              "body": "```suggestion\r\nNote that no recomputation is needed if the tree hash of S is unchanged since\r\nthe last time P was updated.  This is the case for computing or processing a\r\nCommit whose UpdatePath traverses P, since the Commit itself resets P.  (In\r\nother words, it is only necessary to recompute the original sibling tree hash\r\nwhen validating group's tree on joining.) More generally, if none of the entries\r\nin `P.unmerged_leaves` is in the subtree under S (and thus no nodes were truncated),\r\nthen the original tree hash at S is the tree hash of S in the current tree.\r\n\r\nIf it is necessary to recompute the original tree hash of a node, the efficiency\r\nof recomputation can be improved by caching intermediate tree hashes, to avoid\r\nrecomputing over the subtree when the subtree is included in multiple parent\r\nhashes.  A subtree hash can be reused as long as the intersection of the\r\nparent's unmerged leaves with the subtree is the same as in the earlier\r\ncomputation.\r\n```",
              "createdAt": "2022-02-18T21:30:45Z",
              "updatedAt": "2022-02-18T21:38:49Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c41Xfwh",
          "commit": {
            "abbreviatedOid": "f7fab60"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-02-28T16:58:06Z",
          "updatedAt": "2022-02-28T16:58:06Z",
          "comments": []
        }
      ]
    },
    {
      "number": 529,
      "id": "PR_kwDOBoyH6c4v_0jh",
      "title": "Refactor Group Joining and fix External Inits",
      "url": "https://github.com/mlswg/mls-protocol/pull/529",
      "state": "MERGED",
      "author": "kkohbrok",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "This PR refactors the two sections on Group Joining (via Welcome and via External Init) by changing the `GroupInfo` struct that can be used for both cases. The `external_pub` used in the course of an External Init is added as an optional field. This PR also:\r\n\r\n- removes the redundant ProtocolVersion in the GroupInfo\r\n- adds a GroupInfoTBS struct to follow the convention of specifying a TBS struct for signed messages\r\n- implicitly, the `confirmed_transcript_hash` and `confirmation_tag` is now used for external inits instead of the `interim_transcript_hash`, which was not sufficient to create a valid commit",
      "createdAt": "2021-12-17T10:53:40Z",
      "updatedAt": "2022-01-19T17:09:12Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "6754a8edc9d77c902643d37a519b9a546ab00b4e",
      "headRepository": "kkohbrok/mls-protocol",
      "headRefName": "refactor_pgs_and_welcome",
      "headRefOid": "5b507f4df091107bde42b619791376ff2335efbb",
      "closedAt": "2022-01-19T17:09:12Z",
      "mergedAt": "2022-01-19T17:09:12Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "f02d296844fef310d417485100ae0a2e32feb9c7"
      },
      "comments": [
        {
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thanks for the suggestions! I agree that it's a bit nicer to have an extension rather then an optional field.",
          "createdAt": "2022-01-10T07:09:53Z",
          "updatedAt": "2022-01-10T07:09:53Z"
        },
        {
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "body": "I agree it's good to align `PublicGroupState` and `GroupInfo`!",
          "createdAt": "2022-01-10T20:47:34Z",
          "updatedAt": "2022-01-10T20:47:34Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOBoyH6c4ybLO6",
          "commit": {
            "abbreviatedOid": "b970e19"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "So basically, we're converging the internal and external join cases as a result of fixing a bug in external join.  Seems like a fine idea.\r\n\r\nI will note that this promotes GroupInfo into a \"public\" / \"on-the-wire\" object, as opposed to always being wrapped in a Welcome.  In the internal join case, the GroupInfo is always sent encrypted to the new joiner; in the external join case, it isn't necessarily encrypted (up to the application).  Doesn't need to be a blocker, but might be worth elaborating on in an implementation document.\r\n\r\nMarking as approved, but I would pretty strongly prefer that `external_pub` be in an extension vs. an optional field.",
          "createdAt": "2022-01-06T19:23:58Z",
          "updatedAt": "2022-01-06T19:34:24Z",
          "comments": [
            {
              "originalPosition": 136,
              "body": "I would probably make this an extension (in `other_extensions`, like `ratchet_tree`) instead of an optional field.",
              "createdAt": "2022-01-06T19:23:58Z",
              "updatedAt": "2022-01-06T19:34:24Z"
            },
            {
              "originalPosition": 211,
              "body": "Suggest saying a little more about the dynamics here:\r\n\r\n```suggestion\r\nIn other words, to join a group via an External Commit, a new member needs a GroupInfo with\r\nan `external_pub` present.  Thus, a member of the group can enable new clients to join by\r\nmaking a GroupInfo object available to them.  Note that because a GroupInfo object is specific \r\nto an epoch, it will need to be updated as the group advances.  In particular, each GroupInfo\r\nobject can be used for one external join, since that external join will cause the epoch to change.\r\n```",
              "createdAt": "2022-01-06T19:28:59Z",
              "updatedAt": "2022-01-06T19:34:24Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c4ykF6H",
          "commit": {
            "abbreviatedOid": "98981c5"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-01-10T20:46:34Z",
          "updatedAt": "2022-01-10T20:46:35Z",
          "comments": [
            {
              "originalPosition": 135,
              "body": "Since it's now an extension, do we still need it here?",
              "createdAt": "2022-01-10T20:46:35Z",
              "updatedAt": "2022-01-10T20:46:35Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c4ylr_E",
          "commit": {
            "abbreviatedOid": "98981c5"
          },
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-01-11T07:23:15Z",
          "updatedAt": "2022-01-11T07:23:15Z",
          "comments": [
            {
              "originalPosition": 135,
              "body": "Ah, sorry. Forgot to remove that one. Thanks!",
              "createdAt": "2022-01-11T07:23:15Z",
              "updatedAt": "2022-01-11T07:23:15Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c4zFlv_",
          "commit": {
            "abbreviatedOid": "5b507f4"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-01-19T17:09:05Z",
          "updatedAt": "2022-01-19T17:09:05Z",
          "comments": []
        }
      ]
    },
    {
      "number": 532,
      "id": "PR_kwDOBoyH6c4wThM0",
      "title": "Get rid of explicit protocol version fields",
      "url": "https://github.com/mlswg/mls-protocol/pull/532",
      "state": "CLOSED",
      "author": "kkohbrok",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "In all instances that I could find in the spec, the `ProtocolVersion` is redundant, as it appears alongside the `ciphersuite, which implies an MLS version. This PR thus removes explicit handling of MLS versions outside of ciphersuite concerns.",
      "createdAt": "2021-12-27T14:05:44Z",
      "updatedAt": "2022-01-26T12:48:33Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "6754a8edc9d77c902643d37a519b9a546ab00b4e",
      "headRepository": "kkohbrok/mls-protocol",
      "headRefName": "protocol-versions",
      "headRefOid": "6f5f452cf5eb07ae01d76487f99f44a30b5128bf",
      "closedAt": "2022-01-26T12:48:33Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "body": "This seems like a bad idea to me. We may well want to change ciphers without changing protocols or vice versa. ",
          "createdAt": "2022-01-06T18:53:07Z",
          "updatedAt": "2022-01-06T18:53:07Z"
        },
        {
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I don't have a strong opinion either way, but the way it currently is doesn't makes the version fields redundant. @bifurcation do you want to make a PR with a scheme that detaches the ciphersuites from the versions? Although that's probably a discussion we should have on the mailing list as well.",
          "createdAt": "2022-01-10T06:58:43Z",
          "updatedAt": "2022-01-10T06:58:43Z"
        },
        {
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "body": "I agree that we should really choose between:\r\n\r\na) Having protocol version-specific ciphersuites and not repeat the protocol version (note that ciphersuites could still be changed for a given protocol version)\r\nb) Not have protocol version-specific ciphersuites and mention the protocol version wherever needed\r\n\r\nIIRC we discussed this at the interim in 2020 in NYC and the reason for deviating from what TLS does were the following:\r\n\r\n - MLS is unlikely to ever have as many ciphersuites as TLS\r\n - The meaning/set of the crypto primitives mentioned in the ciphersuite might considerably change between MLS versions. If the primitives are used differently in a newer version (their meaning changes), it might be a security issue (e.g. a certain security level is now no longer considered sufficient). If the set changes, ciphersuites can't be carried over between versions anyway.\r\n\r\nI'm not very hung up on this, but we did have reasons to do what we did at the time.\r\n",
          "createdAt": "2022-01-10T20:59:39Z",
          "updatedAt": "2022-01-10T20:59:39Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "As discussed on working call 2022-01-20, closing in favor of #544 ",
          "createdAt": "2022-01-26T12:48:33Z",
          "updatedAt": "2022-01-26T12:48:33Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOBoyH6c4ybHc9",
          "commit": {
            "abbreviatedOid": "6f5f452"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "Yeah, I think the actual error here is that we tied ciphersuites to version in the first place.  I seem to recall objecting at the time, but relenting because it was a soft association -- having a separate version number meant that even if a ciphersuite was allegedly tied to a given version, you could have a new version adopt it.  So I would object to making this a hard association.\r\n\r\nBy way of comparison: TLS went through three iterations over 20 years without having to redefine all of its ciphersuites, which is a good thing because there are 350 entries!  TLS 1.3 made a bit of a cut-over, but that still doesn't argue for a hard single-version association.  The pre-1.3 suites work with earlier versions, and the 1.3 suites are expected to be good for the next few versions.\r\n\r\nSo if we do anything here, we should strip the version name from the ciphersuite name, and maybe add a column to the registry to indicate what version the suite can be used with.",
          "createdAt": "2022-01-06T19:10:41Z",
          "updatedAt": "2022-01-06T19:10:41Z",
          "comments": []
        }
      ]
    },
    {
      "number": 533,
      "id": "PR_kwDOBoyH6c4wj668",
      "title": "Fix typo in EncryptedGroupSecrets",
      "url": "https://github.com/mlswg/mls-protocol/pull/533",
      "state": "MERGED",
      "author": "TWal",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "This PR fixes a typo in `EncryptedGroupSecrets` introduced by PR #491 .",
      "createdAt": "2022-01-05T13:50:09Z",
      "updatedAt": "2022-01-06T18:05:25Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "6754a8edc9d77c902643d37a519b9a546ab00b4e",
      "headRepository": "TWal/mls-protocol",
      "headRefName": "twal_encrypted_group_secret_typo",
      "headRefOid": "930686892f16fe8d9ba48d043c6be3b9df0f1969",
      "closedAt": "2022-01-06T18:05:25Z",
      "mergedAt": "2022-01-06T18:05:25Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "e39695c6e8fe39e04fe644a213eb8a82ac483e3b"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOBoyH6c4ya42e",
          "commit": {
            "abbreviatedOid": "9306868"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-01-06T18:05:19Z",
          "updatedAt": "2022-01-06T18:05:19Z",
          "comments": []
        }
      ]
    },
    {
      "number": 535,
      "id": "PR_kwDOBoyH6c4wtxNQ",
      "title": "Require extensions to be unique in any given extensions vector",
      "url": "https://github.com/mlswg/mls-protocol/pull/535",
      "state": "MERGED",
      "author": "kkohbrok",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #530.",
      "createdAt": "2022-01-10T07:15:21Z",
      "updatedAt": "2022-01-19T17:06:29Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "e39695c6e8fe39e04fe644a213eb8a82ac483e3b",
      "headRepository": "kkohbrok/mls-protocol",
      "headRefName": "extension_uniqueness",
      "headRefOid": "be98d1da1f2138de63bf026cc8ba6bf5650677ca",
      "closedAt": "2022-01-19T17:06:28Z",
      "mergedAt": "2022-01-19T17:06:28Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "6b712c4d50c3a6bcec178fd714e491634e119a8b"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOBoyH6c4ykIv2",
          "commit": {
            "abbreviatedOid": "aa763c9"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-01-10T21:00:33Z",
          "updatedAt": "2022-01-10T21:00:33Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOBoyH6c4y1whE",
          "commit": {
            "abbreviatedOid": "aa763c9"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "SGTM, one minor rephrasing for more  clarity.",
          "createdAt": "2022-01-14T14:06:46Z",
          "updatedAt": "2022-01-14T14:06:59Z",
          "comments": [
            {
              "originalPosition": 18,
              "body": "```suggestion\r\n* Any field containing a list of extensions MUST NOT have more than one extension of any given type.\r\n```",
              "createdAt": "2022-01-14T14:06:46Z",
              "updatedAt": "2022-01-14T14:06:59Z"
            }
          ]
        }
      ]
    },
    {
      "number": 536,
      "id": "PR_kwDOBoyH6c4wvqZX",
      "title": "Reword padding section to reflect updated padding structure",
      "url": "https://github.com/mlswg/mls-protocol/pull/536",
      "state": "MERGED",
      "author": "tomleavy",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "The padding section was out of date based on prior changes. Resolves #534 ",
      "createdAt": "2022-01-10T16:34:53Z",
      "updatedAt": "2022-01-19T17:06:03Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "e39695c6e8fe39e04fe644a213eb8a82ac483e3b",
      "headRepository": "tomleavy/mls-protocol",
      "headRefName": "padding-update",
      "headRefOid": "9555eb99b3f21b9b38e6fe849bc43dbd9139d668",
      "closedAt": "2022-01-19T17:06:03Z",
      "mergedAt": "2022-01-19T17:06:02Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "da39458fc145efd489a44015bbc81f6b88bd9691"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOBoyH6c4ym38u",
          "commit": {
            "abbreviatedOid": "9555eb9"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-01-11T11:39:41Z",
          "updatedAt": "2022-01-11T11:39:41Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOBoyH6c4zFkzL",
          "commit": {
            "abbreviatedOid": "9555eb9"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-01-19T17:05:58Z",
          "updatedAt": "2022-01-19T17:05:58Z",
          "comments": []
        }
      ]
    },
    {
      "number": 541,
      "id": "PR_kwDOBoyH6c4xDtKt",
      "title": "Make some sections easier to read.",
      "url": "https://github.com/mlswg/mls-protocol/pull/541",
      "state": "MERGED",
      "author": "Bren2010",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2022-01-14T20:04:17Z",
      "updatedAt": "2022-05-06T15:42:12Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "e39695c6e8fe39e04fe644a213eb8a82ac483e3b",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "brendan/editorial",
      "headRefOid": "91c5587b2d86b06cab40a03e2c73f460ffd1c25a",
      "closedAt": "2022-01-26T13:19:10Z",
      "mergedAt": "2022-01-26T13:19:10Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "6575f556877bd826ca9e6f74f9e2432cd49d1eb1"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOBoyH6c4zGCMm",
          "commit": {
            "abbreviatedOid": "91c5587"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Overall lgtm, one small comment.",
          "createdAt": "2022-01-19T18:55:05Z",
          "updatedAt": "2022-01-19T18:56:34Z",
          "comments": [
            {
              "originalPosition": 247,
              "body": "```suggestion\r\n* The `group_id` field is constant.\r\n* The `extensions` field is updated whenever a GroupContextExtensions proposal is committed.\r\n```\r\n\r\n(And the `extensions` part should go lower down.)",
              "createdAt": "2022-01-19T18:55:06Z",
              "updatedAt": "2022-01-19T18:56:34Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c4zeFlD",
          "commit": {
            "abbreviatedOid": "91c5587"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-01-26T13:19:01Z",
          "updatedAt": "2022-01-26T13:19:02Z",
          "comments": [
            {
              "originalPosition": 247,
              "body": "Will handle this in a small follow-on.",
              "createdAt": "2022-01-26T13:19:02Z",
              "updatedAt": "2022-01-26T13:19:02Z"
            }
          ]
        }
      ]
    },
    {
      "number": 543,
      "id": "PR_kwDOBoyH6c4xRvfM",
      "title": "Be consistent about version labeling",
      "url": "https://github.com/mlswg/mls-protocol/pull/543",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #531 ",
      "createdAt": "2022-01-19T17:21:12Z",
      "updatedAt": "2022-01-26T13:16:32Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "ced24321bd52a912e45a6e4bf221fd426ed100b0",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "consistent-version",
      "headRefOid": "bb0bd744b274540c5500538cec32f3cfd90d49c5",
      "closedAt": "2022-01-26T13:16:32Z",
      "mergedAt": "2022-01-26T13:16:32Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "30079cba38ffe838fb7d2e19d675be3dafbf3039"
      },
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "@TWal suggests moving everything to `MLS 1.0` instead.  Will do.",
          "createdAt": "2022-01-20T15:16:24Z",
          "updatedAt": "2022-01-20T15:16:24Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 544,
      "id": "PR_kwDOBoyH6c4xR9-v",
      "title": "Remove version from ciphersuites",
      "url": "https://github.com/mlswg/mls-protocol/pull/544",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "#532 proposes to remove redundancy between version fields and ciphersuites by removing the version fields.  This PR removes the version from the ciphersuite instead.",
      "createdAt": "2022-01-19T18:38:38Z",
      "updatedAt": "2022-01-26T13:24:37Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "ced24321bd52a912e45a6e4bf221fd426ed100b0",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "remove-ciphersuite-version",
      "headRefOid": "1137ac0f013d2bf5caedc82fbd0733fe5cc93e17",
      "closedAt": "2022-01-26T13:24:37Z",
      "mergedAt": "2022-01-26T13:24:37Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "a7b13352b5529c41ff4c32004b4c52e6a0bd46fc"
      },
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "@raphaelrobert suggests adding some advisory text in the extensibility section to the effect that future versions of the protocol should consider whether they want to keep all defined ciphersuites.",
          "createdAt": "2022-01-20T15:37:44Z",
          "updatedAt": "2022-01-20T15:37:44Z"
        },
        {
          "author": "seanturner",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@raphaelrobert here is some text we put in RFC 8447 (IANA registries for TLS) that was also included in the IANA registry to warn about cipher suites getting weaker over time. This could be modified to mention culling at different version.\r\n\r\n    WARNING: : Cryptographic algorithms and parameters will be\r\n    broken or weakened over time. Blindly implementing cipher\r\n    suites listed here is not advised. Implementers and users\r\n    need to check that the cryptographic algorithms listed continue\r\n    to provide the expected level of security.",
          "createdAt": "2022-01-20T15:45:54Z",
          "updatedAt": "2022-01-20T15:45:54Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOBoyH6c4zeHjg",
          "commit": {
            "abbreviatedOid": "1137ac0"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-01-26T13:23:49Z",
          "updatedAt": "2022-01-26T13:23:49Z",
          "comments": []
        }
      ]
    },
    {
      "number": 545,
      "id": "PR_kwDOBoyH6c4xSKP5",
      "title": "Add missing word",
      "url": "https://github.com/mlswg/mls-protocol/pull/545",
      "state": "MERGED",
      "author": "stefunctional",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2022-01-19T19:48:09Z",
      "updatedAt": "2022-01-20T16:46:45Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "f02d296844fef310d417485100ae0a2e32feb9c7",
      "headRepository": "stefunctional/mls-protocol",
      "headRefName": "missing-word",
      "headRefOid": "c75594d534594568949d1cf6a7deeb26c2524982",
      "closedAt": "2022-01-20T16:46:45Z",
      "mergedAt": "2022-01-20T16:46:45Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "60410380e80c0335dec1f535e5db84b827bd212e"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOBoyH6c4zKf72",
          "commit": {
            "abbreviatedOid": "c75594d"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-01-20T15:14:41Z",
          "updatedAt": "2022-01-20T15:14:41Z",
          "comments": []
        }
      ]
    },
    {
      "number": 546,
      "id": "PR_kwDOBoyH6c4xVBWo",
      "title": "Downgrade MUST to SHOULD for commit senders including all valid commits",
      "url": "https://github.com/mlswg/mls-protocol/pull/546",
      "state": "MERGED",
      "author": "tomleavy",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Addresses the comments in ( Resolves #542 )\r\n\r\nSince a member performing a commit including all valid proposals within an epoch is best effort, it makes sense to downgrade the requirement from MUST to SHOULD. \r\n\r\nIMO, MUST should be reserved for instances where the receiver would throw an error in the condition the sender did not 100% comply with the rule. Since in this case it is not a hard error under certain conditions, such as the member performing the commit having not received a proposal in transit while generating the commit, SHOULD is a better choice.",
      "createdAt": "2022-01-20T14:32:56Z",
      "updatedAt": "2022-01-27T19:07:23Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "f02d296844fef310d417485100ae0a2e32feb9c7",
      "headRepository": "tomleavy/mls-protocol",
      "headRefName": "commit-must-should",
      "headRefOid": "a532316b2173b7aa55734a5c26e583193ea0c0ad",
      "closedAt": "2022-01-27T19:07:23Z",
      "mergedAt": "2022-01-27T19:07:23Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "40cd70c1e15b6caad28cb356fc5b0ec8792978bf"
      },
      "comments": [
        {
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "body": "I'm not sure this PR addresses the issues raised in #542, especially regarding the redundancy of proposals. I would suggest the following:\r\n\r\n4. The sender of a commit SHOULD use all valid non-redundant proposals it has received\r\n5. In the event that a valid non-redundant proposal is omitted from the next Commit, the sender of the proposal SHOULD retransmit it in the new epoch\r\n",
          "createdAt": "2022-01-20T17:31:57Z",
          "updatedAt": "2022-01-20T17:31:57Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Re: non-redundant: I'm not sure we need to say \"valid non-redundant\".  We can just include non-redundancy in the definition of \"valid\".\r\n\r\nRe: retransmit: I would frame this as \"If a group member sent a proposal within an epoch that was not included in a Commit that initiates the next epoch, then the proposer MAY retransmit the proposal in the new epoch.\"",
          "createdAt": "2022-01-20T20:53:27Z",
          "updatedAt": "2022-01-20T20:53:27Z"
        },
        {
          "author": "tomleavy",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I believe the existing language in the \"if there are multiple proposals ...\" paragraph covers the non-redundant aspect of the requirements.\r\n\r\nHow about this for retransmit? I can push a new commit if we think this helps\r\n\r\n\"The Commit MUST NOT combine proposals sent within different epochs. In the event that a valid proposal is omitted from the next Commit, and that proposal is still valid in the current epoch, the sender of the proposal MAY retransmit it.\"",
          "createdAt": "2022-01-21T21:18:31Z",
          "updatedAt": "2022-01-21T21:18:31Z"
        },
        {
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "body": "I think that works.",
          "createdAt": "2022-01-26T13:26:04Z",
          "updatedAt": "2022-01-26T13:26:04Z"
        },
        {
          "author": "tomleavy",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Pushed a commit to add the copy in my comment",
          "createdAt": "2022-01-27T02:26:32Z",
          "updatedAt": "2022-01-27T02:26:32Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Discussion on working call:\r\n\r\n* Agreement to soften receiver requirement, keep MUST on sender\r\n* @tomleavy to update, then we can merge",
          "createdAt": "2022-01-27T15:28:56Z",
          "updatedAt": "2022-01-27T15:28:56Z"
        },
        {
          "author": "tomleavy",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Just posted new wording, let me know what you think ",
          "createdAt": "2022-01-27T17:25:48Z",
          "updatedAt": "2022-01-27T17:25:48Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Looks good to me, thanks @tomleavy ",
          "createdAt": "2022-01-27T19:07:19Z",
          "updatedAt": "2022-01-27T19:07:19Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOBoyH6c4zKftf",
          "commit": {
            "abbreviatedOid": "f1b0ec9"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-01-20T15:14:03Z",
          "updatedAt": "2022-01-20T15:14:03Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOBoyH6c4zhHso",
          "commit": {
            "abbreviatedOid": "051b71e"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-01-27T02:41:11Z",
          "updatedAt": "2022-01-27T02:41:12Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "I don't really agree with downgrading this from a MUST to a SHOULD. Quoting RFC 2119:\r\n\r\n```\r\nImperatives of the type defined in this memo must be used with care\r\nand sparingly.  In particular, they MUST only be used where it is\r\nactually required for interoperation or to limit behavior which has\r\npotential for causing harm (e.g., limiting retransmisssions)\r\n```\r\n\r\nThis is a case where we're limiting potentially harmful behavior (intentionally dropping proposals and forcing others to retransmit) such that implementations that don't follow the MUST are non-compliant with the spec.",
              "createdAt": "2022-01-27T02:41:11Z",
              "updatedAt": "2022-01-27T02:41:12Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c4zhMZm",
          "commit": {
            "abbreviatedOid": "051b71e"
          },
          "author": "tomleavy",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-01-27T03:24:48Z",
          "updatedAt": "2022-01-27T03:24:49Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "I see your point, my primary concern was reducing how often commits are rejected due to the async nature of the protocol since those packets likely have a higher computational and bandwidth cost.\r\n\r\n\"A group member that has observed one or more proposals within an epoch MUST send a Commit message\" also plays into this choice. If a group is receiving an uptick in proposals, which tends to happen when they are first created and a large number of users in size, then commits will fail and block members from sending messages until a new commit is generated and uploaded. When you are using the protocol on something like a mobile app on a bad connection this becomes a problem due to high amounts of latency between message send and receive.",
              "createdAt": "2022-01-27T03:24:49Z",
              "updatedAt": "2022-01-27T03:24:49Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c4zhQe2",
          "commit": {
            "abbreviatedOid": "051b71e"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-01-27T04:08:36Z",
          "updatedAt": "2022-01-27T04:08:36Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "Commits wouldn't be rejected if they don't have 100% of the proposals. There are valid reasons a Commit would not have all proposals: lossy delivery channel, race condition. So like in the case where 1.) I start preparing a Commit, 2.) You send a new proposal, 3.) I send my Commit without your proposal -- your proposal would be dropped and you'd have the option to re-send it in the new epoch. There's not a technical enforcement of this \"MUST\", its more about policy.\r\n\r\nI believe a Commit would only be rejected if it was sent at the same time as another Commit, and the Delivery Service chose to use the other Commit instead. That would be less common because it would only happen when two users are trying to send application data at the same time.",
              "createdAt": "2022-01-27T04:08:36Z",
              "updatedAt": "2022-01-27T04:08:36Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c4zi9fr",
          "commit": {
            "abbreviatedOid": "051b71e"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-01-27T12:31:31Z",
          "updatedAt": "2022-01-27T12:31:31Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "This is why I think SHOULD is appropriate here -- I hesitate to have a MUST-level requirement for behavior that is not observable to remote parties.  After all, if it's not observable, then it can hardly be a requirement for interop!",
              "createdAt": "2022-01-27T12:31:31Z",
              "updatedAt": "2022-01-27T12:31:31Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c4zjTIc",
          "commit": {
            "abbreviatedOid": "051b71e"
          },
          "author": "rohan-wire",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-01-27T13:48:45Z",
          "updatedAt": "2022-01-27T13:48:45Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "In my experience it is totally reasonable to split behavior into sending/receiving roles for example. It's fine to say that when you send a commit you MUST include all valid proposals you have received, as long as the receiving behavior makes it clear what to do (and under what circumstances the receiver might see a proposal not in the commit: ex: invalid, or hadn't arrived yet).\r\n\r\nIf we make this a SHOULD, we need an extra sentence explaining under what circumstances the sender might choose not to include a specific proposal. SHOULD's are always more complicated. My general IETF advice is to use them sparingly.",
              "createdAt": "2022-01-27T13:48:45Z",
              "updatedAt": "2022-01-27T13:48:45Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c4zjqkV",
          "commit": {
            "abbreviatedOid": "051b71e"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-01-27T14:55:11Z",
          "updatedAt": "2022-01-27T14:55:11Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "I can live with that.  Then maybe the way to resolve the confusion @tomleavy notes is to add a note here that receivers SHOULD NOT enforce that everything they sent is included?",
              "createdAt": "2022-01-27T14:55:11Z",
              "updatedAt": "2022-01-27T14:55:11Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c4zkhfF",
          "commit": {
            "abbreviatedOid": "a532316"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-01-27T17:31:50Z",
          "updatedAt": "2022-01-27T17:31:50Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOBoyH6c4zk6ba",
          "commit": {
            "abbreviatedOid": "a532316"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-01-27T19:06:58Z",
          "updatedAt": "2022-01-27T19:06:58Z",
          "comments": []
        }
      ]
    },
    {
      "number": 547,
      "id": "PR_kwDOBoyH6c4xX9C7",
      "title": "Domain separation for KeyPackage and Proposal references",
      "url": "https://github.com/mlswg/mls-protocol/pull/547",
      "state": "MERGED",
      "author": "kkohbrok",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "It doesn't seem super critical, but I think right now there could be a collision between references to Update/Add proposals and KeyPackages. Also, it's essentially free and it just feels wrong not to have proper domain separation for these values \ud83d\ude2c.",
      "createdAt": "2022-01-21T10:03:45Z",
      "updatedAt": "2022-01-26T15:15:04Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "28489f2c85c9bee07b0d4aff3b81b5fb59572e8f",
      "headRepository": "kkohbrok/mls-protocol",
      "headRefName": "separate_reference_spaces",
      "headRefOid": "5e1929dca64838616768b984f8b33aadeec22102",
      "closedAt": "2022-01-26T15:15:03Z",
      "mergedAt": "2022-01-26T15:15:03Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "da826dffc27c4312e152637dba5022e69a179f26"
      },
      "comments": [
        {
          "author": "TWal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I also thought about this but didn't see what are the security implications.\r\n\r\nIn any case, that's always good hygiene and doesn't cost much!",
          "createdAt": "2022-01-24T13:24:27Z",
          "updatedAt": "2022-01-24T13:24:27Z"
        },
        {
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yeah, no particular security implications. It just seems right to do it this way and it doesn't seem to hurt.",
          "createdAt": "2022-01-24T13:44:01Z",
          "updatedAt": "2022-01-24T13:44:01Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOBoyH6c4zQJVW",
          "commit": {
            "abbreviatedOid": "cf1e0ad"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-01-21T18:01:08Z",
          "updatedAt": "2022-01-21T18:01:08Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOBoyH6c4zeiER",
          "commit": {
            "abbreviatedOid": "cf1e0ad"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-01-26T14:47:13Z",
          "updatedAt": "2022-01-26T14:47:28Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "```suggestion\r\nMakeKeyPackageRef(value) = KDF.expand(\r\n  KDF.extract(\"\", value), \"MLS 1.0 KeyPackage Reference\", 16)\r\n\r\nMakeProposalRef(value) = KDF.expand(\r\n  KDF.extract(\"\", value), \"MLS 1.0 Proposal Reference\", 16)\r\n```\r\n\r\nWrapping to fit within RFC Editor's preferred line lengths.",
              "createdAt": "2022-01-26T14:47:13Z",
              "updatedAt": "2022-01-26T14:47:28Z"
            }
          ]
        }
      ]
    },
    {
      "number": 548,
      "id": "PR_kwDOBoyH6c4xnbx5",
      "title": "Update the description of the evolution of GroupContext",
      "url": "https://github.com/mlswg/mls-protocol/pull/548",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes a minor bug in #541 \r\n",
      "createdAt": "2022-01-26T13:23:42Z",
      "updatedAt": "2022-01-26T13:24:48Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "6575f556877bd826ca9e6f74f9e2432cd49d1eb1",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "pr541-fix",
      "headRefOid": "0d4372d27e0655efb4ccd99fddcc9c0a040fedd2",
      "closedAt": "2022-01-26T13:24:48Z",
      "mergedAt": "2022-01-26T13:24:48Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "4e3bf741c54764d266ed7065e1a6e8507eaf332e"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 549,
      "id": "PR_kwDOBoyH6c4xniPt",
      "title": "Add branch/init overview",
      "url": "https://github.com/mlswg/mls-protocol/pull/549",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Adds the overview text proposed in #525.",
      "createdAt": "2022-01-26T13:56:16Z",
      "updatedAt": "2022-01-26T17:41:05Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "4e3bf741c54764d266ed7065e1a6e8507eaf332e",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "psk-usage-overview",
      "headRefOid": "9f8026889c734113f13e8636da34edf335258a8f",
      "closedAt": "2022-01-26T17:41:05Z",
      "mergedAt": "2022-01-26T17:41:05Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "a9a6d223a5d680503b119f804c1b12606553e22e"
      },
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks @kkohbrok !",
          "createdAt": "2022-01-26T17:36:50Z",
          "updatedAt": "2022-01-26T17:36:50Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOBoyH6c4ze4-_",
          "commit": {
            "abbreviatedOid": "c596fe1"
          },
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "Thanks for putting together the overview. The figures are great :-)\r\n\r\nLooks good to me with one proposition.",
          "createdAt": "2022-01-26T15:48:36Z",
          "updatedAt": "2022-01-26T15:49:43Z",
          "comments": [
            {
              "originalPosition": 10,
              "body": "I feel like it doesn't become clear here, what the actual benefits of this are. Although the full details should probably go into the architecture docs. Something as follows maybe?\r\n\r\n```suggestion\r\nA group comprises a single linear sequence of epochs and groups are generally\r\nindependent of one-another. However, it can sometimes be useful to link epochs\r\ncryptographically, either within a group or across groups. MLS derives a\r\nresumption pre-shared key (PSK) from each epoch to allow entropy extracted from\r\none epoch to be injected into a future epoch. This link guarantees that members\r\nentering the new epoch agree on a key if and only if were members of the group\r\nduring the epoch from which the resumption key was extracted.\r\n```",
              "createdAt": "2022-01-26T15:48:37Z",
              "updatedAt": "2022-01-26T15:49:43Z"
            }
          ]
        }
      ]
    },
    {
      "number": 550,
      "id": "PR_kwDOBoyH6c4xn_xM",
      "title": "Adjust ASCII art to fit within 72 character limit.",
      "url": "https://github.com/mlswg/mls-protocol/pull/550",
      "state": "MERGED",
      "author": "rohan-wire",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Adjust ASCII art to fit within 72 character limit. Did not fix tables or code in appendices.",
      "createdAt": "2022-01-26T16:00:47Z",
      "updatedAt": "2022-01-28T03:46:16Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "da826dffc27c4312e152637dba5022e69a179f26",
      "headRepository": "rohan-wire/mls-protocol",
      "headRefName": "rohan/fix-ascii-art",
      "headRefOid": "0b7aaa7325adec8705278adae9984134d6bfe582",
      "closedAt": "2022-01-26T17:41:43Z",
      "mergedAt": "2022-01-26T17:41:42Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "870dfb60e7feae8c83350ceaa1ff7f5d2bf981a8"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOBoyH6c4zfdbT",
          "commit": {
            "abbreviatedOid": "0b7aaa7"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-01-26T17:40:40Z",
          "updatedAt": "2022-01-26T17:40:40Z",
          "comments": []
        }
      ]
    },
    {
      "number": 551,
      "id": "PR_kwDOBoyH6c4xobcN",
      "title": "Rename InitKeys -> KeyPackages;  and GroupInfo -> PublicGroupState",
      "url": "https://github.com/mlswg/mls-protocol/pull/551",
      "state": "MERGED",
      "author": "rohan-wire",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Complete the renaming of InitKeys ->  KeyPackages;  and GroupInfo -> PublicGroupState",
      "createdAt": "2022-01-26T18:10:16Z",
      "updatedAt": "2022-01-28T03:46:47Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "870dfb60e7feae8c83350ceaa1ff7f5d2bf981a8",
      "headRepository": "rohan-wire/mls-protocol",
      "headRefName": "rohan/rename-initkeys",
      "headRefOid": "37712708b94e9106c92c392cd7b0b2024f4192ab",
      "closedAt": "2022-01-27T19:09:46Z",
      "mergedAt": "2022-01-27T19:09:46Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "bf8a61546d8a4c3934e297e0fad95f80ea0f901f"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOBoyH6c4zk7Ed",
          "commit": {
            "abbreviatedOid": "3771270"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-01-27T19:09:39Z",
          "updatedAt": "2022-01-27T19:09:39Z",
          "comments": []
        }
      ]
    },
    {
      "number": 552,
      "id": "PR_kwDOBoyH6c4xodaH",
      "title": "fetching KeyPackages SHOULD be rate limited.",
      "url": "https://github.com/mlswg/mls-protocol/pull/552",
      "state": "MERGED",
      "author": "rohan-wire",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2022-01-26T18:20:58Z",
      "updatedAt": "2022-01-28T03:47:15Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "90beaae11e5a7ed92a59258ea8d2baf9fb7c7f05",
      "headRepository": "rohan-wire/mls-protocol",
      "headRefName": "rohan/should-rate-limit-keypackages",
      "headRefOid": "f5d75df366ab3bafcf9427a8e1b7008dbba98893",
      "closedAt": "2022-01-27T19:20:16Z",
      "mergedAt": "2022-01-27T19:20:16Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "986f8909971ffe150db40f404257f2a602c2cbfc"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOBoyH6c4zk88w",
          "commit": {
            "abbreviatedOid": "362432d"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-01-27T19:17:26Z",
          "updatedAt": "2022-01-27T19:17:26Z",
          "comments": []
        }
      ]
    },
    {
      "number": 553,
      "id": "PR_kwDOBoyH6c4xoe7n",
      "title": "Make definition of _group_ match the Introduction definition",
      "url": "https://github.com/mlswg/mls-protocol/pull/553",
      "state": "MERGED",
      "author": "rohan-wire",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "The definition of an MLS group in the 2nd paragraph of the Protocol Overview is really good. Let's use it as the definition in the Terminology section as well.",
      "createdAt": "2022-01-26T18:29:38Z",
      "updatedAt": "2022-01-28T03:47:39Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "870dfb60e7feae8c83350ceaa1ff7f5d2bf981a8",
      "headRepository": "rohan-wire/mls-protocol",
      "headRefName": "rohan/group-definition",
      "headRefOid": "3b6e4c78efb467c338df84ac5938bff1aac42849",
      "closedAt": "2022-01-27T19:12:44Z",
      "mergedAt": "2022-01-27T19:12:44Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "a262708332df4aa79cf99ca4d7ec1ef80532a033"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOBoyH6c4zhFSU",
          "commit": {
            "abbreviatedOid": "3b6e4c7"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-01-27T02:19:39Z",
          "updatedAt": "2022-01-27T02:19:39Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOBoyH6c4zk7x0",
          "commit": {
            "abbreviatedOid": "3b6e4c7"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-01-27T19:12:34Z",
          "updatedAt": "2022-01-27T19:12:34Z",
          "comments": []
        }
      ]
    },
    {
      "number": 554,
      "id": "PR_kwDOBoyH6c4xogUm",
      "title": "Use common-sense definition of _descendant_",
      "url": "https://github.com/mlswg/mls-protocol/pull/554",
      "state": "MERGED",
      "author": "rohan-wire",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Make the definition of _descendant_ match the common-sense definition (you are not your own descendant), adjust the text which uses the definition. Note: this allows for a much clearer definition of the tree invariant as well.",
      "createdAt": "2022-01-26T18:37:57Z",
      "updatedAt": "2022-01-28T03:48:02Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "870dfb60e7feae8c83350ceaa1ff7f5d2bf981a8",
      "headRepository": "rohan-wire/mls-protocol",
      "headRefName": "rohan/descendant-definition",
      "headRefOid": "579bde487e2f1663a843a66fba430199cf557a74",
      "closedAt": "2022-01-27T19:16:13Z",
      "mergedAt": "2022-01-27T19:16:13Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "90beaae11e5a7ed92a59258ea8d2baf9fb7c7f05"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOBoyH6c4zhErV",
          "commit": {
            "abbreviatedOid": "624037f"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-01-27T02:14:24Z",
          "updatedAt": "2022-01-27T02:14:24Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOBoyH6c4zk8M0",
          "commit": {
            "abbreviatedOid": "624037f"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-01-27T19:14:18Z",
          "updatedAt": "2022-01-27T19:15:12Z",
          "comments": [
            {
              "originalPosition": 10,
              "body": "```suggestion\r\n_contains_ a node if that node is a descendant of the root of the tree,\r\nor if the node itself is the root of the tree. Nodes are _siblings_ if they share the same parent.\r\n```",
              "createdAt": "2022-01-27T19:14:18Z",
              "updatedAt": "2022-01-27T19:15:12Z"
            }
          ]
        }
      ]
    },
    {
      "number": 555,
      "id": "PR_kwDOBoyH6c4xohpv",
      "title": "Add clarifying note about _resolution_ in the most common case.",
      "url": "https://github.com/mlswg/mls-protocol/pull/555",
      "state": "MERGED",
      "author": "rohan-wire",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "In the most basic case, the resolution of a node is the node, so let's say that.",
      "createdAt": "2022-01-26T18:45:52Z",
      "updatedAt": "2022-01-28T03:44:28Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "870dfb60e7feae8c83350ceaa1ff7f5d2bf981a8",
      "headRepository": "rohan-wire/mls-protocol",
      "headRefName": "rohan/resolution-basic-case",
      "headRefOid": "f1d28c339ef23e093d5a9790d6a17ce15287a7a0",
      "closedAt": "2022-01-27T19:15:34Z",
      "mergedAt": "2022-01-27T19:15:34Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "7870335bf620e97ce076ba44463c177134ebe41b"
      },
      "comments": [
        {
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "body": "Fwiw this is stated immediately below your note:\r\n```\r\n* The resolution of a non-blank node comprises the node itself,\r\nfollowed by its list of unmerged leaves, if any\r\n```",
          "createdAt": "2022-01-27T02:09:29Z",
          "updatedAt": "2022-01-27T02:09:29Z"
        },
        {
          "author": "rohan-wire",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Bren2010 said:\r\n>Fwiw this is stated immediately below your note:\r\n\r\nYes. And it took me three readings to understand that the most complicated scenario was being described first and the most basic scenario is not explicitly stated. Most readers will not understand in what cases there will be unmerged leaves by this point.",
          "createdAt": "2022-01-27T13:37:47Z",
          "updatedAt": "2022-01-27T13:37:47Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOBoyH6c4zk7jg",
          "commit": {
            "abbreviatedOid": "f76c7cc"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-01-27T19:11:39Z",
          "updatedAt": "2022-01-27T19:11:39Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "```suggestion\r\nof a non-blank node with no unmerged leaves is just the node itself. More generally, the resolution\r\n```",
              "createdAt": "2022-01-27T19:11:39Z",
              "updatedAt": "2022-01-27T19:11:39Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c4zk7mo",
          "commit": {
            "abbreviatedOid": "f76c7cc"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Looks good with one minor edit.",
          "createdAt": "2022-01-27T19:11:51Z",
          "updatedAt": "2022-01-27T19:11:51Z",
          "comments": []
        }
      ]
    },
    {
      "number": 556,
      "id": "PR_kwDOBoyH6c4xrQnj",
      "title": "Fix some typos.",
      "url": "https://github.com/mlswg/mls-protocol/pull/556",
      "state": "MERGED",
      "author": "rohan-wire",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2022-01-27T13:30:02Z",
      "updatedAt": "2022-01-28T18:43:26Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "870dfb60e7feae8c83350ceaa1ff7f5d2bf981a8",
      "headRepository": "rohan-wire/mls-protocol",
      "headRefName": "rohan/nits",
      "headRefOid": "c91f0c815af9f82cbc9ab1ed43830c3ed9034479",
      "closedAt": "2022-01-27T19:10:22Z",
      "mergedAt": "2022-01-27T19:10:22Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "ecd2975c5700b7115726f737a9281bc9a2ebb35b"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOBoyH6c4zk7N2",
          "commit": {
            "abbreviatedOid": "c91f0c8"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-01-27T19:10:16Z",
          "updatedAt": "2022-01-27T19:10:16Z",
          "comments": []
        }
      ]
    },
    {
      "number": 560,
      "id": "PR_kwDOBoyH6c4xsytW",
      "title": "Exempt default features from RequiredCapabilities",
      "url": "https://github.com/mlswg/mls-protocol/pull/560",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #537 ",
      "createdAt": "2022-01-27T19:46:58Z",
      "updatedAt": "2022-01-27T22:26:35Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "2ba0a99931f896d24404ec33c6a5dbe388ad49c6",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "default-features",
      "headRefOid": "ca7b35ecfa6b482591f1d04d4564e282c145d1e4",
      "closedAt": "2022-01-27T22:26:35Z",
      "mergedAt": "2022-01-27T22:26:35Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "620e3f75e7bac22228014cef156bbecc56661ac3"
      },
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "cc @tomleavy \r\n",
          "createdAt": "2022-01-27T19:47:23Z",
          "updatedAt": "2022-01-27T19:47:23Z"
        },
        {
          "author": "tomleavy",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Looks good to me, thanks!",
          "createdAt": "2022-01-27T22:16:58Z",
          "updatedAt": "2022-01-27T22:16:58Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 561,
      "id": "PR_kwDOBoyH6c4xszha",
      "title": "Strip end of line whitespace",
      "url": "https://github.com/mlswg/mls-protocol/pull/561",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2022-01-27T19:51:51Z",
      "updatedAt": "2022-01-27T19:53:32Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "986f8909971ffe150db40f404257f2a602c2cbfc",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "eol-whitespace",
      "headRefOid": "732c2716ea3c1b50fac93c11d5eb5d067fde3eab",
      "closedAt": "2022-01-27T19:53:26Z",
      "mergedAt": "2022-01-27T19:53:26Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "2ba0a99931f896d24404ec33c6a5dbe388ad49c6"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 562,
      "id": "PR_kwDOBoyH6c4xsz-K",
      "title": "Forbid proposals by reference in external commits",
      "url": "https://github.com/mlswg/mls-protocol/pull/562",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #540 ",
      "createdAt": "2022-01-27T19:54:35Z",
      "updatedAt": "2022-01-28T18:38:48Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "2ba0a99931f896d24404ec33c6a5dbe388ad49c6",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "no-ref-in-ext-commit",
      "headRefOid": "317b89bae10893abbf0fced808ca32b3713f3d6c",
      "closedAt": "2022-01-28T18:38:48Z",
      "mergedAt": "2022-01-28T18:38:48Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "1f46884a9dbe4fa826e66f40ac64dde7bf3c591f"
      },
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "cc @kkohbrok ",
          "createdAt": "2022-01-27T19:54:58Z",
          "updatedAt": "2022-01-27T19:54:58Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 563,
      "id": "PR_kwDOBoyH6c4xs11p",
      "title": "Align cryptographic state description with figure",
      "url": "https://github.com/mlswg/mls-protocol/pull/563",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #557 ",
      "createdAt": "2022-01-27T20:05:44Z",
      "updatedAt": "2022-01-27T22:52:02Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "2ba0a99931f896d24404ec33c6a5dbe388ad49c6",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "ratchet-tree-secret-tree",
      "headRefOid": "369ed7bbf752bf1dc72ddc0cef303f86597828f9",
      "closedAt": "2022-01-27T22:52:02Z",
      "mergedAt": "2022-01-27T22:52:02Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "9ddcd5a33832a0f65084af0531dabb20067fcde1"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOBoyH6c4zltUE",
          "commit": {
            "abbreviatedOid": "369ed7b"
          },
          "author": "rohan-wire",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-01-27T22:50:50Z",
          "updatedAt": "2022-01-27T22:50:50Z",
          "comments": []
        }
      ]
    },
    {
      "number": 564,
      "id": "PR_kwDOBoyH6c4xtclJ",
      "title": "Define _key schedule_ and reference in Figure 1",
      "url": "https://github.com/mlswg/mls-protocol/pull/564",
      "state": "MERGED",
      "author": "rohan-wire",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Note that `## Secret Tree` is currently under `# Key Schedule`, so that should probably move or the top level section should be renamed. I ran out of imagination for today.",
      "createdAt": "2022-01-28T00:34:20Z",
      "updatedAt": "2022-01-28T18:44:25Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "9ddcd5a33832a0f65084af0531dabb20067fcde1",
      "headRepository": "rohan-wire/mls-protocol",
      "headRefName": "rohan/key-schedule-def",
      "headRefOid": "41bf6b856d13e13a95ef123f92df1f5c40c66aa2",
      "closedAt": "2022-01-28T18:37:55Z",
      "mergedAt": "2022-01-28T18:37:55Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "8500b89e024f6dcbdd29d5f150b6fb938ee918d6"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOBoyH6c4zpip_",
          "commit": {
            "abbreviatedOid": "41bf6b8"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-01-28T18:37:47Z",
          "updatedAt": "2022-01-28T18:37:47Z",
          "comments": []
        }
      ]
    },
    {
      "number": 565,
      "id": "PR_kwDOBoyH6c4xwK9I",
      "title": "Add some subsection divisions to the Commit section",
      "url": "https://github.com/mlswg/mls-protocol/pull/565",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "As suggested by @rohan-wire to improve the legibility of the document structure.",
      "createdAt": "2022-01-28T18:32:20Z",
      "updatedAt": "2022-01-28T18:42:04Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "1f46884a9dbe4fa826e66f40ac64dde7bf3c591f",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "reorg-add-commit-sections",
      "headRefOid": "8bd60fd0f8d71f790bc8f02fe4d7942316805c92",
      "closedAt": "2022-01-28T18:42:04Z",
      "mergedAt": "2022-01-28T18:42:04Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "83108dbfe7f0aa3daeea5e869413e02e2f662404"
      },
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Sounds good.  Queue it up for after the reorg :)",
          "createdAt": "2022-01-28T18:41:57Z",
          "updatedAt": "2022-01-28T18:41:57Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOBoyH6c4zpjTq",
          "commit": {
            "abbreviatedOid": "b286079"
          },
          "author": "rohan-wire",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "This is a good start. I may propose some additional refactoring of the text before ### Creating a Commit in another PR.",
          "createdAt": "2022-01-28T18:40:46Z",
          "updatedAt": "2022-01-28T18:40:46Z",
          "comments": []
        }
      ]
    },
    {
      "number": 566,
      "id": "PR_kwDOBoyH6c4xwPqz",
      "title": "Split ratchet tree into concepts and operations",
      "url": "https://github.com/mlswg/mls-protocol/pull/566",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Concepts go into the introduction, operations become their own top-level section.",
      "createdAt": "2022-01-28T18:55:38Z",
      "updatedAt": "2022-01-28T23:52:31Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "83108dbfe7f0aa3daeea5e869413e02e2f662404",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "reorg-ratchet-tree-split",
      "headRefOid": "4843ccb73f4759aae2eae91ad6c6855236c8614d",
      "closedAt": "2022-01-28T23:52:27Z",
      "mergedAt": "2022-01-28T23:52:27Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "4fa832bf5219e06a01ff673bfb9d5e28e9ef1e05"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOBoyH6c4zqAOP",
          "commit": {
            "abbreviatedOid": "8a99a73"
          },
          "author": "rohan-wire",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "## Ratchet Tree Concepts should be \r\n# Ratchet Tree Concepts\r\n\r\nto keep normative and non normative separate",
          "createdAt": "2022-01-28T19:50:51Z",
          "updatedAt": "2022-01-28T19:50:51Z",
          "comments": []
        }
      ]
    },
    {
      "number": 567,
      "id": "PR_kwDOBoyH6c4xwQrc",
      "title": "Reorg move crypto forward",
      "url": "https://github.com/mlswg/mls-protocol/pull/567",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Depends on #566 \r\n\r\nMoves the `Cryptographic Objects` and `Message Framing` sections ahead of `Ratchet Tree Operations`, to reduce forward references and have ratchet tree / key schedule / secret tree sections together.\r\n\r\n<img width=\"495\" alt=\"image\" src=\"https://user-images.githubusercontent.com/75597/151605925-af25de8b-9361-4409-bd40-c9dafccc8038.png\">\r\n",
      "createdAt": "2022-01-28T19:01:45Z",
      "updatedAt": "2022-01-31T22:04:42Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "4fa832bf5219e06a01ff673bfb9d5e28e9ef1e05",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "reorg-move-crypto-forward",
      "headRefOid": "355717e6787dcc5e0bec0a0c9b92bca4d75f5f25",
      "closedAt": "2022-01-31T22:03:50Z",
      "mergedAt": "2022-01-31T22:03:50Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "8efbc7f8af47028978829b29132755b7e144484c"
      },
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "If you look at this with `git diff main --diff-algorithm=minimal`, it shows the session move more clearly.",
          "createdAt": "2022-01-31T21:23:43Z",
          "updatedAt": "2022-01-31T21:23:43Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOBoyH6c4zw9GY",
          "commit": {
            "abbreviatedOid": "355717e"
          },
          "author": "rohan-wire",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-01-31T22:04:42Z",
          "updatedAt": "2022-01-31T22:04:42Z",
          "comments": []
        }
      ]
    },
    {
      "number": 568,
      "id": "PR_kwDOBoyH6c4xwUxd",
      "title": "Consolidate ratchet-tree-related sections",
      "url": "https://github.com/mlswg/mls-protocol/pull/568",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Depends on #567 \r\n\r\nSome subsections of `Key Packages` are more natural within the ratchet tree operations section.  This PR pulls them up into the `Ratchet Tree Operations` section.\r\n\r\n<img width=\"495\" alt=\"image\" src=\"https://user-images.githubusercontent.com/75597/151607463-8ffdd738-1034-4c80-b137-c64492e6e001.png\">\r\n",
      "createdAt": "2022-01-28T19:27:56Z",
      "updatedAt": "2022-02-01T02:16:55Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "8efbc7f8af47028978829b29132755b7e144484c",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "reorg-ratchet-tree-together",
      "headRefOid": "b07503101c5bafd51652adb1b79d7d197ab2fd10",
      "closedAt": "2022-02-01T02:16:55Z",
      "mergedAt": "2022-02-01T02:16:55Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "1616f4172550aaaf8a65a6aaad059c269462b7ac"
      },
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Again, this diff looks better with `git diff main --diff-algorithm=minimal`\r\n",
          "createdAt": "2022-01-31T22:08:47Z",
          "updatedAt": "2022-01-31T22:08:47Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOBoyH6c4zxe7-",
          "commit": {
            "abbreviatedOid": "b075031"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-02-01T01:49:56Z",
          "updatedAt": "2022-02-01T01:49:56Z",
          "comments": []
        }
      ]
    },
    {
      "number": 569,
      "id": "PR_kwDOBoyH6c4x3eB_",
      "title": "Move Key Packages section down",
      "url": "https://github.com/mlswg/mls-protocol/pull/569",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Depends on #568 \r\n\r\nThis swaps the \"Key Packages\" and \"Key Schedule\" sections, so that the former is just before \"Group Creation\".\r\n\r\n<img width=\"472\" alt=\"image\" src=\"https://user-images.githubusercontent.com/75597/151881864-641618af-7c5a-493e-b174-1fe8d1185848.png\">\r\n",
      "createdAt": "2022-01-31T22:14:07Z",
      "updatedAt": "2022-02-01T02:20:58Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "1616f4172550aaaf8a65a6aaad059c269462b7ac",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "reorg-move-kp-down",
      "headRefOid": "5aa26e4b0876ade14cd11c6f1ac3f119582219d5",
      "closedAt": "2022-02-01T02:20:58Z",
      "mergedAt": "2022-02-01T02:20:58Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "34a6ac78b764208f994c20f4d9a709a9692e3c5e"
      },
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Best reviewed with `git diff  reorg-ratchet-tree-together --diff-algorithm=minimal`, which will show the diff against #568 ",
          "createdAt": "2022-01-31T22:14:27Z",
          "updatedAt": "2022-01-31T22:16:07Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOBoyH6c4zxfJ_",
          "commit": {
            "abbreviatedOid": "97414ef"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-02-01T01:52:19Z",
          "updatedAt": "2022-02-01T01:52:19Z",
          "comments": []
        }
      ]
    },
    {
      "number": 570,
      "id": "PR_kwDOBoyH6c4x3fTi",
      "title": "Split out Secret Tree",
      "url": "https://github.com/mlswg/mls-protocol/pull/570",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Depends on #569 \r\n\r\nAs described in the protocol overview, the Secret Tree can be understood apart from the key schedule; the key schedule just provides the `encryption_secret` to become the root of the tree.  This PR pulls out the secret-tree-related subsections of the key schedule section into their own top-level section.\r\n\r\nBest reviewed with `git diff reorg-move-kp-down --diff-algorithm=minimal` to show the diff against #569 \r\n\r\n<img width=\"472\" alt=\"image\" src=\"https://user-images.githubusercontent.com/75597/151882712-66b6ba56-7688-4b47-9516-a19affe15336.png\">\r\n",
      "createdAt": "2022-01-31T22:20:55Z",
      "updatedAt": "2022-02-01T02:23:18Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "34a6ac78b764208f994c20f4d9a709a9692e3c5e",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "reorg-split-out-secret-tree",
      "headRefOid": "f7c12f74d6a376ff28ae465768f0b8e218ab8388",
      "closedAt": "2022-02-01T02:23:18Z",
      "mergedAt": "2022-02-01T02:23:18Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "dab97f24b30cf395919e64d8c86beda1756f5b48"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOBoyH6c4zxfRK",
          "commit": {
            "abbreviatedOid": "72168c2"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-02-01T01:53:26Z",
          "updatedAt": "2022-02-01T01:53:26Z",
          "comments": []
        }
      ]
    },
    {
      "number": 571,
      "id": "PR_kwDOBoyH6c4x3gXe",
      "title": "Move up group state",
      "url": "https://github.com/mlswg/mls-protocol/pull/571",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Depends on #570 \r\n\r\nThis PR moves the \"Group State\" subsection up into the \"Key Schedule\" section, where it fits more naturally.\r\n\r\n<img width=\"482\" alt=\"image\" src=\"https://user-images.githubusercontent.com/75597/151883518-7f8b52c1-51d8-4b67-9252-c85ef92c09cc.png\">\r\n",
      "createdAt": "2022-01-31T22:27:21Z",
      "updatedAt": "2022-02-01T02:26:07Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "dab97f24b30cf395919e64d8c86beda1756f5b48",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "reorg-move-up-group-state",
      "headRefOid": "eb45ddc1d5bc5cbfc1e63e7789c52a02dc94da23",
      "closedAt": "2022-02-01T02:26:07Z",
      "mergedAt": "2022-02-01T02:26:07Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "e7e132080d81149639cc64642f4e16beef58786a"
      },
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "`git diff reorg-split-out-secret-tree --diff-algorithm=minimal`",
          "createdAt": "2022-01-31T22:27:56Z",
          "updatedAt": "2022-01-31T22:27:56Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOBoyH6c4zxfet",
          "commit": {
            "abbreviatedOid": "06e1de2"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-02-01T01:55:38Z",
          "updatedAt": "2022-02-01T01:55:38Z",
          "comments": []
        }
      ]
    },
    {
      "number": 572,
      "id": "PR_kwDOBoyH6c4x4Do9",
      "title": "Split the Group State section into Group Context and Transcript Hashes",
      "url": "https://github.com/mlswg/mls-protocol/pull/572",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This is the last of the reorg PRs.  Does what it says in the title.\r\n\r\n<img width=\"482\" alt=\"image\" src=\"https://user-images.githubusercontent.com/75597/151904958-f1b7530e-2ef0-4ed0-93dd-b9e9db6bfcfc.png\">\r\n",
      "createdAt": "2022-02-01T02:32:32Z",
      "updatedAt": "2022-02-03T15:08:05Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "e7e132080d81149639cc64642f4e16beef58786a",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "reorg-split-group-state",
      "headRefOid": "91c2d322322c19289991f9dafb43e9966cf56532",
      "closedAt": "2022-02-03T15:08:05Z",
      "mergedAt": "2022-02-03T15:08:05Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "9ec5be0cda8a6eb6d387f564fee984ddb699d9b1"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOBoyH6c4z-OMp",
          "commit": {
            "abbreviatedOid": "91c2d32"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-03T14:48:56Z",
          "updatedAt": "2022-02-03T14:48:57Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "```suggestion\r\n* The `confirmed_transcript_hash` is updated according to the rules in the following section.\r\n\r\n## Transcript Hashes\r\n```",
              "createdAt": "2022-02-03T14:48:56Z",
              "updatedAt": "2022-02-03T14:48:57Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c4z-O_r",
          "commit": {
            "abbreviatedOid": "91c2d32"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-03T14:51:08Z",
          "updatedAt": "2022-02-03T14:51:09Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "This is already covered above:\r\n\r\n> * The `confirmed_transcript_hash` field is updated with the data for an\r\n>   MLSPlaintext message encoding a Commit message as described below.",
              "createdAt": "2022-02-03T14:51:08Z",
              "updatedAt": "2022-02-03T14:51:09Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c4z-Q7x",
          "commit": {
            "abbreviatedOid": "91c2d32"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-02-03T14:56:18Z",
          "updatedAt": "2022-02-03T14:56:18Z",
          "comments": []
        }
      ]
    },
    {
      "number": 573,
      "id": "PR_kwDOBoyH6c4x6YFP",
      "title": "Remove endpoint_id",
      "url": "https://github.com/mlswg/mls-protocol/pull/573",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #558\r\n\r\nThis involved a couple of changes other than just removing the field and references to it:\r\n\r\n* Detecting duplicative Adds is now a little more ambiguous, since you can't just match on `endpoint_id`.  However (a) this doesn't degrade the security of the protocol, just makes it a little less efficient (b) as discussed in #558, if applications want to sharpen it, they can add an `endpoint_id`-like identifier in an extension.\r\n* The External Commit language around resync got generalized to say that the KeyPackage needs to meet the requirements of an Update for the removed node, which captures the successor notions we've discussed.\r\n\r\nI also noticed that when we forbade proposals by reference in #562, we didn't totally remove them.  So I went ahead and fixed that here.",
      "createdAt": "2022-02-01T15:46:15Z",
      "updatedAt": "2022-02-03T15:23:38Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "e7e132080d81149639cc64642f4e16beef58786a",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "remove-endpoint-id",
      "headRefOid": "eb8396a5b47c72260c024750da6d50dd1c926f04",
      "closedAt": "2022-02-03T15:23:37Z",
      "mergedAt": "2022-02-03T15:23:37Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "b40a1a65d0c491a5e456464c6cfc345d459b8db7"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOBoyH6c4z0QlS",
          "commit": {
            "abbreviatedOid": "eb8396a"
          },
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Thanks for taking care of the cleanup here after the discussion on #509.\r\n\r\nIf the application has to provide a function that determines if a given KeyPackage represents a valid update, we could use the same function to determine if an Add is a duplicate. Although admittedly, in that case one would have to compare with all other KeyPackages in the group and the function might not be very efficient.\r\n\r\nGenerally, I'm ok with this solution, though \ud83d\udc4d\ud83c\udffb.",
          "createdAt": "2022-02-01T15:55:46Z",
          "updatedAt": "2022-02-01T15:55:46Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOBoyH6c4z-PTD",
          "commit": {
            "abbreviatedOid": "eb8396a"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-02-03T14:51:57Z",
          "updatedAt": "2022-02-03T14:51:57Z",
          "comments": []
        }
      ]
    },
    {
      "number": 575,
      "id": "PR_kwDOBoyH6c4x_q2y",
      "title": "Split LeafNode from KeyPackage",
      "url": "https://github.com/mlswg/mls-protocol/pull/575",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Depends on  #573 \r\n\r\nFixes #539 \r\n\r\nThis PR implements the suggestion from @TWal in #539, taking into account the discussion on the issue and on the call last week.  There are a bunch of small changes (e.g., changing a lot of `KeyPackageRef` to `LeafNodeRef`), but the critical change is the following split of KeyPackage into LeafNode and KeyPackage:\r\n\r\n```\r\nstruct {\r\n    opaque group_id<0..255>;\r\n    opaque parent_hash<0..255>;\r\n} MembershipInfo;\r\n\r\nstruct {\r\n    HPKEPublicKey public_key;\r\n    Credential credential;\r\n    Capabilities capabilities;\r\n    optional<MembershipInfo> membership;\r\n    Extension extensions<8..2^32-1>;\r\n    // SignWithLabel(., \"LeafNodeTBS\", LeafNodeTBS)\r\n    opaque signature<0..2^16-1>;\r\n} LeafNode;\r\n\r\nstruct {\r\n    ProtocolVersion version;\r\n    CipherSuite cipher_suite;\r\n    HPKEPublicKey init_key;\r\n    Lifetime lifetime;\r\n    LeafNode leaf_node;\r\n    Extension extensions<8..2^32-1>;\r\n    // SignWithLabel(., \"KeyPackageTBS\", KeyPackageTBS)\r\n    opaque signature<0..2^16-1>;\r\n} KeyPackage;\r\n```\r\n\r\nThis does a few things we had discussed:\r\n\r\n* KeyPackage is the thing you pre-publish; LeafNode is what goes in the tree\r\n* Sign the LeafNode and the KeyPackage separately, nesting the LeafNode inside the signed KeyPackage information\r\n* Sign the `group_id` when possible.  (This PR takes the chattiest approach, replicating the `group_id` in each leaf.)\r\n* Promote mandatory extensions to fields\r\n\r\nAdd continues to refer to KeyPackage.  Update and Commit use LeafNode directly.\r\n\r\nI did a walk through the document grepping for KeyPackage, and I think I found all the instances that needed to be changed.  But some review to make sure I didn't miss anything would be appreciated.",
      "createdAt": "2022-02-02T22:59:46Z",
      "updatedAt": "2022-02-13T15:49:32Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "24a79aa83757fe43bca33131791ec4894c6ca318",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "split-leaf-kp",
      "headRefOid": "e3daff0b5b8ea74d359f579eee805dc6b475ca32",
      "closedAt": "2022-02-13T15:49:31Z",
      "mergedAt": "2022-02-13T15:49:31Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "a281ec78289057a674756738d2e9b11c5d98666f"
      },
      "comments": [
        {
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I haven't done a full review yet, but one thing to note is that if a member commits an Update proposal by another member, there should be a `group_id`, but there can't be a `parent_hash`. One way to tackle that issue would be to remove the notion of an update proposal entirely such that key material can only be updated via commit. I have no data to back it up, of course, but I doubt that there are going to be many cases where clients will issue update proposals without actually committing them themselves.",
          "createdAt": "2022-02-03T08:02:05Z",
          "updatedAt": "2022-02-03T08:04:10Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "@kkohbrok I think this is already taken into account:\r\n\r\n> * A LeafNode sent in an Update proposal MUST have this field set.  The\r\n>  `group_id` MUST match the value set for the overall group, and the\r\n>  `parent_hash` field MUST be empty.\r\n\r\nMaybe it would be clearer to say `parent_hash` MUST be the zero-length octet string.  Or make `group_id` and `parent_hash` two independent optionals (this is a bit messy with the TLS syntax, but doable).  I kind of liked the MembershipInfo approach because it gave you a clean signal of whether the LeafNode was a prepublished one or not.",
          "createdAt": "2022-02-03T13:49:55Z",
          "updatedAt": "2022-02-03T13:49:55Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "After the virtual interim today, I did a little thinking on how to structure these objects to take into account @TWal's point about having the signature be lifetime-constrained in the prepublished case.  I think we all agree on which fields should appear in which cases:\r\n\r\n| Item                            | KeyPackage    | Pre-pub LeafNode | Update LeafNode  | Commit LeafNode |\r\n|:--------------------------------|:-------------:|:----------------:|:----------------:|:---------------:|\r\n| `version`                       | X             |                  |                  |                 | \r\n| `cipher_suite`                  | X             |                  |                  |                 | \r\n| `init_key` (for Welcome)        | X             |                  |                  |                 | \r\n| `lifetime`                      | X             | X                |                  |                 | \r\n| `public_key` (for TreeKEM)      |               | X                | X                | X               | \r\n| `credential`                    | X             | X                | X                | X               | \r\n| `capabilities`                  | X             | X                | X                | X               | \r\n| `group_id`                      |               |                  | X                | X               | \r\n| `parent_hash`                   |               |                  |                  | X               | \r\n| `extensions`                    | X             | X                | X                | X               |\r\n\r\n(Where the Credential/Capabilities in KeyPackage might be indirect, via containing a pre-pub LeafNode.) So it's mainly a question of how we lay this out syntactically.  A couple of options follow. I have not split the Update and Commit cases; they would differ only in whether the `parent_hash` field has a value.\r\n\r\n## Option 1: Variant field within leaf node\r\n\r\n```\r\nstruct {\r\n    HPKEPublicKey public_key;\r\n    Credential credential;\r\n    Capabilities capabilities;\r\n\r\n    LeafNodeSource leaf_node_source;\r\n    select (leaf_node_source) {\r\n        case pre_published: \r\n            Lifetime lifetime;\r\n        \r\n        case member:\r\n            opaque parent_hash<0..255>;   // zero-length octet string if update\r\n    }\r\n    \r\n    // SignWithLabel(., \"LeafNodeTBS\", LeafNodeTBS)\r\n    opaque signature<0..2^16-1>;\r\n} LeafNode;\r\n\r\n// LeafNodeTBS adds group_id in the `leaf_node_source = member` case\r\n// KeyPackage wraps LeafNode as in current PR\r\n```\r\n\r\n## Option 2: Two types of leaf node\r\n\r\n```\r\nstruct {\r\n    ProtocolVersion version;\r\n    CipherSuite cipher_suite;\r\n    HPKEPublicKey init_key;\r\n    Lifetime lifetime;\r\n\r\n    HPKEPublicKey public_key;\r\n    Credential credential;\r\n    Capabilities capabilities;\r\n\r\n    Extension extensions<8..2^32-1>;\r\n    // SignWithLabel(., \"KeyPackageTBS\", KeyPackageTBS)\r\n    opaque signature<0..2^16-1>;\r\n} KeyPackage;\r\n\r\nstruct {\r\n    HPKEPublicKey public_key;\r\n    Credential credential;\r\n    Capabilities capabilities;\r\n\r\n    opaque parent_hash<0..255>;\r\n    \r\n    Extension extensions<8..2^32-1>;\r\n    // SignWithLabel(., \"LeafNodeContentTBS\", LeafNodeContentTBS)\r\n    opaque signature<0..2^16-1>;\r\n} LeafNodeContent;\r\n\r\n// KeyPackageTBS just has fields above signature\r\n// LeafNodeContentTBS adds group_id\r\n\r\nstruct {\r\n    LeafNodeSource leaf_node_source;\r\n    select (leaf_node_type) {\r\n        case pre_published:\r\n            KeyPackage key_package;\r\n\r\n        case member:\r\n            LeafNodeContent leaf_node_content;\r\n    }\r\n} LeafNode;\r\n```\r\n\r\n## Opinion below this line\r\n\r\nPersonally, I feel pretty strongly that Option 1 will be easier to work with.  Option 2 basically means that there are three types of tree node, and two different algorithms for verifying leaf signatures. (!)  That seems like a bigger distinction than is merited here, given that the two types of leaf have mostly the same content.\r\n\r\nHaving selects here is helpful, though.  (Once again `select > optional`!)  In addition to avoiding the chattiness of replicating the `group_id` everywhere (since now there's a clear signal of when to inject the `group_id` as context), it provides a simple way to check that a LeafNode has the right contents for a given context in the protocol.\r\n\r\nIn either case, we will need to be clear about how the `lifetime` field should be interpreted in a pre-published LeafNode.  I got the impression from the call today that there was agreement that the limitation here was purely advisory, i.e., that we would **not** require that a client reject as invalid a leaf with an expired `lifetime`.  I'm OK with that, but it does seem like it reduces the utility of including the lifetime in the leaf node.\r\n\r\n",
          "createdAt": "2022-02-03T20:47:57Z",
          "updatedAt": "2022-02-03T20:47:57Z"
        },
        {
          "author": "TWal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think I also prefer the first option!\r\nThis refactor looks great, it makes things about leaf content a lot more clear. I also like the new consistency between the names `LeafNode` and `ParentNode`.\r\n\r\nI think we should advise to reject expired LeafNode when adding them to the tree (and also check that they have the same lifetime as the corresponding KeyPackage?)\r\nHowever when joining a group, we should not reject a tree containing expired leaf nodes (as they might have been added when they were not expired)",
          "createdAt": "2022-02-07T21:16:01Z",
          "updatedAt": "2022-02-07T21:16:01Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "@TWal  - Thanks for the feedback.\r\n\r\nWith regard to when expired LeafNodes should be rejected -- With the scheme you propose, why does the Lifetime need to be in the LeafNode instead of the KeyPackage?  Since the KeyPackage is in the Add, having the lifetime there would still allow it to be validated at add time.  And if you're not going to do anything with the lifetime after add time, why do you need it to still be in the tree?",
          "createdAt": "2022-02-07T21:32:56Z",
          "updatedAt": "2022-02-07T21:32:56Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "The latest commit updates the PR to match Option 1.  It still seems awkward to have the Lifetime in the LeafNode.",
          "createdAt": "2022-02-07T21:44:58Z",
          "updatedAt": "2022-02-07T21:44:58Z"
        },
        {
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think I also prefer the first option.\r\n\r\nOn lifetimes: Lifetimes are the only thing that allow us to get some degree of PCS for pre-published key material. If Alice is compromised and Bob won't check lifetimes if he is invited into a group that includes Alice, then the adversary can impersonate Alice towards Bob indefinitely after compromise: He creates a group using Alice's KeyPackage and invites Bob.\r\n\r\nOf course there are a few caveats to this attack:\r\n- the credential could have its own lifetime\r\n- a higher-level signature key could have been rotated in the meantime, leading to Bob's check with the AS to fail\r\n- the credential could be revoked (with a mandatory stapling scheme that implements a lifetime)\r\n- depending on how the application handles \"duplicated\" groups, this might or might not work if Bob already has a 1-to-1 group with Alice\r\n  - although the adversary could just include another party in the group, weakening the attack slightly",
          "createdAt": "2022-02-08T08:01:34Z",
          "updatedAt": "2022-02-08T08:01:34Z"
        },
        {
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "body": "Given the two options, I also prefer option 1. That being said, it still bothers me that we now have two signatures instead of one, which doubles the creation time for large groups.",
          "createdAt": "2022-02-08T20:15:58Z",
          "updatedAt": "2022-02-08T20:15:58Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "@raphaelrobert note that Option 2 does avoid double signature.  But in my experience, the slow thing about MLS in large groups is not so much the cryptography (signature or otherwise), but the moving around of the large tree.",
          "createdAt": "2022-02-08T20:17:56Z",
          "updatedAt": "2022-02-08T20:17:56Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "@kkohbrok  - To refine your analysis a bit -- the interesting case here is when the Alice's *HPKE* private key is compromised, but not her signature key.  If her signature key is compromised, then all bets are off; the attacker can impersonate Alice in any way, until the AS invalidates the signature key (e.g., via credential expiry/revocation).\r\n\r\nIf we take on that constraint, then your attack actually doesn't work.  The attacker can't create sign a GroupInfo message that Bob will accept.\r\n\r\nThe best the attacker could do is create a group with the attacker, Alice, and Bob, such that if Bob removes the attacker, the attacker still has access to the group via knowledge of Alice's HPKE private key (since Bob's UpdatePath will TreeKEM-encrypt to Alice's compromised HPKE key).  And here the attacker is pretty limited, since they can't send any MLSPlaintext/MLSCiphertext signatures.\r\n\r\nBut at that point, it seems like you're in the same posture for pre-published keys as for keys in the group.  Any leaf signed by Alice can be used in that attack in the same way.\r\n\r\nSo it seems like the answer for PCS in any case is \"Update/Commit\"?",
          "createdAt": "2022-02-08T20:35:33Z",
          "updatedAt": "2022-02-08T20:36:02Z"
        },
        {
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@bifurcation you're right, the attack doesn't quite work the way I thought it would. \r\n\r\nIt all depends a bit on what the AS does.\r\n- If the app naively checks the signature based on the key package (credential) provided in the Welcome, the attack has a chance. Although I admit that's quite an oversight on part of the AS/app, the lifetime would be useful here and add some robustness.\r\n- Similarly, if the app uses per-group credentials that don't expire, the attack still works. If we had lifetimes, the client could recover by updating all groups and cycling the key packages that were uploaded to the server. This is again assuming the AS doesn't invalidate credentials after a while.\r\n\r\nGood point also about the adversary being able to just pluck key packages from any given group at the time of compromise. Those would have to be fitted with lifetimes as well to make this work.\r\n\r\nI still like lifetimes as a conservative, defense-in-depth approach in case the AS is very minimal or just not very good. I think as a general rule, it's good to attach an expiration date to key material that is not single-use.\r\n\r\nThat being said, I understand that due to the asynchronicity in many use-cases it's going to be hard to enforce in a meaningful way that doesn't impede usability too much.",
          "createdAt": "2022-02-09T08:04:50Z",
          "updatedAt": "2022-02-09T08:04:50Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Discussion at virtual interim:\r\n\r\n* @raphaelrobert points out that a Commit+Add might be processed some time after it is created, so the lifetime might have expired\r\n* @Bren2010 notes that a lifetime in the leaf node at least provides a signal as to how old the leaf is (`notBefore` being more useful than `notAfter` here, since it roughly corresponds to creation time)\r\n* TODO(@bifurcation): Implement the following, then merge:\r\n    * Leave lifetime in LeafNode\r\n    * MUST verify lifetime when creating an Add from a prepublished KP\r\n    * SHOULD verify lifetime when receive an Add (modulo time skew between send and receive)\r\n    * SHOULD NOT enforice lifetime when receiving a tree\r\n* It's also possible to put a \"last updated epoch\" in the leaf alongside the group ID, useful?\r\n    * Doesn't obviously correspond to time, use cases not obvious\r\n    * No action for now",
          "createdAt": "2022-02-10T15:38:47Z",
          "updatedAt": "2022-02-10T15:38:47Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 579,
      "id": "PR_kwDOBoyH6c4yMy2t",
      "title": "Enforce uniqueness of PreSharedKeyIDs in PreSharedKey proposals",
      "url": "https://github.com/mlswg/mls-protocol/pull/579",
      "state": "MERGED",
      "author": "tomleavy",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "As discussed in #578 , PreSharedKeyIDs shouldn't be repeated in the same commit",
      "createdAt": "2022-02-07T22:12:30Z",
      "updatedAt": "2022-02-10T15:11:25Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "b40a1a65d0c491a5e456464c6cfc345d459b8db7",
      "headRepository": "tomleavy/mls-protocol",
      "headRefName": "unique-psk",
      "headRefOid": "5597985ca1b3d61ca66d3f7c08138a6c90df90c8",
      "closedAt": "2022-02-10T15:11:25Z",
      "mergedAt": "2022-02-10T15:11:25Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "838f0e15951b49af438bad501f3bd787798c2f4d"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOBoyH6c40YxOi",
          "commit": {
            "abbreviatedOid": "e6dd45e"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-02-10T14:20:48Z",
          "updatedAt": "2022-02-10T14:20:48Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOBoyH6c40Y9b5",
          "commit": {
            "abbreviatedOid": "e6dd45e"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-10T14:53:52Z",
          "updatedAt": "2022-02-10T14:55:09Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "```suggestion\r\nPreSharedKey proposals that reference the same PreSharedKeyID, the committer\r\n```",
              "createdAt": "2022-02-10T14:53:52Z",
              "updatedAt": "2022-02-10T14:55:09Z"
            }
          ]
        }
      ]
    },
    {
      "number": 580,
      "id": "PR_kwDOBoyH6c4yM0w-",
      "title": "Move definition of blank node earlier into ## Ratchet Tree Terminology",
      "url": "https://github.com/mlswg/mls-protocol/pull/580",
      "state": "MERGED",
      "author": "rohan-wire",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "The definition of blank node needs to move ahead into ## Ratchet Tree Terminology as it is used in the section immediately following (## Views of a Ratchet Tree).",
      "createdAt": "2022-02-07T22:22:45Z",
      "updatedAt": "2022-02-10T15:19:31Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "b40a1a65d0c491a5e456464c6cfc345d459b8db7",
      "headRepository": "rohan-wire/mls-protocol",
      "headRefName": "rohan/blank-nodes",
      "headRefOid": "0a1e30656a2efe8fa08eef4c9f3d1b755350b724",
      "closedAt": "2022-02-10T14:14:19Z",
      "mergedAt": "2022-02-10T14:14:18Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "87e8ce4c981609dd399bb7a7354e7fd24b8677fd"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOBoyH6c40Yu_v",
          "commit": {
            "abbreviatedOid": "0a1e306"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-02-10T14:14:14Z",
          "updatedAt": "2022-02-10T14:14:14Z",
          "comments": []
        }
      ]
    },
    {
      "number": 581,
      "id": "PR_kwDOBoyH6c4yM4xm",
      "title": "Add message/mls MIME type registration",
      "url": "https://github.com/mlswg/mls-protocol/pull/581",
      "state": "MERGED",
      "author": "rohan-wire",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "This is a minimal section for MIME type registration of message/mls. \r\n\r\nIt assumes that PR #523 include wire_format in all MLS messages (making a format parameter unnecessary),\r\nand that all messages have the MLS version number encoded (making a version parameter unnecessary).\r\n\r\nThese parameters can be added if needed.",
      "createdAt": "2022-02-07T22:47:35Z",
      "updatedAt": "2022-02-24T05:02:33Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "b40a1a65d0c491a5e456464c6cfc345d459b8db7",
      "headRepository": "rohan-wire/mls-protocol",
      "headRefName": "rohan/mime-type",
      "headRefOid": "72233f8e35484a115df6fa146ca6ba2f3e4b0dc9",
      "closedAt": "2022-02-13T14:24:41Z",
      "mergedAt": "2022-02-13T14:24:41Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "3e75c7d620902342663e2c723549a791dbad3c40"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOBoyH6c40YwQZ",
          "commit": {
            "abbreviatedOid": "d15cbbc"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2022-02-10T14:18:01Z",
          "updatedAt": "2022-02-10T14:19:45Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "```suggestion\r\n# Security Considerations\r\n```\r\n\r\nYou don't need the explicit tag, you can just use `{{security-considerations}}`.  But you don't refer to that section in this PR.",
              "createdAt": "2022-02-10T14:18:01Z",
              "updatedAt": "2022-02-10T14:19:45Z"
            },
            {
              "originalPosition": 25,
              "body": "As we discussed on the last virtual interim, there are a few options here.  I might prefer just adding a version field to the front of MLSMessage, so that `message/mls` could remain unadorned.",
              "createdAt": "2022-02-10T14:19:27Z",
              "updatedAt": "2022-02-10T14:19:45Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c40ZDnT",
          "commit": {
            "abbreviatedOid": "d15cbbc"
          },
          "author": "rohan-wire",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-10T15:09:48Z",
          "updatedAt": "2022-02-10T15:09:48Z",
          "comments": [
            {
              "originalPosition": 25,
              "body": "This is just an escape-hatch mechanism that allows us to specify the version if it in NOT 1.0. ",
              "createdAt": "2022-02-10T15:09:48Z",
              "updatedAt": "2022-02-10T15:09:48Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c40bBo5",
          "commit": {
            "abbreviatedOid": "72233f8"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-02-10T21:27:01Z",
          "updatedAt": "2022-02-10T21:27:01Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOBoyH6c40ZHuH",
          "commit": {
            "abbreviatedOid": "72233f8"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-02-10T15:20:42Z",
          "updatedAt": "2022-02-13T14:24:36Z",
          "comments": [
            {
              "originalPosition": 25,
              "body": "Discussion at virtual interim:\r\n\r\n* There are cases where you want to talk about version without having a message (e.g., HTTP Accept)\r\n* Risk of conflict if you have a version in MIME type and in the protocol\r\n* Punt conflict resolution to the application?\r\n* Maybe clarify here?  \"The version expressed in the MLS message overrides\"\r\n* TODO(Rohan): Add a sentence to clarify",
              "createdAt": "2022-02-10T15:20:42Z",
              "updatedAt": "2022-02-13T14:24:36Z"
            }
          ]
        }
      ]
    },
    {
      "number": 582,
      "id": "PR_kwDOBoyH6c4yM6v0",
      "title": "Figure 1 is more accurate showing init_secret as start and end secrets.",
      "url": "https://github.com/mlswg/mls-protocol/pull/582",
      "state": "CLOSED",
      "author": "rohan-wire",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "change Figure 1 to be more accurate:\r\n\r\nbefore: epoch_secret -> epoch_secret -> epoch_secret\r\n\r\nafter: init_secret -> epoch_secret -> init_secret",
      "createdAt": "2022-02-07T23:02:42Z",
      "updatedAt": "2022-02-10T15:19:18Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "b40a1a65d0c491a5e456464c6cfc345d459b8db7",
      "headRepository": "rohan-wire/mls-protocol",
      "headRefName": "rohan/init_secret_drawing",
      "headRefOid": "29874110e593ac0ded53209944b466c15751cb13",
      "closedAt": "2022-02-10T15:14:45Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "I actually disagree with this.  This figure needs to show one epoch secret chaining to the next.  If you're going to show the init secret, you still need to show the epoch secret.  But that gets too cluttered.  So even though it's true that the init secret is in the middle, the underlying message here is that one epoch secret feeds into the next, and the intervening derivations can be elided.",
          "createdAt": "2022-02-10T14:13:08Z",
          "updatedAt": "2022-02-10T14:13:08Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Discussed on virtual interim: epoch->epoch better for newcomers.",
          "createdAt": "2022-02-10T15:14:45Z",
          "updatedAt": "2022-02-10T15:14:45Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 583,
      "id": "PR_kwDOBoyH6c4yNIxk",
      "title": "Fix tables in IANA section",
      "url": "https://github.com/mlswg/mls-protocol/pull/583",
      "state": "MERGED",
      "author": "rohan-wire",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Fix ciphersuite table so the .txt version can fit in 73 chars.\r\n\r\nUse the correct separator (-) between table header and the table body for some tables. Some where using the footer separator (=).",
      "createdAt": "2022-02-08T00:45:20Z",
      "updatedAt": "2022-02-10T15:19:32Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "b40a1a65d0c491a5e456464c6cfc345d459b8db7",
      "headRepository": "rohan-wire/mls-protocol",
      "headRefName": "rohan/fix-long-tables",
      "headRefOid": "2040bcc6706dbe6f0f28846b159599ec2fd67b03",
      "closedAt": "2022-02-10T14:13:41Z",
      "mergedAt": "2022-02-10T14:13:41Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "878c54877541112ce69b9a3e5b27df98f696c28a"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOBoyH6c40Yux7",
          "commit": {
            "abbreviatedOid": "2040bcc"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-02-10T14:13:36Z",
          "updatedAt": "2022-02-10T14:13:36Z",
          "comments": []
        }
      ]
    },
    {
      "number": 584,
      "id": "PR_kwDOBoyH6c4yNsTH",
      "title": "Move validation of identity change to the AS",
      "url": "https://github.com/mlswg/mls-protocol/pull/584",
      "state": "MERGED",
      "author": "kkohbrok",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "This PR moves the remark that there has to be validation of the attested identities upon a credential update to the KeyPackage validation subsection. It also changes the responsibility for the check to be that of the AS rather than that of the application. Note, that the boundaries are somewhat arbitrary at this point, since the application running on the local device may well implement parts of the AS. The reason for this change is to ensure any validation checks that pertain to authentication are part of the AS.",
      "createdAt": "2022-02-08T06:11:49Z",
      "updatedAt": "2022-02-13T14:25:28Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "b40a1a65d0c491a5e456464c6cfc345d459b8db7",
      "headRepository": "kkohbrok/mls-protocol",
      "headRefName": "as_credential_succession_validation",
      "headRefOid": "5003623a5dac2e296fe7689705061d0b279624b4",
      "closedAt": "2022-02-13T14:25:28Z",
      "mergedAt": "2022-02-13T14:25:28Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "24a79aa83757fe43bca33131791ec4894c6ca318"
      },
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "@kkohbrok Please make any required changes to the architecture document as well.  Since I think that's where the AS is defined.",
          "createdAt": "2022-02-10T14:16:42Z",
          "updatedAt": "2022-02-10T14:16:42Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOBoyH6c40Yvna",
          "commit": {
            "abbreviatedOid": "36b52bc"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-02-10T14:16:04Z",
          "updatedAt": "2022-02-10T14:16:04Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOBoyH6c40ZIxm",
          "commit": {
            "abbreviatedOid": "36b52bc"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-10T15:23:35Z",
          "updatedAt": "2022-02-10T15:23:36Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "DIscussion on the virtual interim:\r\n\r\n* This bullet seems redundant given the changes to the first bullet.  It is also out of place here in KeyPackage validation, since there might not be an update.\r\n* TODO(@kkohbrok) Remove this bullet, then clear to merge",
              "createdAt": "2022-02-10T15:23:36Z",
              "updatedAt": "2022-02-10T15:23:36Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c40cT0n",
          "commit": {
            "abbreviatedOid": "36b52bc"
          },
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-11T07:22:29Z",
          "updatedAt": "2022-02-11T07:22:29Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "Whoops, I think this wasn't supposed to be there in the first place. I'll remove it.",
              "createdAt": "2022-02-11T07:22:29Z",
              "updatedAt": "2022-02-11T07:22:29Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c40gtG2",
          "commit": {
            "abbreviatedOid": "5003623"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-02-13T14:25:22Z",
          "updatedAt": "2022-02-13T14:25:22Z",
          "comments": []
        }
      ]
    },
    {
      "number": 585,
      "id": "PR_kwDOBoyH6c4yPi-W",
      "title": "Fix typo",
      "url": "https://github.com/mlswg/mls-protocol/pull/585",
      "state": "MERGED",
      "author": "stefunctional",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2022-02-08T15:23:39Z",
      "updatedAt": "2022-02-10T14:09:25Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "b40a1a65d0c491a5e456464c6cfc345d459b8db7",
      "headRepository": "stefunctional/mls-protocol",
      "headRefName": "fix-typo",
      "headRefOid": "46d8ec1fc4ab289ff3f6f7e6c2b3a7423d75bf24",
      "closedAt": "2022-02-10T14:09:25Z",
      "mergedAt": "2022-02-10T14:09:25Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "cf574f3493b08b4f7575bbc4afb9cd48b81265f6"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOBoyH6c40YtVX",
          "commit": {
            "abbreviatedOid": "46d8ec1"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-02-10T14:09:20Z",
          "updatedAt": "2022-02-10T14:09:20Z",
          "comments": []
        }
      ]
    },
    {
      "number": 586,
      "id": "PR_kwDOBoyH6c4yPpVJ",
      "title": "Fix indexes in `psk_secret` diagram",
      "url": "https://github.com/mlswg/mls-protocol/pull/586",
      "state": "MERGED",
      "author": "stefunctional",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2022-02-08T15:46:13Z",
      "updatedAt": "2022-02-11T14:31:10Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "b40a1a65d0c491a5e456464c6cfc345d459b8db7",
      "headRepository": "stefunctional/mls-protocol",
      "headRefName": "fix-psk-indexes",
      "headRefOid": "6c525f3b2a97f73662ba15662696c789922d6227",
      "closedAt": "2022-02-10T14:10:31Z",
      "mergedAt": "2022-02-10T14:10:31Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "2527267abccc81f1682eadd325fd1a484ec38b01"
      },
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks @stefunctional !",
          "createdAt": "2022-02-10T14:10:40Z",
          "updatedAt": "2022-02-10T14:10:40Z"
        },
        {
          "author": "stefunctional",
          "authorAssociation": "CONTRIBUTOR",
          "body": "You're welcome and thank you!",
          "createdAt": "2022-02-11T14:31:10Z",
          "updatedAt": "2022-02-11T14:31:10Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOBoyH6c40YtrH",
          "commit": {
            "abbreviatedOid": "6c525f3"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-02-10T14:10:22Z",
          "updatedAt": "2022-02-10T14:10:22Z",
          "comments": []
        }
      ]
    },
    {
      "number": 587,
      "id": "PR_kwDOBoyH6c4yQFBk",
      "title": "Stop generating redundant PKE key pairs.",
      "url": "https://github.com/mlswg/mls-protocol/pull/587",
      "state": "MERGED",
      "author": "MartaMularczyk",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "This PR is motivated by an observation made independently by me and @bifurcation that MLS currently generates many \"redundant\" PKE keypairs which never have to be used. The proposal is to stop generating such key pairs, which greatly improves efficiency. In particular, in some scenarios the solution from this PR results in ~3 times smaller ratchet trees compared to the current MLS (we found such a scenario and @bifurcation illustrated it here [careful-truncate.pdf](https://github.com/mlswg/mls-protocol/files/8026064/careful-truncate.pdf)). This PR addresses the issue #559.\r\n\r\n### Problem\r\n\r\nTo give a better intuition, we explain the problem on an example. Take the following ratchet tree [trees.txt](https://github.com/mlswg/mls-protocol/files/8026207/trees.txt).\r\n\r\nCurrently, when E rekeys her path in a commit, she generates new PKE key pairs for all nodes on her direct path, i.e., Z, W, U and T. We notice that the key pairs for nodes Z and W are redundant -- since the subtrees of their children on the copath are all blank, E's leaf key pair can be used equivalently. Moreover, we notice that generating redundant key pairs is inefficient for 2 reasons:\r\n1. The redundant public keys have to be sent as part of E's commit and potentially welcome messages.\r\n2. The redundant public keys together with the parent hash mechanism prevent \"aggressive truncation\". Aggressive truncation was introduced in #461 in order to \"heal\" the ratchet tree (which decreases complexity). However, it broke the protocol due to incompatibility with the parent hash mechanism. For this reason, it was replaced in #524 by a far less efficient \"careful truncation\" mechanism. \r\n\r\n### Solution\r\n\r\nThis PR proposes to stop generating redundant key pairs, getting rid of both of the above inefficiencies. More precisely, we say that a node on E's path is _redundant_ if its copath child (or in general any child) has an empty resolution (which implies that its subtree is empty). Further, we say that E's _filtered direct path_ is her direct path with all redundant nodes removed. When E commits, she rekeys only her filtered direct path. The redundant nodes are blanked. In the example above, E's filtered direct path consists of Y and Z. After her, commit we get the following tree [trees_no_redundant.txt](https://github.com/mlswg/mls-protocol/files/8026218/trees_no_redundant.txt).\r\n\r\nThis way, E doesn't send redundant public keys for Z and W. Moreover, we can restore aggressive truncation -- the blank nodes above E can be truncated without destroying the parent hash. The following picture by @bifurcation shows how the above solution can result in ~3 times smaller trees than currently generated by MLS [careful-truncate.pdf](https://github.com/mlswg/mls-protocol/files/8026064/careful-truncate.pdf).\r\n\r\n### Parent Hash\r\n\r\nThe above solution requires modifying how the parent hash is verified by new members joining the group. Roughly, before the proposed change, the new member for each node U with children V and W performed the following check: either A) `V.parent_hash` is equal to the parent hash of U with copath child W or B) `W.parent_hash` is equal to the parent hash of U with copath child V. In the running example, B) would be true.\r\n\r\nAfter the proposed change, W is blank and the parent hash of U with copath child V is stored in the node E instead. Accordingly, the new member performs the following modified check: either A) there exists a node X in the resolution of V s.t. `X.parent_hash` is equal to the parent hash of U with copath child W or B) [modified analogous to A)].\r\n\r\nFrom the security perspective, the new check fulfils the same purpose as we meant for the original check: for every node U, the member who last rekeyed U attests to the publickey U.pk they generated and the public keys they told U.sk to.",
      "createdAt": "2022-02-08T17:40:32Z",
      "updatedAt": "2022-02-18T19:43:55Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "84f6874da9464dbbbfb4c7eff35cfc2c9113f27f",
      "headRepository": "MartaMularczyk/mls-protocol",
      "headRefName": "aggressive-truncate",
      "headRefOid": "7793b2f047927389286a0893f902cb8363327eef",
      "closedAt": "2022-02-18T19:43:55Z",
      "mergedAt": "2022-02-18T19:43:55Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "515a65a0f78976c3a5e608aa6b8ede939c192522"
      },
      "comments": [
        {
          "author": "TWal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I feel a bit uncomfortable with the part \"there exists a node X in the resolution of V such that \u2026\". I think we can replace \"resolution\" with \"original resolution\" and furthermore enforce the original resolution to only contain one node?",
          "createdAt": "2022-02-09T16:22:26Z",
          "updatedAt": "2022-02-09T16:22:26Z"
        },
        {
          "author": "MartaMularczyk",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> I feel a bit uncomfortable with the part \"there exists a node X in the resolution of V such that \u2026\". I think we can replace \"resolution\" with \"original resolution\" and furthermore enforce the original resolution to only contain one node?\r\n\r\nI think that the \"uneasy\" feeling may come from the fact that we don't agree about the intuition for what the parent hash attempts to achieve. Maybe it would help to explain it better in the draft, perhaps in \"security considerations\". Details follow.\r\n\r\nI noticed that many people think that the parent hash attempts to authenticate the structure of the tree. I have a different opinion. The parent hash attempts to enforce is the tree invariant. More precisely, say that a signature or a PKE key pair is \"good\" if the secret key is not leaked to or chosen by the adversary. The tree invariant requires that for each node W, if the signature keys of all members in W's subtree are good then W's PKE key pair is good. Looking ahead, this allows to give the following guarantee to joiners: if the signature keys of all group members are good, then all PKE key pairs in the tree are good. Thus, the next commit heals the group key.\r\n\r\nThinking about authenticating the structure, one naturally thinks that via the parent hash, the committer authenticates their path together with its properties, e..g, the length. This PR suggests to not authenticate some of such properties which naturally makes people uneasy.\r\n\r\nBut I think that authenticating such properties is not the job of the parent hash. Having in mind enforcing the tree invariant, I thinks that via the parent hash, the committer authenticates, the PKE public key of each (individual) node W on its path.\r\n\r\nThe most direct way to achieve the above would be to include in each node W on the path the committer's signature over W's PKE public key and W's original child resolution. However, this is inefficient. So instead, we use the current \"hash to the leaf & sign\" method. It's important to understand that it's only an efficiency improvement.\r\n\r\nWe can arrive at the \"hash to the leaf & sign\" solution by the following reasoning. If there was only one committer A, she could simply sign her whole path with a single signature. This doesn't work with many committers, because the last part of the path may be rekeyed by a different committer B. In this case, A's signature can no longer be verified (unless we store old public keys, which would be secure but inefficient). Therefore, we modify the solution so that one can verify any prefix of the sequence signed by A. The \"hash to the leaf & sign\" method allows to do just this.",
          "createdAt": "2022-02-11T18:37:37Z",
          "updatedAt": "2022-02-11T18:37:37Z"
        },
        {
          "author": "TWal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I agree that security-wise, as long as the public key and sibling resolution of every node is ultimately signed by a leaf, we are fine. And this property still holds after this PR.\r\n\r\nHere is how I understand parent hash: when generating a Commit, the leaf must sign the new public key for each node that was modified, and also sign who knows the private keys associated with the new public keys (== who can decrypt the data when we encrypt to the new public key).\r\n(Big parenthesis)\r\nThe resolution approach works by \"recursion\" in some sense, the signature says something like \"the people knowing the private part of this key are the people knowing the private part of these other public keys\".\r\nThe \"tree authentication\" approach is more straightforward, the signature encapsulate every leaf who could have decrypted the private part of the public key.\r\n(End of parenthesis)\r\nFinally as you explained, the parent hash construct is a way to do all these signature using only one signature, and furthermore make it resistant against future commits.\r\n\r\nIf we look at every node whose content was generated by a given leaf, we can notice it has a nice structure: it corresponds to a path starting to the leaf and going up to the root, possibly reaching the root if the leaf was the last committer, or stopping earlier in most cases.\r\n\r\nWith that said, here is the first thing that makes me uncomfortable: the parent hash in the current document exactly covers path with the shape described above: every cover of the tree with such paths can be correctly encoded using parent hash, and valid parent hashes on a tree encode such a cover of paths on the tree. With your proposal, we lose the second property.\r\n\r\nThe second thing that makes me uncomfortable is that in the parent hash correctness proof I've worked on, I use the notion of \"expected parent hash for a node\" (well I should talk about \"left expected parent hash\" and \"right expected parent hash\"), but the thing is we can give this a name because it is unique. Saying that we must search inside the resolution makes it not unique anymore.\r\n\r\n\r\nDuring the last virtual interim I think you said that my proposal is only an optimization (hence optional), and I agree.\r\nHowever thinking more about it, I have some questions:\r\n- the goal of this PR is to optimize MLS, so why not do all the optimizations available?\r\n- saying \"a node U in the subtree of V\" is conceptually simpler than \"a node U in the resolution of V\" while achieving the same security guarantee, so using the resolution is already an optimization?",
          "createdAt": "2022-02-14T15:48:53Z",
          "updatedAt": "2022-02-14T15:48:53Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "@TWal - Note that this proposal is actually synergistic with using tree hashes to represent siblings in parent hashes.  TH-for-PH is faster with sparser trees, and this proposal makes trees as sparse as possible. \r\n\r\nAs far as \"unease\", I think there's a solution that removes the ambiguity of \"searching\" for a child in the resolution and is compatible with the changes in PR.  Since we're trying to verify that every node chains to some leaf via the parent hash, simply update the parent hash validation to work up from the leaves instead of processing parent independently:\r\n\r\n* Let validated = set()\r\n* For each leaf node:\r\n  * Let N = leaf node\r\n  * while N != root:\r\n    * P = N.parent\r\n    * while !validated.contains(P) and P is blank and P != root: validated.add(P); P = P.parent;\r\n    * if validated.contains(P); break;\r\n    * if P is blank; validated.add(P); break;\r\n    * if !parent_hash_match(P, N): break;\r\n    * validated.add(P)\r\n    * N = P\r\n* return validated.len() == nodes.len()\r\n\r\nThe only ambiguity here is in the number of blank nodes you traverse before hitting the next non-blank parent.  (Without this PR, you would break if P is blank.)  But here again, the TH-for-PH helps by authenticating the subtrees: The most recent UpdatePath signs the whole structure of the tree, including all the blanks.  And the blanks in that UpdatePath are guaranteed by the filtered direct path computation and the height of the copath subtrees.\r\n\r\nSo it seems like if we do this PR, the TH-for-PH PR, and revise the parent hash validation as above, we end up with better performance and a cleaner semantic for the parent hash.",
          "createdAt": "2022-02-14T16:14:19Z",
          "updatedAt": "2022-02-14T16:14:19Z"
        },
        {
          "author": "TWal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'm noticing that I forgot to say that I was globally in favor of this PR!\r\n\r\nThe only itch for me really is the resolution part. The easiest fix for this would be to check that the original child resolution only contain one node and expected parent hash = this node's content.parent_hash.\r\n\r\nWhy is it true that the original child resolution only contain one node?\r\n- It's true when processing and UpdatePath (the child is non-blank since it's part of an UpdatePath so its resolution only contain itself)\r\n- It remains true when extending the tree or truncating the tree (since the resolution is not affected by adding or removing blank nodes)\r\n- It remains true when adding a leaf in an available blank leaf (thanks to the \"original\" in \"original child resolution\").",
          "createdAt": "2022-02-14T16:53:55Z",
          "updatedAt": "2022-02-14T16:53:55Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Discussion on virtual interim:\r\n\r\n* Ready to merge\r\n* Refactor parent hash validation in a follow-up",
          "createdAt": "2022-02-17T15:37:50Z",
          "updatedAt": "2022-02-17T15:37:50Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "I resolved merge conflicts in the most obvious way possible.  Along the way I noticed that we reference the `parent_hash` extension, which is no longer relevant.  I will file a follow-up to clean this up.",
          "createdAt": "2022-02-18T19:41:01Z",
          "updatedAt": "2022-02-18T19:41:01Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOBoyH6c40Tm8u",
          "commit": {
            "abbreviatedOid": "e2533ff"
          },
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "Neat solution! Just a few editorial comments.\r\n\r\nLooking forward to implementing and testing it.",
          "createdAt": "2022-02-09T14:36:46Z",
          "updatedAt": "2022-02-09T14:48:50Z",
          "comments": [
            {
              "originalPosition": 21,
              "body": "This is already mentioned in the paragraph above.",
              "createdAt": "2022-02-09T14:36:46Z",
              "updatedAt": "2022-02-09T14:48:50Z"
            },
            {
              "originalPosition": 23,
              "body": "I'm not sure if that is what you meant here, but I believe the HPKE key pair is generated from a given (symmetric) secret rather than the public key being generated using the private key.",
              "createdAt": "2022-02-09T14:39:01Z",
              "updatedAt": "2022-02-09T14:48:50Z"
            },
            {
              "originalPosition": 133,
              "body": "A pretty similar sentence is already in the paragraph above.",
              "createdAt": "2022-02-09T14:42:33Z",
              "updatedAt": "2022-02-09T14:48:50Z"
            },
            {
              "originalPosition": 13,
              "body": "I'm aware that this is not the style this section was written in previously, but when trying to implement an algorithm like this, I found it very helpful in the past if the description is a bit more structured. An example of this is the parent hash verification algorithm that (in the shape of bullet points) has pretty clear instructions on what should happen when.",
              "createdAt": "2022-02-09T14:47:19Z",
              "updatedAt": "2022-02-09T14:48:50Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c40Z9Tu",
          "commit": {
            "abbreviatedOid": "e2533ff"
          },
          "author": "MartaMularczyk",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-10T17:50:31Z",
          "updatedAt": "2022-02-10T17:50:32Z",
          "comments": [
            {
              "originalPosition": 133,
              "body": "It's similar, but there's a key difference: the paragraph above considers attesting to the public key V.pk for each node V on the path. This paragraph considers attesting to the public keys U.pk to which V.sk was encrypted.\r\n\r\nMaybe giving names to nodes would make it clearer? Like \"This way, P's parent hash fixes V.pk for each V on the filtered path from P to the root\" and then \"This way, P's parent hash fixes all public key to which V.pk was encrypted for each V[...]\"?",
              "createdAt": "2022-02-10T17:50:31Z",
              "updatedAt": "2022-02-10T17:50:32Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c40ciOR",
          "commit": {
            "abbreviatedOid": "453430a"
          },
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Thanks for addressing my comments! Looks good to me now.",
          "createdAt": "2022-02-11T08:42:15Z",
          "updatedAt": "2022-02-11T08:42:15Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOBoyH6c40exQz",
          "commit": {
            "abbreviatedOid": "453430a"
          },
          "author": "MartaMularczyk",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-11T17:32:06Z",
          "updatedAt": "2022-02-11T17:32:07Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "I agree. But I also think that this text could use a general improvement. I created a separate PR for this #593 ",
              "createdAt": "2022-02-11T17:32:06Z",
              "updatedAt": "2022-02-11T17:32:07Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c406RdI",
          "commit": {
            "abbreviatedOid": "a71407f"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-18T19:41:50Z",
          "updatedAt": "2022-02-18T19:42:06Z",
          "comments": [
            {
              "originalPosition": 121,
              "body": "```suggestion\r\ndirect path of U. This way, P's Parent Hash fixes\r\n```\r\n\r\nBroken link.",
              "createdAt": "2022-02-18T19:41:50Z",
              "updatedAt": "2022-02-18T19:42:06Z"
            }
          ]
        }
      ]
    },
    {
      "number": 592,
      "id": "PR_kwDOBoyH6c4ybHBE",
      "title": "Add a simple ProofCredential alternative to Certificate.",
      "url": "https://github.com/mlswg/mls-protocol/pull/592",
      "state": "CLOSED",
      "author": "Bren2010",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "- Adds an `extra_data` field to BasicCredential to hold application-specific data about a user (examples: link to avatar, information about device)\r\n- Adds a ProofCredential to cover a lot of the cases we're currently missing, particularly:\r\n  - credentials that are just BasicCredential signed with a fixed public key\r\n  - credentials that are authenticated by a system like Key Transparency\r\n  - credentials authenticated by secure hardware",
      "createdAt": "2022-02-10T20:01:06Z",
      "updatedAt": "2022-05-06T15:42:11Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "13955995bc4bb81f8f15f92014fad49494a4acf1",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "brendan/proof-credential",
      "headRefOid": "e165edd5c11f56a5cc8d1dc8839ae0083afea845",
      "closedAt": "2022-05-03T17:41:47Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "rohan-wire",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I am concerned about extra_data having neither semantics nor name spacing. If extra_data is scoped to an authority or a namespace, then i don't see the harm, but as it is now, I think it is harmful to interoperability. \r\n\r\nIf the intention is for this to be an extra identity, then let's say that directly. I would go so far as to then say it should be a URI. ",
          "createdAt": "2022-02-15T00:08:19Z",
          "updatedAt": "2022-02-15T00:09:20Z"
        },
        {
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "body": "`extra_data` is a place for general application data, similar to `authenticated_data`, and the protocol would be agnostic to what it contains. I think if you did want to specify what goes into it for interop, that might go in the \"Federation\" draft.",
          "createdAt": "2022-02-15T22:00:00Z",
          "updatedAt": "2022-02-15T22:00:00Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "I'm not sure what the extra mechanism here is buying on top of (a) the `BasicCredential.identity` field and (b) extensions.  A lot of the use cases described would work well in extensions.  For example, just like a CT log inclusion proof can be sent in a TLS ServerHello extension, it seems like you could put a KT inclusion proof in a LeafNode extension.  And if you want to stick within the basic framework, the `identity` field is entirely application defined, so you can just use it like you would `extra_data`.",
          "createdAt": "2022-02-15T22:48:00Z",
          "updatedAt": "2022-02-15T22:48:00Z"
        },
        {
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'm not opposed to this change specifically, but I'm generally wondering if we need concrete credentials in the spec beyond the basic credential, which is useful for interop. After we've pushed so much of the authentication logic into the AS and the implementation, the spec doesn't really care about what the credential looks like. I don't think we even strictly need it to provide a signature key, since message authentication just needs \"the signing private key corresponding to the public key, which was authenticated by the credential\". I'm still not sure why X509 needs to be in there.",
          "createdAt": "2022-02-16T07:27:54Z",
          "updatedAt": "2022-02-16T07:27:54Z"
        },
        {
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "body": "> A lot of the use cases described would work well in extensions. For example, just like a CT log inclusion proof can be sent in a TLS ServerHello extension, it seems like you could put a KT inclusion proof in a LeafNode extension.\r\n\r\nI would like us to have some way to support these cases already in the protocol so you don't have to immediately go out and build something new if you want to use anything besides X.509. So I can switch the ProofCredential to some kind of Proof extension but that seems like a worse abstraction? And it's not clear why Proof would be an extension when X.509 is a type of credential.\r\n\r\n> And if you want to stick within the basic framework, the identity field is entirely application defined, so you can just use it like you would extra_data.\r\n\r\nIt's more about the ease of having one field which contains just the unique identifier for the client and another field which may need to be parsed to be understood",
          "createdAt": "2022-02-17T05:10:53Z",
          "updatedAt": "2022-02-17T05:10:53Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Discussion on the virtual interim:\r\n\r\n* On the one hand, could implement this in a follow-on spec\r\n* On the other hand, could be nice to avoid the need for implementations to add stuff off the bat\r\n* TODO(@Bren2010): Flesh out use cases",
          "createdAt": "2022-02-17T15:48:42Z",
          "updatedAt": "2022-02-17T15:48:42Z"
        },
        {
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "body": "So in terms of fleshing out use cases more explicitly:\r\n\r\n## 1. Signature from fixed public key\r\n\r\nIn this case, clients authenticate with the AS and provide it their signature key, and the AS provides back a fixed `ProofCredential` object, with the fields set as follows:\r\n\r\n- `authority_id`: This contains an arbitrary identifier of the public key that was used. For example, `company.com/keys/feb22`. The exact contents of the field and any semantics are up to the AS.\r\n- `credential`: A BasicCredential where `identity` is the client's unique identifier, `extra_data` contains extra structured data like when the credential is valid / other metadata about the client that's authenticated but might not be uniquely identifying, and `signature_key` contains the signature key provided by the client.\r\n- `proof`: Contains a signature over the serialized `credential` field from the AS.\r\n\r\nThis is probably the simplest (secure!) way for an organization to start using MLS, while also supporting important future tasks like key rotation (through `authority_id`) and extensibility (through `extra_data`).\r\n\r\n## 2. Key Transparency\r\n\r\nClients authenticate with the AS and provide it their signature key, and the AS incorporates their signature key in a Key Transparency tree along with some additional metadata. Clients can get a [proof object](https://github.com/google/keytransparency/blob/master/docs/verification.md) from the AS that authenticates the binding of their identity to their signature key and metadata. The client builds their own `ProofCredential` as follows:\r\n\r\n- `authority_id`: This contains an identifier of the KT tree used -- possibly a URL.\r\n- `credential`: A BasicCredential with the proper `identity`, `extra_data`, and `signature_key`.\r\n- `proof`: The serialized proof object from the KT tree.\r\n\r\n",
          "createdAt": "2022-02-18T23:46:50Z",
          "updatedAt": "2022-02-18T23:46:50Z"
        },
        {
          "author": "rohan-wire",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thanks @Bren2010 for writing up these use cases. My concern is that if the authority _id is under-specified we could end up with a mess where different implementations assume a different syntax/semantic/context. This definitely happened with the Subject in X.509 certificates and it took almost a decade before we had reasonable semantics defined for SubjectAltName (URI, DNS, RID, IP, dirName, or otherName) and implementations still get confused sometimes when expecting DNS but a URI is present or vice versa.\r\n",
          "createdAt": "2022-03-03T18:27:42Z",
          "updatedAt": "2022-03-03T18:27:42Z"
        },
        {
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "body": "There's no structure prescribed to `authority_id`, much like `group_id` it's an opaque identifier. An implementation that relies on it having a certain structure wouldn't be compliant with the specification.",
          "createdAt": "2022-03-03T18:53:56Z",
          "updatedAt": "2022-03-03T18:53:56Z"
        },
        {
          "author": "rohan-wire",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> There's no structure prescribed to `authority_id`, much like `group_id` it's an opaque identifier. An implementation that relies on it having a certain structure wouldn't be compliant with the specification.\r\n\r\nWith an additional field with no structure, the ability to interoperate later will be even more difficult. I am already uncomfortable that there isn't even any optional structure in the Identity in a BasicCredential. As I said, look at what happened with Subject name in X.509.",
          "createdAt": "2022-03-10T08:51:29Z",
          "updatedAt": "2022-03-10T08:51:29Z"
        },
        {
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "body": "@rohan-wire I'm not sure why this concern doesn't apply to `group_id` but I could add some text to the PR along the lines of what I said in my last comment?\r\n\r\n```\r\nImplementations MAY construct the value of the `authority_id` field to have a particular \r\nformat, but MUST NOT enforce that the `authority_id` field always has that format. \r\n```",
          "createdAt": "2022-03-10T16:22:48Z",
          "updatedAt": "2022-03-10T16:22:48Z"
        },
        {
          "author": "rohan-wire",
          "authorAssociation": "CONTRIBUTOR",
          "body": "What if every credential contains a BasicCredential and you can just build on top of it?\r\nex:  https://github.com/mlswg/mls-protocol/pull/628",
          "createdAt": "2022-04-01T02:23:52Z",
          "updatedAt": "2022-04-01T02:23:52Z"
        },
        {
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "body": "Hey @rohan-wire, that idea doesn't really address the same problem as this PR. With this PR merged, any baseline implementation of MLS would support a restricted set of credential types: those where you can condense the necessary proof information into the \"proof\" field, and the implementation can call an application-provided callback to verify the proof. The application only needs to provide a callback that implements the verification logic because the wire format and data plumbing is already set up.\r\n\r\nWithout this PR, and also with #628, any new credential type has to be implemented as an extension to the protocol which would reasonably require modifying the MLS implementation. That's a lot of work and creates a maintenance burden.",
          "createdAt": "2022-04-01T18:42:48Z",
          "updatedAt": "2022-04-01T18:42:48Z"
        },
        {
          "author": "claucece",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I agree with @Bren2010 in that (as it was pointed out) it avoids the need for `implementations to add stuff off the bat`. I do see, though, the importance of being careful so we don't end up with the problems of the subject name in X.509. This seems reasonable for the latter point: https://github.com/mlswg/mls-protocol/pull/592#issuecomment-1086219398\r\n\r\n",
          "createdAt": "2022-04-09T15:16:05Z",
          "updatedAt": "2022-04-09T15:16:05Z"
        },
        {
          "author": "seanturner",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I posted this PR to the [mls list](https://mailarchive.ietf.org/arch/msg/mls/SitToPUL1CvPgx0vLnom730Wwes/) to see if we could get more input. I got crickets in response. I am going to close this PR out because it does not appear that we have consensus to merge this at this time.",
          "createdAt": "2022-05-03T17:41:47Z",
          "updatedAt": "2022-05-03T17:41:47Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 593,
      "id": "PR_kwDOBoyH6c4yidzJ",
      "title": "Clean up the description of tree evolution.",
      "url": "https://github.com/mlswg/mls-protocol/pull/593",
      "state": "MERGED",
      "author": "MartaMularczyk",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Changes (apart from editorial):\r\n* Remove the text about the key schedule. Reason: I found the text confusing, because updating paths provides FS and PCS for the HPKE keys in the ratchet tree, and not directly for the key schedule.\r\n* Generate the leaf key pair simply as a fresh HPKE key pair, and not from the leaf_secret. I couldn't see any benefit of using the leaf_secret. I wonder if there is a good reason?",
      "createdAt": "2022-02-11T17:30:46Z",
      "updatedAt": "2022-02-18T19:18:59Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "a281ec78289057a674756738d2e9b11c5d98666f",
      "headRepository": "MartaMularczyk/mls-protocol",
      "headRefName": "cleanup-tree-evolution",
      "headRefOid": "57b86384275d2fa5fb087d3d38df5418e85428e0",
      "closedAt": "2022-02-18T19:18:59Z",
      "mergedAt": "2022-02-18T19:18:59Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "84f6874da9464dbbbfb4c7eff35cfc2c9113f27f"
      },
      "comments": [
        {
          "author": "rohan-wire",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> * Generate the leaf key pair simply as a fresh HPKE key pair, and not from the leaf_secret. I couldn't see any benefit of using the leaf_secret. I wonder if there is a good reason?\r\n\r\nI am concerned that we are asking for a LOT of fresh entropy if (in addition to nonces) we need a crypto-random value every epoch for every group (a Wire client can easily a member of thousands of groups at a time). Do you have a concern about deriving it?\r\n",
          "createdAt": "2022-02-16T19:59:05Z",
          "updatedAt": "2022-02-16T19:59:05Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Discussion on the virtual interim:\r\n\r\n* To @rohan-wire's concern: This allows the base path secret to be derived, e.g., using a KDF, so this doesn't *necessarily* increase the amount of entropy needed\r\n* Clear to merge",
          "createdAt": "2022-02-17T15:51:53Z",
          "updatedAt": "2022-02-17T15:51:53Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOBoyH6c40gtMU",
          "commit": {
            "abbreviatedOid": "f9a64f3"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "A couple of editorial comments, but in general, LGTM",
          "createdAt": "2022-02-13T14:28:18Z",
          "updatedAt": "2022-02-13T14:33:03Z",
          "comments": [
            {
              "originalPosition": 32,
              "body": "\"allows\" needs a subject here.\r\n\r\n```suggestion\r\nfollowing procedure. The procedure is designed in a way that allows group members to\r\n```",
              "createdAt": "2022-02-13T14:28:18Z",
              "updatedAt": "2022-02-13T14:33:03Z"
            },
            {
              "originalPosition": 46,
              "body": "I would split the middle bullet here:\r\n\r\n* Generate the leaf key pair\r\n* Generate path secrets\r\n    * `path_secret[0]` is sampled at random\r\n    * `path_secret[n] = DeriveSecret(path_secret[n-1], \"path\")`\r\n* Derive node key pairs from path secrets",
              "createdAt": "2022-02-13T14:30:46Z",
              "updatedAt": "2022-02-13T14:33:03Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c40gtXp",
          "commit": {
            "abbreviatedOid": "f9a64f3"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-13T14:34:50Z",
          "updatedAt": "2022-02-13T14:35:04Z",
          "comments": [
            {
              "originalPosition": 46,
              "body": "Note also that the current version doesn't render quite properly.  \"In this context...\" isn't rendered as part of the bullet.  You might be able to fix this by indenting that part by 2 spaces.  Or you might have better success putting the code block after the prose.",
              "createdAt": "2022-02-13T14:34:50Z",
              "updatedAt": "2022-02-13T14:35:04Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c406Mu2",
          "commit": {
            "abbreviatedOid": "57b8638"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-02-18T19:18:41Z",
          "updatedAt": "2022-02-18T19:18:41Z",
          "comments": []
        }
      ]
    },
    {
      "number": 594,
      "id": "PR_kwDOBoyH6c4ytyJs",
      "title": "TLS syntax updates",
      "url": "https://github.com/mlswg/mls-protocol/pull/594",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "There are two changes in this PR:\r\n\r\n* Pull the `optional<T>` extension to the TLS syntax up into the Terminology section\r\n* Add an extension that lets vectors have variable-length headers, allowing them to be efficient at small sizes while also accommodating large sizes\r\n\r\nAll vectors are converted to the variable-length header representation.  It seems like this should simplify implementation, since the encoder will no longer have to be told how many bytes of header to use for a given vector.  This has been the source of several annoying interop bugs.\r\n",
      "createdAt": "2022-02-13T15:23:14Z",
      "updatedAt": "2022-02-18T19:07:32Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "a281ec78289057a674756738d2e9b11c5d98666f",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "tls-syntax-updates",
      "headRefOid": "62e3ea963ac8bbd45892062f43391de1ebf215e0",
      "closedAt": "2022-02-18T19:07:25Z",
      "mergedAt": "2022-02-18T19:07:25Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "0934bfad155d76f97ba62130f3f8c7df61202849"
      },
      "comments": [
        {
          "author": "TWal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Looks great!\r\n\r\nI only have a small objection: there is now several valid ways to serialize a length, as the example shows, both `25` and `40 25` are valid ways to encode 37. This means that if you parse a structure, and later want to re-serialize it to check a signature for example, you need to remember how many bits were used to store the length.\r\nIn short, we loose the property that `serialize(parse(buffer)) == buffer`.\r\n\r\nThe fix is easy: can we add that \"the length MUST be stored using the smallest amount of bits possible\"?",
          "createdAt": "2022-02-14T14:45:13Z",
          "updatedAt": "2022-02-14T14:45:13Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Good point, updated!",
          "createdAt": "2022-02-14T15:59:32Z",
          "updatedAt": "2022-02-14T15:59:32Z"
        },
        {
          "author": "rohan-wire",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I wasn't clear under which circumstances you would use a longer length with a number that would fit in a smaller range.  \r\n`| 00   | 1      | 6           | 0-63                  |`\r\n`| 01   | 2      | 14          | 0-16383               |`\r\n`| 10   | 4      | 30          | 0-1073741823          |`\r\n`| 11   | 8      | 62          | 0-4611686018427387903 |`\r\n\r\nIf never, then the table should be:\r\n`| prefix | length bits | usable bits | min | max |`\r\n`|-----|---|---|---|---|`  \r\n`| 00   | 1  | 6  | 0 | 63 |`\r\n`| 01   | 2  | 14 | 64 | 16383 |`\r\n`| 10   | 4  | 30 | 16384 | 1073741823 |`\r\n`| 11   | 8  | 62 | 1073741824 | 4611686018427387903 |`\r\n",
          "createdAt": "2022-02-15T00:01:40Z",
          "updatedAt": "2022-02-15T00:03:04Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "DIscussion on virtual interim\r\n\r\n* Some concern about being able to send gigantic stuff\r\n    * In adversarial cases, the 4-byte headers used for a lot of stuff might already be a problem\r\n    * Could also have length constraints decoupled from the syntax\r\n    * SIP experience shows that imposing arbitrary length limits isn't a good idea\r\n    * ... but applications should have a way to signal that things are too big\r\n    * TODO(@bifurcation): Advisory text \"Beware, things can get big; consider imposing limits and clear failure cases for this\"\r\n    * Consider streaming implementations, where you might not know that the whole message fits in memory\r\n* Modulo the above TODO, clear to merge  ",
          "createdAt": "2022-02-17T16:03:53Z",
          "updatedAt": "2022-02-17T16:03:53Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOBoyH6c40qlcz",
          "commit": {
            "abbreviatedOid": "f75a0ed"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-15T19:56:15Z",
          "updatedAt": "2022-02-15T20:03:55Z",
          "comments": [
            {
              "originalPosition": 125,
              "body": "nit: I prefer sender_type but at minimum need to update references to sender_type elsewhere in doc",
              "createdAt": "2022-02-15T19:56:15Z",
              "updatedAt": "2022-02-15T20:03:55Z"
            },
            {
              "originalPosition": 46,
              "body": "Was the intention to convert all vectors to variable length?\r\n- If so, there are still some fixed-length left\r\n- If not, how did you decide which to change?",
              "createdAt": "2022-02-15T20:02:32Z",
              "updatedAt": "2022-02-15T20:03:55Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c40q3VP",
          "commit": {
            "abbreviatedOid": "f75a0ed"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-15T21:08:39Z",
          "updatedAt": "2022-02-15T21:08:39Z",
          "comments": [
            {
              "originalPosition": 125,
              "body": "I think this is a typo anyway.  Will reverse.",
              "createdAt": "2022-02-15T21:08:39Z",
              "updatedAt": "2022-02-15T21:08:39Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c40q3xF",
          "commit": {
            "abbreviatedOid": "f75a0ed"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-15T21:10:31Z",
          "updatedAt": "2022-02-15T21:10:31Z",
          "comments": [
            {
              "originalPosition": 46,
              "body": "The example here is intended to have an old-style vector next to the new style, of course.\r\n\r\nI did intend to change everything over, but you're correct that I missed a bunch with whatever regexp I used.  I'll take another pass.",
              "createdAt": "2022-02-15T21:10:31Z",
              "updatedAt": "2022-02-15T21:10:31Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c40rJmq",
          "commit": {
            "abbreviatedOid": "f75a0ed"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-15T22:30:26Z",
          "updatedAt": "2022-02-15T22:30:26Z",
          "comments": [
            {
              "originalPosition": 46,
              "body": "Looks like this was due to merge conflicts.  Fixed now in any case.",
              "createdAt": "2022-02-15T22:30:26Z",
              "updatedAt": "2022-02-15T22:30:26Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c40sjSc",
          "commit": {
            "abbreviatedOid": "00f7acb"
          },
          "author": "franziskuskiefer",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-16T08:00:08Z",
          "updatedAt": "2022-02-16T08:04:31Z",
          "comments": [
            {
              "originalPosition": 37,
              "body": "RFC9000 also has pseudocode for doing the encoding. Maybe it's worth mentioning it here.",
              "createdAt": "2022-02-16T08:00:08Z",
              "updatedAt": "2022-02-16T08:04:31Z"
            },
            {
              "originalPosition": 52,
              "body": "The MUST here differs from the definition in RFC9000 that explicitly says \"Values do not need to be encoded on the minimum number of bytes necessary [...]\". It should be made clear that there's difference between the algorithm here and the one in RFC9000.",
              "createdAt": "2022-02-16T08:03:35Z",
              "updatedAt": "2022-02-16T08:04:31Z"
            }
          ]
        }
      ]
    },
    {
      "number": 595,
      "id": "PR_kwDOBoyH6c4y2pNK",
      "title": "Allowlist approach for proposals in external commit",
      "url": "https://github.com/mlswg/mls-protocol/pull/595",
      "state": "MERGED",
      "author": "kkohbrok",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "The current description of external commits still leaves room for the committer to include various other proposals such as arbitrary proposals that are not Update or Remove proposals (e.g., Adds, RequiredCapability, PSK, etc.). I think we should narrow that down to a specific set of proposals (i.e. an allow list style) to keep the implementation and general protocol complexity low for external commits, both for creation and processing.\r\n\r\nThe way I see it, the new joiner can always issue a follow-up commit for other proposals, but I might be missing important use-cases, so I'd be grateful for feedback on this.",
      "createdAt": "2022-02-15T12:04:11Z",
      "updatedAt": "2022-02-17T16:13:26Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "a281ec78289057a674756738d2e9b11c5d98666f",
      "headRepository": "kkohbrok/mls-protocol",
      "headRefName": "external_commit_proposals",
      "headRefOid": "94881144f66f44bd11ca639340644d05e100b4f7",
      "closedAt": "2022-02-17T16:13:26Z",
      "mergedAt": "2022-02-17T16:13:26Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "72e3b01e9c1c7adcef04ba58efec26151d1cd470"
      },
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "I agree with the intent here.  Looking through the list of proposal types, the only other one that seems like it might be useful is PSK -- I could see it being useful to prove that you have a PSK when joining from the outside.  If we can add that as an option (probably in parallel to Remove), this seems good to go to me.",
          "createdAt": "2022-02-15T22:35:01Z",
          "updatedAt": "2022-02-15T22:35:01Z"
        },
        {
          "author": "rohan-wire",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Would an External Commit adding yourself contain an Add or an Update Proposal?",
          "createdAt": "2022-02-16T19:51:30Z",
          "updatedAt": "2022-02-16T19:51:30Z"
        },
        {
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "It used to contain an `Add` proposal, but since that's pretty much redundant with the `path` the commiter has to include, it got optimized away. So an external commit should be handled as if it contained an Add proposal, where the KeyPackage in the Add is instead in the `path`.",
          "createdAt": "2022-02-17T07:15:13Z",
          "updatedAt": "2022-02-17T07:15:13Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 597,
      "id": "PR_kwDOBoyH6c4y4751",
      "title": "Require Commit.path by default",
      "url": "https://github.com/mlswg/mls-protocol/pull/597",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #596 \r\n\r\nThis PR introduces a notion of a proposal type being \"path safe\", in the sense that it is safe for the path to be omitted.  (Better phrasing welcome!)  The `path` field is required default, and allowed to be omitted only if all the proposals in the Commit are path-safe.",
      "createdAt": "2022-02-15T23:19:47Z",
      "updatedAt": "2022-02-18T19:18:56Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "a281ec78289057a674756738d2e9b11c5d98666f",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "path-by-default",
      "headRefOid": "d2b0af01063a688266bc22a7c0d720bdef9afc0d",
      "closedAt": "2022-02-18T19:18:51Z",
      "mergedAt": "2022-02-18T19:18:50Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "155e031a1d3bd3a9992c699fb1fcff6bfbcfa3a6"
      },
      "comments": [
        {
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thanks for taking care of this fix! One suggestion: Instead of having a global list of which types are path safe and which ones aren't, we could make it a property of the proposal. Maybe something like this:\r\n\r\n```\r\nallPathSafe = true\r\n\r\nfor i, id in commit.proposals:\r\n    proposal = proposalCache[id]\r\n    assert(proposal != null)\r\n\r\n    allPathSafe = allPathSafe && proposal.is_path_safe\r\n\r\nif len(commit.proposals) == 0 || !allPathSafe:\r\n    assert(commit.path != null)\r\n```\r\nRegarding the name, the only thing I can think of is that we could invert the property and call it `requires_path`:\r\n\r\n```\r\npath_required = false\r\n\r\nfor i, id in commit.proposals:\r\n    proposal = proposalCache[id]\r\n    assert(proposal != null)\r\n\r\n    path_required = path_required || proposal.requires_path\r\n\r\nif len(commit.proposals) == 0 || requires_path:\r\n    assert(commit.path != null)\r\n```\r\nIn fact, I think I'd be slightly in favor of the latter proposal.",
          "createdAt": "2022-02-16T07:33:51Z",
          "updatedAt": "2022-02-16T07:37:06Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Discussion on virtual interim:\r\n\r\n* OK to keep using type\r\n* TODO(@bifurcation) \"path safe\" -> \"path required\"\r\n* Otherwise clear to merge",
          "createdAt": "2022-02-17T16:17:25Z",
          "updatedAt": "2022-02-17T16:17:25Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 598,
      "id": "PR_kwDOBoyH6c4zHcde",
      "title": "Better name for preconfigured sender ID",
      "url": "https://github.com/mlswg/mls-protocol/pull/598",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #588 ",
      "createdAt": "2022-02-18T19:46:06Z",
      "updatedAt": "2022-02-18T19:53:07Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "515a65a0f78976c3a5e608aa6b8ede939c192522",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "external-key-id",
      "headRefOid": "cee7e88c052239c9652ac7fe57f3ba5c26f18791",
      "closedAt": "2022-02-18T19:53:04Z",
      "mergedAt": "2022-02-18T19:53:03Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "079e1bfbdeff8013b5ca7a7f49b03c4da7ae82bf"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 599,
      "id": "PR_kwDOBoyH6c4zHnqv",
      "title": "Clean up from KeyPackage/LeafNode split",
      "url": "https://github.com/mlswg/mls-protocol/pull/599",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "While landing #587, I noticed that there were some dangling references left over from the KeyPackage/LeafNode split, e.g., to the \"`parent_hash` extension\" or `leaf_key_package`.  This PR cleans those up.",
      "createdAt": "2022-02-18T20:21:53Z",
      "updatedAt": "2022-02-18T21:11:41Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "079e1bfbdeff8013b5ca7a7f49b03c4da7ae82bf",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "leaf-node-cleanup",
      "headRefOid": "d7bc6e153b28690276190f7256d88339e0671c1a",
      "closedAt": "2022-02-18T21:11:40Z",
      "mergedAt": "2022-02-18T21:11:40Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "13955995bc4bb81f8f15f92014fad49494a4acf1"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOBoyH6c406aJh",
          "commit": {
            "abbreviatedOid": "d7bc6e1"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-02-18T20:25:08Z",
          "updatedAt": "2022-02-18T20:25:08Z",
          "comments": []
        }
      ]
    },
    {
      "number": 600,
      "id": "PR_kwDOBoyH6c4zHpZQ",
      "title": "Add version to MLSMessage",
      "url": "https://github.com/mlswg/mls-protocol/pull/600",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #590 ",
      "createdAt": "2022-02-18T20:29:01Z",
      "updatedAt": "2022-03-06T16:35:55Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "079e1bfbdeff8013b5ca7a7f49b03c4da7ae82bf",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "message-version",
      "headRefOid": "bd67356ecbd4f68be4409ee6a4648fde02ced3b2",
      "closedAt": "2022-03-06T16:35:55Z",
      "mergedAt": "2022-03-06T16:35:54Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "fe5ec3acea1e8270f9ec9cdbf5f5378744bba14a"
      },
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Note that this is a little bit duplicative: There's already a `version` field in KeyPackage.  But removing that would require something like sending MLSMessage in Add, which seems unpleasant.  We should probably either require that `KeyPackage.version == MLSMessage.version`, or just not use MLSMessage for KeyPackage.\r\n\r\nLikewise, the version field in GroupInfo can probably be removed, since it will be on the outside MLSMessage regardless of whether the GroupInfo is sent bare or in Welcome.",
          "createdAt": "2022-02-18T22:07:41Z",
          "updatedAt": "2022-02-18T22:09:40Z"
        },
        {
          "author": "rohan-wire",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> Note that this is a little bit duplicative: There's already a `version` field in KeyPackage. But removing that would require something like sending MLSMessage in Add, which seems unpleasant. We should probably either require that `KeyPackage.version == MLSMessage.version`, or just not use MLSMessage for KeyPackage.\r\n> \r\n> Likewise, the version field in GroupInfo can probably be removed, since it will be on the outside MLSMessage regardless of whether the GroupInfo is sent bare or in Welcome.\r\n\r\nFirst, we need to add ProtocolVersion to the beginning of MLSMessageContentTBS. \r\n\r\nRegarding KeyPackage and GroupInfo, the semantics here are subtle.\r\nExample: My MLS 1.1 client could send an MLSMessage with MLS version 1.1 to the DS/Directory, which contains a KeyPackage which only advertises MLS version 1.0. Another MLS client which only supports MLS 1.0 could read it with no problem. (I could publish both 1.0 and 1.1 KeyPackages).\r\n",
          "createdAt": "2022-02-22T18:16:31Z",
          "updatedAt": "2022-02-22T18:16:31Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "The latest commits here address the initial comments about KeyPackage and GroupInfo, and fixes the problem @rohan-wire notes about MLSMessageContentTBS.\r\n\r\nFor GroupInfo: I have just removed the `version` field.  I don't think there's any ambiguity created by moving it out to the MLSMessage wrapper.\r\n\r\nFor KeyPackage: I have left the `version` field and required it to be the same as the MLSMessage `version` field.  The thinking here is that these are saying the same thing to different audiences (the adder and everything else), so they should be consistent.\r\n\r\nYou could allow them to differ if you said that `MLSMessage.version` is only to indicate the format/semantics of the inner KeyPackage; then `KeyPackage.version` would indicate the actual version in use.  So to @rohan-wire's point, if  MLS 1.1 used the same KeyPackage format/semantics as MLS 1.0 (but presumably differed some other way), then you could have `MLSMessage{version=1.0, KeyPackage{version=1.1, ...}}`.  But this seems harder to reason about than just saying \"If I don't support the outer version, I can't use this KeyPackage\".",
          "createdAt": "2022-02-28T19:47:59Z",
          "updatedAt": "2022-02-28T19:47:59Z"
        },
        {
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'm confused about what we're trying to do here. The way I understand it is that MLS messages are always sent in the context of a group. That group has a version associated with it via the group context. I see how it would make sense to add the version field to MLS messages, but I don't see how that version has anything to do with a potential KeyPackage that might or might not be a part of that message. I think the spec already has enough requirements about versions: If the version indicated by an MLSMessage differs from that of the group indicated by the group id, it's invalid. Similarly, if the version of the KeyPackage contained in a given Add proposal doesn't match that of the group in which it's meant to be used, it's invalid. Where exactly do we run into trouble if we don't explicitly relate the version in the framing and that of it's contents? The versions should already be the same, since they have to be the same as that of the group.\r\n\r\nRegarding the example with the DS: I don't quite understand the setting. As far as I'm aware, uploading or downloading of KeyPackages is not specified in the spec, so even if it happens within an MLS group (maybe the DS and the client are in a group) the KeyPackage would be part of an application message and thus the version of the KeyPackage would be irrelevant as far as the spec is concerned. Please correct me if I'm wrong or if I misunderstand the problem at hand.",
          "createdAt": "2022-03-01T07:58:37Z",
          "updatedAt": "2022-03-01T07:58:37Z"
        },
        {
          "author": "rohan-wire",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Hi Konrad,\r\n> The way I understand it is that MLS messages are always sent in the context of a group.\r\nNot all MLS _objects_ are sent in the context of a group. KeyPackage objects are not. The version number applies to the _protocol_ which specifies the _objects_, some of which are messages.\r\n\r\nWhen some lower level protocol sends an MLSCiphertext or MLSPlaintext message, the MLS client and/or DS could support multiple versions of MLS. The DS can't tell which group is being referenced until it can parse the message. It can't do that until it knows the protocol version, so the protocol and version are typically the first fields. \r\n\r\nI agree that for MLSCiphertext and MLSPlaintext objects if the version of the message doesn't correspond to the version of the group, that sounds like an invalid message to me.\r\n\r\n(I don't see when you would put a KeyPackage inside an MLS application message.)\r\n\r\nEven though uploading and downloading KeyPackage objects is not included in the spec, we need to allow another protocol to do so and give that protocol a reasonable migration path. If my directory supports KeyPackages in v1.0 and v1.1 format, we should be able to publish both versions until all the v1.0 potential peers have migrated. The format of the KeyPackage objects may be different. Being able to distinguish these so they can be parsed without external help is a basic data-hygiene function.",
          "createdAt": "2022-03-02T00:07:12Z",
          "updatedAt": "2022-03-02T00:07:12Z"
        },
        {
          "author": "rohan-wire",
          "authorAssociation": "CONTRIBUTOR",
          "body": ">So to @rohan-wire's point, if MLS 1.1 used the same KeyPackage format/semantics as MLS 1.0 (but presumably differed some other way), then you could have `MLSMessage{version=1.0, KeyPackage{version=1.1, ...}}`. But this seems harder to reason about than just saying \"If I don't support the outer version, I can't use this KeyPackage\".\r\n\r\nMLSMessage{version=1.1, KeyPackage{version=1.0,...}} is the case I am envisioning. My client supports both MLS version 1.1 and 1.0. My DS supports v1.1 so I always communicate with v1.1, but I publish keypackages in both 1.0 and 1.1 formats.\r\n\r\n",
          "createdAt": "2022-03-02T00:10:31Z",
          "updatedAt": "2022-03-02T00:10:31Z"
        },
        {
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thanks for the explanation, that makes the intent a bit clearer to me. However, I still don't see the scenario where something like `MLSMessage{version=1.1, KeyPackage{version=1.0,...}}` is a valid message in the context of the MLS spec. I agree that you should be able to publish KeyPackages of multiple versions and that version agility is important. \r\n\r\nDo I understand correctly, that in the scenario you describe (`MLSMessage{version=1.1, KeyPackage{version=1.0,...}}`) you're uploading a KeyPackage to the DS? I guess I don't understand why that would be an MLSMessage and not some message in the proprietary protocol you use to upload KeyPackages.",
          "createdAt": "2022-03-02T07:47:12Z",
          "updatedAt": "2022-03-02T07:47:12Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "@rohan-wire - You don't need `MLSMessage{mls11, KeyPackage{mls10,...}})` to allow for uploading both 1.0 and 1.1 key packages -- you just have the client upload both `MLSMessage{mls10, KeyPackage{mls10,...}})` and `MLSMessage{mls11, KeyPackage{mls11,...}})`.\r\n\r\nSince there doesn't seem to be a compelling case here for allowing the versions to differ, I'm going to go ahead and merge with the requirement that they be the same.",
          "createdAt": "2022-03-06T16:35:47Z",
          "updatedAt": "2022-03-06T16:35:47Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 601,
      "id": "PR_kwDOBoyH6c4zHqx2",
      "title": "Remove dangling references to PublicGroupState",
      "url": "https://github.com/mlswg/mls-protocol/pull/601",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "PublicGroupState was removed as an independent struct in #529.  This PR fixes some dangling references to it.",
      "createdAt": "2022-02-18T20:34:01Z",
      "updatedAt": "2022-02-28T18:57:18Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "079e1bfbdeff8013b5ca7a7f49b03c4da7ae82bf",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "no-pgs",
      "headRefOid": "ef3341f0160725ef8136f4c7b70d181560d344de",
      "closedAt": "2022-02-28T18:57:18Z",
      "mergedAt": "2022-02-28T18:57:18Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "3c5882cc9f6311cbbe95e3308f8397a8852e7b9d"
      },
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "cc @kkohbrok",
          "createdAt": "2022-02-18T20:34:22Z",
          "updatedAt": "2022-02-18T20:34:22Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOBoyH6c41E1iQ",
          "commit": {
            "abbreviatedOid": "c55c63e"
          },
          "author": "rohan-wire",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "Also, update WireFormat:\r\n\r\ns/mls_public_group_state(4),/mls_group_info(4),/\r\n",
          "createdAt": "2022-02-22T22:55:34Z",
          "updatedAt": "2022-02-22T22:55:34Z",
          "comments": []
        }
      ]
    },
    {
      "number": 602,
      "id": "PR_kwDOBoyH6c4zIC9T",
      "title": "Limit the new variable length encoding to 30-bit",
      "url": "https://github.com/mlswg/mls-protocol/pull/602",
      "state": "MERGED",
      "author": "raphaelrobert",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "The recently introduced variable size encoding allows for very large message sizes that are not practical in any realistic scenario. Since decoders will most likely not allow such large messages anyway, this PR limits the maximum size to 30-bit.",
      "createdAt": "2022-02-18T22:00:14Z",
      "updatedAt": "2022-02-28T16:56:03Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "13955995bc4bb81f8f15f92014fad49494a4acf1",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "cap-large-encoding",
      "headRefOid": "76e79876551886bcb17b2fce7d62a626372c2a00",
      "closedAt": "2022-02-28T16:56:03Z",
      "mergedAt": "2022-02-28T16:56:03Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "866cbbc050e68901b8156fe8fef36da2f851dbf1"
      },
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "cc @rohan-wire who had some thoughts about limits on the last virtual interim.",
          "createdAt": "2022-02-18T22:18:51Z",
          "updatedAt": "2022-02-18T22:18:51Z"
        },
        {
          "author": "rohan-wire",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> cc @rohan-wire who had some thoughts about limits on the last virtual interim.\r\nMy general points are:\r\n- Code defensively\r\n- Fail gracefully\r\n- Use the lower level protocol carrying MLS Messages to send a clear and relevant error message if something is too big.\r\n   Ex: HTTP/2.0 413 Commit.Proposals exceeds 2^16 bytes\r\n   ex: HTTP/2.0 413 Too many proposals referenced in Commit (>9999)",
          "createdAt": "2022-02-22T18:45:29Z",
          "updatedAt": "2022-02-22T21:32:06Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOBoyH6c406sKy",
          "commit": {
            "abbreviatedOid": "d32cdc0"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-18T22:13:17Z",
          "updatedAt": "2022-02-18T22:13:18Z",
          "comments": [
            {
              "originalPosition": 40,
              "body": "```suggestion\r\nFor example, the four byte sequence 0x9d7f3e7d decodes to 494878333; \r\nthe two byte sequence 0x7bbd decodes to 15293; and the single byte 0x25 \r\ndecodes to 37.\r\n```\r\n\r\n* Added `0x` to disambiguate hex vs. decimal\r\n* Removed the final parenthetical because it doesn't obey minimum-length encoding.",
              "createdAt": "2022-02-18T22:13:17Z",
              "updatedAt": "2022-02-18T22:13:18Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c406s4h",
          "commit": {
            "abbreviatedOid": "d32cdc0"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-18T22:18:30Z",
          "updatedAt": "2022-02-18T22:18:30Z",
          "comments": [
            {
              "originalPosition": 36,
              "body": "An alternative approach here would be to leave the `11` prefix, but forbid encoded values larger than some limit.  That way, if there were some case where reusing this encoding would be useful (cTLS, maybe) and larger sizes were allowed, then it could just be reused.  It also just seems a bit ugly to encode range limitations in the formatting.\r\n\r\nSuggest something like the following:\r\n\r\n\r\n> The `11` prefix is included for completeness.  To avoid compatibility issues for devices with limited storage, however, vectors in MLS MUST NOT have a length greater than 2^32.  A vector with an encoded length greater than this limit MUST be rejected as malformed.",
              "createdAt": "2022-02-18T22:18:30Z",
              "updatedAt": "2022-02-18T22:18:30Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c41D0-7",
          "commit": {
            "abbreviatedOid": "76e7987"
          },
          "author": "rohan-wire",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-22T18:22:54Z",
          "updatedAt": "2022-02-22T18:22:55Z",
          "comments": [
            {
              "originalPosition": 36,
              "body": "I think Richard's text is overkill. How about:\r\n\u00abVectors that start with \"11\" prefix are invalid and MUST be rejected, as that prefix would represent vectors too large to be included in any practical message.\u00bb",
              "createdAt": "2022-02-22T18:22:54Z",
              "updatedAt": "2022-02-22T18:22:55Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c41XfHL",
          "commit": {
            "abbreviatedOid": "76e7987"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-02-28T16:55:57Z",
          "updatedAt": "2022-02-28T16:55:57Z",
          "comments": []
        }
      ]
    },
    {
      "number": 603,
      "id": "PR_kwDOBoyH6c4zIEM0",
      "title": "Update parent hash validation",
      "url": "https://github.com/mlswg/mls-protocol/pull/603",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This PR revises the parent hash verification section to reflect more recent discussion.  Right now, the definition of validity according to the parent hash ties it to the \"top-down\" validation algorithm, when what really matters is that each parent node has a path to a leaf.  This PR changes the definition to that more general version, and mentions the \"top-down\" and \"bottom-up\" approaches to checking this property.",
      "createdAt": "2022-02-18T22:03:54Z",
      "updatedAt": "2022-02-28T19:06:38Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "13955995bc4bb81f8f15f92014fad49494a4acf1",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "revised-parent-hash",
      "headRefOid": "9316effb2c692322569669c672d0aa8796d2181e",
      "closedAt": "2022-02-28T19:06:38Z",
      "mergedAt": "2022-02-28T19:06:38Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "e2afa1903e3a42d8a4ca661d329087b0d80365f9"
      },
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "cc @TWal @MartaMularczyk ",
          "createdAt": "2022-02-18T22:04:08Z",
          "updatedAt": "2022-02-18T22:04:08Z"
        },
        {
          "author": "MartaMularczyk",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Great proposal! It achieves what we want much more directly.\r\n\r\nOne comment: in the description of the \"top down\" approach, the part \"there is _exactly_ one descendant\" isn't exactly consistent with being \"parent hash valid\", because the latter requires that P can be chained to _at least_ one leaf. The bottom up approach is consistent with being parent hash valid.\r\nAs a result, a malicious insider may be able to craft a tree that is accepted by the bottom up approach but not by the top down approach [1] which may hurt interoperability.\r\nI'd suggest either to change \"exactly one\" to \"at least one\" in the top down approach or to change \"can be chained back to a leaf\" to \"can be chained back to exactly one leaf\" in the definition of parent hash valid (and modify the bottom up approach accordingly). I don't have a strong opinion which is better.\r\n\r\n---------------------\r\n[1] An example such tree: the tree has 3 nodes: the root P and its children A and B. Assuming both A and B are malicious, A signs the parent hash of P with copath child B and B signs the parent hash of P with copath child A. (This is possible with the current resolution-hash for parent-hash.)\r\n\r\n",
          "createdAt": "2022-02-22T12:14:30Z",
          "updatedAt": "2022-02-22T12:14:30Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "@MartaMularczyk - I am keen on the \"exactly one\" framing precisely because you shouldn't have these collisions in a real tree.  At least I haven't been able to think up a case; maybe you have a non-malicious case?  Given that, I'm inclined to tighten the \"bottom-up\" so that it fails if there are multiple valid paths to a node. ",
          "createdAt": "2022-02-28T16:35:09Z",
          "updatedAt": "2022-02-28T16:35:09Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Just to close the loop here:\r\n\r\n* @TWal - thanks for the suggestion, added a sentence\r\n* @MartaMularczyk - Updated the \"bottom up\" description to say that each node should be covered by exactly one chain, which is the parallel requirement to exactly one child.",
          "createdAt": "2022-02-28T19:06:27Z",
          "updatedAt": "2022-02-28T19:06:27Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOBoyH6c407HD_",
          "commit": {
            "abbreviatedOid": "63151b2"
          },
          "author": "TWal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "Note that this doesn't completely address the \"unease\" feeling mentioned in #587, but I can live it.\r\n\r\nOther than that, I think it makes the parent hash construct a lot more clear and this PR has a lot of pedagogical value. The section on parent hash in the current document is really difficult to grasp for a newcomer.",
          "createdAt": "2022-02-19T10:04:45Z",
          "updatedAt": "2022-02-19T10:05:08Z",
          "comments": [
            {
              "originalPosition": 35,
              "body": "Maybe add something to say the nodes on the path of the commit form a new parent-hash-chain?",
              "createdAt": "2022-02-19T10:04:45Z",
              "updatedAt": "2022-02-19T10:05:08Z"
            }
          ]
        }
      ]
    },
    {
      "number": 605,
      "id": "PR_kwDOBoyH6c4zYkEA",
      "title": "Add mime_type object before application_data",
      "url": "https://github.com/mlswg/mls-protocol/pull/605",
      "state": "CLOSED",
      "author": "rohan-wire",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "This allows applications to express the MIME type of the application_data if desired.",
      "createdAt": "2022-02-24T05:10:27Z",
      "updatedAt": "2022-05-02T18:27:44Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "13955995bc4bb81f8f15f92014fad49494a4acf1",
      "headRepository": "rohan-wire/mls-protocol",
      "headRefName": "rohan/mime_app_data",
      "headRefOid": "5589c90ecd6accc930d95394a9365bfc68b06127",
      "closedAt": "2022-05-02T18:27:44Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "rohan-wire",
          "authorAssociation": "CONTRIBUTOR",
          "body": "In case you are wondering how you would negotiate mime types used by an MLS client, here is a WIP very rough preview:\r\nhttps://github.com/rohan-wire/ietf-drafts/blob/main/mahy-dispatch-immi-mls-mime/draft-mahy-dispatch-immi-mls-mime.md",
          "createdAt": "2022-02-24T06:16:52Z",
          "updatedAt": "2022-02-24T06:16:52Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "@rohan-wire why should this not just go inside of `application_data`?  HTTPS doesn't specify Content-Type at the TLS layer.  I realize there's probably a closer match between MLS messages and objects than with TLS frames, but still, it seems simpler to keep this layer as a transport for bytes, and do content negotiation within the byte stream.",
          "createdAt": "2022-02-28T20:15:16Z",
          "updatedAt": "2022-02-28T20:15:16Z"
        },
        {
          "author": "rohan-wire",
          "authorAssociation": "CONTRIBUTOR",
          "body": "\r\n> @rohan-wire why should this not just go inside of `application_data`? HTTPS doesn't specify Content-Type at the TLS layer. \r\n\r\nTLS is usually running directly on IPv4 or IPv6 and was reached by a specific port or started inside an Application protocol with STARTTLS. The format of the thing inside TLS is known from the port number or the outer protocol. Most of the protocols running inside TLS (SMTP, HTTP, IMAP, SIP) have their own way of advertising content, most of them using MIME headers. All of them are 1:1 and most are client-to-server. None of the protocols running inside TLS are 1:N protocols.\r\n\r\nNow take the case of MLS. MLS does not know how to run on top of IP. You could write a profile to do that, but it would be a lot of work to make a standardized protocol that covers all the corner cases. It would be useful for some applications but almost certainly not for the basic messaging applications which motivate it. It needs to run on some other protocol. See my map below. So, what goes inside an MLS message? \r\n\r\nA: content goes here\r\nP: MLS   <- You are here\r\nS: HTTP\r\nT: TLS  <- not here\r\nN: IPv4 or v6\r\nD: 802.3\r\nP: 1000BASE-T\r\n\r\nIn a proprietary application you can just have all the MLS clients agree, but what about if you want to support an interoperable IM system, or an interoperable Pub/Sub messaging bus for IoT devices? What are you going to use to communicate the content of the message?  HTTP won't work for 1:N messages. Do you really want to require an ASCII Content-Type header at the top of each message just so you know what is inside it? That's a pretty fundamental thing to know. \r\n\r\nFor me this is a no-brainer. If you don't need it, you lose 1 octet to carry a zero-length MIME type. If you need it, you have it built-in. You don't need messy content-encodings, line folding, optional whitespace, header capitalization arguments, etc which have dogged IETF text-based protocols for decades. If the MIME type of your MLS application message is application/vnd.foo-pubsub, application/cbor, text/html, application/geo+json, message/cpim, or message/vnd.bar-protocol you don't have to guess. You can easily migrate from one format to another. You can even use multipart/alternative to send a vendor-proprietary version usable to some clients in a group and a standardized interoperable version to others.\r\n",
          "createdAt": "2022-03-01T23:41:57Z",
          "updatedAt": "2022-03-01T23:41:57Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "I think I've got a different view of the protocol stack:\r\n\r\n```\r\n1. Actual user content\r\n2. Message framing\r\n3. MLS as used in context\r\n4. Transport\r\n```\r\n\r\nIn order to get to an interoperable system, there's going to have to be work on (2), (3 \"as used\"), and (4).  (And I expect the work-split among those layers to be a point of significant debate!)  My point is that any of those could handle the content negotiation: \r\n\r\n* Transport says \"this is the content type inside the MLS-protected thing\"\r\n* \"As used\" specifies a format for `authenticated_data` that specifies the content type\r\n* Inner message framing specifies concrete type  \r\n\r\nAll of that is possible without this PR.  So in other words, I think merging this PR would be getting ahead of ourselves in the full-stack interoperability discussion.",
          "createdAt": "2022-03-06T16:30:04Z",
          "updatedAt": "2022-03-06T16:30:04Z"
        },
        {
          "author": "rohan-wire",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Renumbering your stack:\r\n\r\n> ```\r\n> 7 1/2. Actual user content\r\n> 7. Message framing ??\r\n> 6. MLS as used in context\r\n> 4 + 5. Transport + Session\r\n> ```\r\n> \r\n> In order to get to an interoperable system, there's going to have to be work on (7), (6 \"as used\"), and (4+5). (And I expect the work-split among those layers to be a point of significant debate!) My point is that any of those could handle the content negotiation:\r\n\r\nI don't think we need to define 4 + 5 and probably should not because we want to allow multiple protocols with gateways. In my example TLS and HTTP work just fine without modification, but you could use any number of protocols here. What these protocols should say about their contents is that the contents are message/mls. **Saying anything more is likely to leak private data.**\r\n\r\nWe shouldn't need to define a lot of new things for MLS either. In fact I don't see any reason you couldn't implement a basic instant messaging system with MLS using the base spec.\r\n\r\nAs for what goes inside MLS, whatever it is either has or should have a MIME type. IETF protocols provide a way to specify what is in the next layer. **The next layer cannot be responsible for describing itself.** Unless there is only a single message framing layer that an implementer is allowed to run inside MLS, then MLS needs to describe what runs inside. \r\n\r\nAs for a definition of 7 as a separate layer, I think you are artificially mandating a specific number of layers on top of MLS. I already made a concrete proposal for how to do common instant messaging features on top of MLS in my draft:\r\nhttps://www.ietf.org/archive/id/draft-mahy-dispatch-immi-content-00.html\r\n\r\n",
          "createdAt": "2022-03-09T18:27:00Z",
          "updatedAt": "2022-03-09T18:27:00Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "My sense is that what Richard is describing is probably better than this.\r\n\r\nLet's say that you use CPIM.  There, you define that the payload of the message is MIME, which includes `Content-Type`.  The `Content-Type` header is then found in the payload of the message along with other MIME header fields.\r\n\r\nThis design is better in the sense that you can switch hit between outer content types without any risk of ambiguity/confusion attack, but that is a feature that is rarely needed, and building it within the payload is probably sensible.  Many applications will  have a single message format with other means of unambiguously indicating its type.  For those that do want different interpretations, MIME media types aren't the only way in which they might want to negotiate the type of content.  @bemasc suggested at the DISPATCH meeting the possibility that the label might be ALPN instead (though that assumes a very different context. so I'm not sure if that makes sense).\r\n\r\nAt a minimum, I would suggest that this would need to be a negotiated extension to MLS.",
          "createdAt": "2022-03-21T10:18:38Z",
          "updatedAt": "2022-03-21T10:18:38Z"
        },
        {
          "author": "bemasc",
          "authorAssociation": "NONE",
          "body": "What I meant by \"ALPN\" was just that this \"type signal\" describes something interactive (more like a protocol than a format) and needs negotiation.  Having more than two parties makes it different from ALPN.\r\n\r\nI'd like to see some more thought to agility and forward-compatibility.  How can we gracefully upgrade the group across both small (e.g. new text formatting option) and large (e.g. HTTP/1.1 -> H2) transitions?  This seems like a major challenge.",
          "createdAt": "2022-03-21T10:33:25Z",
          "updatedAt": "2022-03-21T10:33:25Z"
        },
        {
          "author": "rohan-wire",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I just submitted a draft that proposes to do content negotiation when it's GroupContext extension is present.\r\n\r\n> My sense is that what Richard is describing is probably better than this.\r\n> \r\n> Let's say that you use CPIM. There, you define that the payload of the message is MIME, which includes `Content-Type`. The `Content-Type` header is then found in the payload of the message along with other MIME header fields.\r\n> \r\n> This design is better in the sense that you can switch hit between outer content types without any risk of ambiguity/confusion attack, but that is a feature that is rarely needed, and building it within the payload is probably sensible. Many applications will have a single message format with other means of unambiguously indicating its type. For those that do want different interpretations, MIME media types aren't the only way in which they might want to negotiate the type of content. @bemasc suggested at the DISPATCH meeting the possibility that the label might be ALPN instead (though that assumes a very different context. so I'm not sure if that makes sense).\r\n> \r\n> At a minimum, I would suggest that this would need to be a negotiated extension to MLS.\r\n\r\nStill I think replying to two specific things:\r\n>Many applications will have a single message format with other means of unambiguously indicating its type.\r\nYes, in which case this PR would have allowed the mime_type to be an empty string. This would have result with one extra byte for the length (0) for folks that don't need it.\r\n\r\n>but that is a feature that is rarely needed\r\nmembers in a group who want to upgrade their communications format (which happens all the time) would definitely be able to take advantage of this feature. I have rarely seen a system that doesn't end up wanting to make some incremental non-backwards compatible format change. It's really nice when you can do that without having to create a new group or have a flag-day upgrade.\r\n\r\n",
          "createdAt": "2022-04-01T02:07:24Z",
          "updatedAt": "2022-04-01T02:07:24Z"
        },
        {
          "author": "rohan-wire",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Just submitted the following:\r\nhttps://www.ietf.org/archive/id/draft-mahy-mls-content-neg-00.html\r\n",
          "createdAt": "2022-04-01T02:13:16Z",
          "updatedAt": "2022-04-01T02:13:16Z"
        },
        {
          "author": "rohan-wire",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Also, there is a PR for the architecture draft which covers the general advise here:\r\nhttps://github.com/mlswg/mls-architecture/pull/94\r\n",
          "createdAt": "2022-05-02T18:25:29Z",
          "updatedAt": "2022-05-02T18:25:29Z"
        },
        {
          "author": "rohan-wire",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Closing as the changes have all moved elsewhere.",
          "createdAt": "2022-05-02T18:27:43Z",
          "updatedAt": "2022-05-02T18:27:43Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 606,
      "id": "PR_kwDOBoyH6c4zr2sV",
      "title": "Normalize on 'copath'",
      "url": "https://github.com/mlswg/mls-protocol/pull/606",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #604 ",
      "createdAt": "2022-02-28T19:57:22Z",
      "updatedAt": "2022-02-28T19:58:35Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "e2afa1903e3a42d8a4ca661d329087b0d80365f9",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "copath",
      "headRefOid": "99f4d95e9868234980e144605e6a654bcd941a2a",
      "closedAt": "2022-02-28T19:58:35Z",
      "mergedAt": "2022-02-28T19:58:35Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "fac538f3e705e2224ff69547a0d339f49a21273a"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 609,
      "id": "PR_kwDOBoyH6c40B4pJ",
      "title": "Rename generic LeafNode object to ClientInfo and move ahead of # Ratchet Tree Operations",
      "url": "https://github.com/mlswg/mls-protocol/pull/609",
      "state": "CLOSED",
      "author": "rohan-wire",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "The LeafNode text is self-contradictory when it tries to refer to KeyPackages. To avoid these problems, I wrote a version with a separate ClientInfo object (basically the LeafNode object today) and put the generic stuff there. There is an alias for LeafNode to ClientInfo and the KeyPackage uses ClientInfo as one of its components. Stuff which is unique to the usage as a LeafNode or KeyPackage is in the relevant section.\r\n\r\nComments welcome. Probably more than one way to do resolve this, but the text now has lots of duplication.",
      "createdAt": "2022-03-07T09:50:13Z",
      "updatedAt": "2022-03-07T16:09:15Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "fe5ec3acea1e8270f9ec9cdbf5f5378744bba14a",
      "headRepository": "rohan-wire/mls-protocol",
      "headRefName": "rohan/clientinfo",
      "headRefOid": "fd15f107d115980da1939845973a7dbb00984a8b",
      "closedAt": "2022-03-07T16:09:15Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing in favor of #612 ",
          "createdAt": "2022-03-07T16:09:15Z",
          "updatedAt": "2022-03-07T16:09:15Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOBoyH6c41wG4a",
          "commit": {
            "abbreviatedOid": "fd15f10"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Bunch of comments inline.  Overall, I think there are a bunch of helpful clarifications in here around KeyPackages, but I'm not sure the LeafNode -> ClientInfo rename is worthwhile, since we end up having to refer to LeafNodes anyway.",
          "createdAt": "2022-03-07T14:55:57Z",
          "updatedAt": "2022-03-07T15:21:25Z",
          "comments": [
            {
              "originalPosition": 49,
              "body": "Redundant, since the Add has KeyPackage in it.",
              "createdAt": "2022-03-07T14:55:57Z",
              "updatedAt": "2022-03-07T15:21:25Z"
            },
            {
              "originalPosition": 70,
              "body": "I don't love the aesthetics of this.  I would like to maintain the invariants that (a) extensions are always at the end of the message and (b) FooTBS is always clearly an extension of Foo.  You've done (b) here, but it's a little hidden in the `select`.  I think the original structs here are clearer, if a bit chattier.",
              "createdAt": "2022-03-07T15:05:09Z",
              "updatedAt": "2022-03-07T15:21:25Z"
            },
            {
              "originalPosition": 32,
              "body": "I would probably keep this under `# Ratchet Tree Node Contents`, even if we're going to rename to `ClientInfo`.  In general, struct are introduced in context, e.g., GroupInfo and Welcome are introduced in the context of the relevant join operations.",
              "createdAt": "2022-03-07T15:06:40Z",
              "updatedAt": "2022-03-07T15:21:25Z"
            },
            {
              "originalPosition": 152,
              "body": "This is incorrect.  The ClientInfo is used as a leaf in the tree for TreeKEM, regardless of how it got there.  This field says how it got there, thus `source`.",
              "createdAt": "2022-03-07T15:08:42Z",
              "updatedAt": "2022-03-07T15:21:25Z"
            },
            {
              "originalPosition": 170,
              "body": "```suggestion\r\nIn the case where the ClientInfo represents a leaf node inserted into the tree\r\n```",
              "createdAt": "2022-03-07T15:09:38Z",
              "updatedAt": "2022-03-07T15:21:25Z"
            },
            {
              "originalPosition": 249,
              "body": "Should this be LeafNode, to be consistent with the above?",
              "createdAt": "2022-03-07T15:17:20Z",
              "updatedAt": "2022-03-07T15:21:25Z"
            },
            {
              "originalPosition": 387,
              "body": "You removed this and never re-added it.  It needs to be defined somewhere.",
              "createdAt": "2022-03-07T15:18:43Z",
              "updatedAt": "2022-03-07T15:21:25Z"
            },
            {
              "originalPosition": 400,
              "body": "This trails off.",
              "createdAt": "2022-03-07T15:19:05Z",
              "updatedAt": "2022-03-07T15:21:26Z"
            },
            {
              "originalPosition": 400,
              "body": "In any case, this section should be deleted, because Lifetime isn't an extension any more.",
              "createdAt": "2022-03-07T15:20:30Z",
              "updatedAt": "2022-03-07T15:21:26Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c41wUa5",
          "commit": {
            "abbreviatedOid": "fd15f10"
          },
          "author": "rohan-wire",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-03-07T15:33:49Z",
          "updatedAt": "2022-03-07T15:33:50Z",
          "comments": [
            {
              "originalPosition": 152,
              "body": "The idea of how it got there being relevant even days later is a little weird, so adding an extra sentence or two explaining this would be useful. I started originally trying to do a lighter edit, and trying to say something reasonable that applies to KeyPackages, Proposals, and Commits without tripping over myself was a challenge.",
              "createdAt": "2022-03-07T15:33:49Z",
              "updatedAt": "2022-03-07T15:33:50Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c41wVEY",
          "commit": {
            "abbreviatedOid": "fd15f10"
          },
          "author": "rohan-wire",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-03-07T15:35:39Z",
          "updatedAt": "2022-03-07T15:35:39Z",
          "comments": [
            {
              "originalPosition": 170,
              "body": "Yours is better. What do you think of:\r\n...represents a leaf node once it is inserted into the tree.\r\n?",
              "createdAt": "2022-03-07T15:35:39Z",
              "updatedAt": "2022-03-07T15:35:39Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c41wVqI",
          "commit": {
            "abbreviatedOid": "fd15f10"
          },
          "author": "rohan-wire",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-03-07T15:37:21Z",
          "updatedAt": "2022-03-07T15:37:22Z",
          "comments": [
            {
              "originalPosition": 249,
              "body": "There was one place in the KeyPackage section where we were talking about lifetimes. In that case, I think the lifetime originally referred to the lifetime of the KeyPackage.",
              "createdAt": "2022-03-07T15:37:21Z",
              "updatedAt": "2022-03-07T15:37:22Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c41wV2M",
          "commit": {
            "abbreviatedOid": "fd15f10"
          },
          "author": "rohan-wire",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-03-07T15:37:55Z",
          "updatedAt": "2022-03-07T15:37:55Z",
          "comments": [
            {
              "originalPosition": 387,
              "body": "oops. My intent was only that it not appear in KeyPackages.",
              "createdAt": "2022-03-07T15:37:55Z",
              "updatedAt": "2022-03-07T15:37:55Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c41wV-5",
          "commit": {
            "abbreviatedOid": "fd15f10"
          },
          "author": "rohan-wire",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-03-07T15:38:17Z",
          "updatedAt": "2022-03-07T15:38:18Z",
          "comments": [
            {
              "originalPosition": 400,
              "body": "agreed.",
              "createdAt": "2022-03-07T15:38:18Z",
              "updatedAt": "2022-03-07T15:38:18Z"
            }
          ]
        }
      ]
    },
    {
      "number": 610,
      "id": "PR_kwDOBoyH6c40B9Ht",
      "title": "Explicitly allow for deniable signature keys",
      "url": "https://github.com/mlswg/mls-protocol/pull/610",
      "state": "CLOSED",
      "author": "kkohbrok",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "So far, deniable signature keys were permitted by the description of how to perform signature keys in the Content Authentication section, but not by the description of how to verify these signatures in the \"Processing a Commit\" section. This PR explicitly introduces the deniable signature keys and makes the handling of signatures consistent in both sections.",
      "createdAt": "2022-03-07T10:09:33Z",
      "updatedAt": "2022-03-11T17:56:25Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "fe5ec3acea1e8270f9ec9cdbf5f5378744bba14a",
      "headRepository": "kkohbrok/mls-protocol",
      "headRefName": "signature-key-indirection",
      "headRefOid": "beac8e068dc59005d96d5a8951b1c1a19543bae5",
      "closedAt": "2022-03-11T17:56:24Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "#437 didn't happen in a vacuum, but was merged after a discussion on the mailing list with the intent to leave a gap to allow for \"deniable\" keys.\r\n\r\nTo make sure that we're not claiming anything that we can't hold, I've changed the PR to not explicitly talk about \"deniable\" keys, but instead about \"alternative\" keys, the properties of which depend on their mode of distribution.\r\n\r\nAnother addition (as suggested by @bifurcation oob) that I intend to make is that of an explicit group context extension that ensures that group members agree on the use of these types of keys. I'll add this if there's agreement on the ML that we actually want all of this.",
          "createdAt": "2022-03-07T16:59:05Z",
          "updatedAt": "2022-03-07T17:00:18Z"
        },
        {
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I realize now that \"alternative keys\" is probably not the best name... but again, that can be changed if we agree that this is something we want.",
          "createdAt": "2022-03-07T17:00:58Z",
          "updatedAt": "2022-03-07T17:00:58Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing in favor of #617 in light of mailing list discussion",
          "createdAt": "2022-03-11T17:56:24Z",
          "updatedAt": "2022-03-11T17:56:24Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOBoyH6c41wIiP",
          "commit": {
            "abbreviatedOid": "0f9fd60"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "CHANGES_REQUESTED",
          "body": "Thanks, this was indeed inconsistent and didn't reflect what @claucece contributed a while back.",
          "createdAt": "2022-03-07T15:00:19Z",
          "updatedAt": "2022-03-07T15:04:34Z",
          "comments": [
            {
              "originalPosition": 19,
              "body": "Given that this mostly has to do with how the AS works (and therefore it's out-of-scope for the spec), it might be more concise and also sufficient to say that signature keys must be authenticated by the AS, and cite the distribution of signature keys over a deniable channel as an example.",
              "createdAt": "2022-03-07T15:00:20Z",
              "updatedAt": "2022-03-07T15:04:34Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c41wXn_",
          "commit": {
            "abbreviatedOid": "0f9fd60"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "I strongly object to this PR.  This is WONTFIX in my view.\r\n\r\nThis is introducing new ambiguity in the spec that is not there now.  Right now, the spec is clear that the keys used for signatures are the ones in the credential.\r\n\r\nIIUC the confusion here hinges on the following change from #437: Changing \"private key corresponding to the credential\" to \"private key corresponding to the public key authenticated by the credential\".\r\n\r\nThe current PR seems to assume that this allows the public key used to verify signatures to differ from the public key in the credential.  I don't see any plausible reading where that is the case.  Consider X.509 certificates -- the public key authenticated by the certificate is the public key in the certificate.\r\n\r\nIf other folks are unclear on that, we should clarify in the opposite direction, probably just by reverting #437.",
          "createdAt": "2022-03-07T15:42:45Z",
          "updatedAt": "2022-03-07T15:42:45Z",
          "comments": []
        }
      ]
    },
    {
      "number": 611,
      "id": "PR_kwDOBoyH6c40B_JI",
      "title": "Proposed editorial changes",
      "url": "https://github.com/mlswg/mls-protocol/pull/611",
      "state": "MERGED",
      "author": "rohan-wire",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Work in Progress editorial changes.",
      "createdAt": "2022-03-07T10:17:28Z",
      "updatedAt": "2022-03-07T18:54:56Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "fe5ec3acea1e8270f9ec9cdbf5f5378744bba14a",
      "headRepository": "rohan-wire/mls-protocol",
      "headRefName": "rohan/editorial",
      "headRefOid": "39af0dd426955673a8ff1004741522a39c2807e1",
      "closedAt": "2022-03-07T18:54:56Z",
      "mergedAt": "2022-03-07T18:54:56Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "35ad66dc8ded97407cf32b0a31894c67b6fe5179"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOBoyH6c41xG0F",
          "commit": {
            "abbreviatedOid": "44fcb9a"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-03-07T18:06:40Z",
          "updatedAt": "2022-03-07T18:09:04Z",
          "comments": [
            {
              "originalPosition": 89,
              "body": "```suggestion\r\nThe Credentials presented by the clients in a group authenticate\r\n```\r\n\r\n\"Credentials\" is the subject of \"authenticate\".",
              "createdAt": "2022-03-07T18:06:40Z",
              "updatedAt": "2022-03-07T18:09:04Z"
            },
            {
              "originalPosition": 135,
              "body": "```suggestion\r\nprivate key corresponding to the public key, which was authenticated by the \r\ncredential at the leaf of the tree indicated by the sender field. The signature\r\n```\r\n\r\nReverting this in light of ongoing discussion in #610 and on the mailing list.",
              "createdAt": "2022-03-07T18:07:42Z",
              "updatedAt": "2022-03-07T18:09:04Z"
            }
          ]
        }
      ]
    },
    {
      "number": 612,
      "id": "PR_kwDOBoyH6c40DV9W",
      "title": "Clean up LeafNode vs. KeyPackage",
      "url": "https://github.com/mlswg/mls-protocol/pull/612",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This PR picks up changes from #609 clarifying and cleaning up a few issues around LeafNode.",
      "createdAt": "2022-03-07T16:08:48Z",
      "updatedAt": "2022-03-07T16:14:41Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "fe5ec3acea1e8270f9ec9cdbf5f5378744bba14a",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "leafnode-rohan",
      "headRefOid": "0b08934efd7308adf9399785ba911cfcbc31be2f",
      "closedAt": "2022-03-07T16:14:41Z",
      "mergedAt": "2022-03-07T16:14:41Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "3c1c4f49ed5e9b56dc0dbc09d077b5f498b771cf"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOBoyH6c41wil0",
          "commit": {
            "abbreviatedOid": "0b08934"
          },
          "author": "rohan-wire",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "A big improvement in readability and correctness.",
          "createdAt": "2022-03-07T16:13:47Z",
          "updatedAt": "2022-03-07T16:13:47Z",
          "comments": []
        }
      ]
    },
    {
      "number": 613,
      "id": "PR_kwDOBoyH6c40Dx-x",
      "title": "Clarify some things about trees",
      "url": "https://github.com/mlswg/mls-protocol/pull/613",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This PR adds two clarifications suggested by @rohan-wire:\r\n\r\n1. Clarifying some antecedents in UpdatePath processing\r\n2. Explaining how the example trees can come about in practice",
      "createdAt": "2022-03-07T18:04:16Z",
      "updatedAt": "2022-03-07T18:55:11Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "3c1c4f49ed5e9b56dc0dbc09d077b5f498b771cf",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "tree-clarify",
      "headRefOid": "38a229f06d6936739a13342c7dc573b21e5f052d",
      "closedAt": "2022-03-07T18:55:10Z",
      "mergedAt": "2022-03-07T18:55:10Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "79f60a52062070b4683352b75d920002bd1c41e9"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 614,
      "id": "PR_kwDOBoyH6c40D_dH",
      "title": "More editorial changes from # Ratchet Tree Ops through # Group Evolution",
      "url": "https://github.com/mlswg/mls-protocol/pull/614",
      "state": "MERGED",
      "author": "rohan-wire",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2022-03-07T19:10:23Z",
      "updatedAt": "2022-03-07T21:13:01Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "79f60a52062070b4683352b75d920002bd1c41e9",
      "headRepository": "rohan-wire/mls-protocol",
      "headRefName": "rohan/editorial2",
      "headRefOid": "9f7770b7341b0681b27a39aee77837a908ed026e",
      "closedAt": "2022-03-07T21:13:01Z",
      "mergedAt": "2022-03-07T21:13:01Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "a481ebfdfebe641323c568144df3fc930827285a"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOBoyH6c41xcCB",
          "commit": {
            "abbreviatedOid": "5f5ebff"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-03-07T19:25:42Z",
          "updatedAt": "2022-03-07T19:45:11Z",
          "comments": [
            {
              "originalPosition": 139,
              "body": "```suggestion\r\nIn MLS, each such change is accomplished by a two-step process:\r\n```\r\n\r\nSince every change requires a proposal, stating this as Proposal/Commit first, then one-step below.",
              "createdAt": "2022-03-07T19:25:42Z",
              "updatedAt": "2022-03-07T19:45:11Z"
            },
            {
              "originalPosition": 145,
              "body": "```suggestion\r\n2. A member of the group or a new member broadcasts a Commit message that causes\r\n   one or more proposed changes to enter into effect\r\n   \r\nIn cases where the Proposal and Commit are sent by the same member, these two steps\r\ncan be combined by sending the proposals in the commit.\r\n```",
              "createdAt": "2022-03-07T19:26:36Z",
              "updatedAt": "2022-03-07T19:45:11Z"
            },
            {
              "originalPosition": 163,
              "body": "```suggestion\r\nidentifies the proposal to be applied by value or by reference.  Commits that\r\nrefer to new Proposals from the committer can be included by value. Commits\r\nfor previously sent proposals from anyone (including the committer) can be sent\r\nby reference.  Proposals sent by reference are specified by including the hash of\r\nthe MLSPlaintext in which the proposal was sent (see {{hash-based-identifiers}}).\r\n```",
              "createdAt": "2022-03-07T19:30:27Z",
              "updatedAt": "2022-03-07T19:45:11Z"
            },
            {
              "originalPosition": 199,
              "body": "```suggestion\r\nproposal type requires a path, then the proposal type requires a path. This\r\n```\r\n\r\nReverting because the emphasis here is on the \"requires path\" attribute being at the level of proposal types.",
              "createdAt": "2022-03-07T19:31:47Z",
              "updatedAt": "2022-03-07T19:45:11Z"
            },
            {
              "originalPosition": 209,
              "body": "```suggestion\r\n* Generate the provisional ratchet tree and GroupContext by applying the proposals\r\n```\r\n\r\nReverting because the choice of proposals happens earlier.  All proposals included in the initial commit need to be applied.",
              "createdAt": "2022-03-07T19:32:59Z",
              "updatedAt": "2022-03-07T19:45:11Z"
            },
            {
              "originalPosition": 220,
              "body": "```suggestion\r\n* If not populating the `path` field: Set the `path` field in the Commit to the\r\n  null optional.  Define `commit_secret` as the all-zero vector of length\r\n```\r\n\r\nReverting because the `path` field has type `optional<UpdatePath>`.",
              "createdAt": "2022-03-07T19:33:59Z",
              "updatedAt": "2022-03-07T19:45:11Z"
            },
            {
              "originalPosition": 231,
              "body": "```suggestion\r\n  * `group_id`: The group ID for the current group\r\n  * `epoch`: The epoch that the group will be in after this Commit\r\n```\r\n\r\nReverting because the PSK here refers to the last epoch of the earlier group.  So it has to use the old group's information.",
              "createdAt": "2022-03-07T19:36:26Z",
              "updatedAt": "2022-03-07T19:45:11Z"
            },
            {
              "originalPosition": 240,
              "body": "This is wrong, because we're talking about GroupInfo that the joiner consumes.  But this whole paragraph is wrong; will remove in a subsequent commit.",
              "createdAt": "2022-03-07T19:41:20Z",
              "updatedAt": "2022-03-07T19:45:11Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c41x2OK",
          "commit": {
            "abbreviatedOid": "9f7770b"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-03-07T21:12:53Z",
          "updatedAt": "2022-03-07T21:12:53Z",
          "comments": []
        }
      ]
    },
    {
      "number": 615,
      "id": "PR_kwDOBoyH6c40EbLH",
      "title": "Add changelog for draft-13",
      "url": "https://github.com/mlswg/mls-protocol/pull/615",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2022-03-07T21:27:47Z",
      "updatedAt": "2022-03-07T21:29:31Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "a481ebfdfebe641323c568144df3fc930827285a",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "changelog-13",
      "headRefOid": "c80b1442d754f5e5a56bb53474a88f6bbab78bf6",
      "closedAt": "2022-03-07T21:29:22Z",
      "mergedAt": "2022-03-07T21:29:22Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "c0079c6f9840d4589f574d1fef4c106b69653a8a"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 617,
      "id": "PR_kwDOBoyH6c40LKxN",
      "title": "Preconfigured senders extension and removal of signature key indirection",
      "url": "https://github.com/mlswg/mls-protocol/pull/617",
      "state": "MERGED",
      "author": "kkohbrok",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "This PR:\r\n- consolidates instructions on which key should be used to compute (and verify) a signature on an MLS message depending on the sender type\r\n- reverts #437 \r\n- introduces a `preconfigured_senders` extension that ensures that group members agree on preconfigured signature keys, as discussed in #616 and on the mailing list\r\n\r\nFixes #616.\r\n\r\n",
      "createdAt": "2022-03-09T14:04:30Z",
      "updatedAt": "2022-03-23T19:33:32Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "c0079c6f9840d4589f574d1fef4c106b69653a8a",
      "headRepository": "kkohbrok/mls-protocol",
      "headRefName": "preconfigured-senders",
      "headRefOid": "827580b617d17c13a84434f1c9e67fe315702ad3",
      "closedAt": "2022-03-23T19:33:32Z",
      "mergedAt": "2022-03-23T19:33:32Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "1c6aa098efc94d7e9e51ed16ba6c37b873bb4a22"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOBoyH6c4167Ai",
          "commit": {
            "abbreviatedOid": "1ddf05b"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Thanks @kkohbrok, this looks good to me.\r\n\r\nI wonder if it would be better to change \"preconfigured\" to \"external\". They're not really \"preconfigured\" in the sense of being \"configured out of band\", they're merely additional signers who are not in the group.",
          "createdAt": "2022-03-09T16:26:10Z",
          "updatedAt": "2022-03-09T19:06:39Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "```suggestion\r\n            uint32 sender_id;\r\n```",
              "createdAt": "2022-03-09T16:26:10Z",
              "updatedAt": "2022-03-09T19:06:39Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c417uPb",
          "commit": {
            "abbreviatedOid": "1ddf05b"
          },
          "author": "tomleavy",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-03-09T19:09:13Z",
          "updatedAt": "2022-03-09T19:09:14Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "I agree based on the changes made here that `external` makes more sense now",
              "createdAt": "2022-03-09T19:09:14Z",
              "updatedAt": "2022-03-09T19:09:14Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c417ubS",
          "commit": {
            "abbreviatedOid": "1ddf05b"
          },
          "author": "tomleavy",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Thanks for tackling this, looks good",
          "createdAt": "2022-03-09T19:09:57Z",
          "updatedAt": "2022-03-09T19:09:57Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOBoyH6c41_duS",
          "commit": {
            "abbreviatedOid": "ebf2bce"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-03-10T13:27:05Z",
          "updatedAt": "2022-03-10T13:27:06Z",
          "comments": [
            {
              "originalPosition": 45,
              "body": "```suggestion\r\n* `external`: The signature key contained in the Credential at the index\r\n  indicated by the `sender_index` in the `external_senders` group context\r\n  extension (see Section {{external-senders-extension}}).  In this case, the\r\n  `content_type` of the message MUST NOT be `commit`, since only members\r\n  of the group or new joiners can send Commit messages.\r\n```",
              "createdAt": "2022-03-10T13:27:06Z",
              "updatedAt": "2022-03-10T13:27:06Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c41_eIj",
          "commit": {
            "abbreviatedOid": "ebf2bce"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-03-10T13:28:25Z",
          "updatedAt": "2022-03-10T13:28:25Z",
          "comments": [
            {
              "originalPosition": 45,
              "body": "Could also be phrased as \"MUST be only `proposal` / `application`.  Or could be added below these bullets.",
              "createdAt": "2022-03-10T13:28:25Z",
              "updatedAt": "2022-03-10T13:28:25Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c42zDLE",
          "commit": {
            "abbreviatedOid": "a1e63a7"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-03-23T19:31:43Z",
          "updatedAt": "2022-03-23T19:31:44Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "```suggestion\r\n            uint32 sender_index;\r\n```",
              "createdAt": "2022-03-23T19:31:43Z",
              "updatedAt": "2022-03-23T19:31:44Z"
            }
          ]
        }
      ]
    },
    {
      "number": 618,
      "id": "PR_kwDOBoyH6c40sSIF",
      "title": "Require init key and leaf key to be different",
      "url": "https://github.com/mlswg/mls-protocol/pull/618",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This change ensures that the \"init\" key pair associated to the key package is one-time-use, at least to the degree that KeyPackages are one-time-use.  The init key pair is used to encrypt/decrypt the Welcome message, then never again.\r\n\r\nThe main drawback is requiring the KeyPackage sender to generate an additional key pair, which requires more computation and more entropy.",
      "createdAt": "2022-03-19T18:22:13Z",
      "updatedAt": "2022-03-23T19:30:32Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "c0079c6f9840d4589f574d1fef4c106b69653a8a",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "init-not-leaf",
      "headRefOid": "cc53944479b22c41e0a1d6c75143cb45acec3b4d",
      "closedAt": "2022-03-23T19:30:32Z",
      "mergedAt": "2022-03-23T19:30:32Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "a7c822eb72a597b2d46852420bb7938f1f82ad37"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOBoyH6c42u0vQ",
          "commit": {
            "abbreviatedOid": "cc53944"
          },
          "author": "TWal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-03-23T06:25:24Z",
          "updatedAt": "2022-03-23T06:25:24Z",
          "comments": []
        }
      ]
    },
    {
      "number": 619,
      "id": "PR_kwDOBoyH6c40xVgS",
      "title": "Clean up code blocks",
      "url": "https://github.com/mlswg/mls-protocol/pull/619",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "A few changes to make code blocks a little more consistent / usable / pretty:\r\n\r\n* Fence every code block with exactly three tildes\r\n* Mark each code block with a type (`aasvg` / `ascii-art` / `pseudocode` / `tls` / `python`)\r\n\r\nMarking with `aasvg` generates slightly prettier pictures for the ladder diagrams in the introduction.  Marking with `tls` makes it easy to programmatically extract the TLS syntax definitions in case we want to produce a syntax summary appendix like [the one TLS has](https://datatracker.ietf.org/doc/html/rfc8446#appendix-B), or in case implementers want to quickly get a listing of all the structs they need.  \r\n\r\nThe only substantive changes I made here were:\r\n\r\n1. Removing the `ReInit` lines from the branch and re-inject PSK illustrations\r\n2. Splitting pseudocode from TLS syntax in a few cases.",
      "createdAt": "2022-03-21T21:47:49Z",
      "updatedAt": "2022-03-23T19:30:18Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "c0079c6f9840d4589f574d1fef4c106b69653a8a",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "figure-pretty",
      "headRefOid": "795b702e9291e29962331e222aeff34e4a847fb5",
      "closedAt": "2022-03-23T19:30:18Z",
      "mergedAt": "2022-03-23T19:30:18Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "0a48ed20818b70ae664619843b8b046a55b4f2e8"
      },
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Yeah, I specifically had the idea because I wanted to pull out the TLS syntax blocks to update my implementation :)",
          "createdAt": "2022-03-23T11:22:40Z",
          "updatedAt": "2022-03-23T11:22:40Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOBoyH6c42u0pt",
          "commit": {
            "abbreviatedOid": "795b702"
          },
          "author": "TWal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Nice idea! It would also allow someone to compile the document with syntax coloration for TLS formats and Python code.",
          "createdAt": "2022-03-23T06:24:54Z",
          "updatedAt": "2022-03-23T06:24:54Z",
          "comments": []
        }
      ]
    },
    {
      "number": 620,
      "id": "PR_kwDOBoyH6c41ClSd",
      "title": "Add make target to extract TLS stanzas",
      "url": "https://github.com/mlswg/mls-protocol/pull/620",
      "state": "MERGED",
      "author": "rohan-wire",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Added a short python program to extract the TLS presentation language stanzas into a single file.\r\nAdded extract-tls make target to run it.\r\n\r\nAn equivalent one liner option (only in the Makefile) is commented out.",
      "createdAt": "2022-03-25T20:11:21Z",
      "updatedAt": "2022-03-28T18:22:58Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "1c6aa098efc94d7e9e51ed16ba6c37b873bb4a22",
      "headRepository": "rohan-wire/mls-protocol",
      "headRefName": "rohan/export-tls",
      "headRefOid": "a8536efb482528b573ee3f626de3888ff6148e9f",
      "closedAt": "2022-03-28T18:22:58Z",
      "mergedAt": "2022-03-28T18:22:58Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "fb7657fbb1a9303d44ae73f58e3d320985694c85"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOBoyH6c43DHej",
          "commit": {
            "abbreviatedOid": "0079588"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-03-28T18:21:28Z",
          "updatedAt": "2022-03-28T18:22:36Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "```suggestion\r\n```\r\n\r\nHaving a separate script is OK with me.",
              "createdAt": "2022-03-28T18:21:28Z",
              "updatedAt": "2022-03-28T18:22:36Z"
            }
          ]
        }
      ]
    },
    {
      "number": 621,
      "id": "PR_kwDOBoyH6c41CpNO",
      "title": "Add directions for newly required aasvg tools to README.md",
      "url": "https://github.com/mlswg/mls-protocol/pull/621",
      "state": "MERGED",
      "author": "rohan-wire",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Describe in README.md how to fetch the now required aasvg (ASCII art to SVG) and svgcheck tools.",
      "createdAt": "2022-03-25T20:34:14Z",
      "updatedAt": "2022-03-28T18:23:28Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "1c6aa098efc94d7e9e51ed16ba6c37b873bb4a22",
      "headRepository": "rohan-wire/mls-protocol",
      "headRefName": "rohan/readme-aasvg",
      "headRefOid": "354afe54a69d2cc91e272d29bb356283f6e508b3",
      "closedAt": "2022-03-28T18:23:28Z",
      "mergedAt": "2022-03-28T18:23:28Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "64824117512f7d458f40d62f05a034c6f7e503f6"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOBoyH6c43DH-Z",
          "commit": {
            "abbreviatedOid": "354afe5"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-03-28T18:23:23Z",
          "updatedAt": "2022-03-28T18:23:23Z",
          "comments": []
        }
      ]
    },
    {
      "number": 622,
      "id": "PR_kwDOBoyH6c41CtvE",
      "title": "Continue to make HTML drafts prettier with more SVG",
      "url": "https://github.com/mlswg/mls-protocol/pull/622",
      "state": "MERGED",
      "author": "rohan-wire",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Make more ASCII art render as SVG in HTML version of draft.\r\nFix one instance of pseudocode marked as TLS Presentation Language.",
      "createdAt": "2022-03-25T21:03:17Z",
      "updatedAt": "2022-03-28T19:02:12Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "1c6aa098efc94d7e9e51ed16ba6c37b873bb4a22",
      "headRepository": "rohan-wire/mls-protocol",
      "headRefName": "rohan/more-aasvg",
      "headRefOid": "d92a53c066824f23defb1d681403604a1e28e1f9",
      "closedAt": "2022-03-28T18:37:57Z",
      "mergedAt": "2022-03-28T18:37:57Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "000b9d04bac2a4da6c221b489f927e0f758d4058"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOBoyH6c42-IOn",
          "commit": {
            "abbreviatedOid": "e66efa6"
          },
          "author": "hrxi",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-03-26T02:55:56Z",
          "updatedAt": "2022-03-26T02:55:57Z",
          "comments": [
            {
              "originalPosition": 111,
              "body": "```suggestion\r\n~~~ pseudocode\r\n```",
              "createdAt": "2022-03-26T02:55:56Z",
              "updatedAt": "2022-03-26T02:55:57Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c43DJap",
          "commit": {
            "abbreviatedOid": "0ef3dc0"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-03-28T18:28:51Z",
          "updatedAt": "2022-03-28T18:35:50Z",
          "comments": [
            {
              "originalPosition": 57,
              "body": "```suggestion\r\n~~~ ascii-art\r\n```\r\n\r\nThis one doesn't work; the vertical arrows don't render. ",
              "createdAt": "2022-03-28T18:28:51Z",
              "updatedAt": "2022-03-28T18:35:50Z"
            },
            {
              "originalPosition": 102,
              "body": "```suggestion\r\n~~~ ascii-art\r\n```\r\n\r\nThis one doesn't quite work either; the bottom lines of the key/nonce forks don't render properly.",
              "createdAt": "2022-03-28T18:31:01Z",
              "updatedAt": "2022-03-28T18:35:50Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c43DMoq",
          "commit": {
            "abbreviatedOid": "d92a53c"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-03-28T18:36:41Z",
          "updatedAt": "2022-03-28T18:36:41Z",
          "comments": []
        }
      ]
    },
    {
      "number": 624,
      "id": "PR_kwDOBoyH6c41Kpcq",
      "title": "Sub-group branching requires fresh key packages for each member",
      "url": "https://github.com/mlswg/mls-protocol/pull/624",
      "state": "MERGED",
      "author": "tomleavy",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Based on #623 , it should be made explicit that sub-group branching requires a fresh key package for each member. I think there is still a conflict of wording here that I would like feedback on because of this line (which is what triggered me thinking there was a bug)\r\n\r\n```\r\nEach LeafNode in the new group's tree MUST be a leaf in the old group's tree at the epoch indicated in the PreSharedKey\r\n```",
      "createdAt": "2022-03-28T15:53:51Z",
      "updatedAt": "2022-04-12T22:20:54Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "1c6aa098efc94d7e9e51ed16ba6c37b873bb4a22",
      "headRepository": "tomleavy/mls-protocol",
      "headRefName": "branching-update",
      "headRefOid": "5f107cb7b7ef1b2bd2f6c2a9e77dc9b9bb2e8d2c",
      "closedAt": "2022-04-12T22:20:53Z",
      "mergedAt": "2022-04-12T22:20:53Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "01b56730d4bdcdac26441cea2e6078a4d63649a8"
      },
      "comments": [
        {
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thanks for the PR and thanks for digging into this. I think what the sentence is meant to say is that the receiver MUST check that the members of the new group are a subset of the members of the old group at that specific epoch.\r\n\r\nSince we're using new LeafNodes in the new group and we don't have a fixed notion of identity (at least not within MLS), we have to refer to the application/the AS to ensure that the identity expressed by the credential in each LeafNode in the subgroup has a corresponding identity (i.e. one that represents the same party) expressed by a credential in a LeafNode in the original group.\r\n\r\nMaybe something like:\r\n```\r\nThe members of the new group MUST be a subset of the members of the old group. When comparing identifiers across the old and the new group, the identifiers of a member in the new group MUST be such that they would represent a valid set of identifiers for the corresponding member in the old group as described in Section 8.3.    \r\n```\r\nThis leaves the possibility of a collision, where the identifiers in a given leaf in the new group would be valid updates to more than one member in the old group. This should probably be forbidden in general, although outside of this case it's not really a problem, because updates are always specific to one leaf. Alternatively, we could somehow include LeafNodeRefs that specifically indicate which member represents which other member. Or just leave it up to the application to sort this all out.",
          "createdAt": "2022-03-29T06:00:36Z",
          "updatedAt": "2022-03-29T06:00:36Z"
        },
        {
          "author": "tomleavy",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Curious what you think about saying the the credential has to be equal? We can determine equality of the credential itself just by doing tls serialization.",
          "createdAt": "2022-03-31T13:45:44Z",
          "updatedAt": "2022-03-31T13:45:44Z"
        },
        {
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Sure, requiring the credential to be exactly the same would be a simple way to figure out if it's the same party in both groups. However, I can imagine that some applications will want distinct credentials for each group. If we mandate that credentials are the same, this would force the application to use the same credential in every key package/LeafNode. Since subgroups can potentially be branched at any time and in any group, all key packages that a party publishes then have to have the same credential as all of the groups that party is in, so another party branching a subgroup can get hold of a KeyPackage with the same credential as the group the subgroup is branched off of.\r\n\r\nPersonally, I'd prefer asking the application to check that the identities of the new group are a subset of the identities of the original group.",
          "createdAt": "2022-03-31T13:52:59Z",
          "updatedAt": "2022-03-31T13:52:59Z"
        },
        {
          "author": "tomleavy",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I can see that being an issue, although I am somewhat worried about us not being opinionated in same way about how to determine equality here, mainly because of interop type things. We punt on how to validate the credentials as well in general so I guess this is in line with prior decisions",
          "createdAt": "2022-03-31T13:59:18Z",
          "updatedAt": "2022-03-31T13:59:43Z"
        },
        {
          "author": "tomleavy",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Hey @kkohbrok and @bifurcation check the change I just posted. @psyoptix and I put that together, it's a bit tough to get a generic definition of equivalency.",
          "createdAt": "2022-04-07T14:58:00Z",
          "updatedAt": "2022-04-07T14:58:00Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOBoyH6c43YEyQ",
          "commit": {
            "abbreviatedOid": "f98cc4c"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-04-01T14:58:47Z",
          "updatedAt": "2022-04-01T14:58:47Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOBoyH6c43ytFU",
          "commit": {
            "abbreviatedOid": "8f6cc1b"
          },
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Well put!",
          "createdAt": "2022-04-08T07:40:47Z",
          "updatedAt": "2022-04-08T07:41:21Z",
          "comments": [
            {
              "originalPosition": 26,
              "body": "```suggestion\r\n  group. In this context, a pair of LeafNodes is said to \"match\" if the\r\n```",
              "createdAt": "2022-04-08T07:40:47Z",
              "updatedAt": "2022-04-08T07:41:21Z"
            }
          ]
        }
      ]
    },
    {
      "number": 625,
      "id": "PR_kwDOBoyH6c41LjtZ",
      "title": "More aasvg usage",
      "url": "https://github.com/mlswg/mls-protocol/pull/625",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Continuing to convert more figures to SVG.\r\n\r\nThe remaining `ascii-art` figures are that way for two reasons:\r\n\r\n* Trees with blank nodes `_` render poorly with `aasvg`.  Replacements for the `_` character, like `-`, don't do much better.\r\n* The diagram showing the reuse guard application benefits from the byte-by-byte markers",
      "createdAt": "2022-03-28T19:53:21Z",
      "updatedAt": "2022-03-28T20:18:12Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "000b9d04bac2a4da6c221b489f927e0f758d4058",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "more-aasvg",
      "headRefOid": "cdaac8bcc4d9bf832cc0406dd64d15b0652e2c08",
      "closedAt": "2022-03-28T20:18:11Z",
      "mergedAt": "2022-03-28T20:18:11Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "984f2a4c4ff4a0b82e22d03b60b4f8f5bd5d90c1"
      },
      "comments": [
        {
          "author": "rohan-wire",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think these look good. I didn't modify the trees for the reasons you mentioned. In general I have two concerns to keep an eye out for:\r\n- Make sure the overall width of aasvg ASCII version does not exceed 72 chars\r\n- ASCII version of the art shouldn't look substantially worse. Using . and + in some cases looks a bit worse but is still understandable\r\n\r\nIs the Key Schedule the oblong blob or is it derived from the blob?  My read of that section was that it is derived from the blob.\r\n",
          "createdAt": "2022-03-28T20:08:35Z",
          "updatedAt": "2022-03-28T20:08:35Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "* All the `ascii-art` figures fit within 72 columns.  I trimmed some `tls` and `python` ones to fit\r\n* I think the ASCII still looks OK with these.  Guess people can opine in WGLC if they don't like it :)\r\n* Key Schedule is the blob (IMO)",
          "createdAt": "2022-03-28T20:18:02Z",
          "updatedAt": "2022-03-28T20:18:02Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 626,
      "id": "PR_kwDOBoyH6c41Ll4H",
      "title": "Move MIME type registration from ascii-art to definition list",
      "url": "https://github.com/mlswg/mls-protocol/pull/626",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2022-03-28T20:02:13Z",
      "updatedAt": "2022-03-28T20:18:20Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "000b9d04bac2a4da6c221b489f927e0f758d4058",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "iana-mime-style",
      "headRefOid": "95f3b3a374c2de0d3ea31b820bed1c5a820ce97f",
      "closedAt": "2022-03-28T20:18:20Z",
      "mergedAt": "2022-03-28T20:18:20Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "75dc112c95e546ea7c888202c14e154798439355"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOBoyH6c43Dl0E",
          "commit": {
            "abbreviatedOid": "95f3b3a"
          },
          "author": "rohan-wire",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-03-28T20:09:41Z",
          "updatedAt": "2022-03-28T20:09:41Z",
          "comments": []
        }
      ]
    },
    {
      "number": 628,
      "id": "PR_kwDOBoyH6c41dKSR",
      "title": "Strawman proposal to include BasicCredential in any Credential type",
      "url": "https://github.com/mlswg/mls-protocol/pull/628",
      "state": "CLOSED",
      "author": "rohan-wire",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "I was thinking about a possible proliferation of credentials. This could mean a lot more KeyPackages and it could lead to situations where some members are added to a group and use some fancy or rather esoteric credential scheme and then want to invite other new clients, but not all the new clients support that credential scheme.\r\n\r\nThis strikes me as potentially unnecessary. If all clients support BasicCredential, why not include a BasicCredential in every other Credential (it would be a copy of the identity and public key from your X.509Certificate or ProofCredential or JsonWebCredential or CborWebTokenCredential or whatever).\r\n\r\nMaybe this makes it a lot easier to add new credential types later as in the ProofCredential discussion [1] because the new credential does not prevent communication with other other clients.\r\n\r\n[1] https://github.com/mlswg/mls-protocol/pull/592",
      "createdAt": "2022-04-01T02:22:40Z",
      "updatedAt": "2022-05-02T18:17:12Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "75dc112c95e546ea7c888202c14e154798439355",
      "headRepository": "rohan-wire/mls-protocol",
      "headRefName": "rohan/basic-cred",
      "headRefOid": "2883d6319d9e7e8571ad24544ee52746ff5733bb",
      "closedAt": "2022-05-02T18:17:12Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "body": "I like the general idea. Right now the spec effectively only allows X.509 certs besides BasicCredentials and that might be limiting (which is probably what motivated #592). Maybe the two ideas could be combined? Every KeyPackage would have a BasicCredential that can be used for the MLS-internal verification of signatures and additionally provide proof data that the AS can parse and validate. An X.509 certificate chain would just be one instance of such proof data. I think this would make for a nice separation between what MLS needs for its security guarantees/the stuff the AS needs to agree on.",
          "createdAt": "2022-04-01T08:25:51Z",
          "updatedAt": "2022-04-01T08:25:51Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "I think the proposal here is actually a little incoherent.  On the one hand, you only need this proposal if the recipient doesn't know how to parse the credential and extract the public key.  On the other hand, the recipient needs to know how to parse the credential enough to read past it.  I guess you could, for example, have a stack that can parse past an X.509 cert chain, but not parse within the certificates.  But that seems like a pretty fine distinction.\r\n\r\nTo enable a recipient to be totally ignorant of the credential type, you would need to elide even more detail, something like:\r\n\r\n```\r\nstruct {\r\n    CredentialType type;\r\n    opaque authentication_info<V>; // contents defined by `type`\r\n    SignatureScheme scheme;\r\n    opaque public_key<V>;\r\n} Credential;\r\n```\r\n\r\nAll that said, it's still not totally clear to me that we should do this.  I can see the conceptual appeal to these approaches.  It's the AS's job to know about credentials, and MLS just transports them and makes sure they're signed to prevent identity mis-binding.  There are some costs, though:\r\n\r\n* Message bloat: With X509 or other schemes where credentials include the public key, you would end up repeating the public key on the inside and outside of the credential.  This could be painful for PQ schemes with huge keys.  Fixable with gzip, but still.\r\n\r\n* Error prone: Since the public key is represented in two places, the client will have to check that they correspond.\r\n\r\n* Fail slow / fail open: Allowing incompatibilities like this effectively allows for groups where some members are unauthenticated (since their credentials can't be validated by everyone else).  While this ultimately comes down to the AS anyway, there's increased risk that unintended openness at the AS (say allowing unknown credential types) will go unnoticed, since the protocol will continue to work.\r\n\r\nSo I don't have hard objections here, but I do feel a bit queasy.\r\n",
          "createdAt": "2022-04-01T15:33:52Z",
          "updatedAt": "2022-04-01T15:33:52Z"
        },
        {
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "body": "I agree with your concerns regarding duplication. The upside is however a clear split between what's relevant for the protocol (just the stuff in the BasicCredential) and the stuff for the AS. This would make for a much more modular composition of a generic protocol implementation like mlspp or OpenMLS and a more application-specific AS.",
          "createdAt": "2022-04-01T16:53:33Z",
          "updatedAt": "2022-04-01T16:53:33Z"
        },
        {
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I also don't have a strong opinion on this, but we might as well simplify it even further and remove credential types altogether. MLS doesn't care about what's in `authentication_info`, so why even communicate the type? The application might want to know, but we could leave that up to the AS in the same way as we do with the content type in application messages.\r\n\r\nThis would leave us with the same drawbacks that @bifurcation listed, but gain us some more simplicity.",
          "createdAt": "2022-04-02T06:37:03Z",
          "updatedAt": "2022-04-02T06:37:03Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Strong disagree on removing credential types @kkohbrok.  This protocol needs to be clear on what's in the `authentication_info`, even if that information is ultimately only processed by the application.\r\n\r\nOn thinking on this a bit further: I think the concerns about \"Fail slow / fail open\" are adequately addressed by #631.  And it's not clear to me that any format besides X.509 will end up with the duplication that causes the other issues.  (Though there will be some, since the `auth_info` will have to have some binding to the key.)\r\n\r\nSo I would be OK with this PR if we refactor to the \"public key + auth_info\" framework I sketched. ",
          "createdAt": "2022-04-12T22:38:39Z",
          "updatedAt": "2022-04-12T22:38:39Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "@rohan-wire Note that I filed #637 as an alternative approach here.  But as discusssed there, I think any of these approaches where we factor the public key out of the credential risks invites bad design patterns in future credentials.\r\n\r\nSo I'm inclined to burn down this strawman, and close both this PR and #637.",
          "createdAt": "2022-04-29T17:53:03Z",
          "updatedAt": "2022-04-29T17:53:03Z"
        },
        {
          "author": "rohan-wire",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> I think any of these approaches where we factor the public key out of the credential risks invites bad design patterns in future credentials.\r\n\r\nI don't think that is happening at all here. We are putting the public key in a consistent place. The individual credential types can reference it or duplicate it as required by their syntax, but the public key is always there.\r\n",
          "createdAt": "2022-05-02T06:40:51Z",
          "updatedAt": "2022-05-02T06:40:51Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing in favor of #637 ",
          "createdAt": "2022-05-02T18:17:12Z",
          "updatedAt": "2022-05-02T18:17:12Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 629,
      "id": "PR_kwDOBoyH6c41fuQw",
      "title": "Add Path Required to Proposal Type template",
      "url": "https://github.com/mlswg/mls-protocol/pull/629",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #627 ",
      "createdAt": "2022-04-01T15:01:54Z",
      "updatedAt": "2022-04-01T15:03:15Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "75dc112c95e546ea7c888202c14e154798439355",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "path-required-description",
      "headRefOid": "c0c0f259f1bf82aed480d59c273776e2167e90ef",
      "closedAt": "2022-04-01T15:03:15Z",
      "mergedAt": "2022-04-01T15:03:14Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "d21177766dc0f3e245dcd8d668695c4283c3d58a"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 631,
      "id": "PR_kwDOBoyH6c41gvhl",
      "title": "Specify compatibility behavior around new credentials.",
      "url": "https://github.com/mlswg/mls-protocol/pull/631",
      "state": "MERGED",
      "author": "Bren2010",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This PR adds a way for the members of a group to indicate the credential types they support, and how to negotiate which credential types may be used in a group.",
      "createdAt": "2022-04-01T20:10:55Z",
      "updatedAt": "2022-05-06T15:42:09Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "d21177766dc0f3e245dcd8d668695c4283c3d58a",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "brendan/credentials2",
      "headRefOid": "f35409362c551b6b3901e901c06352fc16451d0f",
      "closedAt": "2022-05-02T18:21:32Z",
      "mergedAt": "2022-05-02T18:21:32Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "e472c65195e0b3795dc914dfd38829729afdd353"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOBoyH6c44CpcR",
          "commit": {
            "abbreviatedOid": "3ba066f"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "This seems like a good idea, thanks @Bren2010!",
          "createdAt": "2022-04-12T22:29:55Z",
          "updatedAt": "2022-04-12T22:29:55Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOBoyH6c44C5pP",
          "commit": {
            "abbreviatedOid": "3ba066f"
          },
          "author": "rohan-wire",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "> The types of credential that may be used in a group is restricted to what all\r\n> members of the group support...\r\n\r\nI think this is too restrictive if we adopt PR #628 . I think it is between the client and its AS if all the clients need to support every credential type used in the group.\r\n\r\nIf you agree with the concept, I am happy to propose slight changes.",
          "createdAt": "2022-04-13T00:41:29Z",
          "updatedAt": "2022-04-13T00:41:29Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOBoyH6c44Ev8m",
          "commit": {
            "abbreviatedOid": "3ba066f"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "I think this makes sense.",
          "createdAt": "2022-04-13T10:38:02Z",
          "updatedAt": "2022-04-13T10:38:02Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOBoyH6c45Lnm5",
          "commit": {
            "abbreviatedOid": "3ba066f"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "I discussed this offline with @rohan-wire and we arrived at:\r\n\r\n* We might need multiple credentials later (as I suspect)\r\n* If we do that (say in an extension), we will need to update this text\r\n* We should capture the general theory that covers both single- and multiple-credential cases\r\n\r\nThe proposed additions here just abstract the principle of universal compatibility (which we need in a single-credential world) to one of \"at least something\" compatibility (which is more compatible with a multi-credential world).",
          "createdAt": "2022-05-02T17:31:53Z",
          "updatedAt": "2022-05-02T17:38:49Z",
          "comments": [
            {
              "originalPosition": 71,
              "body": "```suggestion\r\n## Credential Extensibility\r\n\r\nIn order to ensure that MLS provides meaningful authentication it is important\r\nthat each member is able to authenticate some identity information for each\r\nother member.  Identity information is encoded in Credentials, so this property\r\nis assured by ensuring that members use compatible credential types.\r\n\r\n```",
              "createdAt": "2022-05-02T17:31:53Z",
              "updatedAt": "2022-05-02T17:38:49Z"
            },
            {
              "originalPosition": 84,
              "body": "```suggestion\r\n\r\nIn future extensions to MLS, it may be useful to allow a member to present more\r\nthan one credential.  For example, such credentials might present different\r\nattributes attested by different authorities.  To be consistent with the general\r\nprinciple stated at the beginning of this section, such an extension would need\r\nto ensure that each member can authenticate some identity for each other member.\r\nFor each pair of members (Alice, Bob), Alice would need to present at least one\r\ncredential of a type that Bob supports.\r\n```",
              "createdAt": "2022-05-02T17:32:19Z",
              "updatedAt": "2022-05-02T17:38:49Z"
            }
          ]
        }
      ]
    },
    {
      "number": 632,
      "id": "PR_kwDOBoyH6c41hOpo",
      "title": "fix the switch condition for LeafNodeSource",
      "url": "https://github.com/mlswg/mls-protocol/pull/632",
      "state": "MERGED",
      "author": "suhasHere",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2022-04-02T00:20:52Z",
      "updatedAt": "2022-04-12T22:17:55Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "d21177766dc0f3e245dcd8d668695c4283c3d58a",
      "headRepository": "suhasHere/mls-protocol",
      "headRefName": "suhas",
      "headRefOid": "eca7c7c597f680c009f4afdc1e545b05e0a3f08e",
      "closedAt": "2022-04-12T22:17:55Z",
      "mergedAt": "2022-04-12T22:17:55Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "47de5eec3a27eac962012d7e93cfa3e67e483971"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 634,
      "id": "PR_kwDOBoyH6c42InEV",
      "title": "Add missing mention of P-384",
      "url": "https://github.com/mlswg/mls-protocol/pull/634",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #633 ",
      "createdAt": "2022-04-12T22:25:23Z",
      "updatedAt": "2022-04-12T22:26:15Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "01b56730d4bdcdac26441cea2e6078a4d63649a8",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "p-384",
      "headRefOid": "ce12414586cadd664686cbb06025af2e233fdb6c",
      "closedAt": "2022-04-12T22:26:15Z",
      "mergedAt": "2022-04-12T22:26:15Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "172b7235d91491efb066c4808327fc600f61b0cd"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 635,
      "id": "PR_kwDOBoyH6c42cWK5",
      "title": "Fix parent hash",
      "url": "https://github.com/mlswg/mls-protocol/pull/635",
      "state": "MERGED",
      "author": "mulmarta",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "The current draft implements the original incorrect version of the tree-hash-for-parent-hash mechanism proposed in #527. That version [breaks in some border cases](https://github.com/mlswg/mls-protocol/pull/527#issuecomment-1020387612). This PR implements the corrected \"full-extension + tree hash\" mechanism proposed by @TWal [here](https://github.com/mlswg/mls-protocol/pull/527#issuecomment-1035122916).",
      "createdAt": "2022-04-19T18:09:25Z",
      "updatedAt": "2022-04-28T12:56:00Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "172b7235d91491efb066c4808327fc600f61b0cd",
      "headRepository": "mulmarta/mls-protocol",
      "headRefName": "fix-parent-hash",
      "headRefOid": "57241833637e1e3e4100d80f7d3210a9902f74f8",
      "closedAt": "2022-04-28T12:55:59Z",
      "mergedAt": "2022-04-28T12:55:59Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "e9ab1075a816fdc88851d1b6c4db5987dd537aec"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOBoyH6c4489B7",
          "commit": {
            "abbreviatedOid": "9374a5d"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Thanks for finding yet more parent-hash issues @mulmarta :) \r\n\r\nI was initially concerned about this approach, because it seemed like it would be expensive to fill out the tree.  However, (a) we only incur that cost for the `log(N)` nodes on the right edge of the tree, and (b) the extra nodes to the right are \"virtual\", in the sense that they don't take up any memory, they just cause some extra hashes.  I [prototyped this in MLSpp](https://github.com/cisco/mlspp/commit/dc35e790c5d6b22cb3307ed6973084d1315db741) and it was pretty straightforward (that also allowed me to verify that it fixes the pathological case that @mulmarta notes).\r\n\r\nOverall, this looks good to merge once we get the noted nits fixed.",
          "createdAt": "2022-04-27T20:30:41Z",
          "updatedAt": "2022-04-27T20:36:57Z",
          "comments": [
            {
              "originalPosition": 35,
              "body": "```suggestion\r\n  T       _       X[F]   |\r\n```\r\n\r\nI think this is what you mean if you want to get the result below?",
              "createdAt": "2022-04-27T20:30:41Z",
              "updatedAt": "2022-04-27T20:36:58Z"
            },
            {
              "originalPosition": 14,
              "body": "Suggest \"Extend the subtree of S by adding blank leaves\".  Also, since we don't talk much about \"full\", a reminder might be helpful here, say \"(i.e., until its size is a power of 2)\".",
              "createdAt": "2022-04-27T20:31:50Z",
              "updatedAt": "2022-04-27T20:36:58Z"
            },
            {
              "originalPosition": 118,
              "body": "```suggestion\r\n* A adds a new member at F in a partial Commit, adding F as unmerged at X, Y, and W\r\n```",
              "createdAt": "2022-04-27T20:33:30Z",
              "updatedAt": "2022-04-27T20:36:58Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c45AEQr",
          "commit": {
            "abbreviatedOid": "9374a5d"
          },
          "author": "mulmarta",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-04-28T12:04:07Z",
          "updatedAt": "2022-04-28T12:04:08Z",
          "comments": [
            {
              "originalPosition": 35,
              "body": "Actually, it's the result below that's wrong. This tree couldn't result from any execution. Reason: after the \"omit redundant nodes\" PR, X would never be inserted by E's commit if F was blank at the time. I changed the result.",
              "createdAt": "2022-04-28T12:04:07Z",
              "updatedAt": "2022-04-28T12:04:08Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c45AEVl",
          "commit": {
            "abbreviatedOid": "9374a5d"
          },
          "author": "mulmarta",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-04-28T12:04:24Z",
          "updatedAt": "2022-04-28T12:04:24Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "Done. Hope it's better now.",
              "createdAt": "2022-04-28T12:04:24Z",
              "updatedAt": "2022-04-28T12:04:25Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c45AEih",
          "commit": {
            "abbreviatedOid": "9374a5d"
          },
          "author": "mulmarta",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-04-28T12:05:10Z",
          "updatedAt": "2022-04-28T12:05:10Z",
          "comments": [
            {
              "originalPosition": 118,
              "body": "I removed X from the tree, so the current version is correct again.",
              "createdAt": "2022-04-28T12:05:10Z",
              "updatedAt": "2022-04-28T12:05:10Z"
            }
          ]
        }
      ]
    },
    {
      "number": 636,
      "id": "PR_kwDOBoyH6c428kNB",
      "title": "Clean up terminology of derived secrets/keys",
      "url": "https://github.com/mlswg/mls-protocol/pull/636",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #630 ",
      "createdAt": "2022-04-28T13:23:34Z",
      "updatedAt": "2022-04-29T06:06:14Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "e9ab1075a816fdc88851d1b6c4db5987dd537aec",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "secret-key",
      "headRefOid": "a5b94c05a56e28f2d6d3b89503b4ea71f7c40614",
      "closedAt": "2022-04-28T16:50:38Z",
      "mergedAt": "2022-04-28T16:50:38Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "66a59c7c3880b21a49f32cd8aaf2af3e93c8d40e"
      },
      "comments": [
        {
          "author": "mulmarta",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Looks good! I would maybe add 1 sentence explaining the rule for what is called a secret and what is called a key. The rule says that a secret will go through some key derivation to obtain a key/keys, is that right?",
          "createdAt": "2022-04-28T16:20:08Z",
          "updatedAt": "2022-04-28T16:20:08Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "@mulmarta Yep, that's exactly right.  Added a sentence.\r\n\r\nThanks for the feedback everyone!",
          "createdAt": "2022-04-28T16:49:01Z",
          "updatedAt": "2022-04-28T16:49:01Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOBoyH6c45Ax_L",
          "commit": {
            "abbreviatedOid": "1d9359b"
          },
          "author": "TWal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "Things are easier to understand like this!\r\n\r\nThe \"Purpose\" column is quite valuable I think, I remember I was quite overwhelmed when I first read it and had no idea what all those secret / keys were used for. This helps to understand the big picture.",
          "createdAt": "2022-04-28T14:08:37Z",
          "updatedAt": "2022-04-28T14:10:59Z",
          "comments": [
            {
              "originalPosition": 22,
              "body": "Isn't it to prove the membership of the current epoch, to be used in a future epoch?",
              "createdAt": "2022-04-28T14:08:37Z",
              "updatedAt": "2022-04-28T14:10:59Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c45Azn9",
          "commit": {
            "abbreviatedOid": "1d9359b"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-04-28T14:12:40Z",
          "updatedAt": "2022-04-28T14:12:40Z",
          "comments": [
            {
              "originalPosition": 22,
              "body": "Ah, good point, will revise.",
              "createdAt": "2022-04-28T14:12:40Z",
              "updatedAt": "2022-04-28T14:12:40Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c45A_yz",
          "commit": {
            "abbreviatedOid": "af3c5ec"
          },
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "Looks good in general, although I think we should keep the authentication secret a secret rather than a code, since it might be used to do other things than just straight-up compare it. Since it's up to the application to decide how exactly to use it, we should call it a secret and if the application wants to do something with it, it should probably do an additional derivation anyway to make sure there's no potential key-reuse.",
          "createdAt": "2022-04-28T14:41:31Z",
          "updatedAt": "2022-04-28T14:47:25Z",
          "comments": [
            {
              "originalPosition": 23,
              "body": "I'd still call this \"secret\" instead of \"code\", since it's not clear that it's just going to be compared. I could also be used to derive keys for other primitives that are then used for authentication, e.g. to compute a MAC. This also applies to the text changes below.",
              "createdAt": "2022-04-28T14:41:31Z",
              "updatedAt": "2022-04-28T14:47:25Z"
            },
            {
              "originalPosition": 22,
              "body": "The text calls this a PSK, but come to think of it, this is really more of a secret that is then used to derive the proper PSK(s). But then again, I guess it is a key and it is pre-shared, so why wouldn't it be called a PSK?",
              "createdAt": "2022-04-28T14:44:35Z",
              "updatedAt": "2022-04-28T14:47:25Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c45BDWm",
          "commit": {
            "abbreviatedOid": "af3c5ec"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-04-28T14:49:34Z",
          "updatedAt": "2022-04-28T14:49:35Z",
          "comments": [
            {
              "originalPosition": 22,
              "body": "Yeah, it gets used via the `PreSharedKey` proposal, so let's just call it that :)",
              "createdAt": "2022-04-28T14:49:35Z",
              "updatedAt": "2022-04-28T14:49:35Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c45BEoc",
          "commit": {
            "abbreviatedOid": "af3c5ec"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-04-28T14:52:17Z",
          "updatedAt": "2022-04-28T14:52:17Z",
          "comments": [
            {
              "originalPosition": 23,
              "body": "I don't like \"secret\" for this because that makes it sound like the security of the protocol is degraded if it is revealed -- which is true of all the other \"secrets\" here. (Also \"keys\" and sort of \"psk\".)  The authentication value, by contrast, is intended to be safe to send raw out-of-band (e.g., displayed in a Webex meeting!) without degrading the security of the protocol.",
              "createdAt": "2022-04-28T14:52:17Z",
              "updatedAt": "2022-04-28T14:52:17Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c45BFmz",
          "commit": {
            "abbreviatedOid": "af3c5ec"
          },
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-04-28T14:54:39Z",
          "updatedAt": "2022-04-28T14:54:39Z",
          "comments": [
            {
              "originalPosition": 23,
              "body": "Ah, I see what you mean. But the same goes for the exporter secret, doesn't it?",
              "createdAt": "2022-04-28T14:54:39Z",
              "updatedAt": "2022-04-28T14:54:39Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c45BGZW",
          "commit": {
            "abbreviatedOid": "af3c5ec"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-04-28T14:56:39Z",
          "updatedAt": "2022-04-28T14:56:39Z",
          "comments": [
            {
              "originalPosition": 23,
              "body": "Same goes for the export**ed** secrets, and we just call those `exported_value`.  But the `exporter_secret` is an input to the key derivation, so in keeping with the \"secret\" == \"input to HKDF\" scheme, it makes sense.",
              "createdAt": "2022-04-28T14:56:39Z",
              "updatedAt": "2022-04-28T14:56:39Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c45BIiy",
          "commit": {
            "abbreviatedOid": "af3c5ec"
          },
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-04-28T15:01:55Z",
          "updatedAt": "2022-04-28T15:01:55Z",
          "comments": [
            {
              "originalPosition": 23,
              "body": "Ah, good point. I had missed that. I guess if we wanted to use the authentication secret/code for something else than comparison, we'd have to go the same route as with the exporter secret/exported values. I'd be ok to call it \"code\", at least until we figure out a good way to use it beyond comparison.",
              "createdAt": "2022-04-28T15:01:55Z",
              "updatedAt": "2022-04-28T15:01:55Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c45B0w6",
          "commit": {
            "abbreviatedOid": "a5b94c0"
          },
          "author": "br-hale",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-04-28T17:05:30Z",
          "updatedAt": "2022-04-28T17:05:31Z",
          "comments": [
            {
              "originalPosition": 23,
              "body": "I am not OK with it being called a 'code' as that implies it should be used directly without further derivation. If an application uses it directly without proper combinations of other information, that is the responsibility of the developer (or perhaps the \"irresponsibilty\"). Such behavior should not be inferred in the spec.",
              "createdAt": "2022-04-28T17:05:30Z",
              "updatedAt": "2022-04-28T17:05:31Z"
            }
          ]
        }
      ]
    },
    {
      "number": 637,
      "id": "PR_kwDOBoyH6c428ulN",
      "title": "Ensure that a signature public key is always intelligible",
      "url": "https://github.com/mlswg/mls-protocol/pull/637",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This PR moves the signature key from `Credential` to `LeafNode`, to ensure that an MLS client always has a signature public key with which to verify messages, even if it does not support a member's credential type.\r\n\r\nThis is an alternative approach to #628, and IMO a bit cleaner.  We no longer need the notion of a SignatureScheme, since BasicCredential doesn't stand alone.  And since Credential only appears in LeafNode, common fields can be hoisted up into LeafNode. The Credential struct really only exists as a conceptual boundary, to make the exposition clearer; otherwise you could just shove the `select` into LeafNode.\r\n\r\nNote that this does not obviate the need for #631.  This PR only ensures that the signatures can be processed; that PR helps ensure that the signatures are meaningful.",
      "createdAt": "2022-04-28T13:58:50Z",
      "updatedAt": "2022-05-02T18:21:49Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "e9ab1075a816fdc88851d1b6c4db5987dd537aec",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "always-pk",
      "headRefOid": "4957d50bd09b54efe9233808b5efcd500be3e001",
      "closedAt": "2022-05-02T18:21:49Z",
      "mergedAt": "2022-05-02T18:21:49Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "28354251c1ee5a2e8a96304c6604461a834a0063"
      },
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "@kkohbrok - As I noted in the intro comment, I think you can view these two PRs as addressing different levels of interop -- the mechanics of verifying signatures vs. the ability to actually meaningfully interpret a credential.  Always having the key in the same place could also allow some minor simplification to implementation logic\r\n\r\nIt's also interesting to consider what this would imply for future credential types.  On the one hand, they wouldn't need to recite the public key, just provide a binding to it, like a hash or a signature where the public key was filled in from outside.  On the other hand, it would open up the door to credential types that aren't actually bound to the public key, which creates replay risk.\r\n\r\nIn any case, as the above might hint, I don't have strong feelings about this.  I mainly wanted to present an alternative to #628 that was more palatable to me.  Given the replay risk noted above, though, I think I'm trending toward closing both this PR and #628, and just keeping the current structure with the improved compatibilty bounds provided by #631.",
          "createdAt": "2022-04-29T17:50:19Z",
          "updatedAt": "2022-04-29T17:50:19Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Latest commit responds to some offline comments from @rohan-wire: \r\n\r\n* Having `public_key` and `signature_key` makes it a little confusing what `public_key` is about.  So changed to `encryption_key` and propagated that change throughout.\r\n* The definition of `SignaturePublicKey` fits better in the ciphersuites section (next to `HPKEPublicKey`) than it does in the credentials section\r\n\r\nHaving done that, I'm more positive on this change.  The `encryption_key` change is a good clarification, and having the signature public key separate from the credential provides a stonger decoupling of the credential from the MLS crypto. The only thing the credential layer needs to know now is how to bind to the signature key.",
          "createdAt": "2022-05-02T18:14:30Z",
          "updatedAt": "2022-05-02T18:14:30Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOBoyH6c45DvD-",
          "commit": {
            "abbreviatedOid": "483ab6b"
          },
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "Can you elaborate on why we need this if we also mandate that all clients have to support the credential types of all other clients? I would think that if a client supports a credential type, it knows how to extract the signature public key from that credential.",
          "createdAt": "2022-04-29T06:10:08Z",
          "updatedAt": "2022-04-29T06:16:58Z",
          "comments": [
            {
              "originalPosition": 38,
              "body": "```suggestion\r\napplication to decide which identifier or identifiers to use at the application\r\n```",
              "createdAt": "2022-04-29T06:10:09Z",
              "updatedAt": "2022-04-29T06:16:58Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c45Ly1H",
          "commit": {
            "abbreviatedOid": "4957d50"
          },
          "author": "rohan-wire",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-05-02T18:14:23Z",
          "updatedAt": "2022-05-02T18:14:23Z",
          "comments": []
        }
      ]
    },
    {
      "number": 639,
      "id": "PR_kwDOBoyH6c43GZvK",
      "title": "Clarify secret/key; change to epoch authenticator",
      "url": "https://github.com/mlswg/mls-protocol/pull/639",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #638 ",
      "createdAt": "2022-04-29T20:55:59Z",
      "updatedAt": "2022-05-01T14:24:17Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "66a59c7c3880b21a49f32cd8aaf2af3e93c8d40e",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "terminology-v2",
      "headRefOid": "7fe8b3e16173487ba2b16cf764200c75866e636f",
      "closedAt": "2022-05-01T14:24:16Z",
      "mergedAt": "2022-05-01T14:24:16Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "7a995af42e9a9047b83dc4a9169b1fedd445052e"
      },
      "comments": [
        {
          "author": "br-hale",
          "authorAssociation": "CONTRIBUTOR",
          "body": "That looks like a good change and clarification. I added a couple small changes in in-line comments above.",
          "createdAt": "2022-04-29T21:11:06Z",
          "updatedAt": "2022-04-29T21:11:06Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks for the review @br-hale, and thanks for hashing through this.",
          "createdAt": "2022-04-29T21:15:38Z",
          "updatedAt": "2022-04-29T21:15:38Z"
        },
        {
          "author": "br-hale",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The latest edit looks good and that works. ",
          "createdAt": "2022-04-29T21:17:28Z",
          "updatedAt": "2022-04-29T21:17:28Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOBoyH6c45HdPK",
          "commit": {
            "abbreviatedOid": "cd0f800"
          },
          "author": "br-hale",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-04-29T21:08:22Z",
          "updatedAt": "2022-04-29T21:08:22Z",
          "comments": [
            {
              "originalPosition": 51,
              "body": "A slight suggested rewording: \"...in an MLS group were to reliably confirm out-of-band that their epoch authenticator values were equal, then...\"\r\n[this is just because actually showing the epoch authenticators face-to-face depends on other device/display attributes as well, which we do not want to make claims on here]",
              "createdAt": "2022-04-29T21:08:22Z",
              "updatedAt": "2022-04-29T21:08:22Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c45HdY3",
          "commit": {
            "abbreviatedOid": "cd0f800"
          },
          "author": "br-hale",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-04-29T21:09:18Z",
          "updatedAt": "2022-04-29T21:09:19Z",
          "comments": [
            {
              "originalPosition": 58,
              "body": "Corresponding to the above edit:\r\n\"...secondary protocol (such as a face-to-face protocol)...\"",
              "createdAt": "2022-04-29T21:09:19Z",
              "updatedAt": "2022-04-29T21:09:19Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c45HeVq",
          "commit": {
            "abbreviatedOid": "cd0f800"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-04-29T21:14:47Z",
          "updatedAt": "2022-04-29T21:14:48Z",
          "comments": [
            {
              "originalPosition": 51,
              "body": "Added a hand-wave \"(using some suitable user interface)\".  I would like to keep the in-person aspect, since it makes clear that this is really just a toy example, and if you did something real you would need to do real analysis.",
              "createdAt": "2022-04-29T21:14:48Z",
              "updatedAt": "2022-04-29T21:14:48Z"
            }
          ]
        }
      ]
    },
    {
      "number": 646,
      "id": "PR_kwDOBoyH6c43UzU9",
      "title": "Spell check.",
      "url": "https://github.com/mlswg/mls-protocol/pull/646",
      "state": "MERGED",
      "author": "Bren2010",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2022-05-05T00:35:01Z",
      "updatedAt": "2022-05-06T15:42:07Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "28354251c1ee5a2e8a96304c6604461a834a0063",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "brendan/spell-check",
      "headRefOid": "f0015055ef7f5c597223a21c60348d33da202de0",
      "closedAt": "2022-05-05T13:23:14Z",
      "mergedAt": "2022-05-05T13:23:14Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "031bf953fb53eaddd0f7575452b3026643202e53"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOBoyH6c45a6AX",
          "commit": {
            "abbreviatedOid": "f001505"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-05-05T13:23:09Z",
          "updatedAt": "2022-05-05T13:23:09Z",
          "comments": []
        }
      ]
    },
    {
      "number": 650,
      "id": "PR_kwDOBoyH6c43Wym4",
      "title": "Make padding arbitrary-size and all-zero",
      "url": "https://github.com/mlswg/mls-protocol/pull/650",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #642 \r\n\r\nAlso requires that padding be all-zero.  Before, the sender was allowed to put arbitrary octets in there.",
      "createdAt": "2022-05-05T13:51:25Z",
      "updatedAt": "2022-05-19T14:22:37Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "031bf953fb53eaddd0f7575452b3026643202e53",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "ciphertext-len",
      "headRefOid": "4e21bfb38ea614ce01a9b09ae0f1cf4911a9e067",
      "closedAt": "2022-05-19T14:22:37Z",
      "mergedAt": "2022-05-19T14:22:37Z",
      "mergedBy": "seanturner",
      "mergeCommit": {
        "oid": "dde1baef76bc5f278f22e7dc47a6da9ee920f476"
      },
      "comments": [
        {
          "author": "tomleavy",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Looks good to me. @psyoptix I think this covers your issue on the mailing list",
          "createdAt": "2022-05-06T02:18:57Z",
          "updatedAt": "2022-05-06T02:18:57Z"
        },
        {
          "author": "seanturner",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Discussed at 19 May interim. Decision to merge.",
          "createdAt": "2022-05-19T14:22:31Z",
          "updatedAt": "2022-05-19T14:22:31Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOBoyH6c45cBkN",
          "commit": {
            "abbreviatedOid": "c800347"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-05-05T16:24:32Z",
          "updatedAt": "2022-05-05T16:24:32Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOBoyH6c456QQ9",
          "commit": {
            "abbreviatedOid": "c800347"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-12T23:48:20Z",
          "updatedAt": "2022-05-12T23:48:21Z",
          "comments": [
            {
              "originalPosition": 42,
              "body": "```suggestion\r\nto reduce the ability of attackers outside the group to infer the size of the\r\n```",
              "createdAt": "2022-05-12T23:48:20Z",
              "updatedAt": "2022-05-12T23:48:21Z"
            }
          ]
        }
      ]
    },
    {
      "number": 651,
      "id": "PR_kwDOBoyH6c43XP-M",
      "title": "Remove GroupContext from MLSMessageContentTBM",
      "url": "https://github.com/mlswg/mls-protocol/pull/651",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #647 ",
      "createdAt": "2022-05-05T15:36:51Z",
      "updatedAt": "2022-05-19T14:32:32Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "031bf953fb53eaddd0f7575452b3026643202e53",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "tbm",
      "headRefOid": "9c902ee9bb9ab92361ee87f56dbe6a4dc96fac5f",
      "closedAt": "2022-05-19T14:32:31Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOBoyH6c456Qo-",
          "commit": {
            "abbreviatedOid": "9c902ee"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-05-12T23:52:02Z",
          "updatedAt": "2022-05-12T23:52:02Z",
          "comments": []
        }
      ]
    },
    {
      "number": 652,
      "id": "PR_kwDOBoyH6c43XWQN",
      "title": "Add a diagram showing how the message types relate",
      "url": "https://github.com/mlswg/mls-protocol/pull/652",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "I drew this to help explain the relevant patch in MLSpp to someone, and thought it might be helpful to other folks.",
      "createdAt": "2022-05-05T15:59:54Z",
      "updatedAt": "2022-05-18T19:40:18Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "031bf953fb53eaddd0f7575452b3026643202e53",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "message-diagram",
      "headRefOid": "179a3be6a73ef9d1c519c5d3aa654f90b4deae53",
      "closedAt": "2022-05-18T19:40:18Z",
      "mergedAt": "2022-05-18T19:40:18Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "234b22940369d04fb46cbe2e01878201113c6ac3"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOBoyH6c45cCDP",
          "commit": {
            "abbreviatedOid": "179a3be"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-05-05T16:26:06Z",
          "updatedAt": "2022-05-05T16:26:06Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOBoyH6c45keC1",
          "commit": {
            "abbreviatedOid": "179a3be"
          },
          "author": "TWal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Excellent! This is a very nice addition to explain the design introduced #523 .",
          "createdAt": "2022-05-09T09:37:14Z",
          "updatedAt": "2022-05-09T09:37:14Z",
          "comments": []
        }
      ]
    },
    {
      "number": 653,
      "id": "PR_kwDOBoyH6c43XYrB",
      "title": "Add draft-14 changelog",
      "url": "https://github.com/mlswg/mls-protocol/pull/653",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This should have been done before publishing draft-14, but we can't fix that now.  At least this will capture the history in draft-15.",
      "createdAt": "2022-05-05T16:07:39Z",
      "updatedAt": "2022-05-05T16:11:20Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "031bf953fb53eaddd0f7575452b3026643202e53",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "changelog-14",
      "headRefOid": "337f1f8de3839b9f11e093f8afc8e24a3fbdc830",
      "closedAt": "2022-05-05T16:11:19Z",
      "mergedAt": "2022-05-05T16:11:19Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "f64c3ebb5ad2c5f1621e30fbf581c0e02246b1e5"
      },
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Merging my own PR because this is strictly editorial.",
          "createdAt": "2022-05-05T16:11:16Z",
          "updatedAt": "2022-05-05T16:11:16Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 654,
      "id": "PR_kwDOBoyH6c43XmdG",
      "title": "Remove AppAck proposal.",
      "url": "https://github.com/mlswg/mls-protocol/pull/654",
      "state": "MERGED",
      "author": "Bren2010",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2022-05-05T17:11:15Z",
      "updatedAt": "2022-05-20T20:12:13Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "8a5d422f453ea4c7bd60d97a7fdae838573d58cd",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "brendan/no-appack",
      "headRefOid": "4fe13aaf7f557f530ad28b20e65e37686dc6aa13",
      "closedAt": "2022-05-20T17:42:38Z",
      "mergedAt": "2022-05-20T17:42:38Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "7f3a8bf8a7390263249654a4fbaef33eac93f1a5"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOBoyH6c46cznh",
          "commit": {
            "abbreviatedOid": "4fe13aa"
          },
          "author": "rohan-wire",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "One comment that renumbering the group_context_extensions proposal was probably a bad idea from a process perspective which we should avoid doing in the future. In this case it seems unlikely that many people have implemented it who could not make a breaking change.",
          "createdAt": "2022-05-20T20:12:13Z",
          "updatedAt": "2022-05-20T20:12:13Z",
          "comments": []
        }
      ]
    },
    {
      "number": 656,
      "id": "PR_kwDOBoyH6c43bF5K",
      "title": "Editorial",
      "url": "https://github.com/mlswg/mls-protocol/pull/656",
      "state": "MERGED",
      "author": "Bren2010",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "",
      "createdAt": "2022-05-06T15:43:50Z",
      "updatedAt": "2022-05-18T19:41:22Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "f64c3ebb5ad2c5f1621e30fbf581c0e02246b1e5",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "brendan/editorial",
      "headRefOid": "22b322bf8b7cd5e177887517f3752bd7a50b1e42",
      "closedAt": "2022-05-18T19:41:21Z",
      "mergedAt": "2022-05-18T19:41:21Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "80f9137ee8a16cac7614aab1b938be81b5ae7811"
      },
      "comments": [
        {
          "author": "rohan-wire",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Some of these editorial comments I find less clear than the original. The code changes and varint are fine. Could you please split this into two more atomic PRs so we can discuss separately?",
          "createdAt": "2022-05-10T22:27:50Z",
          "updatedAt": "2022-05-10T22:27:50Z"
        },
        {
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "body": "Feel free to leave comments on the editorial portion of this PR to keep things moving",
          "createdAt": "2022-05-10T22:29:18Z",
          "updatedAt": "2022-05-10T22:29:18Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOBoyH6c45kckU",
          "commit": {
            "abbreviatedOid": "6202b54"
          },
          "author": "TWal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-09T09:32:10Z",
          "updatedAt": "2022-05-09T09:32:11Z",
          "comments": [
            {
              "originalPosition": 19,
              "body": "The fix is still buggy, here is the correct one:\r\n```suggestion\r\n  if prefix >= 1 && v < (1 << (8*(1 << (prefix-1))-2)):\r\n```",
              "createdAt": "2022-05-09T09:32:10Z",
              "updatedAt": "2022-05-09T09:32:11Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c45oFfh",
          "commit": {
            "abbreviatedOid": "6202b54"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-09T20:41:52Z",
          "updatedAt": "2022-05-09T20:41:52Z",
          "comments": [
            {
              "originalPosition": 19,
              "body": "What's the bug in the current code?",
              "createdAt": "2022-05-09T20:41:52Z",
              "updatedAt": "2022-05-09T20:41:52Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c45rTEX",
          "commit": {
            "abbreviatedOid": "6202b54"
          },
          "author": "TWal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-10T12:10:02Z",
          "updatedAt": "2022-05-10T12:10:02Z",
          "comments": [
            {
              "originalPosition": 19,
              "body": "In your code, all numbers between `2^14` and `2^22` will be rejected: they are represented with `prefix = 2` (hence `length = 4`). In this case, the buggy check is `v < (1 << (8*3-2))`, the fixed check is `v < (1 << (8*2-2))`.",
              "createdAt": "2022-05-10T12:10:02Z",
              "updatedAt": "2022-05-10T12:10:02Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c454l1B",
          "commit": {
            "abbreviatedOid": "6202b54"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-12T16:18:47Z",
          "updatedAt": "2022-05-12T16:18:48Z",
          "comments": [
            {
              "originalPosition": 19,
              "body": "Ah, thank you!",
              "createdAt": "2022-05-12T16:18:48Z",
              "updatedAt": "2022-05-12T16:18:48Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c46J2Ya",
          "commit": {
            "abbreviatedOid": "9de99af"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Couple of suggestions, generally looks good.",
          "createdAt": "2022-05-17T15:11:12Z",
          "updatedAt": "2022-05-17T15:27:22Z",
          "comments": [
            {
              "originalPosition": 40,
              "body": "```suggestion\r\n  epoch to epoch (mainly using the _init_secret_ and _epoch_secret_), as well as the derivation of\r\n```",
              "createdAt": "2022-05-17T15:11:12Z",
              "updatedAt": "2022-05-17T15:27:22Z"
            },
            {
              "originalPosition": 63,
              "body": "```suggestion\r\nepoch and not to members who have been removed. Commits thus maintain the property that the\r\nthe epoch secret is confidential to the members in the current epoch.\r\n```",
              "createdAt": "2022-05-17T15:14:09Z",
              "updatedAt": "2022-05-17T16:05:02Z"
            },
            {
              "originalPosition": 87,
              "body": "These seem like useful examples?  Since they show how the key schedule actually gets put to use.  Might drop `init_secret` and replace `confirmation_key` with `exporter_secret` to make it more functional.",
              "createdAt": "2022-05-17T15:15:29Z",
              "updatedAt": "2022-05-17T15:27:22Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c46KNuN",
          "commit": {
            "abbreviatedOid": "9de99af"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-17T16:11:54Z",
          "updatedAt": "2022-05-17T16:11:54Z",
          "comments": [
            {
              "originalPosition": 87,
              "body": "Sure, but it doesn't seem to fit in this section. The rest of the text is talking about messages and how they evolve the group state.",
              "createdAt": "2022-05-17T16:11:54Z",
              "updatedAt": "2022-05-17T16:11:54Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c46KjUE",
          "commit": {
            "abbreviatedOid": "f7a1146"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-17T17:22:56Z",
          "updatedAt": "2022-05-17T17:25:54Z",
          "comments": [
            {
              "originalPosition": 87,
              "body": "Maybe move them up under the `_key schedule_` bullet above?  \"... derive a variety of secrets, for example: <sub-bullets>\"",
              "createdAt": "2022-05-17T17:22:56Z",
              "updatedAt": "2022-05-17T17:25:54Z"
            }
          ]
        }
      ]
    },
    {
      "number": 658,
      "id": "PR_kwDOBoyH6c43eRDJ",
      "title": "Replace LeafNodeRef with leaf index.",
      "url": "https://github.com/mlswg/mls-protocol/pull/658",
      "state": "MERGED",
      "author": "Bren2010",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This seems to be a layer of indirection that doesn't add any value to implementation.",
      "createdAt": "2022-05-09T03:53:25Z",
      "updatedAt": "2022-05-19T14:39:48Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "f64c3ebb5ad2c5f1621e30fbf581c0e02246b1e5",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "brendan/leaf-index",
      "headRefOid": "f2bf0183f1d7b41c20cfad12d8bd3cf2107e0782",
      "closedAt": "2022-05-19T14:39:48Z",
      "mergedAt": "2022-05-19T14:39:48Z",
      "mergedBy": "seanturner",
      "mergeCommit": {
        "oid": "8a5d422f453ea4c7bd60d97a7fdae838573d58cd"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOBoyH6c46RMA0",
          "commit": {
            "abbreviatedOid": "f2bf018"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "I don't have a strong opinion on this question, but this change seems sensible to me.  The use of LeafNodeRef requires either (a) a linear scan through the tree, which is time-expensive in large trees, or (b) keeping an index that maps LeafNodeRef values to indices, which is storage-intensive in large trees.\r\n\r\nIIRC, the change to LeafNodeRef was made in the context of @TWal's work to make the tree description less tied to the array representation.  In general, that is the right thing to do, and it's good that we did it.  But we still have leaf indices anyway, for `unmerged_leaves`.  Since we still have the concept, we might as well use it where it makes sense.  And it certainly seems to me like `Sender.sender` and `removed` make sense, since they are internal to the protocol.\r\n\r\nIn case folks are worried about the application-facing API -- MLS stacks can certainly be more intelligent, e.g., exposing `remove(LeafNodeRef)` or `remove(ApplicationIDFromExtension)` or `remove(SignaturePublicKey)`.  But they can do that regardless of this PR.\r\n",
          "createdAt": "2022-05-18T20:18:59Z",
          "updatedAt": "2022-05-19T01:09:15Z",
          "comments": [
            {
              "originalPosition": 34,
              "body": "This could be a little more concrete: A member's leaf index is stable while that member is part of the group, but before that member joins or after they leave, a different member may occupy that leaf.",
              "createdAt": "2022-05-18T20:18:59Z",
              "updatedAt": "2022-05-19T01:09:15Z"
            }
          ]
        }
      ]
    },
    {
      "number": 659,
      "id": "PR_kwDOBoyH6c43wCU_",
      "title": "Remove new_member Add proposals.",
      "url": "https://github.com/mlswg/mls-protocol/pull/659",
      "state": "MERGED",
      "author": "Bren2010",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Sending an Add proposal from outside the group is how we let people do \"external add\" functionality without needing to publish the group state. But you can't talk right away like you can with an external Commit. In that case, applications seem more inclined to build this functionality themselves so let's just remove it from the spec.",
      "createdAt": "2022-05-12T23:03:35Z",
      "updatedAt": "2022-05-20T17:43:25Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "8a5d422f453ea4c7bd60d97a7fdae838573d58cd",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "brendan/tbs-bug",
      "headRefOid": "740b74d597ac3e6015a9a9a93ef87c2302948ee4",
      "closedAt": "2022-05-20T17:43:24Z",
      "mergedAt": "2022-05-20T17:43:24Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "4efa3333ab7b5ab4da0009fa988c0f3f67f7cd29"
      },
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Virtual interim 2022-05-19:\r\n\r\n* External sender change is unrelated\r\n    * @kkohbrok notes that using only SignaturePublicKey loses auth info\r\n    * @Bren2010 to revert this part of the PR\r\n* Clear to merge once conflicts are cleared and above is reverted",
          "createdAt": "2022-05-19T14:59:48Z",
          "updatedAt": "2022-05-19T14:59:48Z"
        },
        {
          "author": "seanturner",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Once SignaturePublicKey is backed out and merge conflicts fixed - merge.",
          "createdAt": "2022-05-19T15:00:02Z",
          "updatedAt": "2022-05-19T15:00:02Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOBoyH6c46RKmC",
          "commit": {
            "abbreviatedOid": "5dea9d2"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Looks good, thanks for putting this together!",
          "createdAt": "2022-05-18T20:13:45Z",
          "updatedAt": "2022-05-18T20:14:30Z",
          "comments": [
            {
              "originalPosition": 69,
              "body": "```suggestion\r\n    the Commit's path (see Section {{joining-via-external-commits}}). The\r\n```",
              "createdAt": "2022-05-18T20:13:45Z",
              "updatedAt": "2022-05-18T20:14:30Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c46bVCi",
          "commit": {
            "abbreviatedOid": "740b74d"
          },
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-05-20T14:48:55Z",
          "updatedAt": "2022-05-20T14:48:55Z",
          "comments": []
        }
      ]
    },
    {
      "number": 660,
      "id": "PR_kwDOBoyH6c43wEcG",
      "title": "Remove clause about verifying identity changes.",
      "url": "https://github.com/mlswg/mls-protocol/pull/660",
      "state": "CLOSED",
      "author": "Bren2010",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "I don't think the \"MUST\" clause here is really weight-bearing, especially given that we don't provide any specific way to do the verification. We already say that applications \"SHOULD require that a client present the same identifiers\" and going against the \"SHOULD\" means the implementer is taking responsibility for any problems.",
      "createdAt": "2022-05-12T23:11:41Z",
      "updatedAt": "2022-05-28T18:39:15Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "f64c3ebb5ad2c5f1621e30fbf581c0e02246b1e5",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "brendan/no-verify",
      "headRefOid": "2eb6a831b6e11068638f64a087e99efd9e8d0794",
      "closedAt": "2022-05-28T18:39:15Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "This is again in the gray area of how much authentication do we want to deal with in MLS. I'm not attached to the MUST, but I think we should give people some guidance on what to look out for when deciding on this SHOULD. Maybe this should go in the architecture doc?",
          "createdAt": "2022-05-13T05:58:45Z",
          "updatedAt": "2022-05-13T05:58:45Z"
        },
        {
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "body": "There is some overlap with #678. I think it is important to be more specific in the protocol spec about the interaction with the AS.",
          "createdAt": "2022-05-19T09:21:07Z",
          "updatedAt": "2022-05-19T09:21:07Z"
        },
        {
          "author": "seanturner",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Park this for now while we evolve #678.",
          "createdAt": "2022-05-19T15:12:56Z",
          "updatedAt": "2022-05-19T15:12:56Z"
        },
        {
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "After the discussion at the interim, I now lean towards keeping the MUST, but maybe we can phrase it a little differently. Instead of mandating that the application MUST do the verification, we could mandate that the implementation MUST present the credentials to the AS for verification of the credential succession. Then it's really up to the AS what it wants to do, but at least different implementations have a somewhat consistent interface with the AS (which we can discuss in #678).",
          "createdAt": "2022-05-24T06:48:08Z",
          "updatedAt": "2022-05-24T06:48:08Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 662,
      "id": "PR_kwDOBoyH6c430E05",
      "title": "More wording improvements, updating sections that got out of date.",
      "url": "https://github.com/mlswg/mls-protocol/pull/662",
      "state": "MERGED",
      "author": "Bren2010",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "",
      "createdAt": "2022-05-14T00:04:33Z",
      "updatedAt": "2022-05-20T17:01:15Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "f64c3ebb5ad2c5f1621e30fbf581c0e02246b1e5",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "brendan/editorial2",
      "headRefOid": "1fcc909fdcdfbf4a9183438d4d0cafd58bacb115",
      "closedAt": "2022-05-20T17:01:15Z",
      "mergedAt": "2022-05-20T17:01:15Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "1bdfebea16cf911426316d2f8b154ea5c7b9c477"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOBoyH6c46RA-d",
          "commit": {
            "abbreviatedOid": "3b8a680"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-18T19:43:53Z",
          "updatedAt": "2022-05-18T19:52:27Z",
          "comments": [
            {
              "originalPosition": 93,
              "body": "```suggestion\r\nfour-byte \"reuse guard\" value and XOR it with the first four bytes of the nonce\r\n```",
              "createdAt": "2022-05-18T19:43:53Z",
              "updatedAt": "2022-05-18T19:52:27Z"
            },
            {
              "originalPosition": 189,
              "body": "This doesn't make sense.  It's not meaningful to just verify the parent hash in a leaf.  For example, a leaf's parent hash might be invalid just because its sibling updated more recently.  Parent hashes should really only be validated (a) on validating a newly received tree, and (b) when validating a Commit UpdatePath.",
              "createdAt": "2022-05-18T19:47:16Z",
              "updatedAt": "2022-05-18T19:52:27Z"
            },
            {
              "originalPosition": 234,
              "body": "```suggestion\r\nrooted at the parent's non-updated child, that is, the child\r\n```\r\n\r\nIf there's a full stop here, the \"That is...\" part isn't a full sentence.  It might read more smoothly as \"i.e.\"?",
              "createdAt": "2022-05-18T19:49:45Z",
              "updatedAt": "2022-05-18T19:52:27Z"
            },
            {
              "originalPosition": 243,
              "body": "The private key needs to computed from the path secret at some point.  Do you just mean for that to be implicit?",
              "createdAt": "2022-05-18T19:50:39Z",
              "updatedAt": "2022-05-18T19:52:27Z"
            },
            {
              "originalPosition": 266,
              "body": "```suggestion\r\nis the next non-blank ancestor of its predecessor in the filtered direct path.\r\n```",
              "createdAt": "2022-05-18T19:52:00Z",
              "updatedAt": "2022-05-18T19:52:27Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c46Sirp",
          "commit": {
            "abbreviatedOid": "3b8a680"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-19T05:07:44Z",
          "updatedAt": "2022-05-19T05:07:45Z",
          "comments": [
            {
              "originalPosition": 266,
              "body": "I don't think this is right, the filtered direct path doesn't have blank nodes. Or at least, this way of saying it is not making sense to me right now.",
              "createdAt": "2022-05-19T05:07:45Z",
              "updatedAt": "2022-05-19T05:08:41Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c46Xm70",
          "commit": {
            "abbreviatedOid": "3b8a680"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-19T21:09:26Z",
          "updatedAt": "2022-05-19T21:09:26Z",
          "comments": [
            {
              "originalPosition": 266,
              "body": "I can see how it's confusing to say both.  How about either \"next non-blank ancestor\" or \"next ancestor in the filtered direct path\"?\r\n\r\nAlternatively, the filtered direct path already has an order defined:\r\n\r\n> The direct path of a root is the empty list, and of any other node is the concatenation of that node's parent along with the parent's direct path.\r\n\r\n> The filtered direct path of a node is obtained from the node's direct path by removing all nodes ... [note this doesn't change the order]\r\n\r\nSo we could just say that the nodes in the UpdatePath correspond to the nodes in the filtered direct path.",
              "createdAt": "2022-05-19T21:09:26Z",
              "updatedAt": "2022-05-19T21:09:26Z"
            }
          ]
        }
      ]
    },
    {
      "number": 675,
      "id": "PR_kwDOBoyH6c438mN5",
      "title": "More clarity around validating proposals",
      "url": "https://github.com/mlswg/mls-protocol/pull/675",
      "state": "MERGED",
      "author": "mulmarta",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "The text in the RFC around validating proposals, choosing which proposals go into a commit and how to validate a received commit could do with a bit more work.\r\n\r\nThe root issue is that Section 13.2 states \u201cThe sender of a Commit MUST include all valid proposals that it has received during the current epoch. Invalid proposals include, for example, proposals with an invalid signature or proposals that are semantically invalid, such as an Add when the sender does not have the application-level permission to add new users.\u201d There are two intertwined issues with this text:\r\n1. The qualifier \u201cMUST\u201d\r\n2. The text is too vague about what a \u201cvalid Proposal\u201d is. E.g. it could be interpreted to mean a Proposal is \u201cvalid\u201d relative to the current group state: Can it be applied to the group as it stands now? Then it\u2019s \u201cvalid\u201d.\r\n\r\nPut simply, it doesn\u2019t make sense to only validate proposals individually. Instead one should validate if the full list of proposals can be committed. Indeed, other parts of the RFC enforce validation steps that apply to the full list. E.g.\r\n* A ReInit proposal MUST be the only one in the commit, and other existing proposals SHOULD be preferred (13.2.1).\r\n* Out of multiple proposals affecting the same leaf, the committer MUST choose an arbitrary one (13.2, \u201cIf there are multiple (\u2026)\u201d).\r\n* Out of multiple PSK proposals with the same ID, the committer MUST choose an arbitrary one (13.2).\r\n\r\nIn fact, once extensions come into play there are likely many more similar situations, even ones affecting lists of otherwise benign proposals (e.g. Add/Remove). Suppose a chat app is built on MLS with a custom room moderator roles extension. The app wants MLS to enforce two rules: Only mods can Add/Remove. Rooms should always have at least 1 Mod. Here\u2019s how the RFC\u2019s current text can become a problem: A and B are the only mods in a room. A makes proposal P1 that removes B. Meanwhile, B makes prop P2 that removes A. C gets both proposals. What should C do?\r\n* Option 1: validate & cache both proposals. \u2192 Problem: C can no longer issue a commit as it \u201cMUST include all valid proposals\u201d. (Alternatively, it does commit to both as instructed by the RFC which leaves the room without a mod.)\r\n* Option 2: validate & cache the first prop received (say, P1), but reject P2 as validating both means C can\u2019t commit. \u2192 Problem: If someone else commits to P2 by ref. C can\u2019t process the commit as it doesn\u2019t \u201cknow\u201d P2.\r\n\r\nSo, to clean all this up a bit more, this PR proposes the following main changes:\r\n1. Add a section \"Validating Proposals\" that defines a procedure for validating a *list* of proposals. The procedure starts with checking that each individual proposal is valid, as described in the \"Proposals\" section. It also has a note that applications may add more rules.\r\n2. Clean up a bit the validation rules in the \"Proposals\" section and remove redundancies. Now for each proposal, we precisely define when it is valid.\r\n3. In the \"Commit\" section, add a requirement that both a committer and a receiver of a commit MUST verify that the committed proposal list is valid according to section \"Validating Proposals\".\r\n4. Downgrade the requirement that \u201cThe sender of a Commit MUST include all valid proposals that it has received\u201c to \"The sender of a Commit SHOULD include all valid proposals that it has received, as long as this does not make the proposal list invalid.\"\r\n\r\nNote that the validation in section \"Proposals\" can be done when a commit is received. The final check in \"Validating Proposals\" is done when a commit is created and when it is received.\r\n\r\nThis also fixes #657.",
      "createdAt": "2022-05-17T10:35:46Z",
      "updatedAt": "2022-05-25T18:57:04Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "bd56532ab26a586d1e951705c068f836a3960f51",
      "headRepository": "mulmarta/mls-protocol",
      "headRefName": "mulmarta/proposal-validation",
      "headRefOid": "2bf3d34867f4b08739e1df47fb3fa6684d7fe323",
      "closedAt": "2022-05-25T18:57:04Z",
      "mergedAt": "2022-05-25T18:57:04Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "a662e60c3584eb3d7d5a94694ca719b515d88114"
      },
      "comments": [
        {
          "author": "seanturner",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Discussed 19 May. Will leave it open for further review from @bifurcation @raphaelrobert review.",
          "createdAt": "2022-05-19T14:53:20Z",
          "updatedAt": "2022-05-19T14:53:20Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Virtual interim 2022-05-19:\r\n\r\n* `SHOULD` include all valid proposals could use explanation of why it's not a `MUST`\r\n   * Proposals can contradict each other\r\n   * Application policy might declare some policy invalid\r\n* Agreement in principle, @raphaelrobert and @bifurcation to review and merge when ready ",
          "createdAt": "2022-05-19T14:53:21Z",
          "updatedAt": "2022-05-19T14:53:21Z"
        },
        {
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "body": "I opened a PR here that resolves the merge conflicts and makes some additional suggested changes: https://github.com/mulmarta/mls-protocol/pull/1",
          "createdAt": "2022-05-22T18:48:45Z",
          "updatedAt": "2022-05-22T18:48:45Z"
        },
        {
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "body": "@mulmarta Please update to resolve merge conflicts.",
          "createdAt": "2022-05-24T16:37:44Z",
          "updatedAt": "2022-05-24T16:37:44Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "@mulmarta I proactively merged my editorial nits (with review from @Bren2010) in the interest of getting this merged.  If I've screwed anything up, obviously feel free to file a follow up to fix.",
          "createdAt": "2022-05-25T18:56:57Z",
          "updatedAt": "2022-05-25T18:56:57Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOBoyH6c46Tn6_",
          "commit": {
            "abbreviatedOid": "783c152"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-19T09:02:50Z",
          "updatedAt": "2022-05-19T09:02:50Z",
          "comments": [
            {
              "originalPosition": 343,
              "body": "```suggestion\r\n* A Remove proposal that removes the committer.\r\n```",
              "createdAt": "2022-05-19T09:02:50Z",
              "updatedAt": "2022-05-19T09:02:50Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c46XoeG",
          "commit": {
            "abbreviatedOid": "7a552d6"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2022-05-19T21:16:43Z",
          "updatedAt": "2022-05-19T21:44:52Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "I'm not clear why this says \"regardless of its use\".  Maybe you mean \"In all these cases...\", but I would prefer leaving it unadorned to not imply that there's a restriction to those cases (in case another one comes up).\r\n\r\nIf you're going to say \"starts with...\" you need to have more steps that follow.",
              "createdAt": "2022-05-19T21:16:43Z",
              "updatedAt": "2022-05-19T21:44:52Z"
            },
            {
              "originalPosition": 21,
              "body": "```suggestion\r\n  For example:\r\n    * An Update proposal updates the sender's old LeafNode to a new one\r\n    * A \"resync\" external commit removes the joiner's old LeafNode via a Remove proposal and replaces it with a new one\r\n```",
              "createdAt": "2022-05-19T21:18:48Z",
              "updatedAt": "2022-05-19T21:44:52Z"
            },
            {
              "originalPosition": 60,
              "body": "Why are you removing this uniqueness requirement?",
              "createdAt": "2022-05-19T21:20:08Z",
              "updatedAt": "2022-05-19T21:44:52Z"
            },
            {
              "originalPosition": 67,
              "body": "This description seems less clear to me than before.  Are you trying to be more generic?\r\n\r\nPerhaps we should just have a generic RECOMMENDED here, and have the MUST in the Add section.",
              "createdAt": "2022-05-19T21:21:46Z",
              "updatedAt": "2022-05-19T21:44:52Z"
            },
            {
              "originalPosition": 103,
              "body": "We should delete these requirements here, and make them generic. It seems like you should always check the signature on MLSMessageContentAuth before using the content, regardless of the content type.",
              "createdAt": "2022-05-19T21:25:28Z",
              "updatedAt": "2022-05-19T21:44:52Z"
            },
            {
              "originalPosition": 60,
              "body": "I see you have added it below.  That seems like a lot of repetition and risk of decoherence.  I would prefer to have it up here.\r\n\r\nIf the concern is the \"added in the same Commit\" part -- it seems like this requirement could be applied iteratively, in the sense that if you're updating/adding a bunch of leaves in a Commit and you do this check relative to the current tree before you apply an update/add, then that will catch a duplication.",
              "createdAt": "2022-05-19T21:30:44Z",
              "updatedAt": "2022-05-19T21:44:52Z"
            },
            {
              "originalPosition": 273,
              "body": "Suggest using a more interesting example here, such as including an Update and Remove for the same member.",
              "createdAt": "2022-05-19T21:33:32Z",
              "updatedAt": "2022-05-19T21:44:52Z"
            },
            {
              "originalPosition": 280,
              "body": "```suggestion\r\nThe sender of a Commit SHOULD include all proposals that it has received\r\nduring the current epoch, that are valid according to the rules for their\r\nproposal types and according to application policy, as long as this results in\r\na valid proposal list.\r\n```",
              "createdAt": "2022-05-19T21:35:21Z",
              "updatedAt": "2022-05-19T21:44:52Z"
            },
            {
              "originalPosition": 283,
              "body": "FWIW I think \"valid proposals\" is a fine shorthand even with the above edit.",
              "createdAt": "2022-05-19T21:35:52Z",
              "updatedAt": "2022-05-19T21:44:52Z"
            },
            {
              "originalPosition": 372,
              "body": "It's slightly confusing that the above is a negative check, and this is a positive check.  But that might be unavoidable.  I might rephrase as something like:\r\n\r\n... the list is valid if it contains only the following proposals (not necessarily in this order):\r\n\r\n* Exactly one ExternalInit proposal\r\n* At most one Remove proposal...\r\n* Zero or more PSK proposals...\r\n* No other proposals\r\n\r\n(The last bullet is a little redundant, but it bears repeating.)",
              "createdAt": "2022-05-19T21:44:04Z",
              "updatedAt": "2022-05-19T21:44:52Z"
            },
            {
              "originalPosition": 372,
              "body": "(And maybe we should require order here!)",
              "createdAt": "2022-05-19T21:44:25Z",
              "updatedAt": "2022-05-19T21:44:52Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c46bpWH",
          "commit": {
            "abbreviatedOid": "c0e6773"
          },
          "author": "mulmarta",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-20T15:46:46Z",
          "updatedAt": "2022-05-20T15:46:46Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "Thanks for pointing this out! (We used to have a earlier version with more cases and more steps.)",
              "createdAt": "2022-05-20T15:46:46Z",
              "updatedAt": "2022-05-20T15:46:46Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c46b2cI",
          "commit": {
            "abbreviatedOid": "a7487e3"
          },
          "author": "mulmarta",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-20T16:10:02Z",
          "updatedAt": "2022-05-20T16:10:03Z",
          "comments": [
            {
              "originalPosition": 60,
              "body": "On second thought, I think this check belongs here.\r\n\r\nRe. \"added in the same Commit\", I think a fix for this would be to change the \"Validating Proposals\" procedure to check individual validity at the end, after applying all committed proposals. I.e. the list is invalid if \"After applying the proposal list, an individual proposal is invalid as specified in {{proposals}}.\"\r\n\r\nRe. applying the check iteratively, the way I read the current draft, it seems that all checks are applied to the current state. For example, its valid to commit to A removing B and B removing A. But if we applied checks iteratively, it would be invalid.",
              "createdAt": "2022-05-20T16:10:02Z",
              "updatedAt": "2022-05-20T16:10:03Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c46eNgE",
          "commit": {
            "abbreviatedOid": "a7487e3"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-22T17:16:48Z",
          "updatedAt": "2022-05-22T17:16:48Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "Also checking if identities are the same in a resync is a good point, but isn't it undermined by being able to do the external join and remove separately?",
              "createdAt": "2022-05-22T17:16:48Z",
              "updatedAt": "2022-05-22T17:17:02Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c46eNz6",
          "commit": {
            "abbreviatedOid": "a7487e3"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-22T17:32:47Z",
          "updatedAt": "2022-05-22T17:32:47Z",
          "comments": [
            {
              "originalPosition": 128,
              "body": "I don't think this was agreed on",
              "createdAt": "2022-05-22T17:32:47Z",
              "updatedAt": "2022-05-22T17:32:47Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c46fPjf",
          "commit": {
            "abbreviatedOid": "c0e6773"
          },
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-23T07:39:00Z",
          "updatedAt": "2022-05-23T07:39:00Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "I think checking identities is also covered in the External Commits section, but mentioning it here or including a reference probably doesn't hurt. I guess allowing a remove in an external commit is more for the benefit of the external joiner itself. Although they might was well do it in a follow-up commit. In my mind, the restrictions on an external commit is meant less to reduce the capabilities of an external joiner and more to reduce the complexity of the external join as a somewhat asymmetric group operation.",
              "createdAt": "2022-05-23T07:39:00Z",
              "updatedAt": "2022-05-23T07:44:32Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c46gLD6",
          "commit": {
            "abbreviatedOid": "a7487e3"
          },
          "author": "mulmarta",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-23T10:16:41Z",
          "updatedAt": "2022-05-23T10:16:41Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "Currently this requirement is in the External Commit section:\r\n>  There MAY be a single Remove proposal, where the LeafNode in the path field MUST meet the same criteria as the LeafNode in an Update for the removed leaf (see Section 13.1.2). In particular, the credential in the LeafNode MUST present a set of identifiers that is acceptable to the application for the removed participant.\r\n\r\nThe PR moves it here (so it's only in one place).\r\n\r\nThis PR is editorial, so I'd rather not remove the restriction here but instead discuss this as a separate issue. I've also been wondering why only one Remove is allowed? E.g. I may want to remove a couple of my old devices.",
              "createdAt": "2022-05-23T10:16:41Z",
              "updatedAt": "2022-05-23T10:16:41Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c46gMb1",
          "commit": {
            "abbreviatedOid": "a7487e3"
          },
          "author": "mulmarta",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-23T10:21:08Z",
          "updatedAt": "2022-05-23T10:21:08Z",
          "comments": [
            {
              "originalPosition": 128,
              "body": "This is how we interpreted the text\r\n> If there are multiple Add proposals containing KeyPackages that the committer considers to represent the same client or a client already in the group (for example, identical KeyPackages or KeyPackages sharing the same Credential), the committer again chooses one to include and considers the rest invalid.\r\n\r\nIf this was not what was meant, the part \"or a client already in the group\" would be redundant. But of course I'll remove it if we were wrong.",
              "createdAt": "2022-05-23T10:21:08Z",
              "updatedAt": "2022-05-23T10:21:08Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c46jj4S",
          "commit": {
            "abbreviatedOid": "a7487e3"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-23T22:17:48Z",
          "updatedAt": "2022-05-23T22:18:36Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "Agree that we should handle the revalidation separately, in #660.\r\n\r\nOn \"why only one\" -- The idea is to *only* cover the resync case, where a device is replacing *its own* state.  Other devices can be cleaned up after the new member has joined.",
              "createdAt": "2022-05-23T22:17:48Z",
              "updatedAt": "2022-05-23T22:18:36Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c46ui1N",
          "commit": {
            "abbreviatedOid": "364bf31"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Couple of nits, otherwise lgtm.",
          "createdAt": "2022-05-25T18:18:51Z",
          "updatedAt": "2022-05-25T18:36:13Z",
          "comments": [
            {
              "originalPosition": 70,
              "body": "```suggestion\r\n  * If the LeafNode appears in a KeyPackage, verify that `leaf_node_source` is\r\n    set to `key_package`.\r\n```",
              "createdAt": "2022-05-25T18:18:51Z",
              "updatedAt": "2022-05-25T18:36:13Z"
            },
            {
              "originalPosition": 90,
              "body": "```suggestion\r\n* Verify that the `leaf_node` of the KeyPackage is valid for a KeyPackage\r\n  according to {{leaf-node-validation}}.\r\n```",
              "createdAt": "2022-05-25T18:19:41Z",
              "updatedAt": "2022-05-25T18:36:13Z"
            },
            {
              "originalPosition": 144,
              "body": "```suggestion\r\nAn Update proposal is invalid if the LeafNode is invalid for an Update\r\nproposal according to {{leaf-node-validation}}.\r\n```",
              "createdAt": "2022-05-25T18:23:17Z",
              "updatedAt": "2022-05-25T18:36:13Z"
            },
            {
              "originalPosition": 148,
              "body": "```suggestion\r\n```",
              "createdAt": "2022-05-25T18:23:53Z",
              "updatedAt": "2022-05-25T18:36:13Z"
            },
            {
              "originalPosition": 282,
              "body": "```suggestion\r\n* Verify that the list of proposals to be committed is valid as specified in\r\n  {{proposal-list-validation}}.\r\n```",
              "createdAt": "2022-05-25T18:26:28Z",
              "updatedAt": "2022-05-25T18:36:13Z"
            },
            {
              "originalPosition": 320,
              "body": "```suggestion\r\n## Proposal List Validation\r\n```",
              "createdAt": "2022-05-25T18:27:05Z",
              "updatedAt": "2022-05-25T18:36:13Z"
            },
            {
              "originalPosition": 320,
              "body": "I would put this above, probably as a subsection of {{proposals}}.  But we can handle that in a section reordering PR; I have added this to #672 ",
              "createdAt": "2022-05-25T18:30:59Z",
              "updatedAt": "2022-05-25T18:36:13Z"
            },
            {
              "originalPosition": 359,
              "body": "I'm not sure why this is here.  It seems like it follows from the Add/Update LeafNode validity requirements.",
              "createdAt": "2022-05-25T18:36:02Z",
              "updatedAt": "2022-05-25T18:36:13Z"
            }
          ]
        }
      ]
    },
    {
      "number": 680,
      "id": "PR_kwDOBoyH6c44C3If",
      "title": "#677: Update PCS claim.",
      "url": "https://github.com/mlswg/mls-protocol/pull/680",
      "state": "MERGED",
      "author": "Bren2010",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "",
      "createdAt": "2022-05-18T17:57:13Z",
      "updatedAt": "2022-05-18T19:42:16Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "f64c3ebb5ad2c5f1621e30fbf581c0e02246b1e5",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "brendan/pcs-claim",
      "headRefOid": "ec0bb9b1f556b7ccc9a6067f430f480501949ce3",
      "closedAt": "2022-05-18T19:42:15Z",
      "mergedAt": "2022-05-18T19:42:15Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "c75ea81796f8a6274850027db30c927acd2b787a"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOBoyH6c46Q_pV",
          "commit": {
            "abbreviatedOid": "ec0bb9b"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-05-18T19:42:08Z",
          "updatedAt": "2022-05-18T19:42:08Z",
          "comments": []
        }
      ]
    },
    {
      "number": 682,
      "id": "PR_kwDOBoyH6c44MicV",
      "title": "Update external senders extension.",
      "url": "https://github.com/mlswg/mls-protocol/pull/682",
      "state": "MERGED",
      "author": "Bren2010",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #681 ",
      "createdAt": "2022-05-20T14:45:25Z",
      "updatedAt": "2022-05-26T14:14:18Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "8a5d422f453ea4c7bd60d97a7fdae838573d58cd",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "brendan/external-senders",
      "headRefOid": "a34abce25aef2584c01e46755b18e1e803aec12f",
      "closedAt": "2022-05-26T14:14:18Z",
      "mergedAt": "2022-05-26T14:14:18Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "60b7fd205e51ffabbff079472e1ec3513475f661"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOBoyH6c46cPbr",
          "commit": {
            "abbreviatedOid": "a34abce"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Thanks @Bren2010 I like that this captures both the signature and authentication aspects.\r\n\r\n@kkohbrok wdyt?",
          "createdAt": "2022-05-20T17:44:16Z",
          "updatedAt": "2022-05-20T17:44:16Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOBoyH6c46dSdP",
          "commit": {
            "abbreviatedOid": "a34abce"
          },
          "author": "tomleavy",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-21T01:09:11Z",
          "updatedAt": "2022-05-21T01:09:25Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "Should the combo of SignaturePublicKey and Credential just be independently defined as a struct like Identity, and then used in LeafNode as well as in the extension? ",
              "createdAt": "2022-05-21T01:09:11Z",
              "updatedAt": "2022-05-21T01:09:26Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c46gnMD",
          "commit": {
            "abbreviatedOid": "a34abce"
          },
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Looks good to me! @tomleavy's idea might be a good additional improvement.",
          "createdAt": "2022-05-23T11:50:26Z",
          "updatedAt": "2022-05-23T11:51:29Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "Not sure I'd call it \"identity\", but I think this is a good idea.",
              "createdAt": "2022-05-23T11:50:26Z",
              "updatedAt": "2022-05-23T11:51:29Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c46oZMZ",
          "commit": {
            "abbreviatedOid": "a34abce"
          },
          "author": "rohan-wire",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-05-24T18:15:33Z",
          "updatedAt": "2022-05-24T18:15:33Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOBoyH6c46yWLn",
          "commit": {
            "abbreviatedOid": "a34abce"
          },
          "author": "rohan-wire",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-05-26T14:11:49Z",
          "updatedAt": "2022-05-26T14:11:49Z",
          "comments": []
        }
      ]
    },
    {
      "number": 683,
      "id": "PR_kwDOBoyH6c44Mm1-",
      "title": "Introduce GroupContext in terminology.",
      "url": "https://github.com/mlswg/mls-protocol/pull/683",
      "state": "MERGED",
      "author": "Bren2010",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #668 ",
      "createdAt": "2022-05-20T15:02:36Z",
      "updatedAt": "2022-05-20T17:44:44Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "8a5d422f453ea4c7bd60d97a7fdae838573d58cd",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "brendan/def-groupctx",
      "headRefOid": "21f883ac61cad2564e9961925df7a29c08cab7c9",
      "closedAt": "2022-05-20T17:44:44Z",
      "mergedAt": "2022-05-20T17:44:44Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "b209e1744abd6c4224c45069361a89e5d78d728b"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOBoyH6c46cPix",
          "commit": {
            "abbreviatedOid": "21f883a"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-05-20T17:44:39Z",
          "updatedAt": "2022-05-20T17:44:39Z",
          "comments": []
        }
      ]
    },
    {
      "number": 684,
      "id": "PR_kwDOBoyH6c44M9sV",
      "title": "Cite AEAD limits draft.",
      "url": "https://github.com/mlswg/mls-protocol/pull/684",
      "state": "MERGED",
      "author": "Bren2010",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #664 ",
      "createdAt": "2022-05-20T16:22:37Z",
      "updatedAt": "2022-05-20T17:42:22Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "8a5d422f453ea4c7bd60d97a7fdae838573d58cd",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "brendan/cite-aead",
      "headRefOid": "ca85d84f7644f95e87fda27a50608d1f37da87c1",
      "closedAt": "2022-05-20T17:42:22Z",
      "mergedAt": "2022-05-20T17:42:21Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "aabeb2ffe875ecac5bdbec8063126aa119cd29c1"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOBoyH6c46cOya",
          "commit": {
            "abbreviatedOid": "ca85d84"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-05-20T17:42:17Z",
          "updatedAt": "2022-05-20T17:42:17Z",
          "comments": []
        }
      ]
    },
    {
      "number": 685,
      "id": "PR_kwDOBoyH6c44OmkP",
      "title": "Partial work on #669",
      "url": "https://github.com/mlswg/mls-protocol/pull/685",
      "state": "CLOSED",
      "author": "Bren2010",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2022-05-21T04:44:22Z",
      "updatedAt": "2022-05-23T21:49:40Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "b209e1744abd6c4224c45069361a89e5d78d728b",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "brendan/pics1",
      "headRefOid": "755ade80196d96d482b6f06604017756affcf1c8",
      "closedAt": "2022-05-23T21:49:40Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "body": "Unfortunately I just realized this overlaps with #644. I'm happy to remove that part of the PR if you want, @bifurcation ",
          "createdAt": "2022-05-21T05:28:24Z",
          "updatedAt": "2022-05-21T05:28:24Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "@Bren2010 I assume you mean #689?  Yeah, I think we can make that one responsible for the direct path / parent hash parts of #669, and this can just hit the secret tree part.",
          "createdAt": "2022-05-22T18:51:14Z",
          "updatedAt": "2022-05-22T18:51:14Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Sorry for the conflict btw.  It ended up being a natural part of reorganizing things.",
          "createdAt": "2022-05-22T18:52:43Z",
          "updatedAt": "2022-05-22T18:52:43Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 686,
      "id": "PR_kwDOBoyH6c44On4e",
      "title": "Recommend that group ids are generated randomly.",
      "url": "https://github.com/mlswg/mls-protocol/pull/686",
      "state": "MERGED",
      "author": "Bren2010",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #661 ",
      "createdAt": "2022-05-21T05:22:05Z",
      "updatedAt": "2022-05-28T18:56:41Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "76b3c4710bf926b9bceea995b746da5a70bf5f3f",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "brendan/group-id",
      "headRefOid": "16e6068f49c7f84022c376bfc20581ff40d2e827",
      "closedAt": "2022-05-28T18:56:41Z",
      "mergedAt": "2022-05-28T18:56:41Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "69cba939aecd0c1265cc74f854539461b345f670"
      },
      "comments": [
        {
          "author": "seanturner",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Brendan to revise based on Rohan suggestion.",
          "createdAt": "2022-05-26T14:26:05Z",
          "updatedAt": "2022-05-26T14:26:05Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Interim 2022-05-26:\r\n\r\n* Concerns around making the group_id totally random\r\n    * Malicious group creator can choose it malicious\r\n    * Federated systems get worse randomness\r\n* Using AEAD.Nk depends on ciphersuite, could be awkward \r\n* @Bren2010  will revise to say:\r\n    * Here are the requirements that group ID must satisfy\r\n    * If you don\u2019t have an alternative plan, do it randomly",
          "createdAt": "2022-05-26T14:26:36Z",
          "updatedAt": "2022-05-26T14:26:36Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOBoyH6c46jZCs",
          "commit": {
            "abbreviatedOid": "37447fb"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-05-23T21:18:55Z",
          "updatedAt": "2022-05-23T21:18:59Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "I may be over-thinking this, but: The group ID isn't necessarily exposed to the DS at group creation time, since the act that creates the group is a Welcome message, which encrypts the group ID.  The group ID is visible in MLSPlaintext and MLSCiphertext, though, so the DS can pick it up there.",
              "createdAt": "2022-05-23T21:18:55Z",
              "updatedAt": "2022-05-23T21:18:59Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c46weWY",
          "commit": {
            "abbreviatedOid": "37447fb"
          },
          "author": "rohan-wire",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2022-05-26T06:35:57Z",
          "updatedAt": "2022-05-26T06:36:13Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "There was never a requirement before that the group id had to have a specific internal structure, format, or length. Why does the protocol suddenly care now? It just needs to be unique enough, and you have specified that in the rest of the diff below. \r\n\r\ns/fresh random value of size `AEAD.Nk`/a unique value set by the creator/\r\n",
              "createdAt": "2022-05-26T06:35:58Z",
              "updatedAt": "2022-05-26T06:36:13Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c46xovP",
          "commit": {
            "abbreviatedOid": "37447fb"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-26T11:35:30Z",
          "updatedAt": "2022-05-26T11:35:30Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "I agree that it would be prohibitive to require a special structure for group IDs. This would potentially make it difficult to use MLS in existing environments, where group IDs already exist.\r\n\r\nIt's also not clear to me why `AEAD.Nk` is a good reference for entropy. It depends on the ciphersuite and is therefore orthogonal to the requirements of uniqueness in a system. Moreover, a system that supports several cipehrsuites would see a conflict here.",
              "createdAt": "2022-05-26T11:35:30Z",
              "updatedAt": "2022-05-26T11:35:30Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c46yX8c",
          "commit": {
            "abbreviatedOid": "37447fb"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-26T14:16:35Z",
          "updatedAt": "2022-05-26T14:16:35Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "I would probably use `KDF.Nh`, since that's what we use for other unique values (e.g., PSK nonces).",
              "createdAt": "2022-05-26T14:16:35Z",
              "updatedAt": "2022-05-26T14:16:35Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c467Atk",
          "commit": {
            "abbreviatedOid": "16e6068"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-05-28T18:56:37Z",
          "updatedAt": "2022-05-28T18:56:37Z",
          "comments": []
        }
      ]
    },
    {
      "number": 687,
      "id": "PR_kwDOBoyH6c44OoYC",
      "title": "Add a marker byte to tree hash input structs.",
      "url": "https://github.com/mlswg/mls-protocol/pull/687",
      "state": "MERGED",
      "author": "Bren2010",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #663. I'm not sure if this is actually necessary, but there usually seem to be issues in Merkle trees when the leaves are not explicitly distinct from the parents.",
      "createdAt": "2022-05-21T05:37:30Z",
      "updatedAt": "2022-05-28T18:58:45Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "a662e60c3584eb3d7d5a94694ca719b515d88114",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "brendan/indicator-bit",
      "headRefOid": "fcf19727be231d04e6aed46afffb8fa838cdca26",
      "closedAt": "2022-05-28T18:58:45Z",
      "mergedAt": "2022-05-28T18:58:45Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "7565848da6480d54ba69523418aa0182abc14e71"
      },
      "comments": [
        {
          "author": "TWal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I would find it nicer to describe things with a `select` like in other parts of the protocol:\r\n\r\n```\r\nstruct {\r\n  uint8 leaf_or_parent_marker;\r\n  select (leaf_or_parent_marker) {\r\n    case 0:\r\n      LeafNodeHashInput hash_input;\r\n    case 1:\r\n      ParentNodeHashInput hash_input;\r\n  }\r\n} TreeHashInput;\r\n```\r\n\r\nIt is equivalent to your modification. Stating things that way ensures there is no ambiguity: TreeHashInput is parseable, which is I think the property you want to ensure with this PR.",
          "createdAt": "2022-05-25T19:57:26Z",
          "updatedAt": "2022-05-25T19:57:26Z"
        },
        {
          "author": "seanturner",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Use enum instead and then ready for merge.",
          "createdAt": "2022-05-26T14:28:57Z",
          "updatedAt": "2022-05-26T14:28:57Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Interim 2022-05-26:\r\n\r\n* Nicer with an `enum`\r\n* @Bren2010 to update to `enum`, then merge",
          "createdAt": "2022-05-26T14:28:58Z",
          "updatedAt": "2022-05-26T14:28:58Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOBoyH6c46jXV0",
          "commit": {
            "abbreviatedOid": "e17f7ab"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "I am also not totally clear on the necessity here.  It seems like the issues with Merkle trees are probably about an adversary being able to choose a leaf value that has the same form as a parent.  Assuming that's the case, we probably wouldn't have similar situations here, given the extra structure.  But having a marker saves us having to make that assumption or do the analysis to check it.\r\n\r\nSeems low-cost and unlikely to hurt in any case.",
          "createdAt": "2022-05-23T21:10:19Z",
          "updatedAt": "2022-05-23T21:13:29Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "Nit: I might call this `leaf_or_parent_marker`.",
              "createdAt": "2022-05-23T21:10:19Z",
              "updatedAt": "2022-05-23T21:13:29Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c467Asm",
          "commit": {
            "abbreviatedOid": "1759f90"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-28T18:55:16Z",
          "updatedAt": "2022-05-28T18:55:17Z",
          "comments": [
            {
              "originalPosition": 19,
              "body": "This is defined all the way down in the ratchet tree extension.  Please move it up to this section.",
              "createdAt": "2022-05-28T18:55:17Z",
              "updatedAt": "2022-05-28T18:55:17Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c467Ava",
          "commit": {
            "abbreviatedOid": "fcf1972"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-05-28T18:58:40Z",
          "updatedAt": "2022-05-28T18:58:40Z",
          "comments": []
        }
      ]
    },
    {
      "number": 688,
      "id": "PR_kwDOBoyH6c44OpFR",
      "title": "Use a hash function for hash identifiers.",
      "url": "https://github.com/mlswg/mls-protocol/pull/688",
      "state": "MERGED",
      "author": "Bren2010",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #640.",
      "createdAt": "2022-05-21T05:59:55Z",
      "updatedAt": "2022-05-26T14:32:52Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "b209e1744abd6c4224c45069361a89e5d78d728b",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "brendan/longer-refs",
      "headRefOid": "eaa874f21dd8b6837bb12270a71f8550f468c1a0",
      "closedAt": "2022-05-26T14:32:52Z",
      "mergedAt": "2022-05-26T14:32:51Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "b9ba20cd3b0cd7b3da052c25d720e10b5317cf58"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOBoyH6c46jV1G",
          "commit": {
            "abbreviatedOid": "bdbb0ec"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2022-05-23T21:02:59Z",
          "updatedAt": "2022-05-23T21:09:07Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "```suggestion\r\nopaque HashReference<V>;\r\n```\r\n\r\nElsewhere, where we have values whose size depends on the ciphersuite, we use vectors instead of arrays.  See, e.g., HPKEPubicKey.  It costs a byte, but it means the parsing/serialization logic doesn't have to know about ciphersuites.",
              "createdAt": "2022-05-23T21:03:00Z",
              "updatedAt": "2022-05-23T21:09:07Z"
            },
            {
              "originalPosition": 19,
              "body": "Paging @kkohbrok @TWal et al. for crypto review.  @Bren2010 fwiw, I think the more minimal change would be:\r\n\r\n``` suggestion\r\nRefHash(label, value) = KDF.expand(KDF.extract(\"\", value), label, KDF.Nh)\r\n```\r\n\r\n(That is, just change `16` to `KDF.Nh`.)\r\n\r\nFrom an implementation POV, I don't think there's much difference either way.  Extract/expand is 4 hash invocations instead of 1, but none of this is done at much scale.",
              "createdAt": "2022-05-23T21:05:53Z",
              "updatedAt": "2022-05-23T21:09:07Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c46jgVm",
          "commit": {
            "abbreviatedOid": "bdbb0ec"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-23T21:56:37Z",
          "updatedAt": "2022-05-23T21:56:37Z",
          "comments": [
            {
              "originalPosition": 19,
              "body": "Using a hash ensures that we're really relying on the ciphersuite's understanding of what a secure hash function is. If KDF.Nh is the size of the output of KDF.Extract (which outputs keys, not collision resistant hashes), then it may again be too small to be collision-secure.",
              "createdAt": "2022-05-23T21:56:37Z",
              "updatedAt": "2022-05-23T21:56:37Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c46kWSQ",
          "commit": {
            "abbreviatedOid": "bdbb0ec"
          },
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-24T05:23:12Z",
          "updatedAt": "2022-05-24T05:23:12Z",
          "comments": [
            {
              "originalPosition": 19,
              "body": "At least for the key derivation proofs, we're already assuming that KDFs are collision resistant, which I believe is fairly standard. That being said increasing the length is probably a good idea. \r\n\r\nAlso, I don't think that it makes much of a difference if we're using a hash function or a KDF, since we don't rely on any pseudorandomness properties of the hash references. ",
              "createdAt": "2022-05-24T05:23:12Z",
              "updatedAt": "2022-05-24T05:23:12Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c46uRZ4",
          "commit": {
            "abbreviatedOid": "bdbb0ec"
          },
          "author": "mulmarta",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-25T17:24:24Z",
          "updatedAt": "2022-05-25T17:24:25Z",
          "comments": [
            {
              "originalPosition": 19,
              "body": "I lean towards using the hash. A hash function is \"the\" collision resistant primitive and since collision resistance is what we want here, hash would be the right primitive. The main purpose of extract is pseudo-randomness, which is unrelated to collision resistance. (Even if we have to assume collision resistance of extract for some property, using hash here makes it less ambiguous which property is needed.)",
              "createdAt": "2022-05-25T17:24:24Z",
              "updatedAt": "2022-05-25T17:24:25Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c46yc6f",
          "commit": {
            "abbreviatedOid": "eaa874f"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-05-26T14:30:01Z",
          "updatedAt": "2022-05-26T14:30:05Z",
          "comments": [
            {
              "originalPosition": 19,
              "body": "Thanks @kkohbrok @mulmarta, clearing my objection.",
              "createdAt": "2022-05-26T14:30:01Z",
              "updatedAt": "2022-05-26T14:30:06Z"
            }
          ]
        }
      ]
    },
    {
      "number": 689,
      "id": "PR_kwDOBoyH6c44PPUb",
      "title": "Reorganize discussion of ratchet tree concepts",
      "url": "https://github.com/mlswg/mls-protocol/pull/689",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #670 \r\nCloses #644 \r\nCloses #669 \r\n\r\nThis PR reorganizes the exposition of tree concept to make them read more clearly.\r\n\r\n* A new Paths through the Ratchet Tree section is introduced, which covers direct paths, copaths, and filtered direct paths\r\n* The Ratchet Tree Nodes section is moved forward, so that the definition of filtered direct paths can refer to the notion of resolutions (see @Bren2010's note on #670)\r\n* The path example expanded so that there are blanks in the tree, and so that it shows all three path types (direct, copath, and filtered direct) for every leaf.\r\n* The section on verifying parent hashes uses the example tree from the path section to illustrate the concepts noted in #669 ",
      "createdAt": "2022-05-21T21:12:53Z",
      "updatedAt": "2022-05-24T23:12:54Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "b209e1744abd6c4224c45069361a89e5d78d728b",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "filter-resolution-figure",
      "headRefOid": "1c952fb8dd4242fb15ca060f073e7dc5abd9b25d",
      "closedAt": "2022-05-24T23:12:54Z",
      "mergedAt": "2022-05-24T23:12:54Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "a32c5a4c6ef957d4887b7902f59307ec1c6e338f"
      },
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Latest commit adds coverage for the last part of #669.  In addition to moving the figure forward, it refactors the explanation to be even more explicit about what must be consumed and what may be kept.",
          "createdAt": "2022-05-23T21:40:40Z",
          "updatedAt": "2022-05-23T21:40:40Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOBoyH6c46ePtK",
          "commit": {
            "abbreviatedOid": "24b87e7"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-22T19:01:21Z",
          "updatedAt": "2022-05-22T19:14:03Z",
          "comments": [
            {
              "originalPosition": 37,
              "body": "```suggestion\r\n```",
              "createdAt": "2022-05-22T19:01:21Z",
              "updatedAt": "2022-05-22T19:14:03Z"
            },
            {
              "originalPosition": 142,
              "body": "```suggestion\r\n| G    | Z, X        | Y, V     | Z, X                 |\r\n```",
              "createdAt": "2022-05-22T19:08:26Z",
              "updatedAt": "2022-05-22T19:14:03Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c46iiU2",
          "commit": {
            "abbreviatedOid": "57db17e"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-05-23T17:28:49Z",
          "updatedAt": "2022-05-23T17:28:49Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOBoyH6c46jfKq",
          "commit": {
            "abbreviatedOid": "1c952fb"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-05-23T21:49:28Z",
          "updatedAt": "2022-05-23T21:49:28Z",
          "comments": []
        }
      ]
    },
    {
      "number": 691,
      "id": "PR_kwDOBoyH6c44P_tk",
      "title": "Clean up PSK provisions",
      "url": "https://github.com/mlswg/mls-protocol/pull/691",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #666 \r\n\r\nAlso covers the PSK part of #673 ",
      "createdAt": "2022-05-22T18:42:02Z",
      "updatedAt": "2022-05-27T13:45:03Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "083f0fe42c12a14465f03c7096e01502c3a62bd7",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "psk-cleanup",
      "headRefOid": "180d612182c82c5b5e9404ad45b49de9d0a1900e",
      "closedAt": "2022-05-27T13:45:03Z",
      "mergedAt": "2022-05-27T13:45:03Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "76b3c4710bf926b9bceea995b746da5a70bf5f3f"
      },
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Interim 2022-05-26:\r\n\r\n* Ready to go once merge conflicts are resolved.",
          "createdAt": "2022-05-26T14:36:35Z",
          "updatedAt": "2022-05-26T14:36:35Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOBoyH6c46inSd",
          "commit": {
            "abbreviatedOid": "347831e"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-05-23T17:44:41Z",
          "updatedAt": "2022-05-23T17:44:45Z",
          "comments": [
            {
              "originalPosition": 56,
              "body": "```suggestion\r\nA PreSharedKey proposal MUST NOT contain a PSK of type `resumption` that has usage\r\n```",
              "createdAt": "2022-05-23T17:44:41Z",
              "updatedAt": "2022-05-23T17:44:45Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c46kVW8",
          "commit": {
            "abbreviatedOid": "6ef8070"
          },
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-05-24T05:16:46Z",
          "updatedAt": "2022-05-24T05:16:46Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOBoyH6c46inSe",
          "commit": {
            "abbreviatedOid": "6ef8070"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-23T17:44:41Z",
          "updatedAt": "2022-05-24T17:31:34Z",
          "comments": [
            {
              "originalPosition": 56,
              "body": "```suggestion\r\nA PreSharedKey proposal MUST NOT contain a PSK of type `resumption` that has usage\r\n```",
              "createdAt": "2022-05-23T17:44:41Z",
              "updatedAt": "2022-05-24T17:31:34Z"
            },
            {
              "originalPosition": 27,
              "body": "The above line about \"epoch must be 1\" conflicts with this line that \"epoch must be +1 the last Commit\"",
              "createdAt": "2022-05-24T17:31:03Z",
              "updatedAt": "2022-05-24T17:31:34Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c46ojT5",
          "commit": {
            "abbreviatedOid": "6ef8070"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-24T18:51:44Z",
          "updatedAt": "2022-05-24T18:51:57Z",
          "comments": [
            {
              "originalPosition": 24,
              "body": "```suggestion\r\n```",
              "createdAt": "2022-05-24T18:51:45Z",
              "updatedAt": "2022-05-24T18:51:57Z"
            },
            {
              "originalPosition": 27,
              "body": "Good point, reverted.",
              "createdAt": "2022-05-24T18:51:49Z",
              "updatedAt": "2022-05-24T18:51:57Z"
            }
          ]
        }
      ]
    },
    {
      "number": 692,
      "id": "PR_kwDOBoyH6c44XpPL",
      "title": "Use new tree for context in path secret encryption",
      "url": "https://github.com/mlswg/mls-protocol/pull/692",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #648 via option (3)",
      "createdAt": "2022-05-24T14:36:28Z",
      "updatedAt": "2022-05-26T14:47:46Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "b209e1744abd6c4224c45069361a89e5d78d728b",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "update-path-creation",
      "headRefOid": "9cbdc45bc976036bb214000d118c99a824ecad8b",
      "closedAt": "2022-05-26T14:47:46Z",
      "mergedAt": "2022-05-26T14:47:46Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "083f0fe42c12a14465f03c7096e01502c3a62bd7"
      },
      "comments": [
        {
          "author": "mulmarta",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Bringing up the issue mentioned in the comments to #648: this can be inconvenient for implementations because this way the update path can't be generated and encrypted at the same time.\r\n\r\nFrom security perspective, I think it can't break anything, since we include strictly more in the context. On the other hand, it's not clear to me what it buys.",
          "createdAt": "2022-05-24T15:45:20Z",
          "updatedAt": "2022-05-24T15:45:20Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "I sympathize with the idea that this constraints applications.  MLSpp does exactly what you're talking about, updating and encrypting at the same time.  But I'm not really seeing why that refactoring matters all that much.  It's not any more net work, aside from maybe computing a filtered direct path twice.  ",
          "createdAt": "2022-05-24T20:28:15Z",
          "updatedAt": "2022-05-24T20:28:15Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOBoyH6c46ylar",
          "commit": {
            "abbreviatedOid": "9cbdc45"
          },
          "author": "rohan-wire",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-26T14:46:18Z",
          "updatedAt": "2022-05-26T14:46:19Z",
          "comments": [
            {
              "originalPosition": 46,
              "body": "If you want to keep the mental models, you could add:\r\n\"Conceptually, these three states could be thought of as three separate ratchet trees.\"",
              "createdAt": "2022-05-26T14:46:18Z",
              "updatedAt": "2022-05-26T14:46:36Z"
            }
          ]
        }
      ]
    },
    {
      "number": 694,
      "id": "PR_kwDOBoyH6c44Ywdg",
      "title": "Always use a full tree",
      "url": "https://github.com/mlswg/mls-protocol/pull/694",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Based on #689 \r\n\r\nCloses #645 ",
      "createdAt": "2022-05-24T18:46:47Z",
      "updatedAt": "2022-06-02T21:31:09Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "12d8f633e4d093b17e866318c21b1dadf84d4d4d",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "always-full",
      "headRefOid": "a1bf709066346e12824d93ea3b8d950da010224e",
      "closedAt": "2022-06-02T21:31:09Z",
      "mergedAt": "2022-06-02T21:31:09Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "731992b04a0861f11221e2975aae422476fa6465"
      },
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Interim 2022-05-26:\r\n\r\n* This will require some optimized implementations\r\n* Have people done performance evaulations?\r\n    * @bifurcation and @TWal did evaluation on parent hash, this should be easier\r\n* How does this affect the secret tree?\r\n    * Would change the structure to be a full tree\r\n    * Always `log(N)` derivations to get to a leaf, instead of sometimes less\r\n* TODO: Hold this for next week, @bifurcation and @TWal to do performance evaluation",
          "createdAt": "2022-05-26T15:04:00Z",
          "updatedAt": "2022-05-26T15:04:00Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Mailing list post with performance metrics:\r\nhttps://mailarchive.ietf.org/arch/msg/mls/42tmYeZIJRAAZTxnSb6pzXKZGa0/",
          "createdAt": "2022-05-28T18:57:49Z",
          "updatedAt": "2022-05-28T18:57:49Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Interim 2022-06-02:\r\n\r\n* @bifurcation presented performance data showing +/- ~20% on join\r\n* @Bren2010 asked about removing leaf index from LeafNodeHashInput in order to allow for precomputing blank subtree hashes\r\n    * Even with leaf indices, can pre-generate, they just have to be in-place\r\n    * No action\r\n* Clear to merge once editorial comments from @Bren2010 are addressed",
          "createdAt": "2022-06-02T14:24:10Z",
          "updatedAt": "2022-06-02T14:24:10Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOBoyH6c46vF8b",
          "commit": {
            "abbreviatedOid": "3944507"
          },
          "author": "TWal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "Using full tree + filtered direct path seems like a fine combo!\r\n\r\nAs you said in #645 it not only faster, but also makes things a lot easier to understand in various places of the protocol.\r\n\r\nI also like a lot the two examples you added (the one for filtered direct path, and the one for parent-hash link), they have a nice pedagogical value!",
          "createdAt": "2022-05-25T20:18:50Z",
          "updatedAt": "2022-05-25T20:54:57Z",
          "comments": [
            {
              "originalPosition": 57,
              "body": "```suggestion\r\nof a node is effectively a left-first enumeration of the nearest\r\n```\r\n\r\nI find the \"depth-first\" misleading, e.g. in the following tree:\r\n```\r\n      Y\r\n    __|__\r\n   /     \\\r\n  _       Z\r\n / \\     / \\\r\nA   B   C   D\r\n```\r\nthe resolution of Y is A, B, Z and not Z, A, B.\r\n\r\nThinking more about it, this high-level description of what is a \"resolution\" is a bit weird because it doesn't takes into account unmerged leaves.\r\nI think a better high-level description of the \"resolution\" would be something like \"The resolution of a node contains the smallest set of keys required to encrypt a secret to its subtree\".\r\n\r\nWhat do you think?",
              "createdAt": "2022-05-25T20:18:51Z",
              "updatedAt": "2022-05-25T20:54:57Z"
            },
            {
              "originalPosition": 687,
              "body": "```suggestion\r\n* Add: Append `N + 1` blank values to the end of the array.\r\n```\r\n\r\nI think it's N+1 because you need the new right tree of the root (N nodes) + 1 node for the root",
              "createdAt": "2022-05-25T20:46:25Z",
              "updatedAt": "2022-05-25T20:54:57Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c463IMB",
          "commit": {
            "abbreviatedOid": "3944507"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-27T13:43:23Z",
          "updatedAt": "2022-05-27T13:43:23Z",
          "comments": [
            {
              "originalPosition": 57,
              "body": "The point of the \"depth-first, left-first\" language is to clarify the order in which the nodes in the resolution are listed.  As I read it, the language is correct, or maybe better as \"left-first, depth first\", in the sense that you visit the left child before the right child, and if you find a blank left child, you descend before going to the right child.  Following those rules, you do indeed end up at [A, B, Z] in your example -- though of course the resolution of Y should be [Y] ;)\r\n\r\nIn any case, I think the wording here could probably be improved a bit, but I will handle this in a follow-on, since this text is an effect of #689, not this PR.",
              "createdAt": "2022-05-27T13:43:23Z",
              "updatedAt": "2022-05-27T13:43:44Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c47Jg7p",
          "commit": {
            "abbreviatedOid": "6d7c14d"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-01T17:19:08Z",
          "updatedAt": "2022-06-01T22:56:19Z",
          "comments": [
            {
              "originalPosition": 38,
              "body": "2*n-1 is no longer true, right?",
              "createdAt": "2022-06-01T17:19:08Z",
              "updatedAt": "2022-06-01T22:56:19Z"
            },
            {
              "originalPosition": 26,
              "body": "```suggestion\r\nthe nodes' indices in the array.  A more traditional representation based on\r\n```",
              "createdAt": "2022-06-01T17:20:11Z",
              "updatedAt": "2022-06-01T22:56:19Z"
            },
            {
              "originalPosition": 27,
              "body": "```suggestion\r\nlinked node objects may also be used.  {{array-based-trees}} and\r\n```",
              "createdAt": "2022-06-01T17:20:33Z",
              "updatedAt": "2022-06-01T22:56:19Z"
            },
            {
              "originalPosition": 105,
              "body": "```suggestion\r\nnode's key pair would be equivalent to encrypting to its non-copath child.\r\n```",
              "createdAt": "2022-06-01T17:26:25Z",
              "updatedAt": "2022-06-01T22:56:19Z"
            },
            {
              "originalPosition": 619,
              "body": "```suggestion\r\n* F sends an empty Commit, setting X, Y, W\r\n* G removes C and D, blanking V, U, and setting Y, W\r\n* B sends an empty Commit, setting T and W\r\n```",
              "createdAt": "2022-06-01T22:51:53Z",
              "updatedAt": "2022-06-01T22:56:19Z"
            },
            {
              "originalPosition": 627,
              "body": "I would've leaned towards leaving this section as it was, since left-balanced and complete are supposed to be functionally equivalent but left-balanced is more memory efficient.",
              "createdAt": "2022-06-01T22:56:02Z",
              "updatedAt": "2022-06-01T22:56:19Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c47QkpN",
          "commit": {
            "abbreviatedOid": "6d7c14d"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-02T21:13:38Z",
          "updatedAt": "2022-06-02T21:13:38Z",
          "comments": [
            {
              "originalPosition": 38,
              "body": "```suggestion\r\nwith `2^d` leaves has `2^(d+1) - 1` nodes, including parent nodes.\r\n```\r\n\r\nThis is still accurate, but we can phrase it more accurately now that `n` is always a power of 2.",
              "createdAt": "2022-06-02T21:13:38Z",
              "updatedAt": "2022-06-02T21:13:38Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c47Qk-M",
          "commit": {
            "abbreviatedOid": "6d7c14d"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-02T21:15:09Z",
          "updatedAt": "2022-06-02T21:15:09Z",
          "comments": [
            {
              "originalPosition": 37,
              "body": "```suggestion\r\nat `0` from the left to `2^d - 1` at the right (for a tree with `2^d` leaves). A tree\r\n```",
              "createdAt": "2022-06-02T21:15:09Z",
              "updatedAt": "2022-06-02T21:15:09Z"
            }
          ]
        }
      ]
    },
    {
      "number": 695,
      "id": "PR_kwDOBoyH6c44Y1C_",
      "title": "Better documentation for transcript hash",
      "url": "https://github.com/mlswg/mls-protocol/pull/695",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #643 \r\n\r\nChanges `MLSMessageCommitContent -> ConfirmedTranscriptHashInput` and `MLSMessageAuthData -> InterimTranscriptHashInput`.",
      "createdAt": "2022-05-24T19:07:52Z",
      "updatedAt": "2022-05-24T23:14:32Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "b209e1744abd6c4224c45069361a89e5d78d728b",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "commit-content-clarify",
      "headRefOid": "5de54299a70a5a1132c92579d1d9cc02f627b90e",
      "closedAt": "2022-05-24T23:14:32Z",
      "mergedAt": "2022-05-24T23:14:32Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "bd56532ab26a586d1e951705c068f836a3960f51"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOBoyH6c46pgAC",
          "commit": {
            "abbreviatedOid": "5de5429"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-05-24T23:13:59Z",
          "updatedAt": "2022-05-24T23:13:59Z",
          "comments": []
        }
      ]
    },
    {
      "number": 697,
      "id": "PR_kwDOBoyH6c44aPz_",
      "title": "More thorough discussion of sequencing solutions.",
      "url": "https://github.com/mlswg/mls-protocol/pull/697",
      "state": "CLOSED",
      "author": "Bren2010",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This PR changes the \"client / server ordering\" distinction to more appropriate \"CP / AP ordering\".",
      "createdAt": "2022-05-25T03:51:18Z",
      "updatedAt": "2022-05-26T15:11:38Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "bd56532ab26a586d1e951705c068f836a3960f51",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "brendan/sequencing",
      "headRefOid": "3fb562ea76f88a89202c2c9812cff84545fc2b56",
      "closedAt": "2022-05-26T15:11:37Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Interim 2022-05-26:\r\n\r\n* General feeling that the details here should go in the architecture document\r\n* @Bren2010 to make a new PR stripping the sequencing section down to minimal requirements, arch PR to add these details.",
          "createdAt": "2022-05-26T15:11:37Z",
          "updatedAt": "2022-05-26T15:11:37Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOBoyH6c46wgJz",
          "commit": {
            "abbreviatedOid": "3fb562e"
          },
          "author": "rohan-wire",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2022-05-26T06:45:11Z",
          "updatedAt": "2022-05-26T06:53:52Z",
          "comments": [
            {
              "originalPosition": 26,
              "body": "This whole discussion belongs in the architecture document and not the protocol document.",
              "createdAt": "2022-05-26T06:45:11Z",
              "updatedAt": "2022-05-26T06:53:52Z"
            },
            {
              "originalPosition": 58,
              "body": "No thank you. Please do not a use a relatively rare acronym when the reading audience will understand \"Server-Enforced Ordering\" just fine.",
              "createdAt": "2022-05-26T06:47:20Z",
              "updatedAt": "2022-05-26T06:53:52Z"
            },
            {
              "originalPosition": 105,
              "body": "Likewise, using \"AP Ordering\" is going this document less clear.",
              "createdAt": "2022-05-26T06:52:42Z",
              "updatedAt": "2022-05-26T06:53:52Z"
            },
            {
              "originalPosition": 131,
              "body": "I propose we punt all this to the architecture document",
              "createdAt": "2022-05-26T06:53:45Z",
              "updatedAt": "2022-05-26T06:53:52Z"
            }
          ]
        }
      ]
    },
    {
      "number": 698,
      "id": "PR_kwDOBoyH6c44aQJT",
      "title": "Editorial",
      "url": "https://github.com/mlswg/mls-protocol/pull/698",
      "state": "MERGED",
      "author": "Bren2010",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2022-05-25T03:53:47Z",
      "updatedAt": "2022-05-28T19:08:23Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "76b3c4710bf926b9bceea995b746da5a70bf5f3f",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "brendan/editorial4",
      "headRefOid": "84e3bd914f21c4ad95506e9f4282ddaafe8afd0b",
      "closedAt": "2022-05-28T19:08:23Z",
      "mergedAt": "2022-05-28T19:08:23Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "2976ea5b1e4d6de39bcbc6a969a9d85dd6c10602"
      },
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Interim 2022-05-26:\r\n\r\n* @Bren2010 to revert the change that @raphaelrobert notes\r\n* Other changes to be handled as editorial.",
          "createdAt": "2022-05-26T15:16:56Z",
          "updatedAt": "2022-05-26T15:16:56Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOBoyH6c46udPv",
          "commit": {
            "abbreviatedOid": "e7adf28"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Couple of minor things, otherwise lgtm.",
          "createdAt": "2022-05-25T17:56:51Z",
          "updatedAt": "2022-05-25T18:14:01Z",
          "comments": [
            {
              "originalPosition": 206,
              "body": "Why is this requirement being removed?",
              "createdAt": "2022-05-25T17:56:51Z",
              "updatedAt": "2022-05-25T18:14:01Z"
            },
            {
              "originalPosition": 315,
              "body": "I would prefer to keep the explicit requirement to verify the signature.",
              "createdAt": "2022-05-25T18:05:29Z",
              "updatedAt": "2022-05-25T18:14:01Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c46uvFi",
          "commit": {
            "abbreviatedOid": "e7adf28"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-25T18:55:05Z",
          "updatedAt": "2022-05-25T18:55:06Z",
          "comments": [
            {
              "originalPosition": 206,
              "body": "Since this is the section on group creation, it doesn't really go here. I believe this requirement is already repeated in other places, but if not, I'll add it back when reviewing ReInit",
              "createdAt": "2022-05-25T18:55:05Z",
              "updatedAt": "2022-05-25T18:55:06Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c46yHIU",
          "commit": {
            "abbreviatedOid": "709aaca"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-26T13:28:21Z",
          "updatedAt": "2022-05-26T13:28:21Z",
          "comments": [
            {
              "originalPosition": 494,
              "body": "Why remove this? It sounds like a viable strategy in some cases.",
              "createdAt": "2022-05-26T13:28:21Z",
              "updatedAt": "2022-05-26T13:28:21Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c466_0C",
          "commit": {
            "abbreviatedOid": "709aaca"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-28T17:58:50Z",
          "updatedAt": "2022-05-28T17:58:51Z",
          "comments": [
            {
              "originalPosition": 494,
              "body": "I thought about this more and I still don't like this section:\r\n- It says you need one acknowledgement per node in the UpdatePath, but that's not really true. You would need one acknowledgement per *ciphertext* in the UpdatePath since the ciphertexts are independent.\r\n- That's assuming that everybody votes honestly. If the attacker colludes with someone to vote dishonestly, then the same attack still works. So I need acknowledgement from *everybody* in the group.",
              "createdAt": "2022-05-28T17:58:51Z",
              "updatedAt": "2022-05-28T17:58:51Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c466_1M",
          "commit": {
            "abbreviatedOid": "709aaca"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-28T18:00:01Z",
          "updatedAt": "2022-05-28T18:00:02Z",
          "comments": [
            {
              "originalPosition": 494,
              "body": "There's really not a reasonable way to prevent this issue. Can only provide reporting mechanism and make it right when it happens",
              "createdAt": "2022-05-28T18:00:01Z",
              "updatedAt": "2022-05-28T18:00:02Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c467A2-",
          "commit": {
            "abbreviatedOid": "84e3bd9"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-05-28T19:08:02Z",
          "updatedAt": "2022-05-28T19:08:02Z",
          "comments": []
        }
      ]
    },
    {
      "number": 699,
      "id": "PR_kwDOBoyH6c44dib6",
      "title": "Clarify some parts of Application Messages section.",
      "url": "https://github.com/mlswg/mls-protocol/pull/699",
      "state": "MERGED",
      "author": "Bren2010",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #679 ",
      "createdAt": "2022-05-25T17:14:50Z",
      "updatedAt": "2022-06-02T14:25:14Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "bd56532ab26a586d1e951705c068f836a3960f51",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "brendan/app-messages",
      "headRefOid": "17ac10466231481685a1e913ac4c5713abd5dc23",
      "closedAt": "2022-06-02T14:25:13Z",
      "mergedAt": "2022-06-02T14:25:13Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "33ff38abab8a72f765d61e62d6db4913a3b9f20c"
      },
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Interim 2022-05-26:\r\n\r\n* Intended to be mostly editorial\r\n* Leaving open for now\r\n* Clear to merge in between meetings if folks are comfortable",
          "createdAt": "2022-05-26T15:19:37Z",
          "updatedAt": "2022-05-26T15:19:37Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Interim 2022-06-02:\r\n\r\n* Still clear from last week",
          "createdAt": "2022-06-02T14:25:08Z",
          "updatedAt": "2022-06-02T14:25:08Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOBoyH6c46uyc6",
          "commit": {
            "abbreviatedOid": "50228fd"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Couple of friendly amendments, otherwise lgtm.\r\n\r\nI am going to hold this as slightly more than editorial, given the number of MUSTs that are affected.  But I would note for others that the MUSTs that are removed here are all redundant with requirements above.",
          "createdAt": "2022-05-25T19:08:16Z",
          "updatedAt": "2022-05-25T19:11:12Z",
          "comments": [
            {
              "originalPosition": 117,
              "body": "```suggestion\r\nsteps that clients will move the ratchet forward in response to a new message. Messages received\r\n```",
              "createdAt": "2022-05-25T19:08:16Z",
              "updatedAt": "2022-05-25T19:11:12Z"
            },
            {
              "originalPosition": 119,
              "body": "```suggestion\r\ncausing a denial-of-service attack by requiring the recipient to perform an\r\nexcessive number of key derivations.  For example, a malicious group member\r\ncould send a message with `generation = 0xffffffff` at the beginning of a new \r\nepoch, forcing recipients to perform billions of key derivations.\r\n```",
              "createdAt": "2022-05-25T19:09:58Z",
              "updatedAt": "2022-05-25T19:11:12Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c46vQOE",
          "commit": {
            "abbreviatedOid": "e421202"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-25T21:00:30Z",
          "updatedAt": "2022-05-25T21:00:30Z",
          "comments": [
            {
              "originalPosition": 121,
              "body": "```suggestion\r\ncould send a message with `generation = 0xffffffff` at the beginning of a new\r\n```",
              "createdAt": "2022-05-25T21:00:30Z",
              "updatedAt": "2022-05-25T21:00:30Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c46yI39",
          "commit": {
            "abbreviatedOid": "8ff5dcd"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-26T13:33:26Z",
          "updatedAt": "2022-05-26T13:33:26Z",
          "comments": [
            {
              "originalPosition": 118,
              "body": "\"unusually high\" is a bit vague. Maybe we can be more specific here by saying that clients can enforce a maximum difference for the generation counter between two subsequent messages.",
              "createdAt": "2022-05-26T13:33:26Z",
              "updatedAt": "2022-05-26T13:33:26Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c46yJMV",
          "commit": {
            "abbreviatedOid": "8ff5dcd"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "Thanks for picking this up! Just one nit, but looks good otherwise.",
          "createdAt": "2022-05-26T13:34:26Z",
          "updatedAt": "2022-05-26T13:34:26Z",
          "comments": []
        }
      ]
    },
    {
      "number": 701,
      "id": "PR_kwDOBoyH6c44fHMQ",
      "title": "Change KeyPackage identifier to be LeafNode identifier.",
      "url": "https://github.com/mlswg/mls-protocol/pull/701",
      "state": "MERGED",
      "author": "Bren2010",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "At first I was going to make `external_key_id` an extension for both KeyPackages and LeafNodes. But I was thinking and couldn't come up with a reason for KeyPackages to need this extension, so did just LeafNode. Closes #696.",
      "createdAt": "2022-05-25T23:29:35Z",
      "updatedAt": "2022-05-28T19:02:03Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "a662e60c3584eb3d7d5a94694ca719b515d88114",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "brendan/leaf-node-id",
      "headRefOid": "ffb8c569997c3888bd3087f39e5c59f901bcaeca",
      "closedAt": "2022-05-28T19:02:03Z",
      "mergedAt": "2022-05-28T19:02:03Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "bdacb41fff6bc44403023af4046251e199389168"
      },
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Interim 2022-05-26:\r\n\r\n* Agreement to merge\r\n* `external` is getting used a lot, so maybe `application_id` or `client_id`?\r\n* @Bren2010 to change to `application_id`",
          "createdAt": "2022-05-26T15:23:12Z",
          "updatedAt": "2022-05-26T15:23:44Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOBoyH6c46vwoX",
          "commit": {
            "abbreviatedOid": "00f941f"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-05-26T00:13:39Z",
          "updatedAt": "2022-05-26T00:13:39Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOBoyH6c467AyI",
          "commit": {
            "abbreviatedOid": "ffb8c56"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-05-28T19:01:59Z",
          "updatedAt": "2022-05-28T19:01:59Z",
          "comments": []
        }
      ]
    },
    {
      "number": 702,
      "id": "PR_kwDOBoyH6c44l7mV",
      "title": "Update contributors",
      "url": "https://github.com/mlswg/mls-protocol/pull/702",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Updating some affiliations / email addresses and adding a few folks.\r\n\r\n@TWal @mulmarta @tomleavy @psyoptix -- please check for accuracy",
      "createdAt": "2022-05-27T16:23:07Z",
      "updatedAt": "2022-05-30T17:18:12Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "76b3c4710bf926b9bceea995b746da5a70bf5f3f",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "contributors",
      "headRefOid": "03cd96c904da0ed3fe5c3000ffb84aee97c007f2",
      "closedAt": "2022-05-30T17:18:12Z",
      "mergedAt": "2022-05-30T17:18:12Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "6526db8781ab70cf5e21aa5d8c994d26c0bebaea"
      },
      "comments": [
        {
          "author": "mulmarta",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Looks good to me.",
          "createdAt": "2022-05-30T06:00:34Z",
          "updatedAt": "2022-05-30T06:00:34Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOBoyH6c4669jt",
          "commit": {
            "abbreviatedOid": "a84a7be"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-28T16:08:10Z",
          "updatedAt": "2022-05-28T16:08:30Z",
          "comments": [
            {
              "originalPosition": 30,
              "body": "```suggestion\r\nbrendanmcmillion@gmail.com\r\n```",
              "createdAt": "2022-05-28T16:08:10Z",
              "updatedAt": "2022-05-28T16:08:30Z"
            },
            {
              "originalPosition": 29,
              "body": "```suggestion\r\n```",
              "createdAt": "2022-05-28T16:08:18Z",
              "updatedAt": "2022-05-28T16:08:30Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c466_8S",
          "commit": {
            "abbreviatedOid": "a84a7be"
          },
          "author": "tomleavy",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-05-28T18:06:14Z",
          "updatedAt": "2022-05-28T18:06:14Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOBoyH6c467AqI",
          "commit": {
            "abbreviatedOid": "707cebc"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-28T18:52:47Z",
          "updatedAt": "2022-05-28T18:52:47Z",
          "comments": [
            {
              "originalPosition": 31,
              "body": "```suggestion\r\n  brendanmcmillion@gmail.com\r\n```",
              "createdAt": "2022-05-28T18:52:47Z",
              "updatedAt": "2022-05-28T18:52:48Z"
            }
          ]
        }
      ]
    },
    {
      "number": 703,
      "id": "PR_kwDOBoyH6c44myWO",
      "title": "Be more precise about credential validation",
      "url": "https://github.com/mlswg/mls-protocol/pull/703",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #678 \r\nReplaces #660 \r\n\r\nThis PR attempts to add precision to the credential validation requirements in the document, along the lines @raphaelrobert suggests in #678, in the spirit of what @Bren2010 wrote up in #660 and drawing inspiration from what RFC 6125 does in the context of TLS.  It seems like this gives a clearer definition of (a) what the AS's job is and (b) when it needs to be done.",
      "createdAt": "2022-05-27T19:52:23Z",
      "updatedAt": "2022-06-02T14:27:33Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "6526db8781ab70cf5e21aa5d8c994d26c0bebaea",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "cred-val",
      "headRefOid": "9df017b2541ae68d1ea853b83886f2e3224964bf",
      "closedAt": "2022-06-02T14:27:33Z",
      "mergedAt": "2022-06-02T14:27:32Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "c30dd0fd3c000bee004f8a8aa7c1083affc539bc"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOBoyH6c4669cH",
          "commit": {
            "abbreviatedOid": "53ff186"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-05-28T16:01:55Z",
          "updatedAt": "2022-05-28T16:07:15Z",
          "comments": [
            {
              "originalPosition": 33,
              "body": "```suggestion\r\n\"presented identifiers\".  A member of a group is authenticated by first\r\n```",
              "createdAt": "2022-05-28T16:01:55Z",
              "updatedAt": "2022-05-28T16:07:15Z"
            },
            {
              "originalPosition": 55,
              "body": "In each of these cases, where does the reference identifier come from? The reference/presented identifier distinction makes sense in TLS because you have a domain the user has typed in. Not as clear in MLS.",
              "createdAt": "2022-05-28T16:07:12Z",
              "updatedAt": "2022-05-28T16:07:15Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c467Zz-",
          "commit": {
            "abbreviatedOid": "53ff186"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "Thanks for picking it up!",
          "createdAt": "2022-05-29T18:19:42Z",
          "updatedAt": "2022-05-29T18:20:19Z",
          "comments": [
            {
              "originalPosition": 50,
              "body": "```suggestion\r\n  either via a Welcome or via an External Commit\r\n```",
              "createdAt": "2022-05-29T18:19:42Z",
              "updatedAt": "2022-05-29T18:20:19Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c468FvJ",
          "commit": {
            "abbreviatedOid": "53ff186"
          },
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "Looks good in general, thanks for the PR!",
          "createdAt": "2022-05-30T06:18:54Z",
          "updatedAt": "2022-05-30T06:18:54Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOBoyH6c468GDA",
          "commit": {
            "abbreviatedOid": "53ff186"
          },
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-30T06:20:30Z",
          "updatedAt": "2022-05-30T06:20:30Z",
          "comments": [
            {
              "originalPosition": 55,
              "body": "We might want to also do this check whenever a new credential shows up in the External Senders extension. ",
              "createdAt": "2022-05-30T06:20:30Z",
              "updatedAt": "2022-05-30T06:20:30Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c47DUB5",
          "commit": {
            "abbreviatedOid": "53ff186"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-31T16:02:06Z",
          "updatedAt": "2022-05-31T16:02:07Z",
          "comments": [
            {
              "originalPosition": 55,
              "body": "It's not so different in messaging applications.  When you add someone to the group, you type in some identifier for them.  And there's typically a way that the application tells you who is in the group, independent of the crypto.  E.g., if you were mapping this on to XMPP, you might compare the credentials to [the JIDs in the roster](https://xmpp.org/rfcs/rfc6121.html#roster-syntax-items-jid).",
              "createdAt": "2022-05-31T16:02:06Z",
              "updatedAt": "2022-05-31T16:02:07Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c47DUPp",
          "commit": {
            "abbreviatedOid": "53ff186"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-31T16:02:46Z",
          "updatedAt": "2022-05-31T16:02:47Z",
          "comments": [
            {
              "originalPosition": 55,
              "body": "Good point, will do.",
              "createdAt": "2022-05-31T16:02:46Z",
              "updatedAt": "2022-05-31T16:02:47Z"
            }
          ]
        }
      ]
    },
    {
      "number": 704,
      "id": "PR_kwDOBoyH6c44oXth",
      "title": "Minimize sequencing section.",
      "url": "https://github.com/mlswg/mls-protocol/pull/704",
      "state": "MERGED",
      "author": "Bren2010",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2022-05-28T17:40:52Z",
      "updatedAt": "2022-06-02T22:06:16Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "76b3c4710bf926b9bceea995b746da5a70bf5f3f",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "brendan/no-sequencing",
      "headRefOid": "4423110cb302334aefc1cef4abb30b34ec93de39",
      "closedAt": "2022-06-02T22:06:16Z",
      "mergedAt": "2022-06-02T22:06:16Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "3044b38638216fb6fd124d795129ed87770e5f9d"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOBoyH6c47OcsD",
          "commit": {
            "abbreviatedOid": "313dbcc"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-02T14:32:20Z",
          "updatedAt": "2022-06-02T14:32:21Z",
          "comments": [
            {
              "originalPosition": 27,
              "body": "Interim 2022-06-02:\r\n\r\n* Probably too tight.  E.g., client could send Commit+Welcome to DS, then DS could decide whether to send Welcome based on whether Commit is accepted.  Proposed text:\r\n\r\n> The Welcome message corresponding to a Commit MUST NOT be delivered to a new joiner until it's clear that the Commit has been accepted.\r\n\r\n* Otherwise clear to merge",
              "createdAt": "2022-06-02T14:32:20Z",
              "updatedAt": "2022-06-02T14:32:21Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c47Qto-",
          "commit": {
            "abbreviatedOid": "313dbcc"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-02T22:00:40Z",
          "updatedAt": "2022-06-02T22:00:41Z",
          "comments": [
            {
              "originalPosition": 27,
              "body": "```suggestion\r\nmessage will conflict with another Commit or not. Similarly, the Welcome\r\nmessage corresponding to a Commit MUST NOT be delivered to a new\r\njoiner until it's clear that the Commit has been accepted.\r\n```",
              "createdAt": "2022-06-02T22:00:40Z",
              "updatedAt": "2022-06-02T22:00:41Z"
            }
          ]
        }
      ]
    },
    {
      "number": 705,
      "id": "PR_kwDOBoyH6c44oZ3D",
      "title": "Clarify rules around Add proposals.",
      "url": "https://github.com/mlswg/mls-protocol/pull/705",
      "state": "MERGED",
      "author": "Bren2010",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #700 ",
      "createdAt": "2022-05-28T18:35:30Z",
      "updatedAt": "2022-06-02T14:33:32Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "76b3c4710bf926b9bceea995b746da5a70bf5f3f",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "brendan/add-rules",
      "headRefOid": "571585fb0265bf34b16abf269a320da6ad3622d4",
      "closedAt": "2022-06-02T14:33:32Z",
      "mergedAt": "2022-06-02T14:33:31Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "dcf4ec5a4a8ceeef3432ef2a26a4c39d0c16d9b2"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOBoyH6c467A2j",
          "commit": {
            "abbreviatedOid": "2c15b9d"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-05-28T19:07:37Z",
          "updatedAt": "2022-05-28T19:07:37Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOBoyH6c467A5z",
          "commit": {
            "abbreviatedOid": "2c15b9d"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-28T19:10:29Z",
          "updatedAt": "2022-05-28T19:10:38Z",
          "comments": [
            {
              "originalPosition": 25,
              "body": "```suggestion\r\n  in the group according to the application, unless there is a Remove proposal\r\n  in the list removing the matching client from the group.\r\n```\r\n\r\nClarifies what it means for a client to be \"removed by another proposal\", and keeps it scoped to the proposal list.",
              "createdAt": "2022-05-28T19:10:29Z",
              "updatedAt": "2022-05-28T19:10:38Z"
            }
          ]
        }
      ]
    },
    {
      "number": 706,
      "id": "PR_kwDOBoyH6c44pMGK",
      "title": "Clean up struct names and references to them",
      "url": "https://github.com/mlswg/mls-protocol/pull/706",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #673 \r\nCloses #674 \r\n\r\nWith regard to #674: I searched for references to MLSPlaintext and Credential that were obsolete in light of the change to the MLSMessage framework.  (In particular, we used to have the idea that you would encode things as MLSPlaintext, then tranform them to MLSCiphertext if needed; now you encode to AuthenticatedContent and then convert that to MLSPlaintext/MLSCiphertext before sending.)  There were a few fixes for MLSPlaintext; I didn't find anything that needed fixing for Credentia, largely thanks to some PRs that have landed since I did the review that resulted in #674.",
      "createdAt": "2022-05-29T18:35:53Z",
      "updatedAt": "2022-06-03T18:26:13Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "731992b04a0861f11221e2975aae422476fa6465",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "streamline-structs",
      "headRefOid": "5a3b54928451246c02126b1a0f616665e02e3fbe",
      "closedAt": "2022-06-03T18:26:13Z",
      "mergedAt": "2022-06-03T18:26:12Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "8ffcba09d0e496db5e679aca1142200e8d1f8c0d"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOBoyH6c46-y4o",
          "commit": {
            "abbreviatedOid": "6936c4d"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-30T16:13:41Z",
          "updatedAt": "2022-05-30T16:21:20Z",
          "comments": [
            {
              "originalPosition": 160,
              "body": "```suggestion\r\nat the same state of the group. A ContentAuthData is said to be valid when both\r\n```",
              "createdAt": "2022-05-30T16:13:41Z",
              "updatedAt": "2022-05-30T16:21:20Z"
            },
            {
              "originalPosition": 65,
              "body": "```suggestion\r\nMessages from senders that aren't in the group are sent as MLSPlaintext. See\r\n```",
              "createdAt": "2022-05-30T16:14:06Z",
              "updatedAt": "2022-05-30T16:21:21Z"
            },
            {
              "originalPosition": 66,
              "body": "```suggestion\r\n{{external-proposals}} and {{joining-via-external-commits}} for more details.\r\n```",
              "createdAt": "2022-05-30T16:15:08Z",
              "updatedAt": "2022-05-30T16:21:21Z"
            },
            {
              "originalPosition": 261,
              "body": "```suggestion\r\nProposals are included in a MessageContent by way of a Proposal structure\r\n```",
              "createdAt": "2022-05-30T16:16:29Z",
              "updatedAt": "2022-05-30T16:21:21Z"
            },
            {
              "originalPosition": 272,
              "body": "```suggestion\r\nOn receiving a MessageContent containing a Proposal, a client MUST verify the\r\n```",
              "createdAt": "2022-05-30T16:16:40Z",
              "updatedAt": "2022-05-30T16:21:21Z"
            },
            {
              "originalPosition": 294,
              "body": "```suggestion\r\n* Construct a MessageContent object containing the Commit object. Sign the\r\n```",
              "createdAt": "2022-05-30T16:17:07Z",
              "updatedAt": "2022-05-30T16:21:21Z"
            },
            {
              "originalPosition": 364,
              "body": "```suggestion\r\n    Extension extensions<V>;\r\n```",
              "createdAt": "2022-05-30T16:18:54Z",
              "updatedAt": "2022-05-30T16:21:21Z"
            },
            {
              "originalPosition": 362,
              "body": "- [x] Please also update GroupInfoTBS below.\r\n- [x] Three references to `group_context_extensions` in text",
              "createdAt": "2022-05-30T16:20:55Z",
              "updatedAt": "2022-06-02T21:36:08Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c46-0cx",
          "commit": {
            "abbreviatedOid": "6936c4d"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-30T16:22:31Z",
          "updatedAt": "2022-05-30T16:22:31Z",
          "comments": [
            {
              "originalPosition": 364,
              "body": "Also will need to update three references to `other_extensions` in text",
              "createdAt": "2022-05-30T16:22:31Z",
              "updatedAt": "2022-05-30T16:22:31Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c47Og6N",
          "commit": {
            "abbreviatedOid": "6936c4d"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Interim 2022-06-22\r\n\r\n* @rohan-wire has found names with `MLS` in them useful in distinguishing from others\r\n    * TODO: Re-add MLS to `MessageContent`, `ContentAuthData`, `AuthenticatedContent`\r\n* TODO: Address Brendan's comments \r\n* Otherwise, clear to merge",
          "createdAt": "2022-06-02T14:41:35Z",
          "updatedAt": "2022-06-02T14:41:35Z",
          "comments": []
        }
      ]
    },
    {
      "number": 707,
      "id": "PR_kwDOBoyH6c44pMP_",
      "title": "Derive the commit secret from the end of the UpdatePath, not the root",
      "url": "https://github.com/mlswg/mls-protocol/pull/707",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #690 ",
      "createdAt": "2022-05-29T18:40:00Z",
      "updatedAt": "2022-06-02T14:47:43Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "2976ea5b1e4d6de39bcbc6a969a9d85dd6c10602",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "commit-secret-next",
      "headRefOid": "847f05cd92d5e371208df63b1f955887bf3fe786",
      "closedAt": "2022-06-02T14:47:43Z",
      "mergedAt": "2022-06-02T14:47:42Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "9575a9d259f4db75aee8706b3faf1e2186c5c76e"
      },
      "comments": [
        {
          "author": "TWal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "One argument for the other option (i.e. force the root to be in the filtered updatepath): it gives a parent-hash chain from the comitting leaf to up to the root, hence the whole tree is bound in the leaf signature (assuming #713).\r\nIt ensures you can't modify the empty subtree.\r\n\r\nI don't think that's a huge deal, because you can always do modifications like this: given a tree T1, you can create tree T2 and a new root R like this (with the parent-hash link of R coming from T2):\r\n```\r\n   R\r\n /  \\\r\nT1  T2\r\n```\r\n\r\nBut it's worth noting that this change is not purely a TreeKEM change.",
          "createdAt": "2022-06-01T20:01:31Z",
          "updatedAt": "2022-06-01T20:01:31Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Interim 2022-06-02\r\n\r\n* As @TWal notes in his comments, tree malleability is not worth blocking this for because you won't block the tree-extension attack anyway\r\n* @mulmarta notes the exception case where the UpdatePath has no nodes in it\r\n    * @bifurcation suggests we should just forbid that case\r\n    * @bifurcation will file a new PR to forbid that case\r\n",
          "createdAt": "2022-06-02T14:47:38Z",
          "updatedAt": "2022-06-02T14:47:38Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOBoyH6c46-0kY",
          "commit": {
            "abbreviatedOid": "847f05c"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-05-30T16:23:08Z",
          "updatedAt": "2022-05-30T16:23:08Z",
          "comments": []
        }
      ]
    },
    {
      "number": 708,
      "id": "PR_kwDOBoyH6c44pNNi",
      "title": "Describe requests to join and directed KeyPackages",
      "url": "https://github.com/mlswg/mls-protocol/pull/708",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #693 \r\n\r\n(At least, this is one approach to closing #693)\r\n\r\nThis PR implements the \"directed KeyPackage\" approach discussed in #693.\r\n\r\nIt uses a KeyPackage extension to carry the target group ID.  This could also be an optional field on KeyPackage. I mainly shied away from that because the mechanics of the TLS presentation syntax would require us to define something like `struct { opaque group_id<V>; } GroupID;` (so that we could have `optional<GroupID>`), which seemed ugly.\r\n\r\nI've also added a subsection to the protocol overview that discusses requests to be added.  I would suggest we add such a subsection regardless of how we resolve #693, to make sure we provide good context  for how the mechanism we define is used.",
      "createdAt": "2022-05-29T19:05:47Z",
      "updatedAt": "2022-06-02T15:41:41Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "2976ea5b1e4d6de39bcbc6a969a9d85dd6c10602",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "directed-key-package",
      "headRefOid": "28959270063afbd8d8698d4138017ff377818b2b",
      "closedAt": "2022-06-02T15:41:41Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "body": "I think that's an excellent candidate for the MLS Extensions document, given that it's a pretty niche feature and that it is written as an extension.",
          "createdAt": "2022-05-30T16:29:39Z",
          "updatedAt": "2022-05-30T16:29:39Z"
        },
        {
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "body": "Making this peer-to-peer (B requests a join from A) seems like an anti-pattern given that MLS is supposed to be async. Might make more sense to have the dominant example be: B requests a join from pre-configured external sender service. Phrasing it that way actually answers my question from before about why we need this extension. The pre-configured external sender service needs the group_id extension, while normal members of the group don't.\r\n\r\nEdit: Agreed that this is a good candidate to just be an extension",
          "createdAt": "2022-05-30T16:39:01Z",
          "updatedAt": "2022-05-30T16:40:11Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Replying to two points from @Bren2010 \r\n\r\n* Re: The value of this extension - The way you get a security property here is if the application knows which channel (prepublished or proactive) the KeyPackage came through, and rejects non-directed KeyPackages in the proactive channe.  It also give the client posting the KeyPackage some control: If my client only ever joins proactively, I can make it so that my KeyPackages can't be replayed from one group to another.\r\n\r\n* Re: Async - This pattern doesn't break the async property any more than prepublication does.  The overall message flow is the same as the prepublicaiton case; the only difference is whether the KeyPackage is pulled or pushed.",
          "createdAt": "2022-05-30T17:17:00Z",
          "updatedAt": "2022-05-30T17:17:00Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Interim 2022-06-02:\r\n\r\n* Closing in favor of #716 ",
          "createdAt": "2022-06-02T15:41:41Z",
          "updatedAt": "2022-06-02T15:41:41Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOBoyH6c46-160",
          "commit": {
            "abbreviatedOid": "2895927"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-05-30T16:31:28Z",
          "updatedAt": "2022-05-30T16:35:27Z",
          "comments": [
            {
              "originalPosition": 49,
              "body": "```suggestion\r\nKeyPackage by including an extension of type `group_id`, of the following\r\n```",
              "createdAt": "2022-05-30T16:31:28Z",
              "updatedAt": "2022-05-30T16:35:27Z"
            },
            {
              "originalPosition": 73,
              "body": "```suggestion\r\n* If the `extensions` field contains an extension of type `group_id`,\r\n```",
              "createdAt": "2022-05-30T16:33:33Z",
              "updatedAt": "2022-05-30T16:35:27Z"
            },
            {
              "originalPosition": 64,
              "body": "I don't understand the value of having this extension. If pre-published KeyPackages already exist without this extension, then I can just use them to do whatever nefarious thing you're trying to stop from happening with the directed KeyPackages.",
              "createdAt": "2022-05-30T16:35:15Z",
              "updatedAt": "2022-05-30T16:35:27Z"
            }
          ]
        }
      ]
    },
    {
      "number": 709,
      "id": "PR_kwDOBoyH6c44pOQq",
      "title": "Add a subsection on applying a proposal list",
      "url": "https://github.com/mlswg/mls-protocol/pull/709",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #665 \r\n\r\nFollowing the pattern of #675, this PR introduces a new section describing how a list of proposals is applied to make a new RatchetTree and GroupContext.  It also moves the validation section introduced in that PR forward so that the sections on validating and applying proposal lists are within the Proposals subsection.",
      "createdAt": "2022-05-29T19:31:03Z",
      "updatedAt": "2022-06-02T21:58:06Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "731992b04a0861f11221e2975aae422476fa6465",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "apply-proposals",
      "headRefOid": "55ede3a26d3e0c127d356ffa04074f746445390b",
      "closedAt": "2022-06-02T21:58:06Z",
      "mergedAt": "2022-06-02T21:58:06Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "fd5ea7fbe0a53f13d6af315d6eafc20a05d0f077"
      },
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "One thing I'm not sure about, would like feedback on: When should GroupContextExtensions be applied?  It seems like you could do it either at the front or the back.  I put it at the front so that it could set context for the remaining proposals.  For example, if the GroupContextExtensions introduces a `required_capabilities` extension, then the Adds would be evaluated against it.",
          "createdAt": "2022-05-29T19:36:45Z",
          "updatedAt": "2022-05-29T19:36:45Z"
        },
        {
          "author": "tomleavy",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yes agreed, you sort of need to apply it first so that you can use the RequiredCapabilities to check the other proposals ",
          "createdAt": "2022-05-29T20:25:46Z",
          "updatedAt": "2022-05-29T20:25:46Z"
        },
        {
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "body": "Fwiw all that's in this PR currently is moving the validation section",
          "createdAt": "2022-05-30T17:03:54Z",
          "updatedAt": "2022-05-30T17:03:54Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks @Bren2010, forgot to push.  Latest commit should have all the changes.\r\n",
          "createdAt": "2022-05-30T17:10:13Z",
          "updatedAt": "2022-05-30T17:10:13Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOBoyH6c47OKZC",
          "commit": {
            "abbreviatedOid": "b3b3f41"
          },
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-06-02T13:46:00Z",
          "updatedAt": "2022-06-02T13:48:44Z",
          "comments": [
            {
              "originalPosition": 65,
              "body": "```suggestion\r\nProposal types defined in the future may make updates to the above validation\r\n```",
              "createdAt": "2022-06-02T13:46:00Z",
              "updatedAt": "2022-06-02T13:48:44Z"
            },
            {
              "originalPosition": 71,
              "body": "Either leave out the \"each\" here, or make it \"... proposal is ...\".",
              "createdAt": "2022-06-02T13:47:03Z",
              "updatedAt": "2022-06-02T13:48:44Z"
            },
            {
              "originalPosition": 80,
              "body": "```suggestion\r\n* Apply any Remove proposals to the ratchet tree, in any order.\r\n```",
              "createdAt": "2022-06-02T13:47:35Z",
              "updatedAt": "2022-06-02T13:48:44Z"
            },
            {
              "originalPosition": 89,
              "body": "```suggestion\r\n  use later in Commit processing.\r\n```",
              "createdAt": "2022-06-02T13:48:10Z",
              "updatedAt": "2022-06-02T13:48:44Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c47OoCK",
          "commit": {
            "abbreviatedOid": "b3b3f41"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-02T15:00:28Z",
          "updatedAt": "2022-06-02T15:00:29Z",
          "comments": [
            {
              "originalPosition": 76,
              "body": "Interim 2022-06-02:\r\n\r\n* Clarify that this means that the new extensions apply to other proposals in the same list.",
              "createdAt": "2022-06-02T15:00:29Z",
              "updatedAt": "2022-06-02T15:00:29Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c47OokS",
          "commit": {
            "abbreviatedOid": "b3b3f41"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Interim 2022-06-02:\r\n\r\n* @bifurcation to resolve comments, then merge",
          "createdAt": "2022-06-02T15:01:58Z",
          "updatedAt": "2022-06-02T15:01:58Z",
          "comments": []
        }
      ]
    },
    {
      "number": 710,
      "id": "PR_kwDOBoyH6c44wdh4",
      "title": "Clarify validation rules for ReInit.",
      "url": "https://github.com/mlswg/mls-protocol/pull/710",
      "state": "MERGED",
      "author": "Bren2010",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2022-05-31T17:17:48Z",
      "updatedAt": "2022-06-02T15:04:34Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "6526db8781ab70cf5e21aa5d8c994d26c0bebaea",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "brendan/fix-reinit",
      "headRefOid": "4e9aa5bff683302aa2a162fc38f524f3997ae42f",
      "closedAt": "2022-06-02T15:04:33Z",
      "mergedAt": "2022-06-02T15:04:33Z",
      "mergedBy": "seanturner",
      "mergeCommit": {
        "oid": "378a68e49c31418a5cd7b77923b8631632cdddad"
      },
      "comments": [
        {
          "author": "seanturner",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Interim 2022-06-02:\r\n* Merge",
          "createdAt": "2022-06-02T15:04:23Z",
          "updatedAt": "2022-06-02T15:04:23Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 712,
      "id": "PR_kwDOBoyH6c44xinv",
      "title": "Clarify description of UpdatePath generation and processing",
      "url": "https://github.com/mlswg/mls-protocol/pull/712",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #671 \r\n\r\nConflicts with #707 (in derivation of `commit_secret`)\r\n\r\nThis is intended just to move around the required steps and give them clearer labels.  Please keep an eye out for things that might have accidentally been added or dropped.",
      "createdAt": "2022-05-31T23:14:53Z",
      "updatedAt": "2022-06-08T17:56:14Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "6526db8781ab70cf5e21aa5d8c994d26c0bebaea",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "create-update-path",
      "headRefOid": "166073f764c3d592296603d1b590a4ff75e2da5f",
      "closedAt": "2022-06-08T17:56:13Z",
      "mergedAt": "2022-06-08T17:56:13Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "83f8648a3ba0d39a16c7ec5c93b0d6b7b3decaab"
      },
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Interim 2022-06-02:\r\n\r\n* @kkohbrok to review, then clear to merge",
          "createdAt": "2022-06-02T15:08:28Z",
          "updatedAt": "2022-06-02T15:08:28Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOBoyH6c47neTd",
          "commit": {
            "abbreviatedOid": "166073f"
          },
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-06-08T17:53:50Z",
          "updatedAt": "2022-06-08T17:53:50Z",
          "comments": []
        }
      ]
    },
    {
      "number": 713,
      "id": "PR_kwDOBoyH6c4422gx",
      "title": "Improve parent hash guarantees",
      "url": "https://github.com/mlswg/mls-protocol/pull/713",
      "state": "MERGED",
      "author": "TWal",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "# A nice security property for parent-hash\r\n\r\nThe goal of #527 was to have a property similar to:\r\n\r\n> If there is a parent-hash chain from the leaf L to a node N, then the signature of L binds the tree Canonicalize(N)\r\n\r\n(where Canonicalize(N) is N with its unmerged leaves removed, i.e. the subtree of N the last time a Commit went through it)\r\n\r\nHowever, this is currently not true, there are a few places where we can do (hopefully benign) modifications on N.\r\n\r\nExample 1:\r\n```\r\n              W\r\n        ______|_____\r\n       /             \\\r\n      _               Y\r\n    __|__           __|__\r\n   /     \\         /     \\\r\n  T       _       X       Z\r\n / \\     / \\     / \\     / \\\r\nA   B   _   _   E   F   G   H\r\n```\r\n\r\nwith the parent-hash chain A-T-W (happening with filtered update path).\r\n\r\nWe can modify the blank subtree:\r\n\r\n```\r\n              W\r\n        ______|_____\r\n       /             \\\r\n      _               Y\r\n    __|__           __|__\r\n   /     \\         /     \\\r\n  T       V       X       Z\r\n / \\     / \\     / \\     / \\\r\nA   B   C   D   E   F   G   H\r\n```\r\n\r\nand the parent-hash chain A-T-W is still valid\r\n\r\nExample 2:\r\n\r\n```\r\n              W\r\n        ______|_____\r\n       /             \\\r\n      U               Y\r\n    __|__           __|__\r\n   /     \\         /     \\\r\n  T       V       X       Z\r\n / \\     / \\     / \\     / \\\r\nA   B   _   D   E   F   G   H\r\n```\r\n\r\nwith the parent-hash chain A-T-U-W.\r\n\r\nWe can add unmerged leaves:\r\n\r\n```\r\n              W\r\n        ______|_____\r\n       /             \\\r\n      U[C]            Y\r\n    __|__           __|__\r\n   /     \\         /     \\\r\n  T       V[C]    X       Z\r\n / \\     / \\     / \\     / \\\r\nA   B   C   D   E   F   G   H\r\n```\r\n\r\nand the parent-hash chain A-T-U-W is still valid.\r\n\r\n# How to get this property\r\n\r\nThese examples are not possible if we require the parent-hash check to verify other invariants that exists in MLS:\r\n- if there is a parent-hash link from U to P and there are blank nodes between U and P, these blank nodes are here because of the filtered update path so their sibling have empty resolution (this invariant forbids example 1)\r\n- if there is a parent-hash link from U to P, then there can't be a leaf which is merged for U but not for P, because U and P were last modified by a commit at the same time (this invariant forbids example 2)\r\n\r\nThis PR add these checks to the parent hash validation procedure.\r\n\r\n# Proof that we do have the property with this PR\r\n\r\n## Definitions\r\n\r\nUn-adding leaves:\r\nLet N be a node, and Ls a list of leaves.\r\nThen UnAdd(N, Ls) is a tree identical to N, except that the leaves of Ls are blanked and removed from every node's unmerged leaves list.\r\nInformally, this operation is the inverse of adding leaves Ls in N by participant not in N.\r\n\r\nCanonicalization:\r\nWe define Canonicalize(N) = UnAdd(N, N.unmerged_leaves).\r\n\r\nTree equivalence:\r\nWe say T1 ~= T2 when Canonicalize(T1) = Canonicalize(T2).\r\n\r\nParent-hash link:\r\nWe say C ~> P when \"the parent hash in a node C is valid with respect to a parent node P\" as described in the \"Verifying Parent Hashes\" section (modified by this PR)\r\n\r\n# Key property on ~= and ~>\r\n\r\nWe prove the following property:\r\nIf C ~> P\r\nand C' ~> P'\r\nand C ~= C'\r\nthen P ~= P'.\r\n\r\nThis is better understood with a nice square:\r\n```\r\nIf we have:\r\n\r\nC ~= C'\r\n~    ~\r\nV    V\r\nP    P'\r\n\r\nThen there is a ~= between P and P'\r\n```\r\n\r\nProof of this property:\r\n\r\nLet S (resp. S') be the sibling in the C ~> P (resp. C' ~> P') relation. Because leaf indices are inside the tree hash, S and S' are both on the same side of P and P'.\r\n\r\nFact 1: UnAdd(S, P.unmerged_leaves) = UnAdd(S', P'.unmerged_leaves).\r\nProof: By definition of the parent hash and injectivity of tree-hash.\r\n\r\nFact 2: UnAdd(C, P.unmerged_leaves) = UnAdd(C', P'.unmerged_leaves).\r\nProof:\r\n\r\n```\r\n  UnAdd(C, P.unmerged_leaves)\r\n= UnAdd(C, Intersection(P.unmerged_leaves, Leaves(C))     by a simple lemma on UnAdd\r\n= UnAdd(C, C.unmerged_leaves)                             by C ~> P (we use the second new invariant here!)\r\n= UnAdd(C', C'.unmerged_leaves)                           by C ~= C'\r\n= UnAdd(C', Intersection(P'.unmerged_leaves, Leaves(C'))) by C' ~> P' (we use the second new invariant here!)\r\n= UnAdd(C', P'.unmerged_leaves)                           by a simple lemma on UnAdd\r\n```\r\n\r\nWith Fact 1 and Fact 2, we deduce that P ~= P' (we use the first new invariant here!).\r\n\r\n# Proof of signature binding\r\n\r\nA leaf signature binds the existence of nodes Mi suh that L ~> M1 ~> ... ~> Mm = root\r\n\r\nWhen there is a parent-hash-link path to a node P starting from a leaf L like L ~> N1 ~> ... ~> Nn ~> P, by applying inductively the property on ~= and ~> you get P ~= Mi for some i, hence L's signature binds Canonicalize(P) = Canonicalize(Mi).\r\n",
      "createdAt": "2022-06-01T13:25:02Z",
      "updatedAt": "2022-06-09T14:13:55Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "839ebbb9b265a39a84cfcb3ac37c54d0a4a70134",
      "headRepository": "TWal/mls-protocol",
      "headRefName": "twal_parent_hash_invariants",
      "headRefOid": "698a343030d12419535477ee679da4849fac30fd",
      "closedAt": "2022-06-09T14:13:54Z",
      "mergedAt": "2022-06-09T14:13:54Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "c47951f54cba337123be1668aa52c5f9d94a3d33"
      },
      "comments": [
        {
          "author": "mulmarta",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I haven\u2019t had tome to look at the proofs, but I have questions:\r\n\r\nRe. Example 1 (and the first new check) what about the following scenario: We start with this tree. \r\n\r\n~~~ aasvg\r\n                ________________R\r\n               /                |\r\n              W                 |\r\n        ______|_____            |\r\n       /             \\          |\r\n      _               Y         |\r\n    __|__           __|__       |\r\n   /     \\         /     \\      |\r\n  T       _       X       Z     |\r\n / \\     / \\     / \\     / \\    |\r\nA   B   _   _   E   F   G   H   I\r\n~~~\r\n\r\nThen `A` commits, setting the A-T-W path then `I` commits adding `C` and we have\r\n\r\n~~~ aasvg\r\n                ________________R\r\n               /                |\r\n              W[C]              |\r\n        ______|_____            |\r\n       /             \\          |\r\n      _               Y         |\r\n    __|__           __|__       |\r\n   /     \\         /     \\      |\r\n  T       _       X       Z     |\r\n / \\     / \\     / \\     / \\    |\r\nA   B   C   _   E   F   G   H   I\r\n~~~\r\n\r\nAccording to your rules, verification of the parent hash of W no longer works, because the blank sibling of T doesn\u2019t have an empty resolution \u2014 it contains C.\r\n\r\n\r\nRe. Example 2 (and the second new check), consider analogous scenario: We start with this tree:\r\n\r\n~~~ aasvg               \r\n              W                 \r\n        ______|_____            \r\n       /             \\          \r\n      U               Y         \r\n    __|__           __|__       \r\n   /     \\         /     \\      \r\n  T       V       X       Z     \r\n / \\     / \\     / \\     / \\   \r\nA   B   _   D   E   F   G   H\r\n~~~\r\n\r\nThen `A` commits setting the A-T-U path and then `G` commits adding `C` and we get\r\n\r\n~~~ aasv\r\n              W              \r\n        ______|_____            \r\n       /             \\          \r\n      U[C]            Y         \r\n    __|__           __|__       \r\n   /     \\         /     \\      \r\n  T       V[C]    X       Z     \r\n / \\     / \\     / \\     / \\    \r\nA   B   C   D   E   F   G   H   \r\n~~~\r\n\r\nThe result look the same as the \u201cbad case\u201d in Example 2. On the other hand, the second new check still passes. So why do you think it prevents the example?",
          "createdAt": "2022-06-01T18:34:17Z",
          "updatedAt": "2022-06-01T18:34:17Z"
        },
        {
          "author": "TWal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "About example 2:\r\nIn my example, with the new invariants, the link U ~> W is broken since U.unmerged_leaves = [C] and Intersection(W.unmerged_leaves, Leaves(U)) = []. Therefore it won't be accepted by the parent hash verification procedure.\r\nIn you example, with the new invariants, W is authenticated by Y ~> W, so there is no problem.\r\n\r\nAbout example 1:\r\nYou are right, there is a problem here.\r\nA quick fix coming to my mind would be: \"The sibling of every node with a blank parent between U (included) and P (excluded) has a resolution included in P.unmerged_leaves\".\r\n\r\nIt doesn't affect my proof, and I think it is this time actually an invariant of MLS (didn't do the proof thoroughly yet so I might be mistaken).",
          "createdAt": "2022-06-01T19:29:57Z",
          "updatedAt": "2022-06-01T19:29:57Z"
        },
        {
          "author": "mulmarta",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think that the quick fix for rule 1 may work. Rule 2 shouldn't hurt correctness either. Nevertheless, I'd feel more confident after seeing a thorough proof of correctness.\r\n\r\nRe. example 2, you're right and thanks for explaining!",
          "createdAt": "2022-06-01T20:14:34Z",
          "updatedAt": "2022-06-01T20:14:34Z"
        },
        {
          "author": "TWal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Here is a quick proof:\r\n\r\nGiven a parent-hash link C ~> P, we write Trees(C ~> P) the list of subtrees of siblings of nodes whose parents are blank between C and P.\r\n\r\nWhen a parent-hash link C ~> P is created, it because there is a Commit going through C and P, the blank nodes between C and P are here because of the filtered direct path, so every tree in Trees(C ~> P) have empty resolution, hence they are included in P.unmerged_leaves.\r\n\r\nGiven a parent-hash link C ~> P, let's see what happens if a tree Ti of Trees(C ~> P) is modified.\r\n- If the operation is a Remove, then P is blanked and the parent-hash link C ~> P don't exist in the new tree\r\n- If the operation is an Add, and the new leaf is L, then we have (before the operation) Resolution(Ti) included in P.unmerged_leaves, so Resolution(Ti) + L included in P.unmerged_leaves + L, and Resolution(NewTi) included in Resolution(Ti) + L, and NewP.unmerged_leaves = P.unmerged_leaves + L. So Resolution(NewTi) is included in NewP.unmerged_leaves.\r\n- If the operation is a UpdatePath, then P has a new parent-hash link.\r\n\r\nIn the case analysis I consider that Adds are always add-only commit, because an Add in a full commit (in this part of the protocol) is equivalent to an add-only Add followed by an UpdatePath.\r\n\r\nThis proof isn't super well-written (did it quickly) but I hope it's convincing enough.",
          "createdAt": "2022-06-01T21:30:12Z",
          "updatedAt": "2022-06-01T21:30:12Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Interim 2022-06-02:\r\n\r\n* @mulmarta concerned about implementability of any changes like this\r\n* Postponed until next week.",
          "createdAt": "2022-06-02T15:16:35Z",
          "updatedAt": "2022-06-02T15:16:35Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "I would note that one of the trees y'all are talking about is impossible:\r\n\r\n```\r\n              W                 \r\n        ______|_____            \r\n       /             \\          \r\n      U               Y         \r\n    __|__           __|__       \r\n   /     \\         /     \\      \r\n  T       V       X       Z     \r\n / \\     / \\     / \\     / \\   \r\nA   B   _   D   E   F   G   H\r\n```\r\n\r\nV would not be generated, because it's redundant.  I don't think that really changes the analysis, though.\r\n",
          "createdAt": "2022-06-03T18:56:02Z",
          "updatedAt": "2022-06-03T18:56:02Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "I wonder if a convenient way to summarize the property would be as follows.  Suppose there is the following relationship between U and P, where (a) the links might be either left or right, and (b) C is either U or a blank node:\r\n\r\n\r\n```\r\n            P\r\n          __|__\r\n         /     \\\r\n        C      ...\r\n       _|_\r\n      /   \\\r\n (blanks) ...\r\n    /\r\n   U\r\n  / \\\r\n... ...\r\n\r\n\r\nintersect(P.unmerged_leaves, subtree(C)) = resolution(C) - D\r\n```\r\n\r\nThat seems like it captures the two properties without the issues @mulmarta notes.\r\n\r\n* A leaf that is unmerged at P is either unmerged at U or not within U's subtree\r\n* The only non-blank nodes outside of U's subtree are leaves that are unmerged at P (and thus were not present when U was last updated)\r\n\r\nIt also has a nice symmetry in that both children of P are verified -- the copath child is verified by the original sibling tree hash, and the direct path child is verified with the unmerged leaves calculation.\r\n\r\nSuggested text:\r\n\r\n```\r\nThe parent hash in a node U is valid with respect to a parent node P if the\r\nfollowing criteria hold.  Here C and S are the children of P (for \"child\" and\r\n\"sibling\"), with C being the child that is on the direct path of U (possibly U\r\nitself) and S the other child:\r\n\r\n* U is a descendant of P in the tree.\r\n\r\n* Any nodes between U and P in the tree are blank.\r\n\r\n* The intersection of P's `unmerged_leaves` with the subtree under C is equal to\r\n  the resolution of C with U removed.\r\n\r\n* The `parent_hash` field of U is equal to the parent hash of P with copath\r\n  child S.\r\n\r\nThese checks verify that U and P were updated at the same time (in the same\r\nUpdatePath), and that they were neighbors in the UpdatePath because the nodes in\r\nbetween them would have omitted from the filtered direct path.\r\n```",
          "createdAt": "2022-06-03T19:23:27Z",
          "updatedAt": "2022-06-03T19:23:27Z"
        },
        {
          "author": "TWal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Hmm, that looks plausible yes! I have to think more about it.\r\n\r\nI started doing formal proofs in F* that this new version of parent hash is correct, and found an interesting weird scenario.\r\nIt exists because we don't enforce unmerged leaves to be under the subtree in which they are listed.\r\n\r\nSuppose we have the following (impossible) tree:\r\n\r\n```\r\n              W\r\n        ______|_____\r\n       /             \\\r\n      U               Y\r\n    __|__           __|__\r\n   /     \\         /     \\\r\n  T       V[0]    X       Z\r\n / \\     / \\     / \\     / \\\r\n_   1   2   3   4   5   6   7\r\n```\r\nLast commit is from 1, so we have the parent-hash chain 1 - T - U - W.\r\nIn the parent-hash link T ~> U, the sibling is:\r\n```\r\n  V[0]\r\n / \\  \r\n2   3 \r\n```\r\n\r\n7 adds 0:\r\n```\r\n              W\r\n        ______|_____\r\n       /             \\\r\n      U[0]            Y\r\n    __|__           __|__\r\n   /     \\         /     \\\r\n  T       V[0]    X       Z\r\n / \\     / \\     / \\     / \\\r\n0   1   2   3   4   5   6   7\r\n```\r\n\r\nIn the parent-hash link T ~> U, the sibling is:\r\n```\r\n  V\r\n / \\  \r\n2   3 \r\n```\r\n\r\nIt is different, and the link is not valid anymore!\r\nI think this should be an invariant checked when joining the group?",
          "createdAt": "2022-06-03T21:21:00Z",
          "updatedAt": "2022-06-03T21:21:00Z"
        },
        {
          "author": "TWal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Your property implies that all nodes between U and P are blank.\r\nIt implies that U is in the resolution of C and all nodes except U in the resolution in C are leaves.\r\nIf U is a parent node, we directly deduce that all nodes between U and P are blank\r\nIf U is a leaf node, then it isn't there because it's an unmerged leaf of some parent node in the resolution of C, because the resolution of C only contains leaves, so we have the same conclusion.\r\n\r\nYour property implies my first invariant, i.e. \"the sibling of every node with a blank parent between U (included) and P (excluded) has a resolution included in P.unmerged_leaves\"\r\nThe tree looks like this:\r\n```\r\n          P\r\n         / \\\r\n      C=_   ...\r\n       / \\\r\n     ...  Sn\r\n     /\r\n    _\r\n   / \\\r\n  _   S2\r\n / \\\r\nU   S1\r\n```\r\nWe have resolution(C) - U = resolution(S1) + ... + resolution(Sn).\r\nSince resolution(C) - U is included in P.unmerged_leaves, then we get my first invariant.\r\n\r\nYour property implies my second invariant.\r\nGiven the equality\r\n```\r\nintersect(P.unmerged_leaves, subtree(C)) = resolution(C) - U\r\n```\r\nwe apply the intersection with subtree(U) on the equality:\r\n```\r\nintersect(intersect(P.unmerged_leaves, subtree(C)), subtree(U)) = intersect(resolution(C) - U, subtree(U))\r\n```\r\nthe left hand side is equal to intersect(P.unmerged_leaves, subtree(U)) by the inclusion subtree(U) it subtree(C)\r\nand the right hand side is equal to U.unmerged_leaves, since resolution(C) = U + U.unmerged_leaves + resolution(S1) + ... + resolution(Sn)\r\ntherefore we get:\r\n```\r\nintersect(P.unmerged_leaves, subtree(U)) = U.unmerged_leaves\r\n```\r\nwhich is my second invariant.\r\n\r\nSo I think it works!\r\nWe just need to be sure that it's actually an invariant preserved in MLS.\r\nAlso I think we need to explicitly say that U is in the resolution of C.\r\n",
          "createdAt": "2022-06-03T22:04:30Z",
          "updatedAt": "2022-06-03T22:04:30Z"
        },
        {
          "author": "TWal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Another quick analysis, this time about correction:\r\n\r\nIf an Add of leaf L is done below U:\r\nWe have\r\n```\r\nintersect(oldP.unmerged_leaves, subtree(oldC)) = resolution(oldC) - U\r\n```\r\nWe also have these equalities:\r\n```\r\nnewP.unmerged_leaves = oldP.unmerged_leaves + L\r\nsubtree(newC) = subtree(oldC) + L\r\nresolution(newC) = resolution(oldC) + L\r\n```\r\nfrom which we deduce:\r\n```\r\nintersect(newP.unmerged_leaves, subtree(newC)) = resolution(newC) - U\r\n```\r\n\r\nIf an Add of leaf L is done below P, not below U:\r\nWe have\r\n```\r\nintersect(oldP.unmerged_leaves, subtree(oldC)) = resolution(oldC) - U\r\n```\r\nWe also have these equalities:\r\n```\r\nnewP.unmerged_leaves = oldP.unmerged_leaves + L\r\nsubtree(newC) = subtree(oldC) + L\r\nresolution(newC) = resolution(oldC) + L\r\n```\r\nfrom which we deduce:\r\n```\r\nintersect(newP.unmerged_leaves, subtree(newC)) = resolution(newC) - U\r\n```\r\n\r\nIt looks like a copy-paste of the previous case, in fact it is!\r\nThe only proof change is in the reason why `resolution(newC) = resolution(oldC) + L`.\r\nIn the first case, it's because it's added to the unmerged_leaves of U.\r\nIn the second case, it's because the recursion in the resolution definition goes all the way down to L.\r\n\r\nThe equality is true when creating the U ~> P link: both hand-side are empty.",
          "createdAt": "2022-06-03T22:16:22Z",
          "updatedAt": "2022-06-03T22:16:22Z"
        },
        {
          "author": "TWal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think the following equation is better:\r\n```\r\nresolution(C) = U + intersect(P.unmerged_leaves, subtree(C))\r\n```\r\nIt is equivalent to the previous one if U is in resolution(C), while also enforcing this fact.\r\nI guess it also feels less \"ninja\" and it is easier to have intuition on.",
          "createdAt": "2022-06-04T07:42:25Z",
          "updatedAt": "2022-06-04T07:42:25Z"
        },
        {
          "author": "TWal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I started doing formal proofs with the equation I gave in the last message, it's actually quite nice to use for proofs!\r\n\r\nI found another weird scenario, where an unmerged leaf is actually blank:\r\n\r\n```\r\n              W\r\n        ______|_____\r\n       /             \\\r\n      U               Y[4]\r\n    __|__           __|__\r\n   /     \\         /     \\\r\n  T       V       _       Z\r\n / \\     / \\     / \\     / \\\r\n0   1   2   3   _   5   6   7\r\n```\r\n\r\nLast update is Commit is from 0. We have the U ~> W parent-hash-link which contains the sibling\r\n\r\n```\r\n      Y[4]\r\n    __|__\r\n   /     \\\r\n  _       Z\r\n / \\     / \\\r\n_   5   6   7\r\n```\r\n\r\n0 add 4, without UpdatePath:\r\n\r\n```\r\n              W[4]\r\n        ______|_____\r\n       /             \\\r\n      U               Y[4]\r\n    __|__           __|__\r\n   /     \\         /     \\\r\n  T       V       _       Z\r\n / \\     / \\     / \\     / \\\r\n0   1   2   3   4   5   6   7\r\n```\r\n\r\nNow the parent-hash computation for the U ~> W link uses this tree:\r\n\r\n```\r\n      Y\r\n    __|__\r\n   /     \\\r\n  _       Z\r\n / \\     / \\\r\n_   5   6   7\r\n```\r\n\r\nTherefore the link is broken",
          "createdAt": "2022-06-04T12:26:04Z",
          "updatedAt": "2022-06-04T12:26:04Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "> It exists because we don't enforce unmerged leaves to be under the subtree in which they are listed. ...\r\n> I think this should be an invariant checked when joining the group?\r\n\r\nYes, we should add this requirement.  Since we're going to be updating this PR anyway, I think we can just add it here.\r\n\r\nSeems like it should go under \"Verify the integrity of the ratchet tree.\" in the \"Joining via ...\" sections.  BTW, while I was looking at that, I notice that the parent hash description there still refers to children, so that needs to be fixed as well.",
          "createdAt": "2022-06-05T19:12:50Z",
          "updatedAt": "2022-06-05T19:12:50Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "> an unmerged leaf is actually blank\r\n\r\nThis seems like something we could also validate easily, along with the above.  \"For each non-blank parent node, verify that each entry in the node's `unmerged_leaves` represents a non-blank leaf node that is a descendant of the parent node.\"",
          "createdAt": "2022-06-05T19:23:43Z",
          "updatedAt": "2022-06-05T19:23:43Z"
        },
        {
          "author": "TWal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "With the checks in latest commit on this PR, I have a formal proof in F* that these checks are actually a invariants of the following operations:\r\n- extending and truncating the tree\r\n- adding a leaf in an empty slot, marking it unmerged up to the root\r\n- removing a leaf, blanking every node up to the root\r\n- apply an UpdatePath\r\n\r\nIn the next days I'll also prove in F* that the checks actually implies the property I mentioned in the first message, to be sure that we don't do all of this for nothing :)\r\n\r\nI dropped the sentence \"The nodes between U and P in the tree are all blank\" because it's implied by the equation on \"resolution(C)\".\r\nI thought about dropping the sentence about \"U is a descendant of P in the tree\" because it's also implied by the equation on \"resolution(C)\", but the problem is that \"C\" is defined with \"U\" so that's not possible\u2026",
          "createdAt": "2022-06-05T22:52:38Z",
          "updatedAt": "2022-06-05T22:52:38Z"
        },
        {
          "author": "TWal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "While doing the formal security proof, I found a problem:\r\n\r\nConsider the following case.\r\n\r\n```\r\n      P1\r\n     /\r\n C1=_\r\n   / \\\r\n  U1  _\r\n```\r\n\r\nwith the U1 ~> P1 parent hash link,\r\n\r\nand the same tree, but U is unmerged\r\n\r\n```\r\n      P2[U2]\r\n     /\r\n C2=_\r\n   / \\\r\n  U2  _\r\n```\r\n\r\n(with the U2 ~> P2 link)\r\n\r\nWe have U1 ~= U2, however P1 ~= P2 is not true.\r\n\r\nTwo possible (equivalent) fixes:\r\n- Use the equation `Resolution(C) = U + Intersection(P.unmerged_leaves, SubTree(C))` and furthermore say that the `+` is disjoint (or, equivalently, if U is a leaf then it is not in P.unmerged_leaves)\r\n- Use the equation `Intersection(P.unmerged_leaves, SubTree(C)) = Resolution(C) - U`, but we have to say that `U` is in `Resolution(C)`\r\n\r\nWhich one has the nicest formulation to you?",
          "createdAt": "2022-06-06T16:34:08Z",
          "updatedAt": "2022-06-06T16:34:08Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Interim 2022-06-09:\r\n\r\n* @TWal reviewed the change and his proofs of correctness and security\r\n* @mulmarta noted that she had implemented it and it passed fuzz testing (~300 commits with random operations)\r\n* Agreement to merge",
          "createdAt": "2022-06-09T14:13:48Z",
          "updatedAt": "2022-06-09T14:13:48Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOBoyH6c47KBlR",
          "commit": {
            "abbreviatedOid": "ef03e1a"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Thanks for the thorough write-up @TWal.  This makes sense to me, especially given that it's a pretty small change.",
          "createdAt": "2022-06-01T18:10:50Z",
          "updatedAt": "2022-06-01T18:13:30Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "I would merge this with the bullet above about the intermediate nodes being blanks.  So something like:\r\n\r\n> Each node between U and P in the tree is blank, and the \"copath child\" of P (its child that is not in the direct path of U) has an empty resolution",
              "createdAt": "2022-06-01T18:10:50Z",
              "updatedAt": "2022-06-01T18:13:30Z"
            }
          ]
        }
      ]
    },
    {
      "number": 714,
      "id": "PR_kwDOBoyH6c445YYV",
      "title": "Require that unmerged_leaves be ordered",
      "url": "https://github.com/mlswg/mls-protocol/pull/714",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "While reviewing #713, I realized that we have a potential interop problem around `ParentNode.unmerged_leaves`.  This struct feeds into the tree hash, so everyone in the group needs to have the entries in the same order or else they'll disagree on the tree hash.  But the order isn't specified anywhere: All the document says right now is \"add L's leaf index to the unmerged_leaves list\", which could be implemented as an insert anywhere in the list.  This PR resolves the ambiguity by requiring the list be sorted.",
      "createdAt": "2022-06-01T18:23:11Z",
      "updatedAt": "2022-06-02T15:17:30Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "6526db8781ab70cf5e21aa5d8c994d26c0bebaea",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "ordered-unmerged-leaves",
      "headRefOid": "7f92260f14fa8627382bfb304d4d72fb3d3b5bb5",
      "closedAt": "2022-06-02T15:17:29Z",
      "mergedAt": "2022-06-02T15:17:29Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "37ac7d95d757696a1e459105db0e1f080fdcfa04"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOBoyH6c47LGoZ",
          "commit": {
            "abbreviatedOid": "7f92260"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-06-01T22:58:42Z",
          "updatedAt": "2022-06-01T22:58:42Z",
          "comments": []
        }
      ]
    },
    {
      "number": 715,
      "id": "PR_kwDOBoyH6c447bie",
      "title": "Clarify tree hash and parent hash",
      "url": "https://github.com/mlswg/mls-protocol/pull/715",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #655 \r\n\r\nDepends on #694 \r\nConflicts with #713 \r\n\r\nThe diff here is messy because it includes #694.  The biggest change is the extended example, for which you can just scroll to the bottom.",
      "createdAt": "2022-06-01T23:26:03Z",
      "updatedAt": "2022-06-07T22:48:13Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "731992b04a0861f11221e2975aae422476fa6465",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "tree-clarify-rohan",
      "headRefOid": "dfa1ddc25e61bc7e9be8223b0b75eb2cbc84f2a3",
      "closedAt": "2022-06-07T22:48:13Z",
      "mergedAt": "2022-06-07T22:48:13Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "839ebbb9b265a39a84cfcb3ac37c54d0a4a70134"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOBoyH6c47Ov_q",
          "commit": {
            "abbreviatedOid": "fab4643"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Interim 2022-06-02:\r\n\r\n* Hold for next week, should be easier to review after rebase.",
          "createdAt": "2022-06-02T15:21:46Z",
          "updatedAt": "2022-06-02T15:21:46Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOBoyH6c47ildn",
          "commit": {
            "abbreviatedOid": "dfa1ddc"
          },
          "author": "rohan-wire",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "This is a huge improvement. While I still prefer \"path hash\" to \"parent hash\", the new language in this PR is clear and I think will be straightforward for new implementers to read.",
          "createdAt": "2022-06-07T22:41:19Z",
          "updatedAt": "2022-06-07T22:41:19Z",
          "comments": []
        }
      ]
    },
    {
      "number": 716,
      "id": "PR_kwDOBoyH6c44-8uU",
      "title": "Add new new_proposal_member SenderType",
      "url": "https://github.com/mlswg/mls-protocol/pull/716",
      "state": "MERGED",
      "author": "rohan-wire",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Add new new_proposal_member SenderType and rename new_member to new_commit_member. \r\n\r\nThis restores the External Proposal Add functionality which was present in the protocol for some years but clarifies how the authorization and signing takes place in this case.\r\n",
      "createdAt": "2022-06-02T15:10:20Z",
      "updatedAt": "2022-06-02T16:01:43Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "378a68e49c31418a5cd7b77923b8631632cdddad",
      "headRepository": "rohan-wire/mls-protocol",
      "headRefName": "rohan/sender-type",
      "headRefOid": "adf83c3fe4c0c8764e07ebeb10e5e074548185d5",
      "closedAt": "2022-06-02T16:01:43Z",
      "mergedAt": "2022-06-02T16:01:43Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "12d8f633e4d093b17e866318c21b1dadf84d4d4d"
      },
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Interim 2022-06-02:\r\n\r\n* Could punt to extensions, but this is partly just because we moved a little too fast on the removal\r\n* No objections to reverting \r\n* Once conflicts and comments resolved, good to merge",
          "createdAt": "2022-06-02T15:40:23Z",
          "updatedAt": "2022-06-02T15:40:23Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Closes #693 ",
          "createdAt": "2022-06-02T15:44:50Z",
          "updatedAt": "2022-06-02T15:44:50Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOBoyH6c47O0rd",
          "commit": {
            "abbreviatedOid": "f259d81"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-02T15:29:38Z",
          "updatedAt": "2022-06-02T15:38:59Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "Nit: I would flip these around, `new_member_commit` and `new_member_proposal`.",
              "createdAt": "2022-06-02T15:29:38Z",
              "updatedAt": "2022-06-02T15:38:59Z"
            },
            {
              "originalPosition": 18,
              "body": "This can just be `struct{}`, since because the KeyPackage you apply is the one in the Add proposal.",
              "createdAt": "2022-06-02T15:30:37Z",
              "updatedAt": "2022-06-02T15:38:59Z"
            },
            {
              "originalPosition": 34,
              "body": "This doesn't seem all that useful, since the KeyPackage is already being signed via the Add proposal.  I would just make this `struct{}`.",
              "createdAt": "2022-06-02T15:31:23Z",
              "updatedAt": "2022-06-02T15:38:59Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c47O-24",
          "commit": {
            "abbreviatedOid": "5f13e07"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "LGTM, though would still prefer `new_member_proposal` etc.  One minor suggestion to lock down the content.",
          "createdAt": "2022-06-02T15:55:35Z",
          "updatedAt": "2022-06-02T15:56:05Z",
          "comments": [
            {
              "originalPosition": 43,
              "body": "```suggestion\r\n* `new_proposal_member`: The signature key in the LeafNode in\r\n    the KeyPackage embedded in an External Add Proposal. The\r\n    `content_type` of the message MUST be `proposal` and the \r\n    `proposal_type` of the Proposal MUST be `add`.\r\n```",
              "createdAt": "2022-06-02T15:55:35Z",
              "updatedAt": "2022-06-02T15:56:05Z"
            }
          ]
        }
      ]
    },
    {
      "number": 717,
      "id": "PR_kwDOBoyH6c45Ay3l",
      "title": "Make git ignore the output of make extract-tls",
      "url": "https://github.com/mlswg/mls-protocol/pull/717",
      "state": "MERGED",
      "author": "rohan-wire",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Currently `make extract-tls` generates a file with all the TLS Presentation Language structs. Add this file to `.gitignore`\r\n",
      "createdAt": "2022-06-02T22:29:39Z",
      "updatedAt": "2022-06-03T17:55:09Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "3044b38638216fb6fd124d795129ed87770e5f9d",
      "headRepository": "rohan-wire/mls-protocol",
      "headRefName": "rohan/gitignore-extract-tls",
      "headRefOid": "ae185761d301820958460cb90f41e663aa7ea724",
      "closedAt": "2022-06-03T17:55:09Z",
      "mergedAt": "2022-06-03T17:55:09Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "fe11f6eaff7722ea72dc3fbb8d1d74908e3f545b"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOBoyH6c47UsHf",
          "commit": {
            "abbreviatedOid": "ae18576"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-06-03T17:55:04Z",
          "updatedAt": "2022-06-03T17:55:04Z",
          "comments": []
        }
      ]
    },
    {
      "number": 718,
      "id": "PR_kwDOBoyH6c45FbBx",
      "title": "Fix resolution example",
      "url": "https://github.com/mlswg/mls-protocol/pull/718",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "The current resolution example tree can't be created by the protocol.  If C were not blank, then D would not populate Z in its filtered direct path.  (Note that this implies that there are never unmerged leaves at the first level of the tree.)  This PR expands the example tree so that it can have unmerged leaves while still having a blank top node.  This makes the example a little more complicated (you have to follow the recursion down two levels), but it doesn't seem too bad.",
      "createdAt": "2022-06-03T18:22:20Z",
      "updatedAt": "2022-06-08T17:35:59Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "fe11f6eaff7722ea72dc3fbb8d1d74908e3f545b",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "fix-resolution-example",
      "headRefOid": "e131f525a5762e253040d1b968d3c464005c5c66",
      "closedAt": "2022-06-08T17:35:59Z",
      "mergedAt": "2022-06-08T17:35:58Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "2f1e9135c5fdeeb920ddc0554548966ef47f9521"
      },
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "cc @mulmarta ",
          "createdAt": "2022-06-03T18:22:39Z",
          "updatedAt": "2022-06-03T18:22:39Z"
        },
        {
          "author": "mulmarta",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Good catch! It's kind of subtle in this case.",
          "createdAt": "2022-06-03T19:11:31Z",
          "updatedAt": "2022-06-03T19:11:31Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "@mulmarta - I think I have this patched up, would appreciate a quick re-review.",
          "createdAt": "2022-06-07T21:39:41Z",
          "updatedAt": "2022-06-07T21:39:41Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOBoyH6c47VBbj",
          "commit": {
            "abbreviatedOid": "2e47dc6"
          },
          "author": "mulmarta",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-03T19:07:16Z",
          "updatedAt": "2022-06-03T19:07:17Z",
          "comments": [
            {
              "originalPosition": 52,
              "body": "```suggestion\r\n* D removes B, C, and G, with the following effects:\r\n```",
              "createdAt": "2022-06-03T19:07:17Z",
              "updatedAt": "2022-06-03T19:07:17Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c47VCej",
          "commit": {
            "abbreviatedOid": "2e47dc6"
          },
          "author": "mulmarta",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-03T19:10:51Z",
          "updatedAt": "2022-06-03T19:10:52Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "Shouldn't this node be set to `Z[C]`? I think D will set it as \"the top node\"",
              "createdAt": "2022-06-03T19:10:52Z",
              "updatedAt": "2022-06-03T19:10:52Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c47VHry",
          "commit": {
            "abbreviatedOid": "2e47dc6"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-03T19:24:58Z",
          "updatedAt": "2022-06-03T19:24:58Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "Ah, yes, as it is now.  I need to have someone outside the subtree remove G in order to clear it.  I'll update the description.",
              "createdAt": "2022-06-03T19:24:58Z",
              "updatedAt": "2022-06-03T19:24:58Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c47ilkP",
          "commit": {
            "abbreviatedOid": "e131f52"
          },
          "author": "rohan-wire",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "I walked through the example tree on a whiteboard with different colored markers and it looks correct to me.",
          "createdAt": "2022-06-07T22:42:08Z",
          "updatedAt": "2022-06-07T22:42:08Z",
          "comments": []
        }
      ]
    },
    {
      "number": 720,
      "id": "PR_kwDOBoyH6c45Y7rr",
      "title": "Include ciphersuite in group context",
      "url": "https://github.com/mlswg/mls-protocol/pull/720",
      "state": "MERGED",
      "author": "mulmarta",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "This will guarantee that all group members agree on the ciphersuite used. It gives more meaning to statements like \"Each MLS session uses a single ciphersuite\".\r\n\r\nAlso, it prevents the following attack: the adversary (a malicious insider) invites someone and convinces them that the group uses a ciphersuite with say a signature scheme that is weaker but still compatible with the one actually used. Now the new member uses a weaker scheme and the adversary can impersonate them.",
      "createdAt": "2022-06-09T12:52:20Z",
      "updatedAt": "2022-06-09T14:17:32Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "83f8648a3ba0d39a16c7ec5c93b0d6b7b3decaab",
      "headRepository": "mulmarta/mls-protocol",
      "headRefName": "mulmarta/group-context-values",
      "headRefOid": "9683d43099505bd34f310682565b24098dc21294",
      "closedAt": "2022-06-09T14:17:32Z",
      "mergedAt": "2022-06-09T14:17:32Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "2e9bdfbf312ca1fa30e799fcbb5a8446758b0892"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOBoyH6c47sFB0",
          "commit": {
            "abbreviatedOid": "7f66f3f"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-09T14:13:45Z",
          "updatedAt": "2022-06-09T14:13:58Z",
          "comments": [
            {
              "originalPosition": 47,
              "body": "```suggestion\r\n  `new_member_commit`.\r\n```",
              "createdAt": "2022-06-09T14:13:45Z",
              "updatedAt": "2022-06-09T14:13:58Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c47sGDi",
          "commit": {
            "abbreviatedOid": "9683d43"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Interim 2022-06-02:\r\n\r\n* Agreement that more binding is better",
          "createdAt": "2022-06-09T14:16:17Z",
          "updatedAt": "2022-06-09T14:16:17Z",
          "comments": []
        }
      ]
    },
    {
      "number": 721,
      "id": "PR_kwDOBoyH6c45aeFi",
      "title": "Minor section reorder",
      "url": "https://github.com/mlswg/mls-protocol/pull/721",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #672 \r\n\r\nSummary:\r\n\r\n``` diff\r\n-## Adding and Removing Leaves\r\n ## Synchronizing Views of the Tree\r\n+## Update Paths\r\n+## Adding and Removing Leaves\r\n ## Tree Hashes\r\n-## Update Paths\r\n # Key Schedule\r\n-#### Joining via External Commits\r\n #### Joining via Welcome Message\r\n-## Ratchet Tree Extension\r\n+#### Joining via External Commits\r\n+#### Ratchet Tree Extension\r\n```",
      "createdAt": "2022-06-09T19:04:51Z",
      "updatedAt": "2022-06-09T19:10:15Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "2e9bdfbf312ca1fa30e799fcbb5a8446758b0892",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "minor-section-reorder",
      "headRefOid": "299675a00786a164170f33f8e3bc6aef9d07d23d",
      "closedAt": "2022-06-09T19:10:14Z",
      "mergedAt": "2022-06-09T19:10:14Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "e2be9169b3ed6e9e109a854f0422d7f32ceb2cd3"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOBoyH6c47txmF",
          "commit": {
            "abbreviatedOid": "299675a"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-06-09T19:09:04Z",
          "updatedAt": "2022-06-09T19:09:04Z",
          "comments": []
        }
      ]
    },
    {
      "number": 722,
      "id": "PR_kwDOBoyH6c45akJv",
      "title": "Add changelog for draft-15",
      "url": "https://github.com/mlswg/mls-protocol/pull/722",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Constructed from the highlights of PR titles, with breaking changes indicated with `(*)` as usual.",
      "createdAt": "2022-06-09T19:34:04Z",
      "updatedAt": "2022-06-09T19:36:49Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "e2be9169b3ed6e9e109a854f0422d7f32ceb2cd3",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "changelog-15",
      "headRefOid": "0e1b0ebd73248afaaeb57d671b02382066e1db0d",
      "closedAt": "2022-06-09T19:36:49Z",
      "mergedAt": "2022-06-09T19:36:49Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "4e4671121d4e38461675adffb7e6f3ebfa919cfb"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 723,
      "id": "PR_kwDOBoyH6c45fEaR",
      "title": "Add `external_senders` to MLS Extension Types registry",
      "url": "https://github.com/mlswg/mls-protocol/pull/723",
      "state": "MERGED",
      "author": "tomleavy",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "`external_senders` was missing from the Extension Types table so it didn't have an extension type value assigned",
      "createdAt": "2022-06-10T18:56:32Z",
      "updatedAt": "2022-06-15T20:24:17Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "4e4671121d4e38461675adffb7e6f3ebfa919cfb",
      "headRepository": "tomleavy/mls-protocol",
      "headRefName": "external-senders-ext-fix",
      "headRefOid": "08fce3b8d0d0952e369caa91e5fc05969d85af3d",
      "closedAt": "2022-06-15T20:24:17Z",
      "mergedAt": "2022-06-15T20:24:16Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "a45a4bf8f511b84122c8c293b8255a0d8fd49694"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOBoyH6c47zRo2",
          "commit": {
            "abbreviatedOid": "08fce3b"
          },
          "author": "rohan-wire",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Thanks",
          "createdAt": "2022-06-10T20:32:32Z",
          "updatedAt": "2022-06-10T20:32:32Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOBoyH6c48FiUw",
          "commit": {
            "abbreviatedOid": "08fce3b"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-06-15T20:24:12Z",
          "updatedAt": "2022-06-15T20:24:12Z",
          "comments": []
        }
      ]
    },
    {
      "number": 724,
      "id": "PR_kwDOBoyH6c45gWHN",
      "title": "Fix #719 (contributors section)",
      "url": "https://github.com/mlswg/mls-protocol/pull/724",
      "state": "MERGED",
      "author": "cabo",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "To check whether there actually is a problem, I made the fix for #719, and it seems to work as designed.",
      "createdAt": "2022-06-11T14:50:28Z",
      "updatedAt": "2022-06-12T20:40:44Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "4e4671121d4e38461675adffb7e6f3ebfa919cfb",
      "headRepository": "cabo/mls-protocol",
      "headRefName": "fix-contributors",
      "headRefOid": "912a56d5b58a601a06b556417bffbdfa2568871f",
      "closedAt": "2022-06-12T20:40:44Z",
      "mergedAt": "2022-06-12T20:40:43Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "7cd54f6f7cddb6ce0f1c2bd6f7cba26809c0aee0"
      },
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks @cabo, I didn't know about this feature!  If you'd like to do the same on [the architecture doc](https://github.com/mlswg/mls-architecture/), I would appreciate it.",
          "createdAt": "2022-06-12T20:40:39Z",
          "updatedAt": "2022-06-12T20:40:39Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOBoyH6c470mK6",
          "commit": {
            "abbreviatedOid": "3a6b385"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-12T16:35:18Z",
          "updatedAt": "2022-06-12T16:38:47Z",
          "comments": [
            {
              "originalPosition": 34,
              "body": "```suggestion\r\n   email: brendanmcmillion@gmail.com\r\n```",
              "createdAt": "2022-06-12T16:35:18Z",
              "updatedAt": "2022-06-12T16:38:47Z"
            }
          ]
        }
      ]
    },
    {
      "number": 727,
      "id": "PR_kwDOBoyH6c45u37t",
      "title": "Add signature input to VerifyWithLabel",
      "url": "https://github.com/mlswg/mls-protocol/pull/727",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #726 ",
      "createdAt": "2022-06-15T20:27:17Z",
      "updatedAt": "2022-06-15T21:44:04Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "a45a4bf8f511b84122c8c293b8255a0d8fd49694",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "sig-input",
      "headRefOid": "e590eb98e4c42f0a39a349612853b81229e890ce",
      "closedAt": "2022-06-15T21:44:04Z",
      "mergedAt": "2022-06-15T21:44:04Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "51bb7416555e7cde38b97aa2349bef80c733111c"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 728,
      "id": "PR_kwDOBoyH6c46BQWq",
      "title": "Fix GroupInfoTBS",
      "url": "https://github.com/mlswg/mls-protocol/pull/728",
      "state": "MERGED",
      "author": "TWal",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "The `confirmation_tag` was missing. The error was introduced in #706.\r\n\r\nThis kind of error makes me wonder if the redundancy between the `...` and the `...TBS` really are necessary.\r\n\r\nIn my code, I use a pattern like this:\r\n```\r\nstruct {\r\n    GroupContext group_context;\r\n    Extension extensions<V>;\r\n    MAC confirmation_tag;\r\n    uint32 signer;\r\n} GroupInfoTBS;\r\n\r\nstruct {\r\n    GroupInfoTBS tbs;\r\n    // SignWithLabel(., \"GroupInfoTBS\", GroupInfoTBS)\r\n    opaque signature<V>;\r\n} GroupInfo;\r\n```\r\n\r\nNo copy-paste error possible! Looks a bit weird, but if we replace \"tbs\" by \"data\", it makes more sense.",
      "createdAt": "2022-06-21T10:44:34Z",
      "updatedAt": "2022-07-11T19:54:41Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "51bb7416555e7cde38b97aa2349bef80c733111c",
      "headRepository": "TWal/mls-protocol",
      "headRefName": "twal_fix_group_info_tbs",
      "headRefOid": "53a1b0973bad01eaa6b5fd4527bb1bbda32ebd50",
      "closedAt": "2022-07-11T19:54:41Z",
      "mergedAt": "2022-07-11T19:54:41Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "b9ac88bc4c7eea9640e63fb53a7374cfaa2ba6a9"
      },
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks, @TWal.  FWIW, I would be disinclined to make the change you propose at this point.  It's a fine idea (it's what [X.509 does](https://datatracker.ietf.org/doc/html/rfc5280#section-4.1)), but we're late enough in the process that I would like to avoid changes of that magnitude.",
          "createdAt": "2022-06-30T12:18:58Z",
          "updatedAt": "2022-06-30T12:18:58Z"
        },
        {
          "author": "MartaMularczyk",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> Thanks, @TWal. FWIW, I would be disinclined to make the change you propose at this point. It's a fine idea (it's what [X.509 does](https://datatracker.ietf.org/doc/html/rfc5280#section-4.1)), but we're late enough in the process that I would like to avoid changes of that magnitude.\r\n\r\nTo me it seems that this doesn't introduce a new change, but instead reverts a change made by mistake a month ago. The tag has always been signed, also in the version of MLS we analyzed.",
          "createdAt": "2022-07-03T15:16:21Z",
          "updatedAt": "2022-07-03T15:16:21Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "@MartaMularczyk - Sorry, I meant the bigger change that @TWal proposed (e.g., putting GroupInfoTBS inside GroupInfo). Signing the tag is obviously correct.  ",
          "createdAt": "2022-07-11T19:54:15Z",
          "updatedAt": "2022-07-11T19:54:15Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOBoyH6c48bifU",
          "commit": {
            "abbreviatedOid": "53a1b09"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-06-21T15:51:01Z",
          "updatedAt": "2022-06-21T15:51:01Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOBoyH6c49FMYa",
          "commit": {
            "abbreviatedOid": "53a1b09"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-06-30T12:19:28Z",
          "updatedAt": "2022-06-30T12:19:28Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOBoyH6c49rq9i",
          "commit": {
            "abbreviatedOid": "53a1b09"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-07-11T19:54:23Z",
          "updatedAt": "2022-07-11T19:54:23Z",
          "comments": []
        }
      ]
    },
    {
      "number": 729,
      "id": "PR_kwDOBoyH6c46oxJV",
      "title": "Make reference to h2 informative",
      "url": "https://github.com/mlswg/mls-protocol/pull/729",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "As @fluffy pointed out on the mailing list, this reference does not need to be normative.",
      "createdAt": "2022-06-30T12:16:02Z",
      "updatedAt": "2022-07-11T19:55:05Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "51bb7416555e7cde38b97aa2349bef80c733111c",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "info-7540",
      "headRefOid": "ae45744e98a895d79202f0d153f26aa3591d3536",
      "closedAt": "2022-07-11T19:55:05Z",
      "mergedAt": "2022-07-11T19:55:05Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "36b4b0d6fa6dd2ccd0cb7f07f4e43587d26e5d36"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 730,
      "id": "PR_kwDOBoyH6c48U5rQ",
      "title": "Complete IANA media type registration",
      "url": "https://github.com/mlswg/mls-protocol/pull/730",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Early review from IANA indicated that we had not completed the [full template](https://datatracker.ietf.org/doc/html/rfc6838#section-5.6).  This PR adds the missing fields.",
      "createdAt": "2022-07-29T15:34:16Z",
      "updatedAt": "2022-10-03T19:47:15Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "36b4b0d6fa6dd2ccd0cb7f07f4e43587d26e5d36",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "media-type",
      "headRefOid": "9987f377b2227465576c58e9576189cf8b269638",
      "closedAt": "2022-10-03T19:47:14Z",
      "mergedAt": "2022-10-03T19:47:14Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "6b25d7accb3a081c227f1ef11dbb4bd2dcc38495"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOBoyH6c4-7WOx",
          "commit": {
            "abbreviatedOid": "9987f37"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-07-29T15:37:33Z",
          "updatedAt": "2022-07-29T15:37:33Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOBoyH6c4_OcPR",
          "commit": {
            "abbreviatedOid": "9987f37"
          },
          "author": "rohan-wire",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-08-03T17:26:59Z",
          "updatedAt": "2022-08-03T17:26:59Z",
          "comments": []
        }
      ]
    },
    {
      "number": 731,
      "id": "PR_kwDOBoyH6c48kCwC",
      "title": "Include leaf index in LeafNodeTBS for better parent-hash guarantees",
      "url": "https://github.com/mlswg/mls-protocol/pull/731",
      "state": "MERGED",
      "author": "TWal",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "# A problem in parent-hash proofs\r\n\r\nThe goal of #527 and #713 was to have a property similar to:\r\n\r\n> If there is a parent-hash chain from the leaf L to a node N, then the signature of L binds the tree Canonicalize(N)\r\n\r\nIn #713, I proved that the pull-request allowed to prove the following property:\r\n\r\n> If Canonicalize(U1) = Canonicalize(U2),\r\n> and there is a parent-hash link from U1 to P1 and from U2 to P2,\r\n> then Canonicalize(P1) = Canonicalize(P2)\r\n\r\nWith this property, the hope is to inductively show that the leaf signature binds the canonicalization of subtrees it is parent-hash linked from.\r\nThe induction step works fine thanks to the previous theorem, however the base case is wrong.\r\n\r\nThe hypothesis \"Canonicalize(U1) = Canonicalize(U2)\" says that the content of the trees are equal, and also says they have the same location (i.e. they have the same node index). This is important for the induction step.\r\nHowever, since the signature of a leaf doesn't bind its position in the tree, we can't initialize the induction.\r\n\r\nThis PR resolves this problem.\r\n\r\n# A concrete counter-example\r\n\r\nAssume we have the following tree:\r\n\r\n          Y\r\n        __|__\r\n       /     \\\r\n      _       Z\r\n     / \\     / \\\r\n    A   _   C   D\r\n\r\nIf there is a parent-hash link from A to Y, then the following tree is also valid:\r\n\r\n          Y\r\n        __|__\r\n       /     \\\r\n      _       Z\r\n     / \\     / \\\r\n    _   A   C   D\r\n    \r\n# The solution\r\n\r\nWe only need to add the leaf index inside the signature when the source is a commit.\r\nI also added it in the update case because it doesn't hurt, but that's not necessary.",
      "createdAt": "2022-08-03T09:48:30Z",
      "updatedAt": "2022-10-03T20:30:18Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "36b4b0d6fa6dd2ccd0cb7f07f4e43587d26e5d36",
      "headRepository": "TWal/mls-protocol",
      "headRefName": "twal_even_better_parent_hash",
      "headRefOid": "d214db8c8fdf42cbbab9b3188eeaeae4c1adeb16",
      "closedAt": "2022-10-03T20:30:17Z",
      "mergedAt": "2022-10-03T20:30:17Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "c1894c7038550b8110c3f168f5f32f9ac80399fd"
      },
      "comments": [
        {
          "author": "TWal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "In this message I will be using the convention used in https://messaginglayersecurity.rocks/mls-protocol/draft-ietf-mls-protocol.html#name-verifying-parent-hashes\r\n\r\nThe position of the committer is indeed implied by the parent hash when there is no filtered node:\r\n\r\n      P\r\n     / \\\r\n    D   S\r\n\r\nIn this case, the parent-hash link is from D to P, and we have C = D (no blank nodes between D and P).\r\nThe position of S is included inside its tree hash, which is therefore included in the parent-hash link D ~> P, and from that we can deduce the position of D (it is the child of P that is not S).\r\n\r\nHowever, if there are filtered nodes between D and P, we have the following situation:\r\n\r\n          P\r\n         / \\\r\n    C = _   S\r\n       /   / \\\r\n      \u2026   \u2026   \u2026\r\n     /\r\n    D\r\n    \r\nIn this case, the position of P is still included in the parent-hash link D ~> P for the same reason. However, we have no information on the position of D, because it can be anywhere inside C's subtree",
          "createdAt": "2022-08-03T11:49:26Z",
          "updatedAt": "2022-08-03T11:49:26Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOBoyH6c4_LrLb",
          "commit": {
            "abbreviatedOid": "d214db8"
          },
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "Nice work Th\u00e9ophile !",
          "createdAt": "2022-08-03T09:56:14Z",
          "updatedAt": "2022-08-03T09:56:14Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOBoyH6c4_LtlZ",
          "commit": {
            "abbreviatedOid": "d214db8"
          },
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-08-03T10:03:45Z",
          "updatedAt": "2022-08-03T10:03:45Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOBoyH6c4_L62Y",
          "commit": {
            "abbreviatedOid": "d214db8"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "Thanks, nice work!\r\n\r\nI think this is particularly relevant for the update case when new joiners examine the public tree. For the commit case, the position of the committer in the tree might be implied by the parent hash (unless I understood it wrong). Either way, it can't hurt to be explicit here.",
          "createdAt": "2022-08-03T10:49:07Z",
          "updatedAt": "2022-08-03T10:49:07Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOBoyH6c4_l0G6",
          "commit": {
            "abbreviatedOid": "d214db8"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Thanks @TWal, this makes sense to me.  The only thought that came to mind was whether there was any other similar information we should bind in here at the same time, but nothing else occurred to me within the constraint that it has to be known to new joiners.",
          "createdAt": "2022-08-09T14:53:45Z",
          "updatedAt": "2022-08-09T14:53:45Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOBoyH6c5DE46B",
          "commit": {
            "abbreviatedOid": "d214db8"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-09-29T13:57:23Z",
          "updatedAt": "2022-09-29T13:57:23Z",
          "comments": []
        }
      ]
    },
    {
      "number": 735,
      "id": "PR_kwDOBoyH6c49DzzP",
      "title": "Update Jon's details",
      "url": "https://github.com/mlswg/mls-protocol/pull/735",
      "state": "MERGED",
      "author": "seanturner",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Addresses #734.",
      "createdAt": "2022-08-11T23:23:16Z",
      "updatedAt": "2022-08-12T05:56:40Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "36b4b0d6fa6dd2ccd0cb7f07f4e43587d26e5d36",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "seanturner-jmillican",
      "headRefOid": "7bbe6467f76423b3f67cc845038dde9b838bc212",
      "closedAt": "2022-08-12T05:56:40Z",
      "mergedAt": "2022-08-12T05:56:40Z",
      "mergedBy": "beurdouche",
      "mergeCommit": {
        "oid": "4b721e6dee6e8dde074be16eb081d5f3614e2658"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 736,
      "id": "PR_kwDOBoyH6c49S2F-",
      "title": "Client aware of its own removal in group",
      "url": "https://github.com/mlswg/mls-protocol/pull/736",
      "state": "MERGED",
      "author": "rohan-wire",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "- Clarify what client should do when receiving a Commit removing itself\r\n- update Remove example to show removed client receiving the Commit\r\n- fix typos in Security Considerations",
      "createdAt": "2022-08-17T05:52:08Z",
      "updatedAt": "2022-10-03T20:31:45Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "4b721e6dee6e8dde074be16eb081d5f3614e2658",
      "headRepository": "rohan-wire/mls-protocol",
      "headRefName": "rohan/removes",
      "headRefOid": "01bc1aec2c2d7de82c10d8738821e6c0f87dbc62",
      "closedAt": "2022-10-03T20:31:45Z",
      "mergedAt": "2022-10-03T20:31:45Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "f4d037b3cfc2e96f152d563ac08815af0e29587b"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOBoyH6c5DEvPE",
          "commit": {
            "abbreviatedOid": "01bc1ae"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-09-29T13:37:14Z",
          "updatedAt": "2022-09-29T13:37:14Z",
          "comments": []
        }
      ]
    },
    {
      "number": 737,
      "id": "PR_kwDOBoyH6c49cRlX",
      "title": "Simplify Remove section",
      "url": "https://github.com/mlswg/mls-protocol/pull/737",
      "state": "MERGED",
      "author": "TWal",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "The part about doing the lookup in the old tree was added in #491, it was relevant here because of the hash references.\r\nThis is not a problem anymore since we came back to referencing with leaf index.",
      "createdAt": "2022-08-19T07:21:01Z",
      "updatedAt": "2022-10-03T20:33:23Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "4b721e6dee6e8dde074be16eb081d5f3614e2658",
      "headRepository": "TWal/mls-protocol",
      "headRefName": "twal_simplify_remove",
      "headRefOid": "451c73a81bef28be2f8a83c3b22e2c9a57f02a30",
      "closedAt": "2022-10-03T20:33:23Z",
      "mergedAt": "2022-10-03T20:33:23Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "8eb6c75731155e73448591e38d7b7201c246ed4d"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOBoyH6c5AWsl5",
          "commit": {
            "abbreviatedOid": "451c73a"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-08-21T16:02:01Z",
          "updatedAt": "2022-08-21T16:02:01Z",
          "comments": []
        }
      ]
    },
    {
      "number": 739,
      "id": "PR_kwDOBoyH6c490IKk",
      "title": "Change to external_pub",
      "url": "https://github.com/mlswg/mls-protocol/pull/739",
      "state": "MERGED",
      "author": "seanturner",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "For consistency with references to other extensions (and with the IANA registry), refer to the extension as \"external_pub\".",
      "createdAt": "2022-08-25T17:52:34Z",
      "updatedAt": "2022-10-03T20:33:36Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "4b721e6dee6e8dde074be16eb081d5f3614e2658",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "seanturner-EP",
      "headRefOid": "8a9881b93c4b881a378f33ed96c0ba0658a32a7d",
      "closedAt": "2022-10-03T20:33:36Z",
      "mergedAt": "2022-10-03T20:33:36Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "3141260555ff01aebb9d3245d7adca06c6a359d3"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOBoyH6c5Budn9",
          "commit": {
            "abbreviatedOid": "8a9881b"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-09-09T17:46:51Z",
          "updatedAt": "2022-09-09T17:46:51Z",
          "comments": []
        }
      ]
    },
    {
      "number": 740,
      "id": "PR_kwDOBoyH6c492qUr",
      "title": "Add limit to ResumptionPSKUsage",
      "url": "https://github.com/mlswg/mls-protocol/pull/740",
      "state": "MERGED",
      "author": "franziskuskiefer",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "- The `ResumptionPSKUsage` enum was missing the `u8` limit.\r\n- The `GroupContextExtensions` wasn't using a TLS environment.",
      "createdAt": "2022-08-26T09:33:00Z",
      "updatedAt": "2022-10-03T20:33:58Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "4b721e6dee6e8dde074be16eb081d5f3614e2658",
      "headRepository": "franziskuskiefer/mls-protocol",
      "headRefName": "editorial1",
      "headRefOid": "55b2b63a06f4610569c8203b61a567a1544a427e",
      "closedAt": "2022-10-03T20:33:58Z",
      "mergedAt": "2022-10-03T20:33:58Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "b0820d803a6e60ea594232a831f613dcae400cb0"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOBoyH6c5A0_w6",
          "commit": {
            "abbreviatedOid": "55b2b63"
          },
          "author": "seanturner",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Seems reasonable to me.",
          "createdAt": "2022-08-27T03:13:28Z",
          "updatedAt": "2022-08-27T03:13:28Z",
          "comments": []
        }
      ]
    },
    {
      "number": 743,
      "id": "PR_kwDOBoyH6c4-sFG5",
      "title": "presentation syntax tweaks",
      "url": "https://github.com/mlswg/mls-protocol/pull/743",
      "state": "MERGED",
      "author": "seanturner",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Mostly this is semicolons at the end of every statement.",
      "createdAt": "2022-09-09T15:47:54Z",
      "updatedAt": "2022-10-03T20:36:50Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "b0820d803a6e60ea594232a831f613dcae400cb0",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "seanturner-semi_colons",
      "headRefOid": "a2305afa53ab38f24bbc45587b70dca7cc3b31e6",
      "closedAt": "2022-10-03T20:36:50Z",
      "mergedAt": "2022-10-03T20:36:50Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "231aaa2c1da88d121d7aa871befe954fea41a8e3"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOBoyH6c5Budxf",
          "commit": {
            "abbreviatedOid": "b831fa9"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-09-09T17:47:27Z",
          "updatedAt": "2022-09-09T17:47:27Z",
          "comments": []
        }
      ]
    },
    {
      "number": 744,
      "id": "PR_kwDOBoyH6c4-sbRH",
      "title": "Add upper limit to ResumptionPSKUsage",
      "url": "https://github.com/mlswg/mls-protocol/pull/744",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #741",
      "createdAt": "2022-09-09T17:26:02Z",
      "updatedAt": "2022-09-09T17:46:31Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "4b721e6dee6e8dde074be16eb081d5f3614e2658",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "bifurcation-patch-1",
      "headRefOid": "dead92678d367649f71a7d140e58f6d8eac29a8a",
      "closedAt": "2022-09-09T17:46:31Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "body": "Doesn't #740 already fix this?",
          "createdAt": "2022-09-09T17:27:55Z",
          "updatedAt": "2022-09-09T17:27:55Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Yes it does.  Closing.",
          "createdAt": "2022-09-09T17:46:31Z",
          "updatedAt": "2022-09-09T17:46:31Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 745,
      "id": "PR_kwDOBoyH6c4-scXL",
      "title": "Use C-style comments in TLS presentation syntax",
      "url": "https://github.com/mlswg/mls-protocol/pull/745",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #742 ",
      "createdAt": "2022-09-09T17:32:05Z",
      "updatedAt": "2022-10-03T20:36:39Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "4b721e6dee6e8dde074be16eb081d5f3614e2658",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "8446-comments",
      "headRefOid": "b176129825a0974d1f745b1421c9438d22b03e8d",
      "closedAt": "2022-10-03T20:36:39Z",
      "mergedAt": "2022-10-03T20:36:39Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "3bde4299f5fb84fe40022020c2f43e00b7abbf6e"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 746,
      "id": "PR_kwDOBoyH6c4-setz",
      "title": "Update Recommended column definition to match 8447bis",
      "url": "https://github.com/mlswg/mls-protocol/pull/746",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #738 \r\n\r\n... by just importing the [current text in 8447bis](https://www.ietf.org/archive/id/draft-ietf-tls-rfc8447bis-01.html#name-adding-recommended-column).  @seanturner lmk if you think we should reference instead.",
      "createdAt": "2022-09-09T17:42:52Z",
      "updatedAt": "2022-10-03T20:36:26Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "4b721e6dee6e8dde074be16eb081d5f3614e2658",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "discouraged",
      "headRefOid": "252c87a09f477eeed94b39325f417e649413bd9e",
      "closedAt": "2022-10-03T20:36:25Z",
      "mergedAt": "2022-10-03T20:36:25Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "11090b44cc0d914ecb355e4f10390870f84cdc31"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOBoyH6c5DFKk5",
          "commit": {
            "abbreviatedOid": "e27cd5c"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-09-29T14:33:45Z",
          "updatedAt": "2022-09-29T14:33:51Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "```suggestion\r\n[[ RFC EDITOR: This section should be the same as the corresponding text in\r\ndraft-ietf-tls-rfc8447bis.  Please align the two documents if they have diverged\r\nin the approval process. ]]\r\n\r\n* Recommended: Whether support for this ciphersuite is recommended by the IETF\r\n```",
              "createdAt": "2022-09-29T14:33:45Z",
              "updatedAt": "2022-10-03T20:36:13Z"
            }
          ]
        }
      ]
    },
    {
      "number": 747,
      "id": "PR_kwDOBoyH6c4_hXJl",
      "title": "Address TSV-ART review comments",
      "url": "https://github.com/mlswg/mls-protocol/pull/747",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Thanks to Gorry Fairhurst:\r\nhttps://mailarchive.ietf.org/arch/msg/mls/ju2j3jsdttOfC06OedFFvZN73l8/",
      "createdAt": "2022-09-23T20:12:05Z",
      "updatedAt": "2022-12-08T12:52:40Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "4b721e6dee6e8dde074be16eb081d5f3614e2658",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "tsv-art",
      "headRefOid": "349364d7d202730247f012f775d8ebd0591758a4",
      "closedAt": "2022-12-08T12:52:40Z",
      "mergedAt": "2022-12-08T12:52:40Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "0d2d151017aa0661d1408fa97f37b93ebc384ade"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOBoyH6c5CtX_c",
          "commit": {
            "abbreviatedOid": "5d6bb55"
          },
          "author": "gorryfair",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-09-24T07:21:56Z",
          "updatedAt": "2022-09-24T07:23:43Z",
          "comments": [
            {
              "originalPosition": 18,
              "body": "/transport/ or /network path/",
              "createdAt": "2022-09-24T07:21:56Z",
              "updatedAt": "2022-09-24T07:23:43Z"
            },
            {
              "originalPosition": 40,
              "body": "Personally, I think it is necessary that the the resulting IP packets do not exceed the actual PMTU. This will \"black hole\" the data, the network will drop these packets. So, saying \"SHOULD\" kind of looks like there might be a way around that exists - whereas really the way around is to make sure this does not happen.\r\n\r\n I wonder in this case where it might be better to say \"needs to avoid sending IP packets that are larger than this size\" - this is of course often handled by lower protocol layers, and you may wish to also note that ",
              "createdAt": "2022-09-24T07:23:30Z",
              "updatedAt": "2022-09-24T07:23:43Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c5CzSEB",
          "commit": {
            "abbreviatedOid": "5d6bb55"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-09-26T18:47:37Z",
          "updatedAt": "2022-09-26T18:47:37Z",
          "comments": [
            {
              "originalPosition": 40,
              "body": "```suggestion\r\nincreasing message size beyond any such limits that exist in a given\r\n```",
              "createdAt": "2022-09-26T18:47:37Z",
              "updatedAt": "2022-09-26T18:47:37Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c5CzTP7",
          "commit": {
            "abbreviatedOid": "5d6bb55"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-09-26T18:51:56Z",
          "updatedAt": "2022-09-26T18:51:56Z",
          "comments": [
            {
              "originalPosition": 40,
              "body": "I don't think this note is talking about deployment over IP specifically. MLS may be deployed over some sort of Tor-like anonymous transport layer where data payloads that are anonymized have a fix/maximum size.",
              "createdAt": "2022-09-26T18:51:56Z",
              "updatedAt": "2022-09-26T18:51:56Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c5DS3-k",
          "commit": {
            "abbreviatedOid": "5d6bb55"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-10-03T21:03:21Z",
          "updatedAt": "2022-10-03T21:03:21Z",
          "comments": [
            {
              "originalPosition": 18,
              "body": "Here we are using \"transport\" in a higher-level sense.  As @Bren2010 points out, the \"transport\" could be something like WebSockets or Tor cells.  It is possible in principle that you might use something like UDP or raw IP packets, but that would require a lot of invention.",
              "createdAt": "2022-10-03T21:03:21Z",
              "updatedAt": "2022-10-03T21:03:21Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c5DS4O9",
          "commit": {
            "abbreviatedOid": "5d6bb55"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-10-03T21:04:26Z",
          "updatedAt": "2022-10-03T21:04:26Z",
          "comments": [
            {
              "originalPosition": 40,
              "body": "Yeah, I think the SHOULD is appropriate here given that we're not talking about a specific set of limitations.",
              "createdAt": "2022-10-03T21:04:26Z",
              "updatedAt": "2022-10-03T21:04:26Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c5DU0Cm",
          "commit": {
            "abbreviatedOid": "349364d"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-10-04T08:44:21Z",
          "updatedAt": "2022-10-04T08:44:47Z",
          "comments": [
            {
              "originalPosition": 18,
              "body": "I think the name \"update message\" is perhaps causing some confusion. They are not some kind of keepalive packets or high-frequency state synchronization messages. In many applications, the interval between two update messages can range from hours to months.\r\nTheir primary purpose is to limit the \"window of compromise\" by providing post-compromise security, I doubt applications will require the window to be < 1 min.",
              "createdAt": "2022-10-04T08:44:21Z",
              "updatedAt": "2022-10-04T08:44:47Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c5DYWfA",
          "commit": {
            "abbreviatedOid": "349364d"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-10-04T18:47:49Z",
          "updatedAt": "2022-10-04T18:47:49Z",
          "comments": []
        }
      ]
    },
    {
      "number": 749,
      "id": "PR_kwDOBoyH6c5AJB7w",
      "title": "Responses to early ARTART review",
      "url": "https://github.com/mlswg/mls-protocol/pull/749",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "https://mailarchive.ietf.org/arch/msg/mls/g9XmmtT5wtxjazHrUVdW27a---U/",
      "createdAt": "2022-10-04T14:31:18Z",
      "updatedAt": "2022-12-08T12:52:57Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "231aaa2c1da88d121d7aa871befe954fea41a8e3",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "artart",
      "headRefOid": "7024ae8c1b9281ddbeb6734567a081e1cfbdd81d",
      "closedAt": "2022-12-08T12:52:57Z",
      "mergedAt": "2022-12-08T12:52:57Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "d7f9cde6fde5708a824d03c7e852ec671307b4bf"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOBoyH6c5E3ulk",
          "commit": {
            "abbreviatedOid": "7024ae8"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-10-25T20:32:02Z",
          "updatedAt": "2022-10-25T20:32:02Z",
          "comments": []
        }
      ]
    },
    {
      "number": 750,
      "id": "PR_kwDOBoyH6c5AJGab",
      "title": "Responses to early OPSDIR review",
      "url": "https://github.com/mlswg/mls-protocol/pull/750",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "https://mailarchive.ietf.org/arch/msg/mls/o-2RdSTL2VV-k0NQ_52Fg6A8zqo/",
      "createdAt": "2022-10-04T14:44:47Z",
      "updatedAt": "2022-12-08T12:53:37Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "231aaa2c1da88d121d7aa871befe954fea41a8e3",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "opsdir",
      "headRefOid": "485966d78c400557d6d6e8e9add72845f2284690",
      "closedAt": "2022-12-08T12:53:37Z",
      "mergedAt": "2022-12-08T12:53:37Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "6b747bd495d8b6e67d3cc0f1bb0cd8f9885e2160"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOBoyH6c5E3vAU",
          "commit": {
            "abbreviatedOid": "485966d"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-10-25T20:33:33Z",
          "updatedAt": "2022-10-25T20:33:33Z",
          "comments": []
        }
      ]
    },
    {
      "number": 751,
      "id": "PR_kwDOBoyH6c5AJRGj",
      "title": "State update/commit epoch in updated LeafNode",
      "url": "https://github.com/mlswg/mls-protocol/pull/751",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #748 ",
      "createdAt": "2022-10-04T15:17:46Z",
      "updatedAt": "2022-12-08T15:20:05Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "231aaa2c1da88d121d7aa871befe954fea41a8e3",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "bind-epoch",
      "headRefOid": "7d55f83b07af84d5ae00b223c63a76ff47cdeb32",
      "closedAt": "2022-12-08T15:20:05Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "psyoptix",
          "authorAssociation": "CONTRIBUTOR",
          "body": "What is the motivation for this change?\r\n\r\nI ask because I think there is a bit of a down side to this change. It amounts to putting more metadata (about the activity of group members) into the ratchet tree which, in many implementations, will end up in the clear on a server. So I'm a bit hesitant at the moment to mandate this as opposed to, say, making it an optional extension.",
          "createdAt": "2022-11-17T13:37:25Z",
          "updatedAt": "2022-11-17T13:37:25Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOBoyH6c5E3xnJ",
          "commit": {
            "abbreviatedOid": "7d55f83"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-10-25T20:42:47Z",
          "updatedAt": "2022-10-25T20:44:44Z",
          "comments": [
            {
              "originalPosition": 50,
              "body": "```suggestion\r\n1. There is a leaf node L and a sequence of parent nodes P\\_1, ..., P\\_N such that\r\n```",
              "createdAt": "2022-10-25T20:42:47Z",
              "updatedAt": "2022-10-25T20:44:44Z"
            },
            {
              "originalPosition": 56,
              "body": "```suggestion\r\n   field indicates an epoch greater than or equal to any `update_epoch` or\r\n```",
              "createdAt": "2022-10-25T20:43:33Z",
              "updatedAt": "2022-10-25T20:44:44Z"
            }
          ]
        }
      ]
    },
    {
      "number": 752,
      "id": "PR_kwDOBoyH6c5Avgiq",
      "title": "Remove the `unmerged_leaves` array from parent nodes",
      "url": "https://github.com/mlswg/mls-protocol/pull/752",
      "state": "CLOSED",
      "author": "TWal",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "This PR builds on #751, and goes one step further: now the add epoch is also stored in leaf nodes whose source is KeyPackage.\r\n\r\nOne nice benefit of this is that there is no need for the `unmerged_leaves` array anymore: it can be re-computed only from the epoch information in the leaves.\r\n\r\nIndeed, define the LastUpdateEpoch(N) as `max { L.last_update_epoch | L.source = commit and L is in N's subtree }`.\r\nThen we have the following invariant on the unmerged leaves array: for every non-blank node N and leaves L: L is in N.unmerged_leaves iff. L.source = key_package and L.add_epoch >= LastUpdateEpoch(N).\r\n\r\n<details><summary>Proof sketch / explanations why it is true</summary>\r\n\r\n> The first invariant is an epoch invariant: at any time, the add / update / commit epoch of leaves is less than or equal to the current epoch.\r\n> \r\n> Then we prove the unmerged leaves invariant by checking every \"atomic\" operation on the tree, as it was done in [the parent-hash correctness proof in the past](https://github.com/mlswg/mls-protocol/pull/527#issuecomment-1035122916).\r\n> \r\n> Addition of a new leaf L:\r\n> By the epoch invariant, the add epoch of L greater or equal than the commit epoch of any leaf of the tree, hence it is greater or equal than LastUpdateEpoch(N) of every non-blank node N on the path from L to the root and is unmerged for these nodes\r\n> \r\n> Removal of a leaf L:\r\n> Every non-blank node N that is not blanked by the removal of L doesn't contain L, hence the invariant is preserved.\r\n> \r\n> UpdatePath from a leaf L:\r\n> By the epoch invariant, the commit epoch of L is strictly greater than the epoch of any leaf of the tree (because it is equal to the current epoch, plus one)\r\n> Hence for every node N on the path from L to the root, LastUpdateEpoch(N) = commit epoch of L, hence no leaf is unmerged for N.\r\n> \r\n> Update of a leaf L:\r\n> Roughly the same as removal\r\n> \r\n> Truncation / extension:\r\n> nothing to say\r\n\r\n</details>\r\n\r\nThis means that we can remove this array, while still conserving the notion of unmerged leaves, using the above equivalence as the new definition for unmerged leaves.\r\n\r\nI think this greatly simplifies the protocol:\r\n- now it is crystal clear that unmerged leaves corresponds to node that were added after the node was last updated (it's their definition!)\r\n- the \"original tree hash\" thing is much easier to explain and understand: no need to explain that we modify the unmerged leaves array\r\n- a lot of invariants of unmerged leaves comes \"for free\", such as the invariants we added in #713: with this definition, unmerged leaves of a node are automatically non-blank leaves in that node's subtree\r\n- even better: this gives even more invariants for unmerged leaves, including one that is crucial for the correctness of the O(n log log n) tree verification procedure described in #527 (discussed in the review of cisco/mlspp#289). The invariant is the following: given and descent D and a parent P, if a leaf L under D's subtree is unmerged for P, then it is unmerged for D. This invariant (that is not currently checked by MLS when joining a group) comes for free, simply because LastUpdateEpoch(P) >= LastUpdateEpoch(D).\r\n\r\nI think this PR is not hard to implement:\r\n- the LastUpdateEpoch thing can be memoized as it is done with TreeHash\r\n- in fact implementations can keep the unmerged leaves array in parent nodes, to memoize the unmerged leaves of every node, but now it's just an implementation trick and not some book-keeping hardcoded inside the protocol\r\n\r\nI think this PR doesn't introduce any problem in security proofs: although we introduce a non-authenticated field (the add epoch of new leaves), it actually correspond to the fact that the unmerged leaves of a node N is not authenticated by one of its leaves via parent-hash.\r\nOf course, \"I think\" is not enough and if we agree that it's a mergeable PR on the only condition that we have security proofs for this PR, I'd be very happy to update my proofs (which should be soon published).",
      "createdAt": "2022-10-13T14:37:24Z",
      "updatedAt": "2022-12-08T15:20:06Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "231aaa2c1da88d121d7aa871befe954fea41a8e3",
      "headRepository": "TWal/mls-protocol",
      "headRefName": "twal_remove_unmerged_leaves",
      "headRefOid": "a6a0580626c56281ff4f347e73733249dac9c737",
      "closedAt": "2022-12-08T15:20:06Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "TWal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Responding to your high-level remarks:\r\n\r\n> Computing unmerged leaves now requires some bookkeeping\r\n\r\nIndeed, but this bookkeeping is currently inlined inside the protocol: implementations have no choice but to implement it.\r\nTherefore it will not be harder to implement unmerged leaves after this PR than before (except when receiving a tree, where you have to compute manually the unmerged leaves array).\r\n\r\n>There is some extra complexity in the parent hash algorithms, which are already complex\r\n\r\nI disagree, I think the parent hash algorithm is much more simple now, and the origin of the various conditions are more obvious.\r\nThey can be rephrased as:\r\n- D is a descendant of P in the tree\r\n- D.parent_hash correctly covers P's subtree\r\n- D and P were last updated at the same time\r\n- Extra nodes between D and P are there because of path filtering\r\n\r\nWhich I think looks quite reasonable\r\n\r\n> The unsigned field in the leaf node is troublesome\r\n\r\nI agree, this requires some serious analysis that I'm willing to do if that's the only thing left for the approval of this PR.\r\nBut I don't really see how that would be exploited by an attacker. This field not being authenticated is roughly the same as leaves not authenticated for which nodes they are unmerged.\r\n",
          "createdAt": "2022-10-14T14:27:00Z",
          "updatedAt": "2022-10-14T14:27:00Z"
        },
        {
          "author": "TWal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "One more remark:\r\n\r\nDoes the `commit_epoch` represents the epoch after the said commit, or before?\r\nIntuitively I prefer the epoch after the commit, hence the condition `L.add_epoch >= LastUpdateEpoch(N)`.\r\nHowever if it were the epoch before the commit, the condition would need to be `L.add_epoch > LastUpdateEpoch(N)`.",
          "createdAt": "2022-10-14T14:34:04Z",
          "updatedAt": "2022-10-14T14:34:04Z"
        },
        {
          "author": "TWal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I have been thinking through this a bit more, and I think this could in fact lead to performance improvements for Welcome processing.\r\nThis is because the new definition of unmerged leaves imply a lot of invariants \"for free\", that we can rely on when processing the Welcome message.\r\nFor example, the correction of the agressive memoization for the O(n log log n) algorithm in #527 rely on an unchecked invariant of unmerged leaves (as I discussed in the first message).\r\n\r\nWith this PR, we could do another optimization for the parent-hash verification procedure: for every node, we could compute the direction from which they were updated. Hence, we would only have to compute one parent-hash per node, instead of two in current implementations (because we don't know if the last commit comes from left or right, we have to test both option).\r\n\r\nThis PR modifies the parent-hash link definition to include the condition \"The last update epoch of D is equal to the last update epoch of P\".\r\nThis implies that if `P` is ultimately authenticated by a leaf `L` by a parent-hash link path, then `LastUpdateEpoch(L) == LastUpdateEpoch(P)`.\r\nIf the leaf `L` satisfying this property were unique, then we could deduce from it the direction from which `P` was last updated.\r\nTo make `L` unique, we only have to make these two changes:\r\n\r\n- `LastUpdateEpoch` becomes `LastCommitEpoch`, i.e. we ignore the `update_epoch` in its computation: only the leaves' `commit_epoch` are relevant\r\n- we check the invariant that all the `commit_epoch`s are different (which is true: only one participant can commit in a given epoch)\r\n\r\nThen the following property is true: if `P_left` and `P_right` are the left and right children of `P`, then `LastCommitEpoch(P_left) != LastCommitEpoch(P_right)`.\r\nFrom this we can deduce the direction of the parent-hash link that authenticated `P`.\r\n",
          "createdAt": "2022-10-24T12:15:47Z",
          "updatedAt": "2022-10-24T12:15:47Z"
        },
        {
          "author": "TWal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "FYI, I updated my mechanically-checked authentication theorem (in F*), it still holds with this modified version of the protocol.\r\nThe fact that `add_epoch` isn't authenticated didn't raised any problems, it's roughly the same as the `unmerged_leaves` array not being authenticated by leaves under it.\r\nIn this PR (and my proofs), the `commit_epoch` references the new epoch induced by the commit, if we want it to refer to the old epoch that's possible I think, we would however need to update the unmerged leaves condition (and another round of mechanical proofs update to make sure we don't miss anything!)\r\nIn the last commit I changed the parent-hash link condition to be a bit more compact (using resolution), but it's equivalent to the ones before the commit.",
          "createdAt": "2022-12-02T21:21:05Z",
          "updatedAt": "2022-12-02T21:21:05Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOBoyH6c5EA1my",
          "commit": {
            "abbreviatedOid": "782f62d"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "I think this can be tuned up so that it works, but I'm pretty split on whether we should do it.\r\n\r\n* Pro...\r\n    * For implementors looking at the structures, having a `last_updated_epoch` seems like an easier thing to understand than an `unmerged_leaves` field\r\n    * The \"last update epoch\" concept might be handy for managing groups\r\n    * This does provide more uniformity in that every leaf has an epoch tag\r\n* Con...\r\n    * Computing unmerged leaves now requires some bookkeeping\r\n    * The unsigned field in the leaf node is troublesome\r\n    * There is some extra complexity in the parent hash algorithms, which are already complex",
          "createdAt": "2022-10-13T15:48:26Z",
          "updatedAt": "2022-10-13T16:12:09Z",
          "comments": [
            {
              "originalPosition": 86,
              "body": "The trouble here is: KeyPackage contains a LeafNode, and this field is meaningless within a KeyPackage.  To resolve this, we would need to do something like:\r\n\r\n1. Reinterpret what is now LeafNode as SignedLeafNodeContent\r\n2. Make a new LeafNode struct that has SignedLeafNodeContent and `add_epoch`\r\n3. Replace the LeafNode in KeyPackage with SignedLeafNodeContent\r\n\r\n(This is what I meant by a structural change.)",
              "createdAt": "2022-10-13T15:48:26Z",
              "updatedAt": "2022-10-13T16:12:09Z"
            },
            {
              "originalPosition": 86,
              "body": "The story for how this field is integrity-protected also seems hard to understand.  Right now, all the data in a leaf is signed by the leaf holder, and non-blank parent nodes are indirectly signed via parent hash.  The only integrity protection this field would get is via being included in the sibling subtree of a parent hash calculation.",
              "createdAt": "2022-10-13T15:51:41Z",
              "updatedAt": "2022-10-13T16:12:09Z"
            },
            {
              "originalPosition": 108,
              "body": "It seems like you need a line here to check that `add_epoch` is the current epoch.",
              "createdAt": "2022-10-13T15:52:49Z",
              "updatedAt": "2022-10-13T16:12:09Z"
            },
            {
              "originalPosition": 163,
              "body": "```suggestion\r\nwhen validating a group's tree on joining.) More generally, if no leaf under S\r\nis unmerged with regard to P (and thus no leaves were blanked),\r\n```",
              "createdAt": "2022-10-13T15:54:46Z",
              "updatedAt": "2022-10-13T16:12:09Z"
            },
            {
              "originalPosition": 173,
              "body": "How is the last update epoch of a parent node defined, if not via the parent hash?  In other words, it seems like to compute the last update epoch of P, you need to verify a parent-hash chain to a leaf with `leaf_source = commit`, and set `P.last_update_epoch = L.commit_epoch`.  So you can't refer to the last update epoch in the chaining algorithm.",
              "createdAt": "2022-10-13T15:56:45Z",
              "updatedAt": "2022-10-13T16:12:09Z"
            },
            {
              "originalPosition": 176,
              "body": "This is less precise.  You need to required that the copath resolution covers *all* unmerged leaves in this subtree.",
              "createdAt": "2022-10-13T15:59:40Z",
              "updatedAt": "2022-10-13T16:12:09Z"
            },
            {
              "originalPosition": 26,
              "body": "This definition is coherent in the abstract, but not useful without more concreteness.  You need to either carry the last update epoch in the node structure (LeafNode / ParentNode) or define a way it is computed from a representation of the tree.",
              "createdAt": "2022-10-13T16:01:49Z",
              "updatedAt": "2022-10-13T16:12:09Z"
            },
            {
              "originalPosition": 33,
              "body": "Nit: We don't use \"iff\" elsewhere, and it shouldn't be followed by a \".\"",
              "createdAt": "2022-10-13T16:03:02Z",
              "updatedAt": "2022-10-13T16:12:09Z"
            },
            {
              "originalPosition": 33,
              "body": "This would be clearer with something like: a leaf node L is unmerged with with regard to a parent node P if:\r\n\r\n* P is an ancestor of L\r\n* `L.leaf_node_source == key_package`\r\n* `L.add_epoch > P.last_update_epoch`",
              "createdAt": "2022-10-13T16:04:06Z",
              "updatedAt": "2022-10-13T16:12:09Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c5EFmkn",
          "commit": {
            "abbreviatedOid": "782f62d"
          },
          "author": "TWal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-10-14T12:10:11Z",
          "updatedAt": "2022-10-14T12:10:11Z",
          "comments": [
            {
              "originalPosition": 173,
              "body": "The last update epoch of a node is defined via the update epoch of their leaves, not via the parent hash definition. Will add a formal definition akin to the resolution one.\r\nThis conditions ensures that the leaf chaining its parent-hash links to P has a commit epoch equal to the last update epoch of P.",
              "createdAt": "2022-10-14T12:10:11Z",
              "updatedAt": "2022-10-14T12:10:11Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c5EFsP4",
          "commit": {
            "abbreviatedOid": "782f62d"
          },
          "author": "TWal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-10-14T12:28:22Z",
          "updatedAt": "2022-10-14T12:28:22Z",
          "comments": [
            {
              "originalPosition": 176,
              "body": "I'm not sure to understand.\r\nYou mean that we also need the converse:\r\nif a leaf L is in the subtree of one of the copath nodes (let's call this node N) and L is unmerged for P\r\nthen L is in the resolution of of N?\r\n\r\nThis is implied by the condition I wrote: since the resolution of N only contains leaves (that are unmerged for P), all parent nodes in N's subtree are blank. Hence every leaf in N subtree is in N resolution.",
              "createdAt": "2022-10-14T12:28:22Z",
              "updatedAt": "2022-10-14T12:28:22Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c5EF8AO",
          "commit": {
            "abbreviatedOid": "782f62d"
          },
          "author": "TWal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-10-14T13:13:07Z",
          "updatedAt": "2022-10-14T13:13:07Z",
          "comments": [
            {
              "originalPosition": 26,
              "body": "I just pushed a commit improving this, giving a formal definition like it is done for resolution.",
              "createdAt": "2022-10-14T13:13:07Z",
              "updatedAt": "2022-10-14T13:13:07Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c5EF8lK",
          "commit": {
            "abbreviatedOid": "782f62d"
          },
          "author": "TWal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-10-14T13:14:39Z",
          "updatedAt": "2022-10-14T13:14:39Z",
          "comments": [
            {
              "originalPosition": 108,
              "body": "No need to check this: the `add_epoch` is set when applying the Add on the tree.\r\nWe might however check that it is equal to some predefined value, for example 0.",
              "createdAt": "2022-10-14T13:14:39Z",
              "updatedAt": "2022-10-14T13:14:39Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c5EF95V",
          "commit": {
            "abbreviatedOid": "782f62d"
          },
          "author": "TWal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-10-14T13:18:07Z",
          "updatedAt": "2022-10-14T13:18:08Z",
          "comments": [
            {
              "originalPosition": 86,
              "body": "I have another suggestion: the KeyPackage contains a LeafNode, which contains the `add_epoch` field. We can simply not care about it, or say that it MUST be equal to some fixed value such as `0`.\r\nThe `add_epoch` field is later modified by the person applying the Add, and that is not a problem because this field is not authenticated.\r\nI think the integrity of this `add_epoch` field really has the same story as the integrity of the current unmerged leaves list: it is authenticated only by parent hash of nodes above it.",
              "createdAt": "2022-10-14T13:18:08Z",
              "updatedAt": "2022-10-14T13:18:08Z"
            }
          ]
        }
      ]
    },
    {
      "number": 754,
      "id": "PR_kwDOBoyH6c5BOSqN",
      "title": "Allow multiple welcomes per commit",
      "url": "https://github.com/mlswg/mls-protocol/pull/754",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #753 \r\n\r\nThis initial effort tweaks the sections that talk about generating and processing Welcome messages.  There might be other references to a single Welcome per Commit that should be amended for clarity.  Someone should audit for those before we merge this PR.",
      "createdAt": "2022-10-20T19:28:43Z",
      "updatedAt": "2022-12-08T15:27:53Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "231aaa2c1da88d121d7aa871befe954fea41a8e3",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "multi-welcome",
      "headRefOid": "aafaeeac98c853175b0c85633174851f386e76bd",
      "closedAt": "2022-12-08T15:27:52Z",
      "mergedAt": "2022-12-08T15:27:52Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "7742ae5b09f22de1a5c5bcf3a252053ca9ae823e"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOBoyH6c5Ei7xW",
          "commit": {
            "abbreviatedOid": "7682997"
          },
          "author": "TWal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-10-20T21:31:52Z",
          "updatedAt": "2022-10-20T21:31:52Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "```suggestion\r\n  Welcome messages to construct.  However, the set of Welcome messages produced\r\n  in this step MUST cover every new member added in the Commit.\r\n```\r\nI found this sentence quite hard to understand (basically it means that every new member must be able to decrypt one of the welcome messages?), I tried a reformulation",
              "createdAt": "2022-10-20T21:31:52Z",
              "updatedAt": "2022-10-20T21:31:52Z"
            }
          ]
        }
      ]
    },
    {
      "number": 755,
      "id": "PR_kwDOBoyH6c5Brwwp",
      "title": "BasicCredential public key must be same as in LeafNode",
      "url": "https://github.com/mlswg/mls-protocol/pull/755",
      "state": "CLOSED",
      "author": "franziskuskiefer",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Unless I'm missing something there's currently no connection between the basic credential and the signature public key in the leaf node. A sentence similar to the x.509 option should be added.",
      "createdAt": "2022-10-27T16:58:12Z",
      "updatedAt": "2022-12-08T15:37:31Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "231aaa2c1da88d121d7aa871befe954fea41a8e3",
      "headRepository": "franziskuskiefer/mls-protocol",
      "headRefName": "leaf_node_alignment",
      "headRefOid": "5d8733568408f372fe6ea19904ec77f938044cbf",
      "closedAt": "2022-12-08T15:37:31Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "I don't think this is necessary.  There is no key material in a BasicCredential, just a (non-cryptographic) identity.  Note that this is a relatively recent change, dating to when we pulled the `signature_key` out of the credential into the LeafNode.  There used to be a signature public key in `BasicCredential`, but now there is not.  In this regard, X509Credential is actually the outlier, since it duplicatively lists the signature public key! ",
          "createdAt": "2022-10-27T17:56:06Z",
          "updatedAt": "2022-10-27T17:56:06Z"
        },
        {
          "author": "franziskuskiefer",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Well, the basic credential is an odd thing right now. Because it's entirely defined by the application at could be anything.\r\nThe only connection between the two right now is \"The credential field contains information authenticating both the member's identity and the provided signing key\" in 8.2. But the basic credential could be a key(pair) itself. How should it then relate to the signature key?\r\nI don't think we need this exact sentence here. But there needs to be a little more clarity around what the \"basic\" credential is supposed to be now, esp. in relation to the signature key.",
          "createdAt": "2022-10-28T06:06:58Z",
          "updatedAt": "2022-10-28T06:06:58Z"
        },
        {
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I don't have a strong opinion about the basic credential one way or another, but the credential (regardless of its type) really must contain either the signature key in the LeafNode or at least a commitment to it. Otherwise the AS-validation of the credential is pretty much meaningless, as it isn't at all connected to the LeafNode it is in. I guess another possibility is for the credential to contain a signature over the LeafNode, but that seems a bit backwards.",
          "createdAt": "2022-11-07T16:38:01Z",
          "updatedAt": "2022-11-07T16:38:01Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 756,
      "id": "PR_kwDOBoyH6c5BsUdy",
      "title": "Remove reference to BasicCredential.",
      "url": "https://github.com/mlswg/mls-protocol/pull/756",
      "state": "MERGED",
      "author": "Bren2010",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "#755 made me realize that BasicCredential actually doesn't exist anymore!",
      "createdAt": "2022-10-27T18:55:21Z",
      "updatedAt": "2022-12-08T15:37:58Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "231aaa2c1da88d121d7aa871befe954fea41a8e3",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "brendan/bc",
      "headRefOid": "72a2ffd4b430a7a0da4f677a3a5851c016371221",
      "closedAt": "2022-12-08T15:37:58Z",
      "mergedAt": "2022-12-08T15:37:58Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "a39cb01a96dc5740d29fafa3d892db983d70b64d"
      },
      "comments": [
        {
          "author": "rohan-wire",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> #755 made me realize that BasicCredential actually doesn't exist anymore!\r\n\r\nWell, \"basic\" is listed as a credential type in the IANA registry defined in [Section 17.4](https://www.ietf.org/archive/id/draft-ietf-mls-protocol-16.html#mls-credential-types). That said, your proposed text seems perfectly consistent with the registry and the rest of the document.\r\n\r\n",
          "createdAt": "2022-11-29T00:02:23Z",
          "updatedAt": "2022-11-29T00:02:23Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOBoyH6c5FHJHr",
          "commit": {
            "abbreviatedOid": "72a2ffd"
          },
          "author": "franziskuskiefer",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "\ud83d\udc4d\ud83c\udffb ",
          "createdAt": "2022-10-28T06:04:49Z",
          "updatedAt": "2022-10-28T06:04:49Z",
          "comments": []
        }
      ]
    },
    {
      "number": 757,
      "id": "PR_kwDOBoyH6c5BwzUD",
      "title": "Clarify external join into first epoch",
      "url": "https://github.com/mlswg/mls-protocol/pull/757",
      "state": "CLOSED",
      "author": "mulmarta",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "I realized that the external joiner deals with the epoch 0 a bit differently. This clarifies the special case. I hope this was the intended behavior.",
      "createdAt": "2022-10-28T16:29:20Z",
      "updatedAt": "2022-12-09T13:49:56Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "231aaa2c1da88d121d7aa871befe954fea41a8e3",
      "headRepository": "mulmarta/mls-protocol",
      "headRefName": "mulmarta/external-join",
      "headRefOid": "95fb05e02376da2947693868c5ad6dad32610f59",
      "closedAt": "2022-12-09T13:49:56Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Interim 2012-12-08:\r\n* Epoch 0 GroupInfo has empty confirmation tag\r\n* Initial Interim transcript hash = confirmed + empty confirmation tag\r\n* OK to merge with those changes \r\n* RLB to file an issue to update Section 12 to clarify that you can have one-member groups",
          "createdAt": "2022-12-08T15:53:37Z",
          "updatedAt": "2022-12-08T15:53:37Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOBoyH6c5IIaK2",
          "commit": {
            "abbreviatedOid": "95fb05e"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-12-08T14:22:39Z",
          "updatedAt": "2022-12-08T14:29:23Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "> epoch ID 0 (i.e., before any members were added)\r\n\r\nThis doesn't make sense.  In epoch 0, there is a member, the creator.",
              "createdAt": "2022-12-08T14:22:40Z",
              "updatedAt": "2022-12-08T14:29:23Z"
            },
            {
              "originalPosition": 8,
              "body": "I think this is correct given the way group creation is specified right now.\r\n\r\nAnother way we could fix this is to make the 0->1 transition a little more like other transitions, in the following sense:\r\n\r\n* Have the group creator choose an epoch secret (not just an init secret)\r\n* Set the initial interim transcript hash to the MAC computed with the empty confirmed transcript hash and the confirmation key from the initial epoch secret\r\n* Then the external joiner computes the interim transcript hash as normal.\r\n\r\nI have a slight preference for doing this latter fix.  It makes things more consistent, but would be a slightly larger change.",
              "createdAt": "2022-12-08T14:29:17Z",
              "updatedAt": "2022-12-08T14:29:23Z"
            }
          ]
        }
      ]
    },
    {
      "number": 761,
      "id": "PR_kwDOBoyH6c5EXbYN",
      "title": "Change of affiliation",
      "url": "https://github.com/mlswg/mls-protocol/pull/761",
      "state": "MERGED",
      "author": "kkohbrok",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "This PR changes the affiliation of @raphaelrobert and myself.",
      "createdAt": "2022-12-05T16:55:15Z",
      "updatedAt": "2022-12-05T17:06:36Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "231aaa2c1da88d121d7aa871befe954fea41a8e3",
      "headRepository": "kkohbrok/mls-protocol",
      "headRefName": "konrad/change-affiliation",
      "headRefOid": "091aed0ea29049aa444fab9b09845338dc870686",
      "closedAt": "2022-12-05T17:06:36Z",
      "mergedAt": "2022-12-05T17:06:36Z",
      "mergedBy": "beurdouche",
      "mergeCommit": {
        "oid": "01a20d330a15fdb45ba2d7fd7701465bf19c544d"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOBoyH6c5H0ZGI",
          "commit": {
            "abbreviatedOid": "091aed0"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-12-05T16:56:15Z",
          "updatedAt": "2022-12-05T16:56:15Z",
          "comments": []
        }
      ]
    },
    {
      "number": 820,
      "id": "PR_kwDOBoyH6c5EhVhl",
      "title": "Address nits",
      "url": "https://github.com/mlswg/mls-protocol/pull/820",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #819",
      "createdAt": "2022-12-06T18:09:07Z",
      "updatedAt": "2022-12-09T13:28:01Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "f90675511b149d2bca6b9e8b07c41e81d2a1f14e",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "nits",
      "headRefOid": "f658d06a7823717a0d44bd9c192779803fe7be74",
      "closedAt": "2022-12-09T13:28:01Z",
      "mergedAt": "2022-12-09T13:28:01Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "55690373d7fbfd97777c86e0597d2c429cc111e7"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOBoyH6c5IEvCs",
          "commit": {
            "abbreviatedOid": "b8b2183"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-12-07T22:18:40Z",
          "updatedAt": "2022-12-07T22:18:40Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOBoyH6c5IJDH7",
          "commit": {
            "abbreviatedOid": "b8b2183"
          },
          "author": "rohan-wire",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-12-08T15:56:11Z",
          "updatedAt": "2022-12-08T15:56:11Z",
          "comments": []
        }
      ]
    },
    {
      "number": 821,
      "id": "PR_kwDOBoyH6c5EhrR9",
      "title": "Make ProtocolVersion two bytes",
      "url": "https://github.com/mlswg/mls-protocol/pull/821",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #766 ",
      "createdAt": "2022-12-06T18:49:26Z",
      "updatedAt": "2022-12-09T14:02:18Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "01a20d330a15fdb45ba2d7fd7701465bf19c544d",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "enum16",
      "headRefOid": "1065cfe440d2121e1dfbb3524e58f82d022a3439",
      "closedAt": "2022-12-09T14:02:18Z",
      "mergedAt": "2022-12-09T14:02:18Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "d31d84c5687d64c3621b955792970bd54815cdc4"
      },
      "comments": [
        {
          "author": "rohan-wire",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think this is unnecessary and capricious. ",
          "createdAt": "2022-12-08T15:48:47Z",
          "updatedAt": "2022-12-08T15:48:47Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Interim 2022-12-08:\r\n* Make ProtocolVersion and WireFormat two bytes\r\n* Leave other enums as-is\r\n* Define an IANA registry for WireFormat",
          "createdAt": "2022-12-08T16:05:13Z",
          "updatedAt": "2022-12-08T16:05:13Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 822,
      "id": "PR_kwDOBoyH6c5EiIsq",
      "title": "Make more vendor code points available",
      "url": "https://github.com/mlswg/mls-protocol/pull/822",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #777 ",
      "createdAt": "2022-12-06T19:44:11Z",
      "updatedAt": "2022-12-08T16:06:15Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "01a20d330a15fdb45ba2d7fd7701465bf19c544d",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "more-vendor-space",
      "headRefOid": "07536d96683ef1494620edfefc14b53e99ae3a0e",
      "closedAt": "2022-12-08T16:06:15Z",
      "mergedAt": "2022-12-08T16:06:15Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "438f36e65e5ece3b699af6df1738e1393ee75d14"
      },
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "@Bren2010 thanks, good catch.  should be fixed now.",
          "createdAt": "2022-12-07T22:25:23Z",
          "updatedAt": "2022-12-07T22:25:23Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOBoyH6c5IEviZ",
          "commit": {
            "abbreviatedOid": "d910300"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-12-07T22:20:47Z",
          "updatedAt": "2022-12-07T22:20:47Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOBoyH6c5IEv3M",
          "commit": {
            "abbreviatedOid": "d910300"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "Missed text mention on line 5042",
          "createdAt": "2022-12-07T22:22:10Z",
          "updatedAt": "2022-12-07T22:22:10Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOBoyH6c5IEwzm",
          "commit": {
            "abbreviatedOid": "07536d9"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-12-07T22:26:19Z",
          "updatedAt": "2022-12-07T22:26:19Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOBoyH6c5IJAdI",
          "commit": {
            "abbreviatedOid": "07536d9"
          },
          "author": "rohan-wire",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-12-08T15:49:27Z",
          "updatedAt": "2022-12-08T15:49:27Z",
          "comments": []
        }
      ]
    },
    {
      "number": 823,
      "id": "PR_kwDOBoyH6c5Ej5an",
      "title": "Minor edits for AD comments",
      "url": "https://github.com/mlswg/mls-protocol/pull/823",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #780 \r\nFixes #781\r\nFixes #797\r\nFixes #798\r\nFixes #799\r\nFixes #801\r\nFixes #814\r\nFixes #817",
      "createdAt": "2022-12-07T00:02:10Z",
      "updatedAt": "2022-12-09T13:23:39Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "01a20d330a15fdb45ba2d7fd7701465bf19c544d",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "minor-ad-review",
      "headRefOid": "739fd299ef58142ae1e70f8f1001ea449afa069a",
      "closedAt": "2022-12-09T13:23:39Z",
      "mergedAt": "2022-12-09T13:23:39Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "f90675511b149d2bca6b9e8b07c41e81d2a1f14e"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOBoyH6c5IEwEL",
          "commit": {
            "abbreviatedOid": "b451e2a"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-12-07T22:23:04Z",
          "updatedAt": "2022-12-07T22:28:31Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "```suggestion\r\nA has received its Commit message back from the Delivery Service does it update its\r\n```",
              "createdAt": "2022-12-07T22:23:04Z",
              "updatedAt": "2022-12-07T22:28:31Z"
            },
            {
              "originalPosition": 74,
              "body": "```suggestion\r\ndefined in {{deletion-schedule}}. Applications SHOULD also define a policy\r\n```",
              "createdAt": "2022-12-07T22:27:11Z",
              "updatedAt": "2022-12-07T22:28:31Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c5IImv-",
          "commit": {
            "abbreviatedOid": "739fd29"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-12-08T14:52:50Z",
          "updatedAt": "2022-12-08T14:52:50Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOBoyH6c5IJCS1",
          "commit": {
            "abbreviatedOid": "739fd29"
          },
          "author": "rohan-wire",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-12-08T15:54:06Z",
          "updatedAt": "2022-12-08T15:54:06Z",
          "comments": []
        }
      ]
    },
    {
      "number": 824,
      "id": "PR_kwDOBoyH6c5Esqar",
      "title": "Credentials should be replaced before expiring",
      "url": "https://github.com/mlswg/mls-protocol/pull/824",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #758 ",
      "createdAt": "2022-12-07T22:27:44Z",
      "updatedAt": "2022-12-14T14:02:09Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "01a20d330a15fdb45ba2d7fd7701465bf19c544d",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "expiry",
      "headRefOid": "fd9d86c1e5c5de52e5062e8bd53b64d4f1a39b1b",
      "closedAt": "2022-12-14T14:02:09Z",
      "mergedAt": "2022-12-14T14:02:08Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "5c1219b512635c3a82c6dd3bf36261b4b422ba10"
      },
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Interim 2022-12-08:\r\n* Distinguish \"time-invalid\" from \"invalid\"\r\n* There is a slightly more general issue: When catching up, there might be messages sent by members whose credentials were valid when the message was sent, but have since expired\r\n* Recommend accepting messages from members with time-invalid credentials when catching up",
          "createdAt": "2022-12-08T16:31:00Z",
          "updatedAt": "2022-12-08T16:31:00Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "I think a note on consistency would work a little better in the architecture document, especially because it applies in the general case as well as the time-varying case.  I filed https://github.com/mlswg/mls-architecture/issues/160",
          "createdAt": "2022-12-12T16:11:42Z",
          "updatedAt": "2022-12-12T16:11:42Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Latest change uses \"expired\" to refer generically to all time based reasons for a `valid -> invalid` transition.  (So, excluding `notBefore`, as @rohan-wire suggests.)",
          "createdAt": "2022-12-12T19:27:51Z",
          "updatedAt": "2022-12-12T19:27:51Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOBoyH6c5IJBP0",
          "commit": {
            "abbreviatedOid": "af18608"
          },
          "author": "rohan-wire",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Perfect.",
          "createdAt": "2022-12-08T15:51:26Z",
          "updatedAt": "2022-12-08T15:51:26Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOBoyH6c5IJlOu",
          "commit": {
            "abbreviatedOid": "af18608"
          },
          "author": "rohan-wire",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-12-08T17:19:21Z",
          "updatedAt": "2022-12-08T17:19:21Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "s/with invalid credentials/with recently expired but otherwise valid credentials/",
              "createdAt": "2022-12-08T17:19:21Z",
              "updatedAt": "2022-12-08T17:19:21Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c5IPEzb",
          "commit": {
            "abbreviatedOid": "29e4252"
          },
          "author": "tomleavy",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Looks great thanks @bifurcation ",
          "createdAt": "2022-12-09T16:24:09Z",
          "updatedAt": "2022-12-09T16:24:09Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOBoyH6c5IT2_F",
          "commit": {
            "abbreviatedOid": "29e4252"
          },
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Looks good with one small nit. Should we also note that the application might want to ensure that however the SHOULDs are interpreted, validation should be consistent for all clients? Or is that too much complexity?",
          "createdAt": "2022-12-12T09:27:43Z",
          "updatedAt": "2022-12-12T09:30:23Z",
          "comments": [
            {
              "originalPosition": 18,
              "body": "```suggestion\r\nIn general, to avoid operational problems such as new joiners rejecting expired\r\n```",
              "createdAt": "2022-12-12T09:27:43Z",
              "updatedAt": "2022-12-12T09:30:23Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c5IXsjb",
          "commit": {
            "abbreviatedOid": "658f6ab"
          },
          "author": "rohan-wire",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2022-12-12T19:01:31Z",
          "updatedAt": "2022-12-12T19:01:39Z",
          "comments": [
            {
              "originalPosition": 25,
              "body": "I still find \"time-invalid\" to be awkward.  I think \"recently expired\" is clearer, narrower, and a better fit. There is no reason for example to accept an Update with a credential which is not yet valid (which sounds time-invalid to me).",
              "createdAt": "2022-12-12T19:01:31Z",
              "updatedAt": "2022-12-12T19:01:40Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c5IXuAq",
          "commit": {
            "abbreviatedOid": "658f6ab"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-12-12T19:04:52Z",
          "updatedAt": "2022-12-12T19:04:53Z",
          "comments": [
            {
              "originalPosition": 25,
              "body": "I had shied away from \"recently expired\" because a credential can also become invalid due to revocation.  I guess we could write \"expired or revoked\" (since you usually can't tell \"recently revoked\").",
              "createdAt": "2022-12-12T19:04:52Z",
              "updatedAt": "2022-12-12T19:04:53Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c5IX42e",
          "commit": {
            "abbreviatedOid": "658f6ab"
          },
          "author": "rohan-wire",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-12-12T19:37:44Z",
          "updatedAt": "2022-12-12T19:37:44Z",
          "comments": [
            {
              "originalPosition": 25,
              "body": "I would argue that you do NOT want to accept revoked credentials. That client is dead to me.  (talk to the \u270b) ",
              "createdAt": "2022-12-12T19:37:44Z",
              "updatedAt": "2022-12-12T19:37:45Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c5IahFm",
          "commit": {
            "abbreviatedOid": "fd9d86c"
          },
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "I like the separate treatment of expired vs. revoked. Looks good to me now!",
          "createdAt": "2022-12-13T08:17:41Z",
          "updatedAt": "2022-12-13T08:17:41Z",
          "comments": []
        }
      ]
    },
    {
      "number": 827,
      "id": "PR_kwDOBoyH6c5E1q2G",
      "title": "Clarify group creation",
      "url": "https://github.com/mlswg/mls-protocol/pull/827",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This PR is an alternative to #757.\r\n\r\nThis PR updates the group creation process so that epoch 0 is a \"full-fledged\" epoch, with an epoch secret (and all the derivatives) instead of just an init secret.  One implication of that is that the interim transcript hash can now be computed in the usual way, by extending the confirmed transcript hash with a confirmation tag:\r\n\r\n```\r\n// creator sets epoch secret\r\nconfirmation_key = DeriveSecret(epoch_secret, \"confirm\")\r\nconfirmed_transcript_hash = \"\"\r\nconfirmation_tag = MAC(confirmation_key, confirmed_transcript_hash)\r\ninterim_transcript_hash = Hash(confirmed_transcript_hash || confirmation_tag)\r\n```\r\n\r\nThis has the nice side effect of immediately mixing the epoch secret into the transcript hash, helping the group diverge (a concern @kkohbrok raised on the call today).\r\n\r\nWhile I was editing the group creation section, I also rationalized the requirements a bit.  One reason that #757 came up is that the group creation section currently assumes you're always starting with multiple members.  So the MUST-level requirement to fetch key packages has been downgraded to a SHOULD.\r\n\r\n Finally, I updated the specification of GroupInfo to explain the fields, in particular explaining how you get the confirmation tag in epoch 0 or later epochs.",
      "createdAt": "2022-12-08T22:43:19Z",
      "updatedAt": "2022-12-14T14:01:45Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "438f36e65e5ece3b699af6df1738e1393ee75d14",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "epoch0",
      "headRefOid": "afdbe25df64668ab19ac6f74acab967064f81012",
      "closedAt": "2022-12-14T14:01:45Z",
      "mergedAt": "2022-12-14T14:01:45Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "676c73c98320c498202241e9b03323b4b121b1d7"
      },
      "comments": [
        {
          "author": "mulmarta",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Since this PR clarifies more than #757 and the solution is equally good, I'd suggest closing #757 and merging this one.",
          "createdAt": "2022-12-09T10:55:22Z",
          "updatedAt": "2022-12-09T10:55:22Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOBoyH6c5INOCF",
          "commit": {
            "abbreviatedOid": "1f1a468"
          },
          "author": "mulmarta",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-12-09T10:09:45Z",
          "updatedAt": "2022-12-09T10:09:46Z",
          "comments": [
            {
              "originalPosition": 25,
              "body": "> select a version and ciphersuite\r\n\r\nIn the previous sentence he doesn't choose a version, only ciphersuite. I guess the version is always MLS1.0?",
              "createdAt": "2022-12-09T10:09:45Z",
              "updatedAt": "2022-12-09T10:09:46Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c5INRlp",
          "commit": {
            "abbreviatedOid": "1f1a468"
          },
          "author": "mulmarta",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-12-09T10:18:53Z",
          "updatedAt": "2022-12-09T10:18:54Z",
          "comments": [
            {
              "originalPosition": 49,
              "body": "Remove the bullet above?",
              "createdAt": "2022-12-09T10:18:53Z",
              "updatedAt": "2022-12-09T10:19:16Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c5INYzn",
          "commit": {
            "abbreviatedOid": "1f1a468"
          },
          "author": "mulmarta",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-12-09T10:42:30Z",
          "updatedAt": "2022-12-09T10:42:31Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "The indexing here is a bit confusing : if `n` starts at `0`, then the computation of `confirmed_transcript_hash_[n]` below contradicts this starting point, and the computation of `interim_transcript_hash_[n+1]` means there is no interim hash at `n=0`.\r\n\r\nHow about this instead : instead of `n`, use `epoch` and say explicitly that `x_hash[epoch]` is stored in the state when epoch id is `epoch` and `XHashInput[epoch]` contains values from the commit creating `epoch`.  Then swap the computations below so that for any `epoch >= 0` we compute 1) `interim_transcript_hash[epoch]` using `confirmed_transcript_hash[epoch]` and 2) `confirmed_transcript_hash[epoch+1]` using `interim_transcript_hash[epoch]` and `ConfirmedTranscriptHashInput[epoch+1]`?",
              "createdAt": "2022-12-09T10:42:31Z",
              "updatedAt": "2022-12-09T10:42:31Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c5ISHQo",
          "commit": {
            "abbreviatedOid": "afdbe25"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-12-11T14:44:06Z",
          "updatedAt": "2022-12-11T14:44:06Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOBoyH6c5IVup6",
          "commit": {
            "abbreviatedOid": "afdbe25"
          },
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-12-12T14:10:54Z",
          "updatedAt": "2022-12-12T14:10:54Z",
          "comments": []
        }
      ]
    },
    {
      "number": 828,
      "id": "PR_kwDOBoyH6c5E1vGn",
      "title": "Update table header dividers",
      "url": "https://github.com/mlswg/mls-protocol/pull/828",
      "state": "MERGED",
      "author": "ericcornelissen",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Update all tables to use hyphens for table dividers instead of equal signs. Suggesting this because using equal signs leads to the tables not being rendered correctly on GitHub (preview below).\r\n\r\nI tried to see if there's a reason for using one over the other, but couldn't find one. If there's some reason to use equal signs, or if this is considered a non-issue, feel free to close this.\r\n\r\n---\r\n\r\n##### Using equal signs\r\n\r\n| this  | is    | an    | example |\r\n|:======|:======|:======|:========|\r\n| using | equal | signs | `=`     |\r\n\r\n##### Using hyphens\r\n\r\n| this  | is      | an      | example |\r\n|:------|:--------|:--------|:--------|\r\n| using | hyphens | instead | `-`     |",
      "createdAt": "2022-12-08T23:01:57Z",
      "updatedAt": "2022-12-09T13:55:27Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "438f36e65e5ece3b699af6df1738e1393ee75d14",
      "headRepository": null,
      "headRefName": "table-format",
      "headRefOid": "529a7b39671f0be64199a14f9e010885a62c7ea9",
      "closedAt": "2022-12-09T13:49:15Z",
      "mergedAt": "2022-12-09T13:49:15Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "c8b9a7f4b8fe0f57a26ef69de83d8144c8ed8640"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOBoyH6c5IOPYq",
          "commit": {
            "abbreviatedOid": "529a7b3"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "I think the RFC renderer doesn't care, but it's nice to have things display properly on GitHub as well.",
          "createdAt": "2022-12-09T13:49:10Z",
          "updatedAt": "2022-12-09T13:49:10Z",
          "comments": []
        }
      ]
    },
    {
      "number": 829,
      "id": "PR_kwDOBoyH6c5E6eEF",
      "title": "Clarify that the AS needs to vet the signature key",
      "url": "https://github.com/mlswg/mls-protocol/pull/829",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #825 \r\n\r\ncc @kkohbrok  for review",
      "createdAt": "2022-12-09T14:55:23Z",
      "updatedAt": "2022-12-09T20:14:36Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "d31d84c5687d64c3621b955792970bd54815cdc4",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "as-pubkey",
      "headRefOid": "4d8914edf7fdbec3656a144c9456e639f8bde16b",
      "closedAt": "2022-12-09T20:14:36Z",
      "mergedAt": "2022-12-09T20:14:36Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "3b4e6b7632a1c0d3bb215f27d5c0c0211bf789bf"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOBoyH6c5IQFii",
          "commit": {
            "abbreviatedOid": "4d8914e"
          },
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-12-09T19:37:51Z",
          "updatedAt": "2022-12-09T19:37:51Z",
          "comments": []
        }
      ]
    },
    {
      "number": 830,
      "id": "PR_kwDOBoyH6c5E6tdC",
      "title": "Update security and operational considerations",
      "url": "https://github.com/mlswg/mls-protocol/pull/830",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #762\r\nFixes #763\r\nFixes #815\r\nFixes #813\r\n\r\n* Add a paragraph to Operational Context describing additional security services that the DS can provide\r\n* Add a citation to security analyses via the MLS Architecture\r\n* Add a section discussing metadata protection",
      "createdAt": "2022-12-09T15:40:39Z",
      "updatedAt": "2022-12-14T16:02:08Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "d31d84c5687d64c3621b955792970bd54815cdc4",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "ad-sec-cons",
      "headRefOid": "4c59cbca2f15c6bbe79cef4224ffe542b92740a2",
      "closedAt": "2022-12-14T16:02:07Z",
      "mergedAt": "2022-12-14T16:02:07Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "0794b07a48450d4d0339307d2af804cdc7bb6e87"
      },
      "comments": [
        {
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "It also feels like the text assumes that the DS is a server as opposed to the abstract layer that we define it as in the architecture document. Maybe we should qualify the considerations accordingly?",
          "createdAt": "2022-12-12T13:53:39Z",
          "updatedAt": "2022-12-12T13:53:39Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "@kkohbrok @raphaelrobert - Thanks for sending #833.  I didn't merge it directly, but rewrote the metadata section trying to hit the key points from your proposal.  LMK what you think.",
          "createdAt": "2022-12-12T19:13:59Z",
          "updatedAt": "2022-12-12T19:13:59Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOBoyH6c5IVgjU",
          "commit": {
            "abbreviatedOid": "9f9e4d8"
          },
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "Thanks for writing up the metadata considerations! Do they belong here or in the architecture doc?",
          "createdAt": "2022-12-12T13:44:34Z",
          "updatedAt": "2022-12-12T13:52:10Z",
          "comments": [
            {
              "originalPosition": 51,
              "body": "If we're using public handshake messages, it would also expose who is adding whom and when.",
              "createdAt": "2022-12-12T13:44:34Z",
              "updatedAt": "2022-12-12T13:52:10Z"
            },
            {
              "originalPosition": 68,
              "body": "No necessarily. The GroupInfo could be uploaded in encrypted form and then the key material could be passed to a prospective joiner.\r\n\r\nIt might also be worth mentioning here that the same goes if the tree is not sent as an extension via the Welcome.",
              "createdAt": "2022-12-12T13:46:30Z",
              "updatedAt": "2022-12-12T13:52:10Z"
            },
            {
              "originalPosition": 87,
              "body": "This is only true if the DS has actually seen the KeyPackage, e.g. when it was uploaded. KeyPackages could be distributed in other ways, though, that are not visible to the DS.\r\n\r\nAlso it might be worth mentioning here that (global or per-group) pseudonyms can be used in conjunction with MLSPlaintext messages to avoid or at least reduce leakage of Metadata.",
              "createdAt": "2022-12-12T13:49:58Z",
              "updatedAt": "2022-12-12T13:52:10Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c5Iad7g",
          "commit": {
            "abbreviatedOid": "3210c66"
          },
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "Thanks for incorporating our ideas for this section. Looks good to me generally, but we should be careful about how we frame the DS.",
          "createdAt": "2022-12-13T08:11:37Z",
          "updatedAt": "2022-12-13T08:15:29Z",
          "comments": [
            {
              "originalPosition": 68,
              "body": "This suggests that the DS is a separate party. As I noted in the other PR, that is not necessarily the case. The DS is an abstract component parts of which may run on the clients themselves. It makes sense to use the DS as adversary when it comes to metadata, but I think its abstract nature forces us to qualify a bit here.",
              "createdAt": "2022-12-13T08:11:38Z",
              "updatedAt": "2022-12-13T08:15:29Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c5Ib7fM",
          "commit": {
            "abbreviatedOid": "3210c66"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "CHANGES_REQUESTED",
          "body": "Modulo a few nits and Konrad's comment, I think this works.",
          "createdAt": "2022-12-13T11:27:00Z",
          "updatedAt": "2022-12-13T11:37:45Z",
          "comments": [
            {
              "originalPosition": 75,
              "body": "```suggestion\r\n* How prospective external joiners get a GroupInfo object for the group\r\n```",
              "createdAt": "2022-12-13T11:27:00Z",
              "updatedAt": "2022-12-13T11:37:45Z"
            },
            {
              "originalPosition": 126,
              "body": "```suggestion\r\nconstruct a member's leaf node to be less identifying, e.g., by using a\r\n```",
              "createdAt": "2022-12-13T11:30:15Z",
              "updatedAt": "2022-12-13T11:37:45Z"
            },
            {
              "originalPosition": 122,
              "body": "```suggestion\r\nNote that these information leaks reveal the group's membership only to the degree\r\n```",
              "createdAt": "2022-12-13T11:31:27Z",
              "updatedAt": "2022-12-13T11:37:45Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c5IkdOX",
          "commit": {
            "abbreviatedOid": "4c59cbc"
          },
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-12-14T14:03:08Z",
          "updatedAt": "2022-12-14T14:03:08Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOBoyH6c5IlEC6",
          "commit": {
            "abbreviatedOid": "4c59cbc"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-12-14T15:26:18Z",
          "updatedAt": "2022-12-14T15:26:18Z",
          "comments": []
        }
      ]
    },
    {
      "number": 831,
      "id": "PR_kwDOBoyH6c5E7V5i",
      "title": "Make private use WireFormat space wider.",
      "url": "https://github.com/mlswg/mls-protocol/pull/831",
      "state": "MERGED",
      "author": "Bren2010",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2022-12-09T17:37:05Z",
      "updatedAt": "2022-12-09T20:14:22Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "d31d84c5687d64c3621b955792970bd54815cdc4",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "brendan/more-private",
      "headRefOid": "76c11efad4a95c9bc2dd4acd81cf67a3539243bb",
      "closedAt": "2022-12-09T20:14:22Z",
      "mergedAt": "2022-12-09T20:14:21Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "fccdedb85d5a74ffe4e286ccb06537bfd9fd67a5"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOBoyH6c5IQOKz",
          "commit": {
            "abbreviatedOid": "76c11ef"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-12-09T20:14:03Z",
          "updatedAt": "2022-12-09T20:14:03Z",
          "comments": []
        }
      ]
    },
    {
      "number": 832,
      "id": "PR_kwDOBoyH6c5FFGx9",
      "title": "editorial: Minor fixes in presentation language.",
      "url": "https://github.com/mlswg/mls-protocol/pull/832",
      "state": "MERGED",
      "author": "duesee",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "This PR fixes some minor issues with the presentation language. Moving `SignContent` and `RefHashInput` to their own `~~~ tls` block is required so that the `extract-tls.py` can now detect them.",
      "createdAt": "2022-12-11T11:25:29Z",
      "updatedAt": "2022-12-14T14:01:27Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "3b4e6b7632a1c0d3bb215f27d5c0c0211bf789bf",
      "headRepository": "duesee/mls-protocol",
      "headRefName": "duesee/fix_presentation_language",
      "headRefOid": "360dbc7133c4923a4d7d29e921dc7587a013dfe3",
      "closedAt": "2022-12-14T14:01:26Z",
      "mergedAt": "2022-12-14T14:01:26Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "7607b58f0c36ffcb63b556f947621374b590206b"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOBoyH6c5IXQ_R",
          "commit": {
            "abbreviatedOid": "4ab37dd"
          },
          "author": "rohan-wire",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "Separate pseudocode from genuine TLS Presentation Language please.\r\n",
          "createdAt": "2022-12-12T18:03:22Z",
          "updatedAt": "2022-12-12T18:58:03Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "Anytime there is an equal sign and something that looks like a function definition, that is no longer TLS Presentation Language, but pseudocode.\r\n\r\nI would move the definition of SignContent into a block like this before line 1334:\r\n`~~~ tls`\r\n`struct {`\r\n`    opaque label<V>;`\r\n`    opaque content<V>;`\r\n`} SignContent;`\r\n\r\nand then keep the content in the current block like this:\r\n\r\n`    label = \"MLS 1.0 \" + Label;`\r\n`    content = Content;`",
              "createdAt": "2022-12-12T18:03:23Z",
              "updatedAt": "2022-12-12T18:58:03Z"
            },
            {
              "originalPosition": 20,
              "body": "Same concept here. This is not TLS Presentation Language.",
              "createdAt": "2022-12-12T18:57:26Z",
              "updatedAt": "2022-12-12T18:58:04Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c5IYPl_",
          "commit": {
            "abbreviatedOid": "4ab37dd"
          },
          "author": "duesee",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-12-12T20:45:10Z",
          "updatedAt": "2022-12-12T20:45:10Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "I see, thanks! I pushed a fixup in [360dbc7](https://github.com/mlswg/mls-protocol/pull/832/commits/360dbc7133c4923a4d7d29e921dc7587a013dfe3) and hope that I got your suggestion right.",
              "createdAt": "2022-12-12T20:45:10Z",
              "updatedAt": "2022-12-12T20:45:45Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c5IepH5",
          "commit": {
            "abbreviatedOid": "360dbc7"
          },
          "author": "rohan-wire",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-12-13T17:13:59Z",
          "updatedAt": "2022-12-13T17:13:59Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOBoyH6c5IkbxE",
          "commit": {
            "abbreviatedOid": "360dbc7"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-12-14T13:59:37Z",
          "updatedAt": "2022-12-14T13:59:37Z",
          "comments": []
        }
      ]
    },
    {
      "number": 833,
      "id": "PR_kwDOBoyH6c5FNnp_",
      "title": "Proposal for changes to #830",
      "url": "https://github.com/mlswg/mls-protocol/pull/833",
      "state": "CLOSED",
      "author": "kkohbrok",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2022-12-12T16:21:16Z",
      "updatedAt": "2022-12-13T08:09:04Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "ad-sec-cons",
      "baseRefOid": "9f9e4d8fad3c514ecd462325859f38d69a68eb56",
      "headRepository": "kkohbrok/mls-protocol",
      "headRefName": "ad-sec-cons-comments",
      "headRefOid": "6af959f5549240258138f38e963fb81680519a09",
      "closedAt": "2022-12-12T19:54:56Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOBoyH6c5IWt4Q",
          "commit": {
            "abbreviatedOid": "6af959f"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-12-12T16:34:34Z",
          "updatedAt": "2022-12-12T16:41:47Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "The DS is always less trusted than the members clients.  The whole point of MLS is to protect against the DS :)  If you're thinking of things like p2p environments, then the DS would be the p2p links and any overlay routing, which is still less trusted than the client itself.",
              "createdAt": "2022-12-12T16:34:34Z",
              "updatedAt": "2022-12-12T16:41:47Z"
            },
            {
              "originalPosition": 34,
              "body": "```suggestion\r\nto the DS. Extensions can also be exposed via GroupInfo objects (see {{groupinfo-objects}}).\r\n```\r\n\r\nOtherwise it will render as \"exposed via Section X.X.X\"\r\n\r\nThis will render as \"exposed via Section X.X.X\".",
              "createdAt": "2022-12-12T16:37:25Z",
              "updatedAt": "2022-12-12T16:41:47Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c5Iactf",
          "commit": {
            "abbreviatedOid": "6af959f"
          },
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-12-13T08:09:03Z",
          "updatedAt": "2022-12-13T08:09:04Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "This has lead to quite a bit of confusion in the past and the architecture document is a bit ambiguous in the way the DS is defined. On the one hand you're right: The role of the DS involves message routing and it's described as a less trusted component. On the other hand, the role of the DS also involves commit ordering, which in case of a p2p system happens on the clients and which can not be done by overlay routing or p2p links.\r\n\r\nI do agree though, that even as an abstract component, we can generally say that the DS is considered less trusted, even if it's (at least partially) running within the trust boundary of the MLS client.",
              "createdAt": "2022-12-13T08:09:03Z",
              "updatedAt": "2022-12-13T08:09:04Z"
            }
          ]
        }
      ]
    },
    {
      "number": 835,
      "id": "PR_kwDOBoyH6c5FdzZ3",
      "title": "Have parent hash validation also verify unmerged leaves",
      "url": "https://github.com/mlswg/mls-protocol/pull/835",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "In #834, @raphaelrobert pointed out that we could be stricter in our validation of the `unmerged_leaves` field in the tree.  This PR updates the parent hash validation algorithm to also check that the `unmerged_leaves` relationships are consistent with the nodes having been updated at the same time.  In particular, it checks that the leaf node that signs the parent-hash chain is not unmerged at any of the parent nodes in the chain.",
      "createdAt": "2022-12-14T15:53:26Z",
      "updatedAt": "2022-12-15T15:34:29Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "5c1219b512635c3a82c6dd3bf36261b4b422ba10",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "tree-val",
      "headRefOid": "141e050310256261b818e19e5dfcc1fccd926330",
      "closedAt": "2022-12-15T15:34:29Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing in favor of #837 ",
          "createdAt": "2022-12-15T15:34:10Z",
          "updatedAt": "2022-12-15T15:34:10Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOBoyH6c5IlpWO",
          "commit": {
            "abbreviatedOid": "141e050"
          },
          "author": "TWal",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "The current parent-hash guarantees are as strong as they can be: for every subtree, the version of this subtree at the time of its last modification (i.e. when we \"un-add\" its unmerged leaves) is authenticated by one of its leaves.\r\nThese new conditions do not improve this result.",
          "createdAt": "2022-12-14T16:38:39Z",
          "updatedAt": "2022-12-14T16:53:11Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "This is implied by the property just above it\r\nSee the [discussion about the property](https://github.com/mlswg/mls-protocol/pull/713#issuecomment-1146399188) in #713, in which I show that the parent-hash link between D and P implies that `intersect(P.unmerged_leaves, subtree(D)) = D.unmerged_leaves`, which implies your condition.",
              "createdAt": "2022-12-14T16:38:39Z",
              "updatedAt": "2022-12-14T16:53:11Z"
            },
            {
              "originalPosition": 8,
              "body": "This is almost implied by the resolution equation for the same reason as the new first condition.\r\nAlmost because we can't prove that `D` is not in the unmerged leaves of nodes not authenticated by `D`.",
              "createdAt": "2022-12-14T16:49:51Z",
              "updatedAt": "2022-12-14T16:53:11Z"
            }
          ]
        }
      ]
    },
    {
      "number": 836,
      "id": "PR_kwDOBoyH6c5FeIOZ",
      "title": "Add a section discussing the security of the sender data protection",
      "url": "https://github.com/mlswg/mls-protocol/pull/836",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #770 ",
      "createdAt": "2022-12-14T16:47:18Z",
      "updatedAt": "2022-12-16T17:02:45Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "0794b07a48450d4d0339307d2af804cdc7bb6e87",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "rand-ct",
      "headRefOid": "4513a3f706c1968b5f603fb2ad0b8bcb1b9c0d82",
      "closedAt": "2022-12-16T17:02:45Z",
      "mergedAt": "2022-12-16T17:02:45Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "0e2eaff34c5156cf28aaf9ead47effd59e91b673"
      },
      "comments": [
        {
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I would propose we say that we need AE1 security for our AEAD scheme, which gives us random ciphertexts and if we have random ciphertexts the input to key/nonce generation for sender data encryption is unique. This in turn gives us AE1 security for sender data encryption. I don't think we need AE2 encryption because our nonces are random and don't reveal any private information. Also, if I understand correctly, AES GCM is not AE2 secure, so if we want AE2 security, we need a different scheme or the transform described in NAN.\r\n\r\nProbably needless to say, but I don't have a security proof for any of this. So more eyes on whatever we write here would be appreciated.",
          "createdAt": "2022-12-15T07:18:04Z",
          "updatedAt": "2022-12-15T07:20:02Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOBoyH6c5ImfHX",
          "commit": {
            "abbreviatedOid": "b5c83aa"
          },
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-12-14T18:47:58Z",
          "updatedAt": "2022-12-14T18:47:58Z",
          "comments": [
            {
              "originalPosition": 52,
              "body": "```suggestion\r\nAny future ciphersuite MUST use an AEAD algorithm that is also a PRF, especially with\r\n```",
              "createdAt": "2022-12-14T18:47:58Z",
              "updatedAt": "2022-12-14T18:47:59Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c5IriYL",
          "commit": {
            "abbreviatedOid": "55cdd1c"
          },
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "Generally looks good, thanks for addressing my concerns. Just two nits.",
          "createdAt": "2022-12-15T14:57:04Z",
          "updatedAt": "2022-12-15T15:06:44Z",
          "comments": [
            {
              "originalPosition": 25,
              "body": "```suggestion\r\nis a variation of the HN1 construction analyzed in {{NAN}}.  A sample of the\r\n```",
              "createdAt": "2022-12-15T14:57:04Z",
              "updatedAt": "2022-12-15T15:06:44Z"
            },
            {
              "originalPosition": 36,
              "body": "Plus we don't actually use the ciphertext as nonce, but instead just use it as context in the key/nonce derivation to ensure that the nonce doesn't repeat.",
              "createdAt": "2022-12-15T15:04:45Z",
              "updatedAt": "2022-12-15T15:06:44Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c5Ir2ZC",
          "commit": {
            "abbreviatedOid": "4513a3f"
          },
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-12-15T15:38:53Z",
          "updatedAt": "2022-12-15T15:38:53Z",
          "comments": []
        }
      ]
    },
    {
      "number": 837,
      "id": "PR_kwDOBoyH6c5FjonF",
      "title": "Validate additional properties of unmerged leaves",
      "url": "https://github.com/mlswg/mls-protocol/pull/837",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "In discussion of #834, it came up that the current tree validation rules are loose enough that they allow configurations of `unmerged_leaves` that could not come about by normal operations.  This PR adds a check to enforce that if a node is unmerged at a parent node, it is also unmerged at every node between that parent node and the unmerged leaf.  \r\n\r\nThis is clearly a necessary property of any honestly-created tree, given the way `unmerged_leaves` entries are set and cleared (including the possible changes in #834).  I think it is also sufficient, but I don't have a proof on hand.",
      "createdAt": "2022-12-15T15:28:21Z",
      "updatedAt": "2022-12-16T17:07:50Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "0794b07a48450d4d0339307d2af804cdc7bb6e87",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "more-valid",
      "headRefOid": "30e5c7250a42d8f053517ff8950a1538b5cded9b",
      "closedAt": "2022-12-16T17:07:49Z",
      "mergedAt": "2022-12-16T17:07:49Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "e14e9c74fe18bc96418712f5fc7c1f61448a7140"
      },
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Note that this property is *partly* checked by parent hash validation, [as @TWal notes](https://github.com/mlswg/mls-protocol/pull/835#discussion_r1048719223), but it still allows [some unnatural trees](https://github.com/mlswg/mls-protocol/issues/834#issuecomment-1352921209).  So the main impact of this PR is to have an explicit, complete check in addition to the implicit, partial check in parent hash validation.",
          "createdAt": "2022-12-15T15:32:18Z",
          "updatedAt": "2022-12-15T15:32:18Z"
        },
        {
          "author": "TWal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Independently of #834, I think this is a useful property to have: this is a key invariant that is used in the O(n log log n) algorithm for parent-hash verification described in #527 and implemented in mlspp.\r\n\r\nI don't know how hard it would be to add enough checks to reject every \"unnatural trees\", for example I don't think it's possible to have a blank node whose children are non-blank internal nodes, but a tree having this thing would be accepted when joining a group?",
          "createdAt": "2022-12-16T12:31:08Z",
          "updatedAt": "2022-12-16T12:31:08Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOBoyH6c5Ivfls",
          "commit": {
            "abbreviatedOid": "e658eb9"
          },
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-12-16T07:49:12Z",
          "updatedAt": "2022-12-16T07:49:12Z",
          "comments": []
        }
      ]
    },
    {
      "number": 838,
      "id": "PR_kwDOBoyH6c5FjtjF",
      "title": "Don't blank leaves that aren't known to a removed member",
      "url": "https://github.com/mlswg/mls-protocol/pull/838",
      "state": "CLOSED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #834 ",
      "createdAt": "2022-12-15T15:40:59Z",
      "updatedAt": "2022-12-16T15:45:15Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "0794b07a48450d4d0339307d2af804cdc7bb6e87",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "remove-unmerged",
      "headRefOid": "089aa2b5408982b6633510e1de46c9641472618c",
      "closedAt": "2022-12-16T15:42:40Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "mulmarta",
          "authorAssociation": "CONTRIBUTOR",
          "body": "While it sounds like a nice idea, I'm rather reluctant to make such changes at this stage. There has been a number of analyses of MLS and most of them are unlikely to be updated. I haven't been able to find an attack in a couple of days, but I don't feel certain enough that this is secure.\r\n\r\nWould it be possible to make this an extension instead? Or maybe (also) a part of MLS 2.0?",
          "createdAt": "2022-12-16T11:40:06Z",
          "updatedAt": "2022-12-16T11:40:06Z"
        },
        {
          "author": "TWal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yes, this could be defined cleanly in an extension. It could be a separate proposal, i.e. we could have `Remove` (as we have now) and `FastRemove` (the new version I proposed) that live together.\r\n\r\nAbout attacks on such a change, I really think it only boils down to whether it breaks the parent-hash invariant (the one checked when joining a group) or not.\r\nHere is an intuition:\r\nif the current MLS is secure, and FastRemove don't break the parent-hash invariants but introduce a security flaw (e.g. break the TreeKEM secrecy invariant), then there would be an attack on the current MLS: the attacker could apply FastRemove on a tree (no need for this to be an actual proposal) and invite someone in a group with this tree.\r\nThe new tree would be accepted by the joining while not satisfying the TreeKEM secrecy invariant, hence an attack on the current MLS.",
          "createdAt": "2022-12-16T12:12:58Z",
          "updatedAt": "2022-12-16T12:12:58Z"
        },
        {
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "body": "I would also like to put the optimisation into perspective again: This only makes removes faster in the narrow time window after a new member joined and before said member did its initial update. Furthermore, this only applies to the removal of new members. With that in mind, the optimisation should be more accurately renamed as \"More efficient removal of new joiners\".\r\nNew members are strongly encouraged to do an update as quickly as possible (even when the general update policy is more relaxed), therefore I expect this time window to be relatively short in an overwhelming majority of MLS deployments.\r\n\r\nThe risk @mulmarta describes is real, and I don't think it is justified by the marginal performance gain.",
          "createdAt": "2022-12-16T12:16:17Z",
          "updatedAt": "2022-12-16T12:16:17Z"
        },
        {
          "author": "seanturner",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Discussed at 12/16/2022 interim. Decided to close, but it can be revived later as an extension.",
          "createdAt": "2022-12-16T15:45:14Z",
          "updatedAt": "2022-12-16T15:45:14Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 839,
      "id": "PR_kwDOBoyH6c5FkGQf",
      "title": "Remove \"MLS\" prefix on structs",
      "url": "https://github.com/mlswg/mls-protocol/pull/839",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #759 \r\n\r\nAs discussed in #759, this PR makes the following terminology changes:\r\n\r\n| Before                      | After                     |\r\n|:----------------------------|:--------------------------|\r\n| MLSMessage                  | MLSMessage                |\r\n| MLSContent                  | GroupContent              |\r\n| MLSContentTBS               | GroupContentTBS           |\r\n| MLSContentAuthData          | GroupContentAuthData      |\r\n| MLSAuthenticatedContent     | AuthenticatedContent      |\r\n| MLSContentTBM               | AuthenticatedContentTBM   |\r\n| MLSSenderData               | SenderData                |\r\n| MLSSenderDataAAD            | SenderDataAAD             |\r\n| MLSCiphertextContent        | AuthenticatedContentTBE   |\r\n| MLSCiphertextContentAAD     | ContentAAD                |\r\n| MLSPlaintext                | PublicMessage             |\r\n| MLSCiphertext               | PrivateMessage            |\r\n\r\nIt might be useful to review the two commits here separately.  The first is just a global search-and-replace.  The second is a light review for grammar (\"a\" vs. \"an\"), and makes a few small copy edits.",
      "createdAt": "2022-12-15T16:51:05Z",
      "updatedAt": "2023-02-14T11:17:59Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "e14e9c74fe18bc96418712f5fc7c1f61448a7140",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "no-mls",
      "headRefOid": "4e6b759e89d7583d06e723189c9a38f14fd10603",
      "closedAt": "2022-12-16T17:20:59Z",
      "mergedAt": "2022-12-16T17:20:59Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "9099b72fb387e4cec03d071444001cb3499066f3"
      },
      "comments": [
        {
          "author": "rohan-wire",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I have a slight preference for SignedMessage and EncryptedMessage instead of PublicMessage and PrivateMessage",
          "createdAt": "2022-12-16T15:23:01Z",
          "updatedAt": "2022-12-16T15:23:01Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "As discussed in the interim 2022-12-16:\r\n* Keeping Public/Private\r\n* GroupContent -> FramedContent\r\n* ContentAAD -> PrivateContentAAD\r\n* I also added: AuthenticatedContentTBE -> PrivateContentTBE (to be parallel with PrivateContentAAD)",
          "createdAt": "2022-12-16T17:20:13Z",
          "updatedAt": "2022-12-16T17:20:13Z"
        },
        {
          "author": "TWal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "For anyone wondering, here are the final changes made by this PR.\r\n\r\n| Before                   | After                      |\r\n| ------------------------ | -------------------------- |\r\n| MLSMessage               | MLSMessage                 |\r\n| MLSContent               | FramedContent              |\r\n| MLSContentTBS            | FramedContentTBS           |\r\n| MLSContentAuthData       | FramedContentAuthData      |\r\n| MLSAuthenticatedContent  | AuthenticatedContent       |\r\n| MLSContentTBM            | AuthenticatedContentTBM    |\r\n| MLSSenderData            | SenderData                 |\r\n| MLSSenderDataAAD         | SenderDataAAD              |\r\n| MLSCiphertextContent     | PrivateContentTBE          |\r\n| MLSCiphertextContentAAD  | PrivateContentAAD          |\r\n| MLSPlaintext             | PublicMessage              |\r\n| MLSCiphertext            | PrivateMessage             |\r\n\r\nWhich makes me wonder: since `SenderData` is only meant to be encrypted, shouldn't it be `SenderDataTBE`?",
          "createdAt": "2023-02-14T11:17:59Z",
          "updatedAt": "2023-02-14T11:17:59Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOBoyH6c5ItW62",
          "commit": {
            "abbreviatedOid": "44c019a"
          },
          "author": "duesee",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "Thanks for tackling this, @bifurcation! I hope to help a bit with a review.\r\n\r\nI grepped for the old names ...\r\n\r\n```sh\r\nfor name_before in MLSContent MLSContentTBS MLSContentAuthData MLSAuthenticatedContent MLSContentTBM MLSSenderData MLSSenderDataAAD MLSCiphertextContent MLSCiphertextContentAAD MLSPlaintext MLSCiphertext; do echo Checking $name_before; rg -i $name_before; done\r\nChecking MLSContent\r\nChecking MLSContentTBS\r\nChecking MLSContentAuthData\r\nChecking MLSAuthenticatedContent\r\nChecking MLSContentTBM\r\nChecking MLSSenderData\r\nChecking MLSSenderDataAAD\r\nChecking MLSCiphertextContent\r\nChecking MLSCiphertextContentAAD\r\nChecking MLSPlaintext\r\ndraft-ietf-mls-protocol.md\r\n355:- Handle non-member sender cases in MLSPlaintextTBS\r\n395:- Move MLSPlaintext signature under the confirmation tag (\\*)\r\n397:- Explicitly authenticate group membership with MLSPLaintext (\\*)\r\n458:- Allow multiple Proposals and a single Commit in one MLSPlaintext (\\*)\r\n481:- Cover the entire MLSPlaintext in the transcript hash (\\*)\r\nChecking MLSCiphertext\r\n```\r\n\r\n... and verified that the remaining instances of `MLSPlaintext` are all in the `##  Change Log` section. Furthermore, I checked that no accidental renames were made to this section.\r\n\r\nI couldn't find any (grammatical or visual) mistakes in the second commit. Also, doing some spot-checks for the first commit, I couldn't find anything wrong either.\r\n\r\nSo, it all looks excellent to me :+1:",
          "createdAt": "2022-12-15T19:46:42Z",
          "updatedAt": "2022-12-15T19:50:13Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOBoyH6c5Iveek",
          "commit": {
            "abbreviatedOid": "44c019a"
          },
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-12-16T07:44:01Z",
          "updatedAt": "2022-12-16T07:44:01Z",
          "comments": [
            {
              "originalPosition": 101,
              "body": "I suggested \"MessageContent\", \"MessageContentTBS\", etc. as opposed to using the \"Group-\" prefix. It got some \ud83d\udc4d\ud83c\udffb, but no other reaction. Do you still prefer the \"Group-\" prefix?",
              "createdAt": "2022-12-16T07:44:01Z",
              "updatedAt": "2022-12-16T07:44:01Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c5Iv_Aa",
          "commit": {
            "abbreviatedOid": "44c019a"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-12-16T09:34:56Z",
          "updatedAt": "2022-12-16T09:34:56Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOBoyH6c5IwB4D",
          "commit": {
            "abbreviatedOid": "44c019a"
          },
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "state": "CHANGES_REQUESTED",
          "body": "I agree with Konrad that `GroupContent` is very weird. Here is a proposal `FrameContent`.\r\nAlso `ContentAAD` should be changed to `PrivateMessageAAD`",
          "createdAt": "2022-12-16T09:44:15Z",
          "updatedAt": "2022-12-16T09:54:50Z",
          "comments": [
            {
              "originalPosition": 101,
              "body": "```suggestion\r\n    select (FrameContent.content_type) {\r\n```",
              "createdAt": "2022-12-16T09:44:15Z",
              "updatedAt": "2022-12-16T09:52:38Z"
            },
            {
              "originalPosition": 110,
              "body": "```suggestion\r\n} FrameContent;\r\n```",
              "createdAt": "2022-12-16T09:45:09Z",
              "updatedAt": "2022-12-16T09:52:38Z"
            },
            {
              "originalPosition": 142,
              "body": "```suggestion\r\n    FrameContent content;\r\n    FrameContentAuthData auth;\r\n```",
              "createdAt": "2022-12-16T09:46:21Z",
              "updatedAt": "2022-12-16T09:52:38Z"
            },
            {
              "originalPosition": 152,
              "body": "```suggestion\r\n                                         FrameContent\r\n```",
              "createdAt": "2022-12-16T09:46:50Z",
              "updatedAt": "2022-12-16T09:52:38Z"
            },
            {
              "originalPosition": 159,
              "body": "```suggestion\r\n                           FrameContentAuthData |                  |   Sign / Verify\r\n```",
              "createdAt": "2022-12-16T09:47:02Z",
              "updatedAt": "2022-12-16T09:52:38Z"
            },
            {
              "originalPosition": 182,
              "body": "```suggestion\r\nFrameContent is authenticated using the FrameContentAuthData structure.\r\n```",
              "createdAt": "2022-12-16T09:47:18Z",
              "updatedAt": "2022-12-16T09:52:38Z"
            },
            {
              "originalPosition": 191,
              "body": "```suggestion\r\n    FrameContent content;\r\n    select (FrameContentTBS.content.sender.sender_type) {\r\n```",
              "createdAt": "2022-12-16T09:47:48Z",
              "updatedAt": "2022-12-16T09:52:38Z"
            },
            {
              "originalPosition": 200,
              "body": "```suggestion\r\n} FrameContentTBS;\r\n```",
              "createdAt": "2022-12-16T09:47:57Z",
              "updatedAt": "2022-12-16T09:52:38Z"
            },
            {
              "originalPosition": 206,
              "body": "```suggestion\r\n    /* SignWithLabel(., \"FrameContentTBS\", FrameContentTBS) */\r\n```",
              "createdAt": "2022-12-16T09:48:13Z",
              "updatedAt": "2022-12-16T09:52:38Z"
            },
            {
              "originalPosition": 209,
              "body": "```suggestion\r\n    select (FrameContent.content_type) {\r\n```",
              "createdAt": "2022-12-16T09:48:23Z",
              "updatedAt": "2022-12-16T09:52:39Z"
            },
            {
              "originalPosition": 218,
              "body": "```suggestion\r\n} FrameContentAuthData;\r\n```",
              "createdAt": "2022-12-16T09:48:33Z",
              "updatedAt": "2022-12-16T09:52:39Z"
            },
            {
              "originalPosition": 223,
              "body": "```suggestion\r\n`\"FrameContentTBS\"` and with a content that covers the message content and\r\n```",
              "createdAt": "2022-12-16T09:48:42Z",
              "updatedAt": "2022-12-16T09:52:39Z"
            },
            {
              "originalPosition": 232,
              "body": "```suggestion\r\nat the same state of the group. A FrameContentAuthData is said to be valid when both\r\n```",
              "createdAt": "2022-12-16T09:48:53Z",
              "updatedAt": "2022-12-16T09:52:39Z"
            },
            {
              "originalPosition": 247,
              "body": "```suggestion\r\n    FrameContent content;\r\n    FrameContentAuthData auth;\r\n```",
              "createdAt": "2022-12-16T09:49:07Z",
              "updatedAt": "2022-12-16T09:52:39Z"
            },
            {
              "originalPosition": 271,
              "body": "```suggestion\r\n  FrameContentTBS content_tbs;\r\n  FrameContentAuthData auth;\r\n```",
              "createdAt": "2022-12-16T09:49:22Z",
              "updatedAt": "2022-12-16T09:52:39Z"
            },
            {
              "originalPosition": 284,
              "body": "```suggestion\r\nFrameContentAuthData is valid.\r\n```",
              "createdAt": "2022-12-16T09:49:31Z",
              "updatedAt": "2022-12-16T09:52:39Z"
            },
            {
              "originalPosition": 325,
              "body": "```suggestion\r\n    FrameContentAuthData auth;\r\n```",
              "createdAt": "2022-12-16T09:49:45Z",
              "updatedAt": "2022-12-16T09:52:39Z"
            },
            {
              "originalPosition": 355,
              "body": "```suggestion\r\nFrameContentAuthData is valid.\r\n```",
              "createdAt": "2022-12-16T09:49:54Z",
              "updatedAt": "2022-12-16T09:52:39Z"
            },
            {
              "originalPosition": 433,
              "body": "```suggestion\r\n    FrameContent content; /* with content_type == commit */\r\n```",
              "createdAt": "2022-12-16T09:50:08Z",
              "updatedAt": "2022-12-16T09:52:39Z"
            },
            {
              "originalPosition": 442,
              "body": "```suggestion\r\nProposals are included in a FrameContent by way of a Proposal structure\r\n```",
              "createdAt": "2022-12-16T09:50:15Z",
              "updatedAt": "2022-12-16T09:52:39Z"
            },
            {
              "originalPosition": 453,
              "body": "```suggestion\r\nOn receiving a FrameContent containing a Proposal, a client MUST verify the\r\n```",
              "createdAt": "2022-12-16T09:50:24Z",
              "updatedAt": "2022-12-16T09:52:39Z"
            },
            {
              "originalPosition": 455,
              "body": "```suggestion\r\nsignature inside FrameContentAuthData and that the `epoch` field of the enclosing\r\nFrameContent is equal to the `epoch` field of the current GroupContext object.\r\n```",
              "createdAt": "2022-12-16T09:50:43Z",
              "updatedAt": "2022-12-16T09:52:39Z"
            },
            {
              "originalPosition": 488,
              "body": "```suggestion\r\n* Construct a FrameContent object containing the Commit object. Sign the\r\n  FrameContent using the old GroupContext as context.\r\n  * Use the FrameContent to update the confirmed transcript hash and update\r\n```",
              "createdAt": "2022-12-16T09:51:01Z",
              "updatedAt": "2022-12-16T09:52:39Z"
            },
            {
              "originalPosition": 497,
              "body": "```suggestion\r\n    hash and the `confirmation_tag` from the FrameContentAuthData.\r\n```",
              "createdAt": "2022-12-16T09:51:12Z",
              "updatedAt": "2022-12-16T09:52:39Z"
            },
            {
              "originalPosition": 513,
              "body": "```suggestion\r\n  * The confirmation_tag from the FrameContentAuthData object\r\n```",
              "createdAt": "2022-12-16T09:51:20Z",
              "updatedAt": "2022-12-16T09:52:39Z"
            },
            {
              "originalPosition": 522,
              "body": "```suggestion\r\n* Verify that the `epoch` field of the enclosing FrameContent is equal\r\n```",
              "createdAt": "2022-12-16T09:51:30Z",
              "updatedAt": "2022-12-16T09:52:39Z"
            },
            {
              "originalPosition": 535,
              "body": "```suggestion\r\n* Verify that the signature on the FrameContent message as described in\r\n```",
              "createdAt": "2022-12-16T09:51:40Z",
              "updatedAt": "2022-12-16T09:52:39Z"
            },
            {
              "originalPosition": 544,
              "body": "```suggestion\r\n  `confirmation_tag` field in the FrameContentAuthData object.\r\n```",
              "createdAt": "2022-12-16T09:51:48Z",
              "updatedAt": "2022-12-16T09:52:39Z"
            },
            {
              "originalPosition": 567,
              "body": "```suggestion\r\nindicated by the `epoch` field of the enclosing FrameContent.\r\n```",
              "createdAt": "2022-12-16T09:51:58Z",
              "updatedAt": "2022-12-16T09:52:39Z"
            }
          ]
        }
      ]
    },
    {
      "number": 841,
      "id": "PR_kwDOBoyH6c5FpYay",
      "title": "Create IANA registries for signature and export labels",
      "url": "https://github.com/mlswg/mls-protocol/pull/841",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #840 \r\n\r\nAlso copies the \"Recommended\" field by reference, instead of reciting it in each registry.\r\n\r\nNote that this has a conflict with #839 that `git` will not catch -- \"MLSContentTBS\" will have to be changed to whatever new name is agreed in that PR.",
      "createdAt": "2022-12-16T14:24:43Z",
      "updatedAt": "2022-12-16T17:04:26Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "0794b07a48450d4d0339307d2af804cdc7bb6e87",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "iana-labels",
      "headRefOid": "4a485e4a8616f00bceb305b1178c16d76f87f9d6",
      "closedAt": "2022-12-16T17:04:26Z",
      "mergedAt": "2022-12-16T17:04:26Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "b52457283d7b0d2376151b527221bdec29949add"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOBoyH6c5Ix0At",
          "commit": {
            "abbreviatedOid": "14514e4"
          },
          "author": "mulmarta",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-12-16T15:18:52Z",
          "updatedAt": "2022-12-16T15:18:53Z",
          "comments": [
            {
              "originalPosition": 30,
              "body": "```suggestion\r\n* MLS Exporter Labels ({{mls-exporter-labels}})\r\n```",
              "createdAt": "2022-12-16T15:18:53Z",
              "updatedAt": "2022-12-16T15:18:53Z"
            }
          ]
        }
      ]
    },
    {
      "number": 842,
      "id": "PR_kwDOBoyH6c5FqV_O",
      "title": "Add label and context to public-key encryption",
      "url": "https://github.com/mlswg/mls-protocol/pull/842",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "As discussed in the virtual interim 2022-12-16, it is possible that extensions might be tempted to re-use HPKE public keys created for MLS.  Even within MLS, we have two different public-key encryption cases, Welcome and Commit (though these currently use different keys).\r\n\r\nCurrently, for Commit encryption, the HPKE `info` parameter is set to the group context.  The content of `info` is actually undefined for Welcome encryption (!)  This PR makes the following changes:\r\n\r\n* Define general `EncryptWithLabel` and `DecryptWithLabel` functions that populte the HPKE `info` parameter with an encoded label and context\r\n* Apply these to Commit and Welcome encryption:\r\n    * Commit: label=\"UpdatePathNode\", context=`group_context`\r\n    * Welcome: label=\"Welcome\", context=`encrypted_group_info`\r\n* Add an IANA registry of public-key encryption labels (as for signing)\r\n\r\nThere is also a bit of reorganization of the Ciphersuites section to split it into three subsections.",
      "createdAt": "2022-12-16T17:28:58Z",
      "updatedAt": "2022-12-19T14:59:47Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "9099b72fb387e4cec03d071444001cb3499066f3",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "encrypt-with-label",
      "headRefOid": "c1b6d47c6fd6935c510f8a95ef6d6ee0e261b7db",
      "closedAt": "2022-12-19T14:59:47Z",
      "mergedAt": "2022-12-19T14:59:47Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "4727a801d71a12fbd17d33d91e83e501dc1b282e"
      },
      "comments": [
        {
          "author": "mulmarta",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> FWIW, I'm wondering if we didn't have a domain separation issue in the past when we only had one HPKE public key in KeyPackages and used it for both the Welcome subsequently for UpdatePath as well. Either way, I think this is a good defense-in-depth mechanism.\r\n\r\nNote that any previous analysis of MLS had to take this particular reuse into account. This can't be the case for any arbitrary extensions reusing the key. So if MLS uses an extension that reuses the key, none of the existing analysis applies, which is a much bigger issue.\r\n\r\nThis said, this reuse did decrease security -- it weakened FS in that a joiner had to hold on to their HPKE leaf key, which also allowed to decrypt the init secret from the welcome message, long after joining. ",
          "createdAt": "2022-12-19T12:48:59Z",
          "updatedAt": "2022-12-19T12:48:59Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOBoyH6c5I01jL",
          "commit": {
            "abbreviatedOid": "3151f50"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "I think this captures what we discussed during the interim.\r\n\r\nFWIW, I'm wondering if we didn't have a domain separation issue in the past when we only had one HPKE public key in KeyPackages and used it for both the Welcome subsequently for UpdatePath as well. Either way, I think this is a good defense-in-depth mechanism.",
          "createdAt": "2022-12-17T14:47:42Z",
          "updatedAt": "2022-12-17T14:55:21Z",
          "comments": [
            {
              "originalPosition": 81,
              "body": "```suggestion\r\ncontext = Context;\r\n```",
              "createdAt": "2022-12-17T14:47:42Z",
              "updatedAt": "2022-12-17T14:55:21Z"
            },
            {
              "originalPosition": 85,
              "body": "```suggestion\r\nHPKE algorithms specified by the group's ciphersuite.  If MLS extensions\r\n```",
              "createdAt": "2022-12-17T14:48:22Z",
              "updatedAt": "2022-12-17T14:55:21Z"
            },
            {
              "originalPosition": 124,
              "body": "```suggestion\r\nHere `node_public_key` is the public key of the node for which the path secret is\r\nencrypted, `group_context` is the provisional GroupContext object for\r\n```",
              "createdAt": "2022-12-17T14:50:15Z",
              "updatedAt": "2022-12-17T14:55:21Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c5I4rzr",
          "commit": {
            "abbreviatedOid": "3151f50"
          },
          "author": "mulmarta",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-12-19T12:42:26Z",
          "updatedAt": "2022-12-19T12:42:26Z",
          "comments": [
            {
              "originalPosition": 87,
              "body": "Would be possible to recommend or even RECOMMEND that extensions use separate HPKE keys (which can be included in leaves as extensions)?",
              "createdAt": "2022-12-19T12:42:26Z",
              "updatedAt": "2022-12-19T12:42:26Z"
            }
          ]
        }
      ]
    },
    {
      "number": 843,
      "id": "PR_kwDOBoyH6c5FqXtf",
      "title": "Disambiguate section references",
      "url": "https://github.com/mlswg/mls-protocol/pull/843",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2022-12-16T17:34:55Z",
      "updatedAt": "2022-12-16T18:17:18Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "9099b72fb387e4cec03d071444001cb3499066f3",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "disambiguate",
      "headRefOid": "223c215f1068286a3a8f1f25fa16952882ba2eed",
      "closedAt": "2022-12-16T18:17:18Z",
      "mergedAt": "2022-12-16T18:17:18Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "0d0a41ac674999ccae8f3a81217877b1e9564a13"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 844,
      "id": "PR_kwDOBoyH6c5F3sD3",
      "title": "cleanup after plaintext and ciphertext renaming.",
      "url": "https://github.com/mlswg/mls-protocol/pull/844",
      "state": "MERGED",
      "author": "kkohbrok",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Just stumbled over these remaining occurrences of plaintext/ciphertext. Was this intentional?",
      "createdAt": "2022-12-20T14:01:44Z",
      "updatedAt": "2023-02-09T18:58:02Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "4727a801d71a12fbd17d33d91e83e501dc1b282e",
      "headRepository": "kkohbrok/mls-protocol",
      "headRefName": "patch-3",
      "headRefOid": "71d61eadde6812d435f46763bb86ad937bce49f3",
      "closedAt": "2023-02-09T18:58:02Z",
      "mergedAt": "2023-02-09T18:58:02Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "9db329ecf22db17a64d9cc3d11de3904c84a168e"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOBoyH6c5JjWgZ",
          "commit": {
            "abbreviatedOid": "71d61ea"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Thanks!",
          "createdAt": "2023-01-02T23:04:25Z",
          "updatedAt": "2023-01-02T23:04:25Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOBoyH6c5M_5SK",
          "commit": {
            "abbreviatedOid": "71d61ea"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-02-09T18:57:54Z",
          "updatedAt": "2023-02-09T18:57:54Z",
          "comments": []
        }
      ]
    },
    {
      "number": 845,
      "id": "PR_kwDOBoyH6c5Ggu1W",
      "title": "Move pseudocode out of KDFLabel definition.",
      "url": "https://github.com/mlswg/mls-protocol/pull/845",
      "state": "MERGED",
      "author": "Bren2010",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2023-01-03T00:52:59Z",
      "updatedAt": "2023-02-09T18:58:18Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "4727a801d71a12fbd17d33d91e83e501dc1b282e",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "brendan/kdf-label",
      "headRefOid": "3ee63680ee020c30a49c7d4b129ea903de513a95",
      "closedAt": "2023-02-09T18:58:17Z",
      "mergedAt": "2023-02-09T18:58:17Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "a864732160b4243b292a63a3bc7bb08153c8afe3"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOBoyH6c5MvN3U",
          "commit": {
            "abbreviatedOid": "3ee6368"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-02-07T16:19:33Z",
          "updatedAt": "2023-02-07T16:19:33Z",
          "comments": []
        }
      ]
    },
    {
      "number": 847,
      "id": "PR_kwDOBoyH6c5I4jiW",
      "title": "A different check for the length code",
      "url": "https://github.com/mlswg/mls-protocol/pull/847",
      "state": "MERGED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Yes, this is not minimal (@sureshkrishnan suggested something closer to that), but I think that this is easier again to understand.\r\n\r\nA smaller version checks against `1 << (4*len - 2)`, but that doesn't make much sense.",
      "createdAt": "2023-01-31T06:25:56Z",
      "updatedAt": "2023-02-09T19:01:46Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "4727a801d71a12fbd17d33d91e83e501dc1b282e",
      "headRepository": "martinthomson/mls-protocol",
      "headRefName": "patch-1",
      "headRefOid": "0af7acf0f98cccc063e537cc7c2e1b09d181d2ee",
      "closedAt": "2023-02-09T19:01:45Z",
      "mergedAt": "2023-02-09T19:01:45Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "6de04329191c195df88f44f9609d5801cc524fd4"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOBoyH6c5MJXAM",
          "commit": {
            "abbreviatedOid": "0af7acf"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-01-31T15:56:39Z",
          "updatedAt": "2023-01-31T15:56:39Z",
          "comments": []
        }
      ]
    },
    {
      "number": 848,
      "id": "PR_kwDOBoyH6c5I61Fp",
      "title": "IESG Review by Lars Eggert",
      "url": "https://github.com/mlswg/mls-protocol/pull/848",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "https://datatracker.ietf.org/doc/draft-ietf-mls-protocol/ballot/#draft-ietf-mls-protocol_lars-eggert",
      "createdAt": "2023-01-31T14:23:46Z",
      "updatedAt": "2023-02-09T19:02:00Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "4727a801d71a12fbd17d33d91e83e501dc1b282e",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "iesg-lars",
      "headRefOid": "39c191ee1181bdf1a380209777b434ad0559da30",
      "closedAt": "2023-02-09T19:01:59Z",
      "mergedAt": "2023-02-09T19:01:59Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "909e4034534d5b7b3d2d5ae6d4bcc1807afa625a"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOBoyH6c5MQkqD",
          "commit": {
            "abbreviatedOid": "39c191e"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-02-01T16:02:03Z",
          "updatedAt": "2023-02-01T16:02:03Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOBoyH6c5MUYmr",
          "commit": {
            "abbreviatedOid": "39c191e"
          },
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-02-02T06:30:46Z",
          "updatedAt": "2023-02-02T06:30:46Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOBoyH6c5MX9S-",
          "commit": {
            "abbreviatedOid": "39c191e"
          },
          "author": "rohan-wire",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-02-02T15:55:01Z",
          "updatedAt": "2023-02-02T15:55:01Z",
          "comments": []
        }
      ]
    },
    {
      "number": 849,
      "id": "PR_kwDOBoyH6c5I6_ld",
      "title": "IESG Review by Erik Kline",
      "url": "https://github.com/mlswg/mls-protocol/pull/849",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "https://datatracker.ietf.org/doc/draft-ietf-mls-protocol/ballot/#draft-ietf-mls-protocol_erik-kline",
      "createdAt": "2023-01-31T14:50:41Z",
      "updatedAt": "2023-02-09T19:02:12Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "4727a801d71a12fbd17d33d91e83e501dc1b282e",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "iesg-kline",
      "headRefOid": "9630c6bfd11b01bcaddc96ea7a00d95e0819c4ac",
      "closedAt": "2023-02-09T19:02:12Z",
      "mergedAt": "2023-02-09T19:02:12Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "e724d73aa4ea7988bd8f0903bb0edc2a29ef2a4f"
      },
      "comments": [
        {
          "author": "ekline",
          "authorAssociation": "NONE",
          "body": ":+1: ",
          "createdAt": "2023-01-31T19:21:29Z",
          "updatedAt": "2023-01-31T19:21:29Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOBoyH6c5MQlil",
          "commit": {
            "abbreviatedOid": "01d812a"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-02-01T16:04:00Z",
          "updatedAt": "2023-02-01T16:04:01Z",
          "comments": [
            {
              "originalPosition": 44,
              "body": "```suggestion\r\n    of the `lifetime` field.  (This check is not compulsory because the LeafNode\r\n```",
              "createdAt": "2023-02-01T16:04:00Z",
              "updatedAt": "2023-02-01T16:04:01Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c5MUYAT",
          "commit": {
            "abbreviatedOid": "01d812a"
          },
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-02-02T06:28:40Z",
          "updatedAt": "2023-02-02T06:28:40Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOBoyH6c5MYAHM",
          "commit": {
            "abbreviatedOid": "01d812a"
          },
          "author": "rohan-wire",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-02-02T16:00:56Z",
          "updatedAt": "2023-02-02T16:00:57Z",
          "comments": [
            {
              "originalPosition": 44,
              "body": "\"compulsory\" is poorly understood. Please leave as \"required\"",
              "createdAt": "2023-02-02T16:00:57Z",
              "updatedAt": "2023-02-02T16:00:57Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c5MYAT_",
          "commit": {
            "abbreviatedOid": "01d812a"
          },
          "author": "rohan-wire",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-02-02T16:01:22Z",
          "updatedAt": "2023-02-02T16:01:22Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOBoyH6c5MvLFk",
          "commit": {
            "abbreviatedOid": "01d812a"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-02-07T16:13:46Z",
          "updatedAt": "2023-02-07T16:13:47Z",
          "comments": [
            {
              "originalPosition": 44,
              "body": "I can see the confusion here if you read \"not required\" as \"not needed\" as opposed to \"not an absolute requirement\".  Suggest \"not mandatory\", since this is well understood to have the same semantic as \"required\" (see, e.g., \"mandatory to implement\").\r\n\r\n```suggestion\r\n    of the `lifetime` field.  (This check is not mandatory because the LeafNode\r\n```",
              "createdAt": "2023-02-07T16:13:46Z",
              "updatedAt": "2023-02-07T16:13:47Z"
            }
          ]
        }
      ]
    },
    {
      "number": 850,
      "id": "PR_kwDOBoyH6c5I7Lr0",
      "title": "IESG Review from Roman Danyliw",
      "url": "https://github.com/mlswg/mls-protocol/pull/850",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "https://datatracker.ietf.org/doc/draft-ietf-mls-protocol/ballot/#draft-ietf-mls-protocol_roman-danyliw",
      "createdAt": "2023-01-31T15:16:56Z",
      "updatedAt": "2023-02-09T19:02:27Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "4727a801d71a12fbd17d33d91e83e501dc1b282e",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "iesg-roman",
      "headRefOid": "d83bad350d486bf953ee94f30ef9c55e91d3c09f",
      "closedAt": "2023-02-09T19:02:26Z",
      "mergedAt": "2023-02-09T19:02:26Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "dfe0f2269c80102ff116d7c6fe4b0bd5ae40dc79"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOBoyH6c5MQmUR",
          "commit": {
            "abbreviatedOid": "aeefa83"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-02-01T16:05:43Z",
          "updatedAt": "2023-02-01T16:05:43Z",
          "comments": [
            {
              "originalPosition": 18,
              "body": "```suggestion\r\nthat it is confidential to the members of the group in a particular epoch.\r\n```",
              "createdAt": "2023-02-01T16:05:43Z",
              "updatedAt": "2023-02-01T16:05:43Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c5MUYdE",
          "commit": {
            "abbreviatedOid": "aeefa83"
          },
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-02-02T06:29:58Z",
          "updatedAt": "2023-02-02T06:29:58Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOBoyH6c5MX_Dx",
          "commit": {
            "abbreviatedOid": "aeefa83"
          },
          "author": "rohan-wire",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-02-02T15:58:41Z",
          "updatedAt": "2023-02-02T15:58:41Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOBoyH6c5Mplz_",
          "commit": {
            "abbreviatedOid": "aeefa83"
          },
          "author": "br-hale",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-02-06T20:36:21Z",
          "updatedAt": "2023-02-06T20:36:22Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "Suggested edit\r\n\"by its sender, authenticated as coming from a member of the group in a particular epoch, and is confidential...\". I.e. the definition of PrivateMessage mentions confidentiality but leaves off the authenticity mentioned under PublicMessage (albeit implemented as authenticated encryption).",
              "createdAt": "2023-02-06T20:36:21Z",
              "updatedAt": "2023-02-06T20:36:22Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c5MvMjf",
          "commit": {
            "abbreviatedOid": "aeefa83"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-02-07T16:16:41Z",
          "updatedAt": "2023-02-07T16:16:41Z",
          "comments": [
            {
              "originalPosition": 18,
              "body": "Combining suggestions from @br-hale and @raphaelrobert ...\r\n\r\n```suggestion\r\n: An MLS protocol message that is both signed by its sender, authenticated as\r\ncoming from a member of the group in a particular epoch, and encrypted so\r\nthat it is confidential to the members of the group in that epoch.\r\n```",
              "createdAt": "2023-02-07T16:16:41Z",
              "updatedAt": "2023-02-07T16:16:42Z"
            }
          ]
        }
      ]
    },
    {
      "number": 851,
      "id": "PR_kwDOBoyH6c5I99x8",
      "title": "Update Thyla's Email Address",
      "url": "https://github.com/mlswg/mls-protocol/pull/851",
      "state": "MERGED",
      "author": "seanturner",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "",
      "createdAt": "2023-02-01T03:07:34Z",
      "updatedAt": "2023-02-07T16:18:12Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "4727a801d71a12fbd17d33d91e83e501dc1b282e",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "seanturner-tjvdmerwe",
      "headRefOid": "56f0b11aea09c6c934051aa542dcaea59ab81b95",
      "closedAt": "2023-02-07T16:18:12Z",
      "mergedAt": "2023-02-07T16:18:12Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "db75f407e0e3007d491e9fa0443789178ccca0c2"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOBoyH6c5MQKX5",
          "commit": {
            "abbreviatedOid": "56f0b11"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-02-01T15:08:15Z",
          "updatedAt": "2023-02-01T15:08:15Z",
          "comments": []
        }
      ]
    },
    {
      "number": 852,
      "id": "PR_kwDOBoyH6c5JBRmc",
      "title": "IESG Review by Zaheduzzaman Sarker",
      "url": "https://github.com/mlswg/mls-protocol/pull/852",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "https://datatracker.ietf.org/doc/draft-ietf-mls-protocol/ballot/#draft-ietf-mls-protocol_zaheduzzaman-sarker",
      "createdAt": "2023-02-01T15:33:52Z",
      "updatedAt": "2023-02-09T19:02:41Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "4727a801d71a12fbd17d33d91e83e501dc1b282e",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "iesg-zahed",
      "headRefOid": "8751fd7b84ab3e71b834d64654255c7e090cce36",
      "closedAt": "2023-02-09T19:02:41Z",
      "mergedAt": "2023-02-09T19:02:40Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "017da81a614f183ae99715043a05ea114b4b67ac"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOBoyH6c5MQnN_",
          "commit": {
            "abbreviatedOid": "5770637"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-02-01T16:07:46Z",
          "updatedAt": "2023-02-01T16:07:47Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "```suggestion\r\nnot following the above recommendation (e.g., sending MLS directly over UDP instead).\r\n```",
              "createdAt": "2023-02-01T16:07:47Z",
              "updatedAt": "2023-02-01T16:07:47Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c5MX-FN",
          "commit": {
            "abbreviatedOid": "5770637"
          },
          "author": "rohan-wire",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-02-02T15:56:42Z",
          "updatedAt": "2023-02-02T15:56:42Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOBoyH6c5Mb23Z",
          "commit": {
            "abbreviatedOid": "5770637"
          },
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-02-03T06:59:22Z",
          "updatedAt": "2023-02-03T06:59:22Z",
          "comments": []
        }
      ]
    },
    {
      "number": 853,
      "id": "PR_kwDOBoyH6c5JIKYq",
      "title": "IESG Review from \u00c9ric Vyncke",
      "url": "https://github.com/mlswg/mls-protocol/pull/853",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "https://datatracker.ietf.org/iesg/agenda/#draft-ietf-mls-protocol_eric-vyncke",
      "createdAt": "2023-02-02T16:42:50Z",
      "updatedAt": "2023-02-09T19:11:39Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "017da81a614f183ae99715043a05ea114b4b67ac",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "iesg-vyncke",
      "headRefOid": "58304ac375c2ff9bdaa4246e8ca0cf1c1fc06c92",
      "closedAt": "2023-02-09T19:11:38Z",
      "mergedAt": "2023-02-09T19:11:38Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "0cc54ea2f98e3a20987d56dcb79e3a415228417c"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOBoyH6c5MYbLz",
          "commit": {
            "abbreviatedOid": "5eda804"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-02-02T16:55:26Z",
          "updatedAt": "2023-02-02T16:55:26Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOBoyH6c5Mb3bM",
          "commit": {
            "abbreviatedOid": "5eda804"
          },
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2023-02-03T07:02:08Z",
          "updatedAt": "2023-02-03T07:02:33Z",
          "comments": [
            {
              "originalPosition": 239,
              "body": "```suggestion\r\n{: title=\"Initialization of the hash ratchets from the leaves of a secret tree\" }\r\n```",
              "createdAt": "2023-02-03T07:02:08Z",
              "updatedAt": "2023-02-03T07:02:33Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c5MvtE4",
          "commit": {
            "abbreviatedOid": "78bd940"
          },
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-02-07T17:18:56Z",
          "updatedAt": "2023-02-07T17:18:56Z",
          "comments": []
        }
      ]
    },
    {
      "number": 854,
      "id": "PR_kwDOBoyH6c5Jc0n1",
      "title": "Add changelong for draft-16 through draft-18",
      "url": "https://github.com/mlswg/mls-protocol/pull/854",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #846 \r\n\r\nAlso adds a draft-18 section to cover any edits between now and the next I-D.",
      "createdAt": "2023-02-07T16:52:21Z",
      "updatedAt": "2023-03-13T18:38:13Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "e33190491ef90e312d4db31c6c7f9df1f4f36f6d",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "changelog-16-17-18",
      "headRefOid": "2e7db52eeabf1404557bfb9b8a6b4ac195ef93f4",
      "closedAt": "2023-03-13T18:38:12Z",
      "mergedAt": "2023-03-13T18:38:12Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "cc6851e77a98b0f58f59f1d72f66831b791a0740"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOBoyH6c5NQdAG",
          "commit": {
            "abbreviatedOid": "af0c297"
          },
          "author": "rohan-wire",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-02-13T17:43:27Z",
          "updatedAt": "2023-02-13T17:43:27Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "```suggestion\r\n\r\n- Make the document standards track\r\n```",
              "createdAt": "2023-02-13T17:43:27Z",
              "updatedAt": "2023-02-13T17:43:48Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c5NQhMP",
          "commit": {
            "abbreviatedOid": "af0c297"
          },
          "author": "rohan-wire",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-02-13T17:55:05Z",
          "updatedAt": "2023-02-13T17:55:05Z",
          "comments": [
            {
              "originalPosition": 10,
              "body": "```suggestion\r\n\r\n- Rename MLSCiphertext and MLSPlaintext to PrivateMessage and PublicMesssage respectively (\\*)\r\n```",
              "createdAt": "2023-02-13T17:55:05Z",
              "updatedAt": "2023-02-13T17:55:05Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c5Pu4jq",
          "commit": {
            "abbreviatedOid": "35dfdc7"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-13T18:18:12Z",
          "updatedAt": "2023-03-13T18:18:13Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "```suggestion\r\n```",
              "createdAt": "2023-03-13T18:18:12Z",
              "updatedAt": "2023-03-13T18:18:13Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c5PvACk",
          "commit": {
            "abbreviatedOid": "2e7db52"
          },
          "author": "rohan-wire",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-03-13T18:34:02Z",
          "updatedAt": "2023-03-13T18:34:02Z",
          "comments": []
        }
      ]
    },
    {
      "number": 855,
      "id": "PR_kwDOBoyH6c5JiLcl",
      "title": "Clarify transcript hash initialization",
      "url": "https://github.com/mlswg/mls-protocol/pull/855",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "ready to merge"
      ],
      "body": "The current text on initializing the transcript hash is ambiguous.  In particular, it never tells you how to compute the first `interim_transcript_hash`. This PR provides clearer initialization instructions, and a figure that summarizes the transcript hash evolution [2].\r\n\r\n<img width=\"596\" alt=\"image\" src=\"https://user-images.githubusercontent.com/75597/217567652-17e86387-dcdf-476d-ba8d-8a9192e285fd.png\">\r\n\r\n[1] To be clear, I think the intent is clear and all current implementations are consistent.  The text is just bad.\r\n[2] The diagram is a little over-the-top elaborate.  I would be OK removing it :)",
      "createdAt": "2023-02-08T15:04:59Z",
      "updatedAt": "2023-03-07T15:09:47Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "0cc54ea2f98e3a20987d56dcb79e3a415228417c",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "transcript-clarify",
      "headRefOid": "341cd8d69a2ef4e3a5f17fcb991987eea20ffe06",
      "closedAt": "2023-03-07T15:09:46Z",
      "mergedAt": "2023-03-07T15:09:46Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "00c1e9c20798dcd93259a0a31960946f03011385"
      },
      "comments": [
        {
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I generally like the diagram, but the intersection between `confirmed`, `commitX` and `confirm_tag` is not clear to me. What is going where? Also shouldn't `confirmed` and `confirm_tag` also get numbers? And what's the different between the `1` and `[1]` suffix?",
          "createdAt": "2023-02-09T11:01:31Z",
          "updatedAt": "2023-02-09T11:02:12Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "OK, I rotated the diagram 90 degrees and rejiggered things to hopefully be clearer.  It now should just barely fit in the .TXT format.  What do folks think?\r\n\r\n<img width=\"459\" alt=\"image\" src=\"https://user-images.githubusercontent.com/75597/217960303-80af47ea-02a4-414f-9cba-92f4b0568ec5.png\">\r\n",
          "createdAt": "2023-02-09T23:15:35Z",
          "updatedAt": "2023-02-09T23:15:35Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOBoyH6c5NBTSu",
          "commit": {
            "abbreviatedOid": "341cd8d"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-02-09T23:35:02Z",
          "updatedAt": "2023-02-09T23:35:02Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOBoyH6c5NCjxf",
          "commit": {
            "abbreviatedOid": "341cd8d"
          },
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Beautiful!",
          "createdAt": "2023-02-10T07:19:54Z",
          "updatedAt": "2023-02-10T07:19:54Z",
          "comments": []
        }
      ]
    },
    {
      "number": 857,
      "id": "PR_kwDOBoyH6c5JqQVf",
      "title": "Updating Srinivas contact details",
      "url": "https://github.com/mlswg/mls-protocol/pull/857",
      "state": "MERGED",
      "author": "seanturner",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2023-02-09T22:06:49Z",
      "updatedAt": "2023-02-09T23:20:36Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "0cc54ea2f98e3a20987d56dcb79e3a415228417c",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "seanturner-si-poc",
      "headRefOid": "73e02df69dab6f8e8edd1155e258129439bcbf61",
      "closedAt": "2023-02-09T23:20:35Z",
      "mergedAt": "2023-02-09T23:20:35Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "1cab780ae0ac970fddf5a06f1ca46ce9e07a6a92"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 858,
      "id": "PR_kwDOBoyH6c5Jvjuk",
      "title": "Explain resolution slightly more clearly",
      "url": "https://github.com/mlswg/mls-protocol/pull/858",
      "state": "MERGED",
      "author": "ekr",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "ready to merge"
      ],
      "body": "",
      "createdAt": "2023-02-10T20:10:24Z",
      "updatedAt": "2023-03-07T15:10:02Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "1cab780ae0ac970fddf5a06f1ca46ce9e07a6a92",
      "headRepository": "ekr/mls-protocol",
      "headRefName": "clarify_resolution",
      "headRefOid": "9d02ad4af1470fdb5b1f029107dde391a24bc2b4",
      "closedAt": "2023-03-07T15:10:02Z",
      "mergedAt": "2023-03-07T15:10:02Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "3dba97083026dfe62f88ef15d63d85106a295e8a"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOBoyH6c5NIH3R",
          "commit": {
            "abbreviatedOid": "012c751"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-02-10T20:43:05Z",
          "updatedAt": "2023-02-10T20:43:05Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOBoyH6c5NI7mA",
          "commit": {
            "abbreviatedOid": "012c751"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-02-10T22:49:05Z",
          "updatedAt": "2023-02-10T22:49:09Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "```suggestion\r\nThe resolution of the root contains the set of keys which are collectively necessary to\r\n```",
              "createdAt": "2023-02-10T22:49:05Z",
              "updatedAt": "2023-02-10T22:49:09Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c5Oh8Ib",
          "commit": {
            "abbreviatedOid": "9d02ad4"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-02-28T13:05:20Z",
          "updatedAt": "2023-02-28T13:05:20Z",
          "comments": []
        }
      ]
    },
    {
      "number": 859,
      "id": "PR_kwDOBoyH6c5Jv7wS",
      "title": "Add clarifying text around which keys are known",
      "url": "https://github.com/mlswg/mls-protocol/pull/859",
      "state": "MERGED",
      "author": "ekr",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "ready to merge"
      ],
      "body": "",
      "createdAt": "2023-02-10T21:37:36Z",
      "updatedAt": "2023-03-07T15:10:20Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "1cab780ae0ac970fddf5a06f1ca46ce9e07a6a92",
      "headRepository": "ekr/mls-protocol",
      "headRefName": "paths_and_blanks",
      "headRefOid": "bc681be46562680e2e97b05e1d06987f1107ae2f",
      "closedAt": "2023-03-07T15:10:20Z",
      "mergedAt": "2023-03-07T15:10:20Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "bc134e1be7dadd01509690a95185d5f9d2793aae"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOBoyH6c5NI6hs",
          "commit": {
            "abbreviatedOid": "144ea21"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-02-10T22:44:05Z",
          "updatedAt": "2023-02-10T22:46:23Z",
          "comments": [
            {
              "originalPosition": 3,
              "body": "```suggestion\r\nNote how the tree invariant applies: Each member knows only their own leaf,\r\n```",
              "createdAt": "2023-02-10T22:44:05Z",
              "updatedAt": "2023-02-10T22:46:24Z"
            },
            {
              "originalPosition": 9,
              "body": "```suggestion\r\npoint: it is possible for there to be \"holes\" on the path from a member's leaf\r\nto the root in which the member knows the key both above and below\r\na given node, but not for that node, as in the case with D.\r\n```",
              "createdAt": "2023-02-10T22:46:04Z",
              "updatedAt": "2023-02-10T22:46:24Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c5Oh7V5",
          "commit": {
            "abbreviatedOid": "bc681be"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-02-28T13:04:01Z",
          "updatedAt": "2023-02-28T13:04:01Z",
          "comments": []
        }
      ]
    },
    {
      "number": 861,
      "id": "PR_kwDOBoyH6c5JwIaO",
      "title": "#860: Loosen chain requirements.",
      "url": "https://github.com/mlswg/mls-protocol/pull/861",
      "state": "MERGED",
      "author": "Bren2010",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This updates the language around how certificate chains are constructed:\r\n- We allow certificates to be omitted if the client knows any recipients will already possess the omitted certificate.\r\n- We allow certificate chains to be out-of-order and potentially contain unused certificates.\r\n\r\nThis is nice because it means less data needs to be sent on the wire, and also provides a method for root certificates to be rotated gracefully (as clients can provide chains for both old and new roots).",
      "createdAt": "2023-02-10T22:42:17Z",
      "updatedAt": "2023-03-07T17:53:55Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "1cab780ae0ac970fddf5a06f1ca46ce9e07a6a92",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "brendan/860",
      "headRefOid": "1995b699f4594eca0530be1fa61f90746594d9f6",
      "closedAt": "2023-03-07T17:53:55Z",
      "mergedAt": "2023-03-07T17:53:55Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "1d94d5d97b8a9b28ce4203d9054c93be51e421ec"
      },
      "comments": [
        {
          "author": "tomleavy",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@Bren2010 it might be useful to also add this language from RFC 8446. It would make the process exactly the same as TLS which makes implementation easier.\r\n\r\n>The sender's certificate MUST come in the first\r\n>CertificateEntry in the list.  Each following certificate SHOULD\r\n >directly certify the one immediately preceding it.  Because\r\n >certificate validation requires that trust anchors be distributed\r\n >independently, a certificate that specifies a trust anchor MAY be\r\n >omitted from the chain, provided that supported peers are known to\r\n >possess any omitted certificates.",
          "createdAt": "2023-02-11T15:01:43Z",
          "updatedAt": "2023-02-11T15:01:43Z"
        },
        {
          "author": "rohan-wire",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> This updates the language around how certificate chains are constructed:\r\n>     * We allow certificates to be omitted if the client knows any recipients will already possess the omitted certificate.\r\n\r\nI think that is fine and is consistent with RFC8446.\r\n\r\n>     * We allow certificate chains to be out-of-order and potentially contain unused certificates.\r\n>\r\n> This is nice because it means less data needs to be sent on the wire, and also provides a method for root certificates to be rotated gracefully (as clients can provide chains for both old and new roots).\r\n\r\nDon't we already have a better mechanism for rotating certificates? As soon as a member has a new certificate chain, it can update its LeafNode in an UpdatePath. This semantics of X.509 certificate bundles are already a bit fuzzy. Such a change will make validation more complicated and more error prone, when this seems completely unnecessary.\r\n",
          "createdAt": "2023-03-03T12:27:04Z",
          "updatedAt": "2023-03-03T12:27:04Z"
        },
        {
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "body": "> Don't we already have a better mechanism for rotating certificates? As soon as a member has a new certificate chain, it can update its LeafNode in an UpdatePath. This semantics of X.509 certificate bundles are already a bit fuzzy. Such a change will make validation more complicated and more error prone, when this seems completely unnecessary.\r\n\r\nThe scenario that this would address is: say that a root CA is compromised and needs to be replaced. Distributing the new CA certificate likely requires a software release, which not everyone will install simultaneously. During the rollout, some users will know only the old compromised CA and some users will know only the new CA and not the compromised one. To preserve interop during the rollout, users need to include two intermediates in their certificate chain: an intermediate signed by the old root that signs their leaf, and an intermediate signed by the new root that signs their leaf. (In the exact scenario I'm thinking of, the intermediate private key is held by the user, so it would not be compromised with the root. Though there may be other arrangements where this flexibility helps.)\r\n\r\nIn terms of implementation complexity: the X509 chain validation libraries I'm aware of already support path building because it's necessary for TLS, so I would expect those could be used",
          "createdAt": "2023-03-03T20:43:49Z",
          "updatedAt": "2023-03-03T20:43:49Z"
        },
        {
          "author": "tomleavy",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> In terms of implementation complexity: the X509 chain validation libraries I'm aware of already support path building because it's necessary for TLS, so I would expect those could be used\r\n\r\nThis is actually the reason why I think it makes sense to adopt the same mechanism. For example, if you use OpenSSL to validate the chain it does not take a chain as input. It takes a collection of certificates, a set of trusted root certs, and the leaf you want to validate. I believe not making this change has a higher complexity.",
          "createdAt": "2023-03-03T21:58:27Z",
          "updatedAt": "2023-03-03T21:58:27Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOBoyH6c5NWpx8",
          "commit": {
            "abbreviatedOid": "fcbfbe7"
          },
          "author": "tomleavy",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-02-14T15:02:24Z",
          "updatedAt": "2023-02-14T15:02:24Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOBoyH6c5O5i1x",
          "commit": {
            "abbreviatedOid": "fcbfbe7"
          },
          "author": "rohan-wire",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-03T12:20:44Z",
          "updatedAt": "2023-03-03T12:20:45Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "I am very uncomfortable with this change for two reasons. Every SHOULD needs to have a statement explaining when you would not do the recommended behavior and why. Also, since this is regarding credential validation I think this is a pretty terrible idea. \r\n\r\nI would prefer to leave this as a MUST. I will comment on another way to accomplish the stated goal in the Conversation part of the PR.",
              "createdAt": "2023-03-03T12:20:44Z",
              "updatedAt": "2023-03-03T12:20:45Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c5PNCA4",
          "commit": {
            "abbreviatedOid": "2be494e"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-07T15:30:37Z",
          "updatedAt": "2023-03-07T15:30:38Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "```suggestion\r\nFor an X.509 credential, each entry in the `certificates` field represents a single DER-encoded\r\n```",
              "createdAt": "2023-03-07T15:30:37Z",
              "updatedAt": "2023-03-07T15:30:38Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c5PNCo9",
          "commit": {
            "abbreviatedOid": "2be494e"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-07T15:31:07Z",
          "updatedAt": "2023-03-07T15:31:08Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "... and the corresponding change to the struct definition above.",
              "createdAt": "2023-03-07T15:31:08Z",
              "updatedAt": "2023-03-07T15:31:08Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c5PNDXW",
          "commit": {
            "abbreviatedOid": "2be494e"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "One minor comment, otherwise this looks good to me.",
          "createdAt": "2023-03-07T15:32:07Z",
          "updatedAt": "2023-03-07T15:32:07Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOBoyH6c5POgRS",
          "commit": {
            "abbreviatedOid": "1995b69"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-03-07T17:53:49Z",
          "updatedAt": "2023-03-07T17:53:49Z",
          "comments": []
        }
      ]
    },
    {
      "number": 862,
      "id": "PR_kwDOBoyH6c5J39e7",
      "title": "Fix inconsistencies and NITS in -17",
      "url": "https://github.com/mlswg/mls-protocol/pull/862",
      "state": "MERGED",
      "author": "rohan-wire",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "ready to merge"
      ],
      "body": "- Replace stray instance of MLSCiphertext with PrivateMessage\r\n",
      "createdAt": "2023-02-13T18:03:51Z",
      "updatedAt": "2023-03-07T15:10:36Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "1cab780ae0ac970fddf5a06f1ca46ce9e07a6a92",
      "headRepository": "rohan-wire/mls-protocol",
      "headRefName": "rohan/17-nits",
      "headRefOid": "6b05e274a6509a6db99e2ee61d9ffaa75ab89b8c",
      "closedAt": "2023-03-07T15:10:36Z",
      "mergedAt": "2023-03-07T15:10:36Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "cb44dbf5a4b89ae520d0d80bdc4782dc2b078c0c"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOBoyH6c5Oh6tN",
          "commit": {
            "abbreviatedOid": "6b05e27"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-02-28T13:02:56Z",
          "updatedAt": "2023-02-28T13:02:56Z",
          "comments": []
        }
      ]
    },
    {
      "number": 863,
      "id": "PR_kwDOBoyH6c5J8owK",
      "title": "Fix `DecryptWithLabel` argument order for Welcome",
      "url": "https://github.com/mlswg/mls-protocol/pull/863",
      "state": "MERGED",
      "author": "TWal",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "ready to merge"
      ],
      "body": "The argument order is \"PrivateKey, Label, Context, KEMOutput, Ciphertext\"",
      "createdAt": "2023-02-14T13:58:21Z",
      "updatedAt": "2023-03-07T15:10:50Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "1cab780ae0ac970fddf5a06f1ca46ce9e07a6a92",
      "headRepository": "TWal/mls-protocol",
      "headRefName": "twal_fix_welcome",
      "headRefOid": "dc0860c881350a440bdd1fbccf08929e4e982305",
      "closedAt": "2023-03-07T15:10:49Z",
      "mergedAt": "2023-03-07T15:10:49Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "4e574c9978507bc08a0e86a11b2060a5d27f0c75"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOBoyH6c5NYXw5",
          "commit": {
            "abbreviatedOid": "dc0860c"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-02-14T18:59:52Z",
          "updatedAt": "2023-02-14T18:59:52Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOBoyH6c5OeOFV",
          "commit": {
            "abbreviatedOid": "dc0860c"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-02-27T22:41:55Z",
          "updatedAt": "2023-02-27T22:41:55Z",
          "comments": []
        }
      ]
    },
    {
      "number": 864,
      "id": "PR_kwDOBoyH6c5KIl7e",
      "title": "Change MLS-Exporter label from \"exporter\" to \"exported\"",
      "url": "https://github.com/mlswg/mls-protocol/pull/864",
      "state": "MERGED",
      "author": "TWal",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "ready to merge"
      ],
      "body": "Currently the \"exporter\" label is used two times : to derive `exporter_secret`, and in `MLS-Exporter`.\r\nI'm not sure it's really problematic, but using different labels doesn't cost much, hence this PR.",
      "createdAt": "2023-02-16T14:16:32Z",
      "updatedAt": "2023-03-07T15:11:14Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "1cab780ae0ac970fddf5a06f1ca46ce9e07a6a92",
      "headRepository": "TWal/mls-protocol",
      "headRefName": "twal_change_exporter_label",
      "headRefOid": "54efc3a49c292f30d414619bd7ef69a8b35014b9",
      "closedAt": "2023-03-07T15:11:13Z",
      "mergedAt": "2023-03-07T15:11:13Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "a614a204f1773ec48667ae5d5c3e0c8c55b80d16"
      },
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "@duesee, no the point is for the two labels to be different :)",
          "createdAt": "2023-03-01T14:20:00Z",
          "updatedAt": "2023-03-01T14:20:00Z"
        },
        {
          "author": "duesee",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Argh... confused myself, sorry :-)",
          "createdAt": "2023-03-01T14:36:44Z",
          "updatedAt": "2023-03-01T14:36:54Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOBoyH6c5OeOS3",
          "commit": {
            "abbreviatedOid": "54efc3a"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-02-27T22:42:47Z",
          "updatedAt": "2023-02-27T22:42:47Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOBoyH6c5OrJhR",
          "commit": {
            "abbreviatedOid": "54efc3a"
          },
          "author": "duesee",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "~I think this should be adapted, too: https://github.com/mlswg/mls-protocol/pull/864/files#diff-7c369b85b26a746a7e70cd2884037896defe03b3098bec976f79c994d22a604aR2937~ Nevermind :-)",
          "createdAt": "2023-03-01T14:13:05Z",
          "updatedAt": "2023-03-01T14:37:08Z",
          "comments": []
        }
      ]
    },
    {
      "number": 865,
      "id": "PR_kwDOBoyH6c5KW5EH",
      "title": "Use ExpandWithLabel to derive welcome key",
      "url": "https://github.com/mlswg/mls-protocol/pull/865",
      "state": "MERGED",
      "author": "mulmarta",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "ready to merge"
      ],
      "body": "Fix a bug noticed by @bifurcation. Using `ExpandWithLabel` instead of the raw `Expand` seems the right way. Note that after this change \"MLS 1.0\" is prepended to the label.",
      "createdAt": "2023-02-20T15:50:20Z",
      "updatedAt": "2023-03-07T15:11:35Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "1cab780ae0ac970fddf5a06f1ca46ce9e07a6a92",
      "headRepository": "mulmarta/mls-protocol",
      "headRefName": "mulmarta/add-label",
      "headRefOid": "02d97a335af2a725d0d012bcc8c1e073bcdb46fd",
      "closedAt": "2023-03-07T15:11:35Z",
      "mergedAt": "2023-03-07T15:11:35Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "fe1295e9f3b021b86abca07a65f29ab3a52f3891"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOBoyH6c5N2IjU",
          "commit": {
            "abbreviatedOid": "02d97a3"
          },
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-02-20T15:53:13Z",
          "updatedAt": "2023-02-20T15:53:13Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOBoyH6c5OeN7R",
          "commit": {
            "abbreviatedOid": "02d97a3"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-02-27T22:41:15Z",
          "updatedAt": "2023-02-27T22:41:15Z",
          "comments": []
        }
      ]
    },
    {
      "number": 866,
      "id": "PR_kwDOBoyH6c5KbDuT",
      "title": "Allow group context extensions proposal without path",
      "url": "https://github.com/mlswg/mls-protocol/pull/866",
      "state": "CLOSED",
      "author": "mulmarta",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Requiring paths to change group context seems too strict.",
      "createdAt": "2023-02-21T11:56:57Z",
      "updatedAt": "2023-02-28T11:29:51Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "1cab780ae0ac970fddf5a06f1ca46ce9e07a6a92",
      "headRepository": "mulmarta/mls-protocol",
      "headRefName": "mulmarta/proposal",
      "headRefOid": "5441335fbfb6a7264d8d5d19ad48a06a9767c629",
      "closedAt": "2023-02-28T11:29:50Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "body": "I'm slightly concerned about this because it covers extensions, so we don't know exactly what all will be happening here. You're saying there are /no/ extensions possible where it makes sense to maintain the stronger security of a path-populated Commit",
          "createdAt": "2023-02-22T21:49:25Z",
          "updatedAt": "2023-02-22T21:49:25Z"
        },
        {
          "author": "mulmarta",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> I'm slightly concerned about this because it covers extensions, so we don't know exactly what all will be happening here. You're saying there are /no/ extensions possible where it makes sense to maintain the stronger security of a path-populated Commit\r\n\r\nAn extension can still specify that a commit that changes its value in the group context requires a path. So I think what this is doing is changing the default behavior to allow not updating the path (since most extensions won't need it). However, this behavior can be overridden by extensions.",
          "createdAt": "2023-02-27T15:27:10Z",
          "updatedAt": "2023-02-27T15:27:10Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "I think this was discussed and the feeling was that sending the path was more conservative, since you don't know in advance whether a future extension would require a path.  It also lets you decide at the proposal-type level, without having to get into the internals of the GroupContextExtensions.\r\n\r\nIf we are going to do something here, I would suggest being more formal than this PR is, and defining for extensions a notion analogous to \"path required\" for Proposals.  That way at least there's an algorithm defined.\r\n\r\nI would probably prefer to leave this as-is, though.",
          "createdAt": "2023-02-27T22:40:45Z",
          "updatedAt": "2023-02-27T22:40:45Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "I think this was discussed and the feeling was that sending the path was more conservative, since you don't know in advance whether a future extension would require a path.  It also lets you decide at the proposal-type level, without having to get into the internals of the GroupContextExtensions.\r\n\r\nIf we are going to do something here, I would suggest being more formal than this PR is, and defining for extensions a notion analogous to \"path required\" for Proposals.  That way at least there's an algorithm defined.\r\n\r\nI would probably prefer to leave this as-is, though.",
          "createdAt": "2023-02-27T22:40:54Z",
          "updatedAt": "2023-02-27T22:40:54Z"
        },
        {
          "author": "mulmarta",
          "authorAssociation": "CONTRIBUTOR",
          "body": "No strong opinions.",
          "createdAt": "2023-02-28T11:29:50Z",
          "updatedAt": "2023-02-28T11:29:50Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 867,
      "id": "PR_kwDOBoyH6c5KbPae",
      "title": "Rename `SenderData` to `SenderDataTBE`",
      "url": "https://github.com/mlswg/mls-protocol/pull/867",
      "state": "CLOSED",
      "author": "TWal",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "With the renaming in #839, some message formats used before encryption / after decryption were suffixed with `TBE` (with the same spirit as `TBS`).\r\nHowever `SenderData` is only used before encryption / after decryption, so it makes sense to add `TBE` in the name, hence this pull request.",
      "createdAt": "2023-02-21T12:32:34Z",
      "updatedAt": "2023-03-01T15:47:45Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "1cab780ae0ac970fddf5a06f1ca46ce9e07a6a92",
      "headRepository": "TWal/mls-protocol",
      "headRefName": "twal_rename_sender_data",
      "headRefOid": "f24de88d06d36f2d23054932bfd9b212a2fd6f1a",
      "closedAt": "2023-03-01T15:47:44Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "body": "Honestly I'd prefer not to have the extra cruft",
          "createdAt": "2023-02-22T21:44:31Z",
          "updatedAt": "2023-02-22T21:44:31Z"
        },
        {
          "author": "TWal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'm not opposed to leave `SenderData` as-is, but I think the whole document should have a consistent naming convention: either every message format used as input for encryption/decryption has `TBE` suffixed, or none of them has.\r\nA middle-ground where some are named with `TBE` and some aren't is not great I think.",
          "createdAt": "2023-02-23T10:42:28Z",
          "updatedAt": "2023-02-23T10:42:28Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "I am also disinclined to do this.  We have the following structs that are inputs:\r\n\r\n* `GroupSecrets`\r\n* `GroupInfo`\r\n* `SenderData`\r\n* `PrivateMessageTBE`\r\n\r\nIf anything, I would be inclined to remove the `TBE`.  Maybe call it `PrivateMessageContent`. ",
          "createdAt": "2023-02-27T22:37:26Z",
          "updatedAt": "2023-02-27T22:37:26Z"
        },
        {
          "author": "TWal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thanks for the exhaustive list!\r\nDropping the TBE makes sense. I think the difference between `TBE` and `TBS`/`TBM` is that `xxxTBS` and `xxxTBM` are always linked to another message format `xxx`, which is not the case of `xxxTBE`.",
          "createdAt": "2023-03-01T15:44:13Z",
          "updatedAt": "2023-03-01T15:44:13Z"
        },
        {
          "author": "TWal",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Closing in favor of #870.",
          "createdAt": "2023-03-01T15:47:44Z",
          "updatedAt": "2023-03-01T15:47:44Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 868,
      "id": "PR_kwDOBoyH6c5KcR4o",
      "title": "Make the ratchet tree non-malleable",
      "url": "https://github.com/mlswg/mls-protocol/pull/868",
      "state": "MERGED",
      "author": "TWal",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "ready to merge"
      ],
      "body": "As discussed in mlswg/mls-implementations#102 .\r\n\r\nCurrently, there are several valid `ratchet_tree` for one tree: the sender can choose (\"SHOULD\") to omit some (but not all) blank nodes at the right of the tree.\r\nThis PR changes this: the sender MUST omit all the blank nodes at the right of the tree, and the receiver MUST check that it was done correctly (i.e., the last node of `ratchet_tree` is non-blank).",
      "createdAt": "2023-02-21T15:49:56Z",
      "updatedAt": "2023-03-07T15:12:00Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "1cab780ae0ac970fddf5a06f1ca46ce9e07a6a92",
      "headRepository": "TWal/mls-protocol",
      "headRefName": "twal_non_malleable_ratchet_tree",
      "headRefOid": "426b5a64fc270316777f6dca9fe49d969df91477",
      "closedAt": "2023-03-07T15:11:59Z",
      "mergedAt": "2023-03-07T15:11:59Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "c58f04e132e0fb3a9b910cf85f19c54537822b1c"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOBoyH6c5N8kib",
          "commit": {
            "abbreviatedOid": "426b5a6"
          },
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-02-21T16:00:05Z",
          "updatedAt": "2023-02-21T16:00:05Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOBoyH6c5OeMDl",
          "commit": {
            "abbreviatedOid": "426b5a6"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-02-27T22:34:04Z",
          "updatedAt": "2023-02-27T22:34:04Z",
          "comments": []
        }
      ]
    },
    {
      "number": 869,
      "id": "PR_kwDOBoyH6c5K8rgb",
      "title": "GREASE for MLS registries",
      "url": "https://github.com/mlswg/mls-protocol/pull/869",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This PR is an attempt to address #856.  It registers GREASE code points in the relevant registries and recommends their use in the appropriate places.  It also includes some edits to the extensibility provisions to make them clearer and sharper, and a little cleanup on registry formatting.\r\n\r\nFixes #856 ",
      "createdAt": "2023-02-28T16:26:06Z",
      "updatedAt": "2023-03-12T17:59:20Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "1cab780ae0ac970fddf5a06f1ca46ce9e07a6a92",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "grease",
      "headRefOid": "185c1763a032f595fd54960d288d8a94280665c8",
      "closedAt": "2023-03-12T17:59:20Z",
      "mergedAt": "2023-03-12T17:59:20Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "bdf8a9a4092b92b7a11f8762b95907510fda2595"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOBoyH6c5Oki2S",
          "commit": {
            "abbreviatedOid": "ea28f93"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Thanks for doing this! Feel free to use or ignore any of my suggestions as you see fit.",
          "createdAt": "2023-02-28T17:56:21Z",
          "updatedAt": "2023-02-28T18:45:23Z",
          "comments": [
            {
              "originalPosition": 49,
              "body": "Microscopic nit of avoiding 2119 keywords in lowercase\r\n```suggestion\r\n  the `extensions` and `leaf_node.extensions` fields.  Otherwise, it could fail\r\n```",
              "createdAt": "2023-02-28T17:56:21Z",
              "updatedAt": "2023-02-28T18:45:23Z"
            },
            {
              "originalPosition": 93,
              "body": "```suggestion\r\nsignal to its implementer that the client needs to be fixed.\r\n```",
              "createdAt": "2023-02-28T17:59:23Z",
              "updatedAt": "2023-02-28T18:45:23Z"
            },
            {
              "originalPosition": 109,
              "body": "```suggestion\r\npopulate these extensions with a randomly-sized amount of random data.\r\n```",
              "createdAt": "2023-02-28T18:40:01Z",
              "updatedAt": "2023-02-28T18:45:23Z"
            },
            {
              "originalPosition": 119,
              "body": "```suggestion\r\nfield of a Proposal.  Clients MUST NOT implement any special processing rules \r\nfor how to handle these values when receiving them, since this negates their\r\nutility for detecting extensibility failures.\r\n```",
              "createdAt": "2023-02-28T18:42:01Z",
              "updatedAt": "2023-02-28T18:45:23Z"
            },
            {
              "originalPosition": 120,
              "body": "```suggestion\r\nGREASE values MUST be handled using normal logic for processing unsupported\r\n```",
              "createdAt": "2023-02-28T18:42:09Z",
              "updatedAt": "2023-02-28T18:45:23Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c5OlWqU",
          "commit": {
            "abbreviatedOid": "64d36c3"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-02-28T19:25:13Z",
          "updatedAt": "2023-02-28T19:25:14Z",
          "comments": [
            {
              "originalPosition": 287,
              "body": "```suggestion\r\n| 0xf000  - 0xffff | Reserved for Private Use | - | RFC XXXX |\r\n```",
              "createdAt": "2023-02-28T19:25:14Z",
              "updatedAt": "2023-02-28T19:25:14Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c5OtB_A",
          "commit": {
            "abbreviatedOid": "819f2fc"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-01T18:45:25Z",
          "updatedAt": "2023-03-01T19:00:58Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "```suggestion\r\nSHOULD include some GREASE values to help ensure that other clients correctly\r\n```",
              "createdAt": "2023-03-01T18:45:25Z",
              "updatedAt": "2023-03-01T19:00:58Z"
            },
            {
              "originalPosition": 21,
              "body": "```suggestion\r\nignored, and the creator of a `KeyPackage` object SHOULD include some GREASE\r\n```",
              "createdAt": "2023-03-01T18:45:47Z",
              "updatedAt": "2023-03-01T19:00:58Z"
            },
            {
              "originalPosition": 33,
              "body": "```suggestion\r\nGREASE extensions to help ensure that other clients correctly ignore unknown\r\n```",
              "createdAt": "2023-03-01T18:46:17Z",
              "updatedAt": "2023-03-01T19:00:58Z"
            },
            {
              "originalPosition": 108,
              "body": "```suggestion\r\nignored by a correctly-implemented receiver.  For example, a senders might\r\n```",
              "createdAt": "2023-03-01T18:51:32Z",
              "updatedAt": "2023-03-01T19:00:58Z"
            },
            {
              "originalPosition": 116,
              "body": "```suggestion\r\nvalue `0xFAFA` falls within the private use range.) These values MUST only\r\n```",
              "createdAt": "2023-03-01T18:52:05Z",
              "updatedAt": "2023-03-01T19:00:59Z"
            },
            {
              "originalPosition": 122,
              "body": "```suggestion\r\nGREASE values MUST be handled using normal logic for processing unsupported\r\nvalues. Due to the possible injection of GREASE values, clients MUST NOT inspect\r\ndata that they've submitted to the group themself for the purpose of negotiation,\r\nfor example, by referencing their own `LeafNode.capabilities` to detect support\r\nfor a codepoint.\r\n```\r\nNot sure if this is exactly the right way to say this but I think it deserves to be called out",
              "createdAt": "2023-03-01T18:59:20Z",
              "updatedAt": "2023-03-01T19:00:59Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c5OtHyS",
          "commit": {
            "abbreviatedOid": "819f2fc"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-01T19:02:29Z",
          "updatedAt": "2023-03-01T19:02:29Z",
          "comments": [
            {
              "originalPosition": 118,
              "body": "```suggestion\r\nfield of a Proposal.  Clients MUST NOT implement any special processing rules\r\n```",
              "createdAt": "2023-03-01T19:02:29Z",
              "updatedAt": "2023-03-01T19:02:29Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c5Ot5cK",
          "commit": {
            "abbreviatedOid": "819f2fc"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-01T21:32:18Z",
          "updatedAt": "2023-03-01T21:32:18Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "```suggestion\r\nSHOULD contain some random GREASE values to help ensure that other clients correctly\r\n```",
              "createdAt": "2023-03-01T21:32:18Z",
              "updatedAt": "2023-03-01T21:32:18Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c5Ot5ic",
          "commit": {
            "abbreviatedOid": "819f2fc"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-01T21:32:37Z",
          "updatedAt": "2023-03-01T21:32:38Z",
          "comments": [
            {
              "originalPosition": 21,
              "body": "```suggestion\r\nignored, and the creator of a `KeyPackage` object SHOULD include some random GREASE\r\n```",
              "createdAt": "2023-03-01T21:32:38Z",
              "updatedAt": "2023-03-01T21:32:38Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c5OuMuA",
          "commit": {
            "abbreviatedOid": "819f2fc"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-01T22:40:46Z",
          "updatedAt": "2023-03-01T22:40:46Z",
          "comments": [
            {
              "originalPosition": 33,
              "body": "```suggestion\r\nrandom GREASE extensions to help ensure that other clients correctly ignore unknown\r\n```",
              "createdAt": "2023-03-01T22:40:46Z",
              "updatedAt": "2023-03-01T22:40:46Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c5OuONC",
          "commit": {
            "abbreviatedOid": "819f2fc"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-01T22:46:07Z",
          "updatedAt": "2023-03-01T22:46:08Z",
          "comments": [
            {
              "originalPosition": 122,
              "body": "@DavidSchinazi is there a standard way to deal with the possibility that you'll accidentally negotiate a GREASE code point?\r\n\r\nThe best that comes to my mind is something like the following:\r\n> When comparing lists of capabilities to identify mutually-supported capabilities, clients MUST represent their own capabilities with a list containing only the capabilities actually supported, without any GREASE values.  In other words, lists including GREASE values are only sent to other clients; representations of a client's own capabilities MUST NOT contain GREASE values.\r\n\r\n(The latter part of which is basically what @Bren2010 says.)",
              "createdAt": "2023-03-01T22:46:07Z",
              "updatedAt": "2023-03-01T22:46:08Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c5OuS9Q",
          "commit": {
            "abbreviatedOid": "819f2fc"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-01T23:04:29Z",
          "updatedAt": "2023-03-01T23:04:30Z",
          "comments": [
            {
              "originalPosition": 122,
              "body": "It's never possible to negotiate a GREASE value because the recipients ignore them. Conceptually the algorithm for matching is \"take the set of received values, and the set of supported values, and use the intersection set to decide which one to negotiate\" - and that's regardless of GREASE. Perhaps:\r\n\r\n> GREASE values are never added to the list of locally supported capabilities when negotiating capabilities.",
              "createdAt": "2023-03-01T23:04:29Z",
              "updatedAt": "2023-03-01T23:04:30Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c5OuXfi",
          "commit": {
            "abbreviatedOid": "819f2fc"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-01T23:13:01Z",
          "updatedAt": "2023-03-01T23:13:01Z",
          "comments": [
            {
              "originalPosition": 122,
              "body": "Yeah, the problem arises when you look at your own KeyPackage to remind yourself of your capabilities, and accidentally get GREASE in your eyes.  (Sorry)  Which seems a little outlandish, but seems worth mentioning since \"won't we accidentally negotiate GREASE values?\" also came up in my mind and I had to talk myself back.",
              "createdAt": "2023-03-01T23:13:01Z",
              "updatedAt": "2023-03-01T23:13:01Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c5Oudr1",
          "commit": {
            "abbreviatedOid": "819f2fc"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-01T23:36:15Z",
          "updatedAt": "2023-03-01T23:36:16Z",
          "comments": [
            {
              "originalPosition": 122,
              "body": "```suggestion\r\nGREASE values MUST be handled using normal logic for processing unsupported\r\nvalues.  When comparing lists of capabilities to identify mutually-supported\r\ncapabilities, clients MUST represent their own capabilities with a list\r\ncontaining only the capabilities actually supported, without any GREASE values.\r\nIn other words, lists including GREASE values are only sent to other clients;\r\nrepresentations of a client's own capabilities MUST NOT contain GREASE values.\r\n```",
              "createdAt": "2023-03-01T23:36:15Z",
              "updatedAt": "2023-03-01T23:36:16Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c5O5l5V",
          "commit": {
            "abbreviatedOid": "90cec29"
          },
          "author": "rohan-wire",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2023-03-03T12:28:39Z",
          "updatedAt": "2023-03-03T12:36:13Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "This is the first line in the document where GREASE is mentioned. It should be spelled out and have a reference.",
              "createdAt": "2023-03-03T12:28:39Z",
              "updatedAt": "2023-03-03T12:36:13Z"
            },
            {
              "originalPosition": 134,
              "body": "Do we want these GREASE ciphersuites to vary the components? Ex:\r\n\r\nGREASE_128_DHKEMX25519_AES128GCM_SHA256_Ed25519\r\nMLS_128_GREASE_AES128GCM_SHA256_Ed25519\r\nMLS_128_DHKEMX25519_GREASE_SHA256_Ed25519\r\nMLS_128_DHKEMX25519_AES128GCM_GREASE_Ed25519\r\nMLS_128_DHKEMX25519_AES128GCM_SHA256_GREASE",
              "createdAt": "2023-03-03T12:34:42Z",
              "updatedAt": "2023-03-03T12:36:13Z"
            },
            {
              "originalPosition": 198,
              "body": "Do we want some of the GREASE values to be only KP, some only GI, and some either KP or GI?",
              "createdAt": "2023-03-03T12:35:42Z",
              "updatedAt": "2023-03-03T12:36:13Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c5O75-w",
          "commit": {
            "abbreviatedOid": "90cec29"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-03T17:18:41Z",
          "updatedAt": "2023-03-03T17:18:41Z",
          "comments": [
            {
              "originalPosition": 198,
              "body": "That wouldn't change anything because correctly-implemented receivers will ignore them in both KP and GI",
              "createdAt": "2023-03-03T17:18:41Z",
              "updatedAt": "2023-03-03T17:18:41Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c5PM1QE",
          "commit": {
            "abbreviatedOid": "90cec29"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-07T15:15:33Z",
          "updatedAt": "2023-03-07T15:15:34Z",
          "comments": [
            {
              "originalPosition": 134,
              "body": "No, I don't think we need this level of granularity.  As with the `KP, GI` bits below, the behavior is the same regardless of the code point.",
              "createdAt": "2023-03-07T15:15:33Z",
              "updatedAt": "2023-03-07T15:15:34Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c5PO9_N",
          "commit": {
            "abbreviatedOid": "79850b0"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-03-07T19:02:05Z",
          "updatedAt": "2023-03-07T19:15:20Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "```suggestion\r\nAs detailed in {{grease}}, the \"Generate Random Extensions And Sustain\r\n```",
              "createdAt": "2023-03-07T19:02:06Z",
              "updatedAt": "2023-03-07T19:15:20Z"
            },
            {
              "originalPosition": 5,
              "body": "```suggestion\r\nExtensibility\" (GREASE) approach to maintaining extensibility, senders insert random\r\n```",
              "createdAt": "2023-03-07T19:02:51Z",
              "updatedAt": "2023-03-07T19:15:21Z"
            },
            {
              "originalPosition": 121,
              "body": "```suggestion\r\nignored by a correctly-implemented receiver.  For example, a sender might\r\n```",
              "createdAt": "2023-03-07T19:14:24Z",
              "updatedAt": "2023-03-07T19:15:21Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c5PorHs",
          "commit": {
            "abbreviatedOid": "36810bc"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-12T17:52:15Z",
          "updatedAt": "2023-03-12T17:52:23Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "```suggestion\r\nAs detailed in {{grease}}, MLS uses the \"Generate Random Extensions And Sustain\r\nExtensibility\" (GREASE) approach to maintaining extensibility, where senders insert random\r\n```",
              "createdAt": "2023-03-12T17:52:15Z",
              "updatedAt": "2023-03-12T17:52:23Z"
            }
          ]
        }
      ]
    },
    {
      "number": 870,
      "id": "PR_kwDOBoyH6c5LC3tc",
      "title": "Rename `PrivateContentTBE` to `PrivateMessageContent`",
      "url": "https://github.com/mlswg/mls-protocol/pull/870",
      "state": "MERGED",
      "author": "TWal",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "ready to merge"
      ],
      "body": "As discussed in #867, remove the `TBE` for more consistency across names.",
      "createdAt": "2023-03-01T15:47:25Z",
      "updatedAt": "2023-03-07T15:12:27Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "1cab780ae0ac970fddf5a06f1ca46ce9e07a6a92",
      "headRepository": "TWal/mls-protocol",
      "headRefName": "twal_rename_private_content_tbe",
      "headRefOid": "6a7a3599c5d4682d28e484d8a75b608204676a57",
      "closedAt": "2023-03-07T15:12:26Z",
      "mergedAt": "2023-03-07T15:12:26Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "d90bbd611d6300ba32913b4492d157645efddeed"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOBoyH6c5Os_Z2",
          "commit": {
            "abbreviatedOid": "6a7a359"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-03-01T18:38:18Z",
          "updatedAt": "2023-03-01T18:38:18Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOBoyH6c5OtIIy",
          "commit": {
            "abbreviatedOid": "6a7a359"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-03-01T19:03:32Z",
          "updatedAt": "2023-03-01T19:03:32Z",
          "comments": []
        }
      ]
    },
    {
      "number": 871,
      "id": "PR_kwDOBoyH6c5LEuzZ",
      "title": "Three small edits",
      "url": "https://github.com/mlswg/mls-protocol/pull/871",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "ready to merge"
      ],
      "body": "This PR fixes small issues that I noticed while implementing proposal validation and fixing some external join bugs:\r\n\r\n* The pseudocode for determining whether a path is required assumes that all proposals are by-reference.  The PR updates the pseudocode to be more general, and also account for proposals by value.\r\n* There were two references to adding a single leaf to the tree, which are updated to make clear that the tree grows by doubling, not by single leaves.\r\n* There was no current requirement that an Update proposal have a distinct `encryption_key`, so one is added.",
      "createdAt": "2023-03-01T22:34:14Z",
      "updatedAt": "2023-03-07T15:13:58Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "1cab780ae0ac970fddf5a06f1ca46ce9e07a6a92",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "papercuts",
      "headRefOid": "5297222fb0831576e43fef97a1a9711f7399cd7d",
      "closedAt": "2023-03-07T15:13:57Z",
      "mergedAt": "2023-03-07T15:13:57Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "46ecc0bfc7c1ef7c66c57cd962490e77f1b45c80"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOBoyH6c5O5hMy",
          "commit": {
            "abbreviatedOid": "5297222"
          },
          "author": "rohan-wire",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-03-03T12:15:23Z",
          "updatedAt": "2023-03-03T12:15:23Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOBoyH6c5O8xFj",
          "commit": {
            "abbreviatedOid": "5297222"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-03-03T20:30:35Z",
          "updatedAt": "2023-03-03T20:30:35Z",
          "comments": []
        }
      ]
    },
    {
      "number": 872,
      "id": "PR_kwDOBoyH6c5LQZN1",
      "title": "Comments from Nick Sullivan",
      "url": "https://github.com/mlswg/mls-protocol/pull/872",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Nick sent me some late comments, which I have reflected in this PR.  The most significant changes are:\r\n\r\n* A new section in the overview covering external commits, so that that concept has been introduced before it is encountered further down.\r\n\r\n* A new subsection in the security considerations elaborating why key uniqueness mattes, and some slightly stronger requirements around it in the appropriate spots. ",
      "createdAt": "2023-03-03T20:32:50Z",
      "updatedAt": "2023-03-13T18:06:41Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "bdf8a9a4092b92b7a11f8762b95907510fda2595",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "nick",
      "headRefOid": "2a02a550e06f7203eb2543ff5bb122f0be57ef7e",
      "closedAt": "2023-03-13T18:06:40Z",
      "mergedAt": "2023-03-13T18:06:40Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "e33190491ef90e312d4db31c6c7f9df1f4f36f6d"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOBoyH6c5O827o",
          "commit": {
            "abbreviatedOid": "b52af0c"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-03T20:50:47Z",
          "updatedAt": "2023-03-03T22:19:11Z",
          "comments": [
            {
              "originalPosition": 37,
              "body": "```suggestion\r\nprotection against denial of service; a DS could also enforce rate limits in\r\n```",
              "createdAt": "2023-03-03T20:50:47Z",
              "updatedAt": "2023-03-03T22:19:11Z"
            },
            {
              "originalPosition": 31,
              "body": "```suggestion\r\nstronger security properties, especially in cases where MLS handshake messages\r\n```",
              "createdAt": "2023-03-03T20:51:00Z",
              "updatedAt": "2023-03-03T22:19:11Z"
            },
            {
              "originalPosition": 31,
              "body": "```suggestion\r\nstronger security properties, especially in cases where MLS handshake messages\r\n```",
              "createdAt": "2023-03-03T20:51:03Z",
              "updatedAt": "2023-03-12T17:49:03Z"
            },
            {
              "originalPosition": 50,
              "body": "```suggestion\r\n  context is typically distributed in a signed GroupInfo message, which is provided\r\n```",
              "createdAt": "2023-03-03T20:52:00Z",
              "updatedAt": "2023-03-03T22:19:11Z"
            },
            {
              "originalPosition": 88,
              "body": "I don't think this is right? Proposals sent by other members are included in the commit by reference. Only proposals sent by the committer are included by value; important distinction for access control",
              "createdAt": "2023-03-03T21:07:02Z",
              "updatedAt": "2023-03-03T22:19:11Z"
            },
            {
              "originalPosition": 110,
              "body": "```suggestion\r\nmembers of the group process this external Commit in a similar way to a normal\r\n```",
              "createdAt": "2023-03-03T21:09:26Z",
              "updatedAt": "2023-03-03T22:19:11Z"
            },
            {
              "originalPosition": 130,
              "body": "```suggestion\r\n{: #groupinfo-flow title=\"Client A publishes a GroupInfo object and Client Z uses\r\n```",
              "createdAt": "2023-03-03T21:13:05Z",
              "updatedAt": "2023-03-03T22:19:11Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c5PT4Jv",
          "commit": {
            "abbreviatedOid": "b52af0c"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "Looks good modulo the existing suggestions and comments",
          "createdAt": "2023-03-08T12:53:28Z",
          "updatedAt": "2023-03-08T12:55:43Z",
          "comments": [
            {
              "originalPosition": 148,
              "body": "strange line break",
              "createdAt": "2023-03-08T12:53:28Z",
              "updatedAt": "2023-03-08T12:55:43Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c5PoOo2",
          "commit": {
            "abbreviatedOid": "b52af0c"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-11T23:45:45Z",
          "updatedAt": "2023-03-11T23:45:45Z",
          "comments": [
            {
              "originalPosition": 88,
              "body": "```suggestion\r\n* Proposal messages don't need to be immediately sent to all group members.  They need to\r\n  be available to the committer before generating a commit, and to other members before\r\n  processing the commit.\r\n```",
              "createdAt": "2023-03-11T23:45:45Z",
              "updatedAt": "2023-03-11T23:45:45Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c5PoOpA",
          "commit": {
            "abbreviatedOid": "b52af0c"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-11T23:45:58Z",
          "updatedAt": "2023-03-11T23:47:08Z",
          "comments": [
            {
              "originalPosition": 88,
              "body": "@Bren2010 look good?",
              "createdAt": "2023-03-11T23:45:58Z",
              "updatedAt": "2023-03-11T23:47:08Z"
            },
            {
              "originalPosition": 148,
              "body": "Doesn't change the rendering.  I'll fix it if I end up having to do edits locally, vs in the GitHub UI :)",
              "createdAt": "2023-03-11T23:46:57Z",
              "updatedAt": "2023-03-11T23:47:08Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c5PqUDP",
          "commit": {
            "abbreviatedOid": "f30c71a"
          },
          "author": "mulmarta",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-13T08:52:43Z",
          "updatedAt": "2023-03-13T08:52:43Z",
          "comments": [
            {
              "originalPosition": 241,
              "body": "I'm not sure I get this argument. First, keys could be related in different ways, e.g. `pk2 = pk1 ^ 2`. If I know `sk1` corresponding to `pk1`, I can decrypt ciphertexts for `sk2 = 2 * sk1` corresponding to `pk2` as well. In general, such relations can't be detected, so I don't see how this check _can_ improve security. On the other hand, it's a bit annoying to implement.\r\n\r\nAnother reason I don't think this check prevents double joins by malicious insiders. Say leaves A and B have the same HPKE key. This could be because:\r\n\r\n* A is honest and a malicious B copied A's key. Since B doesn't know the secret key, this is not an attack and B can be removed.\r\n* A is honest and generated the same key as a malicious B. This clearly can't happen because keys are random.\r\n* A and B are malicious, they collude and they introduced the same key. In this case security is restored only after removing both insiders. (Since A and B collude, they are one entity in a way)",
              "createdAt": "2023-03-13T08:52:43Z",
              "updatedAt": "2023-03-13T08:52:44Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c5PqUTp",
          "commit": {
            "abbreviatedOid": "f30c71a"
          },
          "author": "mulmarta",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-13T08:53:23Z",
          "updatedAt": "2023-03-13T08:53:23Z",
          "comments": [
            {
              "originalPosition": 206,
              "body": "What exactly does it mean to \"appear in any other node\"? Is it OK e.g. if a signature or an HPKE key of a leaf appears in an intermediate certificate in the X509 chain in the credential of another leaf? Should we also check that the keys don't appear in other places e.g. in the external signers extension or as the HPKE key for external joiners? In general, I'm not sure this check adds much; see below.",
              "createdAt": "2023-03-13T08:53:23Z",
              "updatedAt": "2023-03-13T08:54:20Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c5PunBw",
          "commit": {
            "abbreviatedOid": "6b1de09"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-03-13T17:36:59Z",
          "updatedAt": "2023-03-13T17:38:58Z",
          "comments": [
            {
              "originalPosition": 155,
              "body": "```suggestion\r\nrelative to one of its ancestor nodes if the member at the leaf node does not\r\n```",
              "createdAt": "2023-03-13T17:36:59Z",
              "updatedAt": "2023-03-13T17:38:58Z"
            },
            {
              "originalPosition": 156,
              "body": "```suggestion\r\nknow the private key corresponding to the ancestor node.\r\n```",
              "createdAt": "2023-03-13T17:37:12Z",
              "updatedAt": "2023-03-13T17:38:58Z"
            }
          ]
        }
      ]
    },
    {
      "number": 873,
      "id": "PR_kwDOBoyH6c5LhM8C",
      "title": "Security considerations",
      "url": "https://github.com/mlswg/mls-protocol/pull/873",
      "state": "MERGED",
      "author": "ekr",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This PR adds a few more key points to the security considerations that probably deserve to be in this document.",
      "createdAt": "2023-03-07T21:49:32Z",
      "updatedAt": "2023-03-11T23:55:53Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "1d94d5d97b8a9b28ce4203d9054c93be51e421ec",
      "headRepository": "ekr/mls-protocol",
      "headRefName": "security_considerations",
      "headRefOid": "6d04cd9ffd324894d1e64d0909ac14881ef04923",
      "closedAt": "2023-03-11T23:55:52Z",
      "mergedAt": "2023-03-11T23:55:52Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "b1f6dd9d3761a81f68fe3a8be4128a87f48a6dc7"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOBoyH6c5PR6mJ",
          "commit": {
            "abbreviatedOid": "0d5e8b1"
          },
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "Great additions overall! Just a few nits and questions.",
          "createdAt": "2023-03-08T07:42:03Z",
          "updatedAt": "2023-03-08T07:53:04Z",
          "comments": [
            {
              "originalPosition": 69,
              "body": "```suggestion\r\nhad previously been compromised. Note that sending an Update proposal does not achieve\r\nPCS until another member includes it in a Commit. Members can achieve immediate\r\n```",
              "createdAt": "2023-03-08T07:42:04Z",
              "updatedAt": "2023-03-08T07:53:04Z"
            },
            {
              "originalPosition": 94,
              "body": "```suggestion\r\nDS can still mount some attacks. While it cannot forge messages,\r\n```",
              "createdAt": "2023-03-08T07:43:57Z",
              "updatedAt": "2023-03-08T07:53:04Z"
            },
            {
              "originalPosition": 97,
              "body": "```suggestion\r\nthough it may not always be possible to distinguish an attack from message\r\n```",
              "createdAt": "2023-03-08T07:44:22Z",
              "updatedAt": "2023-03-08T07:53:04Z"
            },
            {
              "originalPosition": 103,
              "body": "```suggestion\r\npreventing a member from ever having its Commits applied.\r\n```",
              "createdAt": "2023-03-08T07:45:09Z",
              "updatedAt": "2023-03-08T07:53:04Z"
            },
            {
              "originalPosition": 108,
              "body": "If I understand correctly, the \"compromised member\" and \"the uncompromised endpoint\" are more or less the same here, aren't they? It might make sense to spell the scenario out a bit more.\r\n\r\nAlso \"generation\" refers to the generation in the messages, right? Since it's a relatively generic word, it might make sense to be explicit about that context.",
              "createdAt": "2023-03-08T07:49:43Z",
              "updatedAt": "2023-03-08T07:53:04Z"
            },
            {
              "originalPosition": 124,
              "body": "Since we're naming mitigation measures here, cross-signing of clients would also be worth mentioning here, I think.",
              "createdAt": "2023-03-08T07:52:25Z",
              "updatedAt": "2023-03-08T07:53:04Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c5PT6RP",
          "commit": {
            "abbreviatedOid": "0d5e8b1"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-08T12:59:31Z",
          "updatedAt": "2023-03-08T13:03:03Z",
          "comments": [
            {
              "originalPosition": 71,
              "body": "This is nitpicking, but PCS is only really achieved when the Commit has reached other members and they start using it, or alternatively when a DS enforces strict ordering and rejects messages for epochs prior to the epoch introduced by the Commit.\r\n",
              "createdAt": "2023-03-08T12:59:31Z",
              "updatedAt": "2023-03-08T13:03:03Z"
            },
            {
              "originalPosition": 108,
              "body": "```suggestion\r\nsame user. Aside from the generation, MLS leaves loss detection up to the\r\n```",
              "createdAt": "2023-03-08T13:01:08Z",
              "updatedAt": "2023-03-08T13:03:03Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c5PoOSX",
          "commit": {
            "abbreviatedOid": "5bc5b79"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-11T23:19:54Z",
          "updatedAt": "2023-03-11T23:19:54Z",
          "comments": [
            {
              "originalPosition": 71,
              "body": "This seems like a worthwhile distinction.  Something like:\r\n\r\n> To be clear, in all these cases, the PCS guarantees come into effect when the members of the group process the relevant Commit, not when the sender creates it.",
              "createdAt": "2023-03-11T23:19:54Z",
              "updatedAt": "2023-03-11T23:19:54Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c5PoOYp",
          "commit": {
            "abbreviatedOid": "5bc5b79"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Overall, these are good additions.  If we can get the comments addressed, I think it's good to merge.",
          "createdAt": "2023-03-11T23:26:15Z",
          "updatedAt": "2023-03-11T23:37:25Z",
          "comments": [
            {
              "originalPosition": 108,
              "body": "Agree that this is a little ambiguous.  Suggest something like:\r\n\r\n> When put together, these abilities potentially allow a DS to collude with an attacker who has compromised a member's state to defeat PCS by suppressing the valid Update and Commit messages from the member that would lock out the attacker and update the member's leaf to a new, uncompromised state.",
              "createdAt": "2023-03-11T23:26:15Z",
              "updatedAt": "2023-03-11T23:37:25Z"
            },
            {
              "originalPosition": 124,
              "body": "```suggestion\r\nusers to detect this kind of misbehavior by the AS.  It is also possible to \r\nconstruct schemes in which the various clients owned by a user vouch\r\nfor each other, e.g., by signing each others' keys.\r\n```\r\n\r\n@kkohbrok - If you had a citation, that would be helpful.",
              "createdAt": "2023-03-11T23:36:55Z",
              "updatedAt": "2023-03-11T23:37:25Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c5PoOrM",
          "commit": {
            "abbreviatedOid": "6d04cd9"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-03-11T23:48:38Z",
          "updatedAt": "2023-03-11T23:48:38Z",
          "comments": []
        }
      ]
    },
    {
      "number": 874,
      "id": "PR_kwDOBoyH6c5LhlmM",
      "title": "Add some more explanatory text to the beginning.",
      "url": "https://github.com/mlswg/mls-protocol/pull/874",
      "state": "MERGED",
      "author": "ekr",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This removes the following graf:\r\n\r\n   The DS and AS may also apply additional policies to MLS operations to obtain\r\n   additional security properties.  For example, MLS enables any participant to add\r\n   or remove members of a group; a DS could enforce a policy that only certain\r\n   members are allowed to perform these operations.  MLS authenticates all members\r\n   of a group; a DS could help ensure that only clients with certain types of\r\n   credential are admitted. MLS provides no inherent protection against denial of\r\n   service; A DS could also enforce rate limits in order to mitigate\r\n   these risks.\r\n\r\nMy sense is this belongs in Security Considerations, not here.",
      "createdAt": "2023-03-07T23:33:25Z",
      "updatedAt": "2023-03-12T17:47:44Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "b1f6dd9d3761a81f68fe3a8be4128a87f48a6dc7",
      "headRepository": "ekr/mls-protocol",
      "headRefName": "introduction",
      "headRefOid": "2b93dd577594f9686b0f95c1010663d5d9069da5",
      "closedAt": "2023-03-12T17:47:44Z",
      "mergedAt": "2023-03-12T17:47:44Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "24fc8e3ceccb5ff715b444dc0e6cf9f16846d37d"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOBoyH6c5PoOkW",
          "commit": {
            "abbreviatedOid": "a509db6"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-11T23:39:49Z",
          "updatedAt": "2023-03-11T23:47:15Z",
          "comments": [
            {
              "originalPosition": 44,
              "body": "I would probably keep the sub-bullets describing the usual functions of the DS.",
              "createdAt": "2023-03-11T23:39:50Z",
              "updatedAt": "2023-03-11T23:47:15Z"
            },
            {
              "originalPosition": 82,
              "body": "```suggestion\r\nclients to add it to groups. When a group member wants to add a new member\r\nto a group it uses the new member's KeyPackage to add the new member to \r\nthe group and construct a Welcome message with which the new member can\r\ninitialize its local state.\r\n```",
              "createdAt": "2023-03-11T23:41:44Z",
              "updatedAt": "2023-03-11T23:47:15Z"
            },
            {
              "originalPosition": 44,
              "body": "```suggestion\r\n* A Delivery Service (DS) that routes MLS messages among the participants in the\r\n  protocol.\r\n  \r\n      * Pre-publication of KeyPackage objects for clients\r\n      * Delivery of Proposal and Commit messages to members of a group\r\n      * Delivery of Welcome messages to new members of a group\r\n      * Sequencing of Commit messages (see {{sequencing}})\r\n```\r\n\r\n(Also incorporating some changes from #872)",
              "createdAt": "2023-03-11T23:43:50Z",
              "updatedAt": "2023-03-11T23:47:15Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c5PoOqw",
          "commit": {
            "abbreviatedOid": "a509db6"
          },
          "author": "ekr",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-11T23:48:08Z",
          "updatedAt": "2023-03-11T23:48:08Z",
          "comments": [
            {
              "originalPosition": 44,
              "body": "I mean it's up to you, but I actually think this is a regression, because it has a lot of forward references.",
              "createdAt": "2023-03-11T23:48:08Z",
              "updatedAt": "2023-03-11T23:48:08Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c5PoOtZ",
          "commit": {
            "abbreviatedOid": "465c42b"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "This looks good to me.  Please do move the removed paragraph to the security considerations, either here or in #873.",
          "createdAt": "2023-03-11T23:51:31Z",
          "updatedAt": "2023-03-11T23:51:31Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOBoyH6c5PomnP",
          "commit": {
            "abbreviatedOid": "2b93dd5"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-03-12T15:35:18Z",
          "updatedAt": "2023-03-12T15:35:18Z",
          "comments": []
        }
      ]
    },
    {
      "number": 875,
      "id": "PR_kwDOBoyH6c5MBk_X",
      "title": "Fix nits.",
      "url": "https://github.com/mlswg/mls-protocol/pull/875",
      "state": "MERGED",
      "author": "Bren2010",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2023-03-14T17:26:10Z",
      "updatedAt": "2023-03-16T14:02:42Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "cc6851e77a98b0f58f59f1d72f66831b791a0740",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "brendan/fix-nits",
      "headRefOid": "61b006df870688bd3be107eb619ee6c02b84c102",
      "closedAt": "2023-03-16T14:02:42Z",
      "mergedAt": "2023-03-16T14:02:42Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "94c8a09593fc93b9279392bb03b3c143109e8209"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOBoyH6c5QBGmi",
          "commit": {
            "abbreviatedOid": "4680818"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-03-15T21:35:56Z",
          "updatedAt": "2023-03-15T21:35:56Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOBoyH6c5QA1wt",
          "commit": {
            "abbreviatedOid": "4680818"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-03-15T20:44:01Z",
          "updatedAt": "2023-03-16T14:02:24Z",
          "comments": [
            {
              "originalPosition": 74,
              "body": "```suggestion\r\ngroup, and thus there is a risk to forward secrecy as long as any\r\n```",
              "createdAt": "2023-03-15T20:44:01Z",
              "updatedAt": "2023-03-16T14:02:24Z"
            }
          ]
        }
      ]
    },
    {
      "number": 876,
      "id": "PR_kwDOBoyH6c5MBp5D",
      "title": "Remove protocol version from KeyPackage.",
      "url": "https://github.com/mlswg/mls-protocol/pull/876",
      "state": "CLOSED",
      "author": "Bren2010",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "The protocol version is already explicitly provided by the enclosing MLSMessage, and signed by SignWithLabel.",
      "createdAt": "2023-03-14T17:38:40Z",
      "updatedAt": "2023-03-15T21:33:13Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "cc6851e77a98b0f58f59f1d72f66831b791a0740",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "brendan/no-kp-version",
      "headRefOid": "cbcdc26d377d6dd6121ef7700870bc7b07aea7c6",
      "closedAt": "2023-03-15T21:33:13Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing this after discussion with @raphaelrobert.  While in principle, a few bytes could be saved, it's a very minor improvement, and not enough to justify changing a signed structure this late in the process.",
          "createdAt": "2023-03-15T21:33:13Z",
          "updatedAt": "2023-03-15T21:33:13Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 877,
      "id": "PR_kwDOBoyH6c5M2aSX",
      "title": "Resolve ambiguities found in interop testing",
      "url": "https://github.com/mlswg/mls-protocol/pull/877",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "@mulmarta and I have completed interop testing that covers all of the functionality in the spec.  We found a couple of places where there were ambiguities in the spec that led to different implementation decisions, and in the process of resolving those, found a couple of errors / omissions in drarft-19.\r\n\r\n* The current PSK proposal validation forbids `resumption` with `usage` other than `applications`.  The branch and reinit sections call for the creation of PSK proposals with types `branch` and `reinit`.  Given the text in the PSK section, these proposals would be invalid.  This PR explicitly allows `branch` and `reinit` in the specific context of those operations.  (This is a little pro-forma, since the PSK proposals are only seen by the committer.  But it seems good to allow the committer to have consistent PSK proposal validation logic.)\r\n\r\n* The text says that Add, Remove, and ReInit proposals can be sent by external senders, but is silent about other proposal types.  This PR explicitly indicates which proposal types may be originated by external senders, and adds an IANA registry column to track.\r\n\r\n* GREASE values for proposal types, credential types, and extension types are defined for use in Capabilities, but nothing currently forbids their use elsewhere.  This PR forbids their use in actual Proposal or Credential objects, and in GroupContext extensions.\r\n\r\n* The `msg_type` field of the Proposal object was inconsistently referred to as both `msg_type` and `proposal_type`.  This PR changes it to be `proposal_type` everywhere.",
      "createdAt": "2023-03-24T16:35:43Z",
      "updatedAt": "2023-03-27T08:29:33Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "94c8a09593fc93b9279392bb03b3c143109e8209",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "interop-clarify",
      "headRefOid": "79263143de45caf6a1a1be1e46e5e1542e49265e",
      "closedAt": "2023-03-27T08:29:32Z",
      "mergedAt": "2023-03-27T08:29:32Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "966e8144638e00a0923690751a962a8d027e5bc0"
      },
      "comments": [
        {
          "author": "seanturner",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Merge when ready.",
          "createdAt": "2023-03-27T08:09:21Z",
          "updatedAt": "2023-03-27T08:09:21Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOBoyH6c5Q6A9J",
          "commit": {
            "abbreviatedOid": "aeeb932"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-24T20:34:01Z",
          "updatedAt": "2023-03-25T01:12:27Z",
          "comments": [
            {
              "originalPosition": 89,
              "body": "This goes against the core value of GREASE where receivers are not supposed to treat them differently. A better phrasing might be \"Senders MUST NOT GREASE these fields X/Y/Z because doing so will result in the proposal being rejected.",
              "createdAt": "2023-03-24T20:34:01Z",
              "updatedAt": "2023-03-25T01:12:27Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c5Q7PcD",
          "commit": {
            "abbreviatedOid": "aeeb932"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-25T02:07:29Z",
          "updatedAt": "2023-03-25T02:07:30Z",
          "comments": [
            {
              "originalPosition": 89,
              "body": "In order for that to be true, though, it has to be the case the the proposal will be rejected.  This text just specifies the sender and receiver sides (\"MUST NOT be included [by senders]\" ... \"MUST reject\").",
              "createdAt": "2023-03-25T02:07:29Z",
              "updatedAt": "2023-03-25T02:07:30Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c5Q7Prz",
          "commit": {
            "abbreviatedOid": "aeeb932"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-25T02:15:19Z",
          "updatedAt": "2023-03-25T02:15:19Z",
          "comments": [
            {
              "originalPosition": 89,
              "body": "What's the receiver behavior with unknown values here? Ignore or reject? If it's reject then you don't need to say anything about rejecting GREASE",
              "createdAt": "2023-03-25T02:15:19Z",
              "updatedAt": "2023-03-25T02:15:19Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c5Q8OzA",
          "commit": {
            "abbreviatedOid": "aeeb932"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2023-03-26T07:57:43Z",
          "updatedAt": "2023-03-26T07:58:34Z",
          "comments": [
            {
              "originalPosition": 155,
              "body": "This one is problematic because an external init is technically an external proposal. This is at odds with 12.1.8, but I think the problem is there, not here. In my mind, the new member proposal is not an external proposal and should have its own category. That would also reflect that it has its own sender type.\r\nTl;DR: Leave this as is but rewrite 12.1.8.",
              "createdAt": "2023-03-26T07:57:44Z",
              "updatedAt": "2023-03-26T07:58:34Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c5Q86qO",
          "commit": {
            "abbreviatedOid": "aeeb932"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-26T23:02:59Z",
          "updatedAt": "2023-03-26T23:02:59Z",
          "comments": [
            {
              "originalPosition": 155,
              "body": "ExternalInit doesn't have the `external` SenderType, it should be `new_member_commit` if I'm understanding correctly",
              "createdAt": "2023-03-26T23:02:59Z",
              "updatedAt": "2023-03-26T23:03:00Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c5Q9REo",
          "commit": {
            "abbreviatedOid": "7926314"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-27T02:29:06Z",
          "updatedAt": "2023-03-27T02:49:02Z",
          "comments": [
            {
              "originalPosition": 155,
              "body": "@Bren2010 is correct.  The concept here is:\r\n\r\n* `SenderType::member` can send any proposal\r\n* `SenderType::new_member_proposal` can send Add\r\n* `SenderType::new_member_commit` can only send an External Commit (with proposals inline)\r\n* `SenderType::external` can send only what is specified here\r\n",
              "createdAt": "2023-03-27T02:29:06Z",
              "updatedAt": "2023-03-27T02:49:02Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c5Q9y9X",
          "commit": {
            "abbreviatedOid": "7926314"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-03-27T06:00:06Z",
          "updatedAt": "2023-03-27T06:00:12Z",
          "comments": [
            {
              "originalPosition": 155,
              "body": "Agreed, I confused it with the `new_member_proposal`.",
              "createdAt": "2023-03-27T06:00:06Z",
              "updatedAt": "2023-03-27T06:00:12Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c5Q-f1v",
          "commit": {
            "abbreviatedOid": "7926314"
          },
          "author": "seanturner",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-03-27T08:09:12Z",
          "updatedAt": "2023-03-27T08:09:12Z",
          "comments": []
        }
      ]
    },
    {
      "number": 878,
      "id": "PR_kwDOBoyH6c5PNpB1",
      "title": "Minor clarifications for AUTH48",
      "url": "https://github.com/mlswg/mls-protocol/pull/878",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This PR includes clarifications on a few minor points that were found during interoperability testing.\r\n\r\n1. The prose description of the `info` parameter to HPKE conflicts with the pseudocode.  This PR deletes the conflicting prose.\r\n2. When `LeafNode.extensions` contains GREASE extensions, those extensions have to be reflected in `LeafNode.capabilities.extensions`, or else the leaf note is invalid.  This PR adds a cautionary note to this effect.\r\n3. #875 allows GREASE extensions in `LeafNode.extensions`, but did not add `LN` to the IANA registrations for the GREASE extension values.  This PR adds that notation.\r\n\r\nWe plan to hold this PR open until AUTH48 begins, then apply the changes in AUTH48.",
      "createdAt": "2023-04-26T15:33:35Z",
      "updatedAt": "2023-05-30T20:50:27Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "966e8144638e00a0923690751a962a8d027e5bc0",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "pre-auth48",
      "headRefOid": "f34f4f277d96d6334badfaa539f233038aa82c8e",
      "closedAt": "2023-05-30T20:50:27Z",
      "mergedAt": "2023-05-30T20:50:27Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "f78583b766d7ddb1af0ac93df5c55386feb676b5"
      },
      "comments": [
        {
          "author": "dconnolly",
          "authorAssociation": "NONE",
          "body": "> 2\\. When `LeafNode.extensions` contains GREASE extensions, those extensions have to be reflected in `LeafNode.capabilities.extensions`, or else the leaf note is invalid.  This PR adds a cautionary note to this effect.\r\n\r\nNot blocking these changes but does this indicate duplication amongst `LeafNode`? It's probably too late to change but",
          "createdAt": "2023-05-17T18:22:56Z",
          "updatedAt": "2023-05-17T18:22:56Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "@dconnolly - It's a good question, but the duplication is small.  The only thing that's duplicated is the 2-byte extension type value.  In addition to sending the GREASE extension with type 0xXXXX, you also need to say \"I support extensions of type 0xXXXX\".",
          "createdAt": "2023-05-17T19:34:06Z",
          "updatedAt": "2023-05-17T19:34:06Z"
        },
        {
          "author": "dconnolly",
          "authorAssociation": "NONE",
          "body": "> @dconnolly - It's a good question, but the duplication is small.  The only thing that's duplicated is the 2-byte extension type value.  In addition to sending the GREASE extension with type 0xXXXX, you also need to say \"I support extensions of type 0xXXXX\".\n\nGot it, that makes sense and is as you say small. Thanks!",
          "createdAt": "2023-05-17T19:35:33Z",
          "updatedAt": "2023-05-17T19:35:33Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "While responding to @dconnolly, though, I got to looking at the relevant text, and suspect we might have yet another minor issue:\r\n\r\n> Proposal and extension types defined in this document are considered \"default\" and thus need not be listed [...]  Extensions that appear in the extensions field of a LeafNode MUST be included in the extensions field of the capabilities field [...]\r\n\r\nThat second sentence reads to me like extensions types must appear in `capabilities` **even if they are default types**.  That seems incorrect to me.  Propose clarifying to \"Extensions of non-default types that appear in the extensions field...\"  You would still have to GREASE consistently, but it would save a few bytes for default extension.  But maybe adding an exception to the logic isn't worth it.  @mulmarta @Bren2010 wdyt?",
          "createdAt": "2023-05-17T19:40:47Z",
          "updatedAt": "2023-05-17T19:40:47Z"
        },
        {
          "author": "mulmarta",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@bifurcation I agree that the clarification you propose reflects what I always understood. Even more clear may be something like \"Non-default types of extensions that appear in the extensions field of a LeafNode...\" -- this indicates that types, not full extensions are copied. (FWIW the impact is quite small, because the only default leaf node extension is application id.)",
          "createdAt": "2023-05-18T07:25:02Z",
          "updatedAt": "2023-05-18T07:25:02Z"
        },
        {
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "body": "I agree it's inconsistent, though I don't have a strong opinion on which way we go. This sentence also stands out:\r\n\r\n> The capabilities field indicates what protocol versions, ciphersuites, extensions, credential types, and non-default proposal types are supported by a client.\r\n\r\n(Extensions isn't covered by \"non-default\")",
          "createdAt": "2023-05-18T17:48:07Z",
          "updatedAt": "2023-05-18T17:48:07Z"
        },
        {
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The PR looks good to me. I support the solution approach proposed by @mulmarta. The inconsistency pointed out by @Bren2010 we can probably get rid of by rewriting as follows:\r\n\r\n> The capabilities field indicates what protocol versions, ciphersuites, credential types, and non-default proposal and extension types are supported by a client.",
          "createdAt": "2023-05-22T06:26:00Z",
          "updatedAt": "2023-05-22T06:26:00Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks @mulmarta @Bren2010 @kkohbrok.  I updated the relevant sentences to clarify, and I also removed the paragraph about GREASE-ing consistently.  Under the theory that since GREASE extensions are defined in this document, they are \"default\", and thus don't have to be listed in `capabilities.extensions` (though they MAY be listed).",
          "createdAt": "2023-05-22T15:24:26Z",
          "updatedAt": "2023-05-22T15:24:26Z"
        },
        {
          "author": "franziskuskiefer",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> Under the theory that since GREASE extensions are defined in this document, they are \"default\", and thus don't have to be listed in `capabilities.extensions` (though they MAY be listed).\r\n\r\nWe ran into this issue interopping between OpenMLS and mlspp because OpenMLS was checking for the GREASE values. But I agree that it is more consistent when GREASE values don't need to be listed as capabilities (since they're \"default\").",
          "createdAt": "2023-05-23T06:38:21Z",
          "updatedAt": "2023-05-23T06:38:21Z"
        },
        {
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "body": "> Under the theory that since GREASE extensions are defined in this document, they are \"default\", and thus don't have to be listed in `capabilities.extensions` (though they MAY be listed).\r\n\r\nWouldn't that defeat the purpose of GREASE values? If they are considered \"default\", it means they need to be hard-coded on the receiving side. Isn't that what should be avoided?",
          "createdAt": "2023-05-23T07:35:41Z",
          "updatedAt": "2023-05-23T07:35:41Z"
        },
        {
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "(Hi! GREASE enthusiast here) I agree with @raphaelrobert. For GREASE codepoints to work as intended, they need to behave exactly like an unknown optional extension. It would be best to specify that the clause `Proposal and extension types defined in this document are considered \"default\"` does not apply to GREASE values.",
          "createdAt": "2023-05-23T16:44:40Z",
          "updatedAt": "2023-05-23T16:44:40Z"
        },
        {
          "author": "franziskuskiefer",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I generally with the GREASE sentiment. But any more exceptions here make this really hard to get right.\r\nI'd be in favour of dropping the notion of \"default\" extensions all together instead.",
          "createdAt": "2023-05-23T16:55:53Z",
          "updatedAt": "2023-05-23T16:55:53Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "I'm inclined to agree, but it just seems like bloat to have to list, e.g., the ratchet tree extension.  I don't think we should consider support for those extensions optional, so they would all appear there.  What if instead we were explicit that implementations are REQUIRED to support extension types 0x0001-0x0005, and thus these are considered default?\r\n\r\n> The following proposal types and extension types MUST be supported by implementations.  They are considered \"default\" and MAY be omitted from the corresponding fields in a Capabilities object.\r\n> * [proposal types 0x0001-0x0007]\r\n> * [extension types 0x0001-0x0005]\r\n\r\n... and then we'll need to re-add the \"consistent GREASE\" paragraph.",
          "createdAt": "2023-05-23T23:28:49Z",
          "updatedAt": "2023-05-23T23:28:49Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "In the latest commit:\r\n\r\n* Be explicit about which proposals/extensions are considered \"default\"\r\n* As @rohan-wire suggests, require that default values MUST NOT be listed\r\n* Re-add the paragraph about consistent GREASE\r\n\r\nI think this reflects all the feedback received so far, so I will plan to merge in the next 24hr or so unless there are objections.",
          "createdAt": "2023-05-30T13:45:19Z",
          "updatedAt": "2023-05-30T13:45:19Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOBoyH6c5TlnyH",
          "commit": {
            "abbreviatedOid": "c0575e2"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-04-26T16:26:02Z",
          "updatedAt": "2023-04-26T16:26:02Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOBoyH6c5VUef5",
          "commit": {
            "abbreviatedOid": "c0575e2"
          },
          "author": "dconnolly",
          "authorAssociation": "NONE",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-05-17T19:36:07Z",
          "updatedAt": "2023-05-17T19:36:07Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOBoyH6c5V4Zgs",
          "commit": {
            "abbreviatedOid": "59b6711"
          },
          "author": "rohan-wire",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-05-24T02:34:06Z",
          "updatedAt": "2023-05-24T02:37:22Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "```suggestion\r\nProposal and extension types defined in this document are considered \"default\" and thus are not listed, while any credential types the application wishes to use MUST\r\n```\r\nIf we don't have any reason to include default proposals and extensions, then they should never be included. There should be exactly one way to say that an MLS client implements the default.",
              "createdAt": "2023-05-24T02:34:06Z",
              "updatedAt": "2023-05-24T02:37:22Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c5WfRtK",
          "commit": {
            "abbreviatedOid": "f34f4f2"
          },
          "author": "mulmarta",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-05-30T13:59:25Z",
          "updatedAt": "2023-05-30T13:59:25Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOBoyH6c5WfUDN",
          "commit": {
            "abbreviatedOid": "f34f4f2"
          },
          "author": "rohan-wire",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-05-30T14:03:48Z",
          "updatedAt": "2023-05-30T14:03:48Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOBoyH6c5WfVGR",
          "commit": {
            "abbreviatedOid": "f34f4f2"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-05-30T14:05:48Z",
          "updatedAt": "2023-05-30T14:05:48Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOBoyH6c5WfXgG",
          "commit": {
            "abbreviatedOid": "f34f4f2"
          },
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-05-30T14:10:01Z",
          "updatedAt": "2023-05-30T14:10:01Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOBoyH6c5WgQI6",
          "commit": {
            "abbreviatedOid": "f34f4f2"
          },
          "author": "DavidSchinazi",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-05-30T15:55:05Z",
          "updatedAt": "2023-05-30T15:55:05Z",
          "comments": []
        }
      ]
    },
    {
      "number": 879,
      "id": "PR_kwDOBoyH6c5Rube0",
      "title": "AUTH48 review of RFC Editor's Proposed Changes",
      "url": "https://github.com/mlswg/mls-protocol/pull/879",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This branch has my changes processing the RFC Editor's proposals.  \r\n\r\n* Diffs on `draft-ietf-mls-protocol.md` reflect accepted changes (plus novel changes)\r\n* Diffs on `rfc9420.authors.xml` to see rejected changes (plus novel changes)\r\n* `QUESTIONS.md` shows my proposed answers to the RFC Editor's questions\r\n\r\nThe diff between the XML generated from Markdown and `rfc9420.authors.xml` is not trivial, but it reflects things that are difficult / impossible to reproduce in Markdown:\r\n\r\n* Coalesced cross-references, e.g., \"Sections 2 and 3\" instead of \"Section 2 and Section 3\"\r\n* One instance of `<blockquote>`\r\n* Some references to email addresses that are styled to appear in a certain way\r\n* Some minutia in the media type registration and references\r\n\r\nTo review the diff yourself (on a Mac, with vimdiff):\r\n\r\n```\r\n> git pull origin auth48-through-sec5\r\n> git checkout auth48-through-sec5\r\n> cd auth48\r\n> make diff\r\n```",
      "createdAt": "2023-05-30T20:57:07Z",
      "updatedAt": "2023-06-16T13:04:44Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "auth48",
      "baseRefOid": "0037db53f55765cec7f2ff72af9f1624a9ae778a",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "auth48-through-sec5",
      "headRefOid": "7a0bd7cbf1b063f0aac6088ce4693573c4d106a7",
      "closedAt": "2023-06-16T12:48:05Z",
      "mergedAt": "2023-06-16T12:48:05Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "f2c607e385b016ab093ed8362596137d23d529d0"
      },
      "comments": [
        {
          "author": "katrielalex",
          "authorAssociation": "MEMBER",
          "body": "Wow this is a nice set of changes. Thank you both!\r\n\r\nI\u2019ll do an independent pass on the full protocol doc but let me not tie that to this review ",
          "createdAt": "2023-06-06T14:08:34Z",
          "updatedAt": "2023-06-06T14:08:34Z"
        },
        {
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "body": "@raphaelrobert Good point.  I would actually go the other direction.  I would like to be consistent with TLS here, which appears to use \"cipher suite\" as two words throughout.  Thus \"cipher suite\" in prose, `CipherSuite`, and `cipher_suite`.  (I'm pretty sure we got the `cipher_suite` variable names via that copy/paste.)  I will implement the change in this direction, but in its own commit so it's easier to revert if we disagree :)",
          "createdAt": "2023-06-15T20:56:06Z",
          "updatedAt": "2023-06-15T20:56:06Z"
        },
        {
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "body": "> @raphaelrobert Good point. I would actually go the other direction. I would like to be consistent with TLS here, which appears to use \"cipher suite\" as two words throughout. Thus \"cipher suite\" in prose, `CipherSuite`, and `cipher_suite`. (I'm pretty sure we got the `cipher_suite` variable names via that copy/paste.) I will implement the change in this direction, but in its own commit so it's easier to revert if we disagree :)\r\n\r\nI've been meaning to check what TLS does, since the term was coined in the context of SSL/TLS originally anyway. Makes perfect sense to align with that.",
          "createdAt": "2023-06-15T22:30:02Z",
          "updatedAt": "2023-06-15T22:30:02Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOBoyH6c5Ws6Uc",
          "commit": {
            "abbreviatedOid": "4db3f53"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "This is a huge amount of work, thank you!",
          "createdAt": "2023-06-01T05:45:23Z",
          "updatedAt": "2023-06-01T05:53:15Z",
          "comments": [
            {
              "originalPosition": 727,
              "body": "\"As a result\" was supposed to be moved into the body of the text I believe",
              "createdAt": "2023-06-01T05:45:23Z",
              "updatedAt": "2023-06-01T05:53:15Z"
            },
            {
              "originalPosition": 805,
              "body": "```suggestion\r\nsubtree_ is the subtree with its left child as head and its\r\n```",
              "createdAt": "2023-06-01T05:46:48Z",
              "updatedAt": "2023-06-01T05:53:16Z"
            },
            {
              "originalPosition": 431,
              "body": "```suggestion\r\nsubtree</em> is the subtree with its left child as head and its\r\n```",
              "createdAt": "2023-06-01T05:47:24Z",
              "updatedAt": "2023-06-01T05:53:16Z"
            },
            {
              "originalPosition": 820,
              "body": "```suggestion\r\nat 0 from the left to 2<sup>d</sup>-1 at the right (for a tree with 2<sup>d</sup> leaves). A tree\r\n```",
              "createdAt": "2023-06-01T05:48:08Z",
              "updatedAt": "2023-06-01T05:53:16Z"
            },
            {
              "originalPosition": 447,
              "body": "```suggestion\r\nat 0 from the left to 2<sup>d</sup>-1 at the right (for a tree with 2<sup>d</sup> leaves). A tree\r\n```",
              "createdAt": "2023-06-01T05:48:30Z",
              "updatedAt": "2023-06-01T05:53:16Z"
            },
            {
              "originalPosition": 1023,
              "body": "```suggestion\r\nHere, the functions `SealBase` and `OpenBase` are defined in {{Section 6.1 of\r\n```",
              "createdAt": "2023-06-01T05:50:01Z",
              "updatedAt": "2023-06-01T05:53:16Z"
            },
            {
              "originalPosition": 1542,
              "body": "```suggestion\r\nposition 2<sup>d</sup>-1 of the array. Intermediate parent nodes can be identified by\r\n```",
              "createdAt": "2023-06-01T05:51:42Z",
              "updatedAt": "2023-06-01T05:53:16Z"
            },
            {
              "originalPosition": 1575,
              "body": "```suggestion\r\n```",
              "createdAt": "2023-06-01T05:52:24Z",
              "updatedAt": "2023-06-01T05:53:16Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c5Wy8B2",
          "commit": {
            "abbreviatedOid": "4db3f53"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-06-01T19:43:53Z",
          "updatedAt": "2023-06-01T19:43:53Z",
          "comments": [
            {
              "originalPosition": 1542,
              "body": "Really good catch, thanks.",
              "createdAt": "2023-06-01T19:43:53Z",
              "updatedAt": "2023-06-01T19:43:53Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c5Wy8yr",
          "commit": {
            "abbreviatedOid": "4db3f53"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-06-01T19:46:08Z",
          "updatedAt": "2023-06-01T19:46:08Z",
          "comments": [
            {
              "originalPosition": 727,
              "body": "This got reworded as it moved.",
              "createdAt": "2023-06-01T19:46:08Z",
              "updatedAt": "2023-06-01T19:46:08Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c5XowpS",
          "commit": {
            "abbreviatedOid": "4e5a952"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-06-08T16:03:06Z",
          "updatedAt": "2023-06-08T16:21:05Z",
          "comments": [
            {
              "originalPosition": 2202,
              "body": "Why is this the only place where `<bcp14>` happened?",
              "createdAt": "2023-06-08T16:03:06Z",
              "updatedAt": "2023-06-08T16:21:05Z"
            },
            {
              "originalPosition": 3287,
              "body": "```suggestion\r\ngroup.  There is thus a risk to forward secrecy as long as any\r\n```",
              "createdAt": "2023-06-08T16:15:54Z",
              "updatedAt": "2023-06-08T16:21:05Z"
            },
            {
              "originalPosition": 3307,
              "body": "```suggestion\r\nbeing added to the tree by in Add proposals, in Update proposals, or in the `path` field of a\r\n```",
              "createdAt": "2023-06-08T16:16:53Z",
              "updatedAt": "2023-06-08T16:21:05Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c5Xo89M",
          "commit": {
            "abbreviatedOid": "4e5a952"
          },
          "author": "Bren2010",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-06-08T16:21:35Z",
          "updatedAt": "2023-06-08T16:21:35Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOBoyH6c5YEzaT",
          "commit": {
            "abbreviatedOid": "4e5a952"
          },
          "author": "rohan-wire",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "Some small changes proposed, and the issue of optional credential types in a group.",
          "createdAt": "2023-06-13T16:47:59Z",
          "updatedAt": "2023-06-13T22:56:56Z",
          "comments": [
            {
              "originalPosition": 686,
              "body": "```suggestion\r\nbroadcasts it to the group. Client A also generates a Welcome message and sends it\r\n```\r\n\r\n\"it\" is referring to the Commit message with Add proposal that A generates.\r\n\r\nIn general, I find it awkward talking about Add and Commit messages. This is a single message (the Commit) with an enclosed Add proposal.",
              "createdAt": "2023-06-13T16:47:59Z",
              "updatedAt": "2023-06-13T22:56:56Z"
            },
            {
              "originalPosition": 698,
              "body": "Again, \"Add and Commit messages\" is awkward ",
              "createdAt": "2023-06-13T16:50:04Z",
              "updatedAt": "2023-06-13T22:56:56Z"
            },
            {
              "originalPosition": 1105,
              "body": "I think \"identifier or identifiers\" is clearer.",
              "createdAt": "2023-06-13T19:05:02Z",
              "updatedAt": "2023-06-13T22:56:56Z"
            },
            {
              "originalPosition": 2118,
              "body": "```suggestion\r\ngroup, clients pre-publish KeyPackage objects that\r\n```\r\nThe \"in order to facilitate\" already makes the \"can\" redundant here.",
              "createdAt": "2023-06-13T19:20:32Z",
              "updatedAt": "2023-06-13T22:56:56Z"
            },
            {
              "originalPosition": 2430,
              "body": "this is still a mouthful of a sentence and reads worse than the original IMO. \r\n\r\n```suggestion\r\ncould be used by an automated service, for example, to remove a member\r\nof a group who has been inactive for a long time, or to propose adding\r\n```",
              "createdAt": "2023-06-13T21:42:45Z",
              "updatedAt": "2023-06-13T22:56:56Z"
            },
            {
              "originalPosition": 3053,
              "body": "This is an unnecessary imposition and makes it impossible to add support for new credential types for some members of a group, and makes KeyPackage more complicated. If a specific credential type is required by all the members of the group, it should be included in `required_capabilities`.  The specific use case of unknown credentials was discussed in various interim meetings and was a major motivator for moving the signature out of the credential and into the LeafNode.\r\n\r\n```suggestion\r\nIf a specific credential type is included in the `required_capabilities` extension\r\nin the GroupContext, then all members of the group MUST support that credential\r\ntype, as specified by the `capabilities` field of each LeafNode in the ratchet tree.\r\nCredential types that are unknown to a member and not included the\r\n`required_capabilities` extension are ignored by the member. This allows a subset\r\nof members to introduce additional functionality without requiring universal\r\nsupport for a new credential type. An application can introduce new credential types\r\n```",
              "createdAt": "2023-06-13T22:35:41Z",
              "updatedAt": "2023-06-13T22:56:56Z"
            },
            {
              "originalPosition": 3104,
              "body": "suggest removing credential_type from the list if my previous change is accepted.\r\n\r\n```suggestion\r\n```",
              "createdAt": "2023-06-13T22:37:49Z",
              "updatedAt": "2023-06-13T22:56:56Z"
            },
            {
              "originalPosition": 3307,
              "body": "```suggestion\r\nUniqueness of keys in leaf nodes is assured by explicitly checking each leaf node\r\nbeing added to the tree in any Add proposals, in any Update proposals, or in the `path` field of a\r\n```",
              "createdAt": "2023-06-13T22:42:11Z",
              "updatedAt": "2023-06-13T22:56:56Z"
            },
            {
              "originalPosition": 3845,
              "body": "```suggestion\r\nafter a three-week review period on the MLS Designated Expert (DE) mailing list\r\n```",
              "createdAt": "2023-06-13T22:51:45Z",
              "updatedAt": "2023-06-13T22:56:56Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c5YM0_Z",
          "commit": {
            "abbreviatedOid": "4e5a952"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-06-14T15:27:14Z",
          "updatedAt": "2023-06-14T15:27:14Z",
          "comments": [
            {
              "originalPosition": 3053,
              "body": "I remember the discussions a bit differently, namely that we included the signature key in the leaf node so that we can have easier extensibility for credentials, but *not* that we can now have arbitrary combinations of credentials. I'm worried that this weakens authentication guarantees when clients can only verify a signature but no longer correlate it to an identity. It's also not clear to me why we can't do what we do with other extensions: first make sure every client in the group supports it as advertized in its capabilities and *only then* make it a required capability before using it.",
              "createdAt": "2023-06-14T15:27:14Z",
              "updatedAt": "2023-06-14T15:27:14Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c5YM2M9",
          "commit": {
            "abbreviatedOid": "4e5a952"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-06-14T15:29:32Z",
          "updatedAt": "2023-06-14T15:29:32Z",
          "comments": [
            {
              "originalPosition": 686,
              "body": "Agreed, I think this terminology got carried over from the times when we had actual Add messages",
              "createdAt": "2023-06-14T15:29:32Z",
              "updatedAt": "2023-06-14T15:29:32Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c5YNmeS",
          "commit": {
            "abbreviatedOid": "4e5a952"
          },
          "author": "mulmarta",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-06-14T17:19:02Z",
          "updatedAt": "2023-06-14T17:19:02Z",
          "comments": [
            {
              "originalPosition": 3053,
              "body": "The part I'm worried about here is `Credential types that are unknown to a member and not included the\r\nrequired_capabilities extension are ignored by the member.` This seems to conflict with the fact that every credential ` MUST be validated with the AS`, since a member can't verify a credential it doesn't support? Note that required capabilities are optional, so credentials must be verified even without them.",
              "createdAt": "2023-06-14T17:19:02Z",
              "updatedAt": "2023-06-14T17:19:02Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c5YQ-kI",
          "commit": {
            "abbreviatedOid": "4e5a952"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "Thanks @bifurcation for setting all this up and answering the questions. Thanks also to the other reviewers, unless where I said otherwise I agree with the suggestions.\r\n\r\nThis looks good to me, I only found one nit: The document is inconsistent regarding ciphersuites. In prose we use \"ciphersuite\", but the C struct is spelled \"CipherSuite\" as if it was a contraction of two words. The same applies to fields spelled \"cipher_suite\". I propose we harmonize it by renaming the C struct to \"Ciphersuite\" and the fields to \"ciphersuite\". I can do a PR against the `auth48` or `auth48-through-sec5` branch, @bifucraction let me know what you prefer.",
          "createdAt": "2023-06-15T07:09:05Z",
          "updatedAt": "2023-06-15T07:09:05Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOBoyH6c5YROug",
          "commit": {
            "abbreviatedOid": "4e5a952"
          },
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-06-15T07:46:48Z",
          "updatedAt": "2023-06-15T07:46:48Z",
          "comments": [
            {
              "originalPosition": 3053,
              "body": "I second @raphaelrobert and @mulmarta. Allowing credentials that are not supported by a subset of group members and which they can thus only ignore seems like a very bad idea from an authentication standpoint. @rohan-wire can you maybe elaborate what kind of use-case you had in mind? Because I'm having trouble thinking of one. It would have to be a situation, where different applications are interoperating and where clients are okay with group members that they cannot authenticate at all. For such a group, one might was well use basic credentials.",
              "createdAt": "2023-06-15T07:46:48Z",
              "updatedAt": "2023-06-15T07:46:48Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c5YTHx8",
          "commit": {
            "abbreviatedOid": "4e5a952"
          },
          "author": "rohan-wire",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-06-15T12:04:15Z",
          "updatedAt": "2023-06-15T12:04:15Z",
          "comments": [
            {
              "originalPosition": 3053,
              "body": "MLS currently supports `basic` and `x509`. It does not require `x509`. So, the \"default\" case is that groups support `basic` which has no authentication (and is similar to what the industry does now for DoubleRatchet protocols). This can be mitigated with key transparency or manual verification, but is mostly just swept under the rug.\r\n\r\nNow imagine a vendor/provider introduces support for x509 credentials tomorrow. Do clients have to wait until they are in a group when 100% of the members support this credential type before they include their credentials? \r\n- What harm does it cause to clients which only support `basic`? I cannot see any. They had no authentication before. They still have no authentication?\r\n- Does it create an opportunity for bid-down?  No. because credential capabilities are signed in KeyPackages.\r\n- Can clients who *do* support `x509` do something useful with those credentials? Yes. the subset of clients which support x509 can indicate to the end user which clients in the roster have been validated and can even put more prominent indications when everyone is using the credentials or when suddenly everyone is not.\r\n- Do we lose the ability to require a specific credential type? No. a client can set `required_capabilities`.\r\n\r\nDoes that help?",
              "createdAt": "2023-06-15T12:04:15Z",
              "updatedAt": "2023-06-15T12:04:15Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c5YWY5m",
          "commit": {
            "abbreviatedOid": "4e5a952"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-06-15T19:36:44Z",
          "updatedAt": "2023-06-15T19:36:44Z",
          "comments": [
            {
              "originalPosition": 3053,
              "body": "You provide an example in which you claim there's no downside to your proposed changes. Here's a counter-example: Suppose a group is to use X.509 and X.509 only. With the proposed changes, a subset of the clients could start using BasicCredentials and the remainder of the clients would have to comply with that, since BasicCredentials would simply be an unknown credential to them.\r\nWe would need better reasoning about the relaxation, however I'm doubtful that it's a good idea to do such a potentially impactful change during AUTH48, without the possibility to fully consider all consequences.",
              "createdAt": "2023-06-15T19:36:44Z",
              "updatedAt": "2023-06-15T19:36:44Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c5YWdgM",
          "commit": {
            "abbreviatedOid": "4e5a952"
          },
          "author": "rohan-wire",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-06-15T19:49:11Z",
          "updatedAt": "2023-06-15T19:49:12Z",
          "comments": [
            {
              "originalPosition": 3053,
              "body": "Why wouldn't those clients just use `required_capabilities` if they only want to use X.509?\r\nI also find it a bit preposterous the idea that an implementation would not understand what `basic` is, as opposed to administratively refusing to use it.\r\n\r\nI am sympathetic about the AUTH48 comment, but that would indicate this is better fixed as an errata than an extension.",
              "createdAt": "2023-06-15T19:49:11Z",
              "updatedAt": "2023-06-15T19:49:12Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c5YWqmC",
          "commit": {
            "abbreviatedOid": "4e5a952"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-06-15T20:26:10Z",
          "updatedAt": "2023-06-15T20:26:10Z",
          "comments": [
            {
              "originalPosition": 2202,
              "body": "I think I added it before I realized that it could get added automatically.  In any case, removed.",
              "createdAt": "2023-06-15T20:26:10Z",
              "updatedAt": "2023-06-15T20:26:10Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c5YWrTJ",
          "commit": {
            "abbreviatedOid": "4e5a952"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-06-15T20:28:32Z",
          "updatedAt": "2023-06-15T20:28:32Z",
          "comments": [
            {
              "originalPosition": 3307,
              "body": "Reworded to:\r\n\r\n> ... each leaf node as it is added to the tree, whether in an Add proposal, in an Update proposal, or in the `path` field of a Commit.\r\n\r\nThat way everything is singular.  Also got rid of \"by in\".",
              "createdAt": "2023-06-15T20:28:32Z",
              "updatedAt": "2023-06-15T20:28:32Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c5YWr6X",
          "commit": {
            "abbreviatedOid": "4e5a952"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-06-15T20:30:25Z",
          "updatedAt": "2023-06-15T20:30:25Z",
          "comments": [
            {
              "originalPosition": 686,
              "body": "Not necessarily!  You could send an Add Proposal alongside a Commit.  At this stage, I think it is a little clearer to address them separately, with inlining as an optimization discussed later.  Reworded to be a little more explicit, though:\r\n\r\n> A generates an Add message and a Commit message to add that member and then broadcasts the two messages to the group",
              "createdAt": "2023-06-15T20:30:25Z",
              "updatedAt": "2023-06-15T20:30:25Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c5YWsSt",
          "commit": {
            "abbreviatedOid": "4e5a952"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-06-15T20:31:38Z",
          "updatedAt": "2023-06-15T20:31:38Z",
          "comments": [
            {
              "originalPosition": 1105,
              "body": "Reduced to \"identifiers\", seems cleaner.",
              "createdAt": "2023-06-15T20:31:38Z",
              "updatedAt": "2023-06-15T20:31:38Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c5YWs5q",
          "commit": {
            "abbreviatedOid": "4e5a952"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-06-15T20:33:36Z",
          "updatedAt": "2023-06-15T20:33:36Z",
          "comments": [
            {
              "originalPosition": 2118,
              "body": "Disagree.  Omitting the \"can\" implies that pre-publication is mandatory, which it isn't really.  In a more real-time setting, you could provide the KeyPackage at join time, to prompt the Add+Commit.  If you want to stretch things, you say that this is still \"pre\" in the sense that it's before the Add.  But that seems like a stretch.",
              "createdAt": "2023-06-15T20:33:36Z",
              "updatedAt": "2023-06-15T20:33:36Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c5YW81C",
          "commit": {
            "abbreviatedOid": "4e5a952"
          },
          "author": "bifurcation",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-06-15T21:25:02Z",
          "updatedAt": "2023-06-15T21:25:02Z",
          "comments": [
            {
              "originalPosition": 3053,
              "body": "Without getting into the details of the discussion here -- this is a significant change for this late.  I would have been skeptical but open earlier in the process; at this point, it's clearly too big.  And it doesn't seem like anyone is in support besides @rohan-wire.  I'm going to decline to include this change unless the chairs tell me otherwise.\r\n\r\nFWIW, I would also argue that this change should not be accepted as an erratum.  It is not an error in the spec, it is a deliberate decision by the working group.\r\n\r\nThat said, you could definitely write a small, no-content `allow_unknown_credentials` GroupContext extension that just says, \"In this group, it's OK to use credentials that not everyone supports\".  Then you just switch on the presence of that extension to turn off the credential support checking.  You still have an everyone-has-to-upgrade problem, but only with regard to that extension, not every credential type.",
              "createdAt": "2023-06-15T21:25:02Z",
              "updatedAt": "2023-06-15T21:25:02Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c5YaxNQ",
          "commit": {
            "abbreviatedOid": "4e5a952"
          },
          "author": "rohan-wire",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-06-16T12:37:01Z",
          "updatedAt": "2023-06-16T12:37:02Z",
          "comments": [
            {
              "originalPosition": 686,
              "body": "Huh?\r\nWe are describing the canonical flow here, not prescribing normative behavior. Even if we were, A sends a Commit message which contains or references A's Add proposal. The important thing for the clarity of this sentence is the Commit message, and in 99% of cases, A will never **separately** send an Add proposal. The proposed rewording misleads the reader otherwise.",
              "createdAt": "2023-06-16T12:37:01Z",
              "updatedAt": "2023-06-16T12:37:02Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOBoyH6c5Yazc4",
          "commit": {
            "abbreviatedOid": "4e5a952"
          },
          "author": "rohan-wire",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-06-16T12:40:52Z",
          "updatedAt": "2023-06-16T12:40:53Z",
          "comments": [
            {
              "originalPosition": 2118,
              "body": "I think the earlier phrase \"In order to facilitate ...\" makes it clear this is optional, but no biggie here.",
              "createdAt": "2023-06-16T12:40:52Z",
              "updatedAt": "2023-06-16T12:40:53Z"
            }
          ]
        }
      ]
    },
    {
      "number": 882,
      "id": "PR_kwDOBoyH6c5TMIJH",
      "title": "One more minor clarification for AUTH48",
      "url": "https://github.com/mlswg/mls-protocol/pull/882",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "In #879, @rohan-wire [proposed a clarification in the protocol overview](https://github.com/mlswg/mls-protocol/pull/879#discussion_r1232195438) that the Add and Commit messages don't have to be separate messages.  He and I talked offline, and came to a compromise: On the one hand, you always send an Add and a Commit (even if the Add is inlined), but on the other hand, the Add may just be a proposal, not a message.  So this PR just changes \"Add message\" to \"Add proposal\".",
      "createdAt": "2023-06-16T13:02:05Z",
      "updatedAt": "2023-06-16T13:13:41Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "auth48",
      "baseRefOid": "f2c607e385b016ab093ed8362596137d23d529d0",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "one-word-for-rohan",
      "headRefOid": "475cda0ff2cdf2ffc8df2f6b26ae74cc99e9dba7",
      "closedAt": "2023-06-16T13:13:41Z",
      "mergedAt": "2023-06-16T13:13:41Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "acd744171cb2b9b46f9c620c6f0414aa4df8d1b8"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOBoyH6c5YbChD",
          "commit": {
            "abbreviatedOid": "475cda0"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-06-16T13:13:20Z",
          "updatedAt": "2023-06-16T13:13:20Z",
          "comments": []
        }
      ]
    },
    {
      "number": 883,
      "id": "PR_kwDOBoyH6c5Ts47k",
      "title": "Round 2 of AUTH48 edits",
      "url": "https://github.com/mlswg/mls-protocol/pull/883",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "The RFC Editor replied to our edits (#879 #880) with a few more questions, comments, and edits.  This PR incorporates those comments into the Markdown and the author's XML, and fixes one thing where author input was required.  The new questions/comments are added to the bottom of QUESTIONS.md.",
      "createdAt": "2023-06-22T23:42:05Z",
      "updatedAt": "2023-06-23T05:55:06Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "auth48",
      "baseRefOid": "acd744171cb2b9b46f9c620c6f0414aa4df8d1b8",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "auth48-round2",
      "headRefOid": "9e3056b99bda74d3f210db80d739b320b38c3d1b",
      "closedAt": "2023-06-23T05:54:57Z",
      "mergedAt": "2023-06-23T05:54:57Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "369027a6042ca356b60061421cd197e36bd9917f"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOBoyH6c5ZDuf6",
          "commit": {
            "abbreviatedOid": "9e3056b"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "Thanks, LGTM.",
          "createdAt": "2023-06-23T00:06:11Z",
          "updatedAt": "2023-06-23T00:06:11Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOBoyH6c5ZD9IA",
          "commit": {
            "abbreviatedOid": "9e3056b"
          },
          "author": "katrielalex",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "lgtm!",
          "createdAt": "2023-06-23T01:39:12Z",
          "updatedAt": "2023-06-23T01:39:12Z",
          "comments": []
        }
      ]
    },
    {
      "number": 884,
      "id": "PR_kwDOBoyH6c5Tt2rH",
      "title": "Improve rendering of QUESTIONS.md",
      "url": "https://github.com/mlswg/mls-protocol/pull/884",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2023-06-23T06:04:11Z",
      "updatedAt": "2023-06-23T06:05:07Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "auth48",
      "baseRefOid": "369027a6042ca356b60061421cd197e36bd9917f",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "questions-render",
      "headRefOid": "e818dce938b34e7fab1bd266937fc982e0285dd4",
      "closedAt": "2023-06-23T06:05:07Z",
      "mergedAt": "2023-06-23T06:05:07Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "eb8ab4862a114bc0a00eb2e9bec40f07561de296"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 885,
      "id": "PR_kwDOBoyH6c5VyqVT",
      "title": "Final changes for RFC 9420",
      "url": "https://github.com/mlswg/mls-protocol/pull/885",
      "state": "MERGED",
      "author": "bifurcation",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "The document changes in this PR were reviewed in #878 #879 #882 #883 #884.  This PR just pulls them into the main branch.  And renames the Markdown file to reflect the fact that MLS is now an RFC!  \ud83c\udf89\ud83c\udf89\ud83c\udf89",
      "createdAt": "2023-07-18T14:18:34Z",
      "updatedAt": "2023-07-18T14:48:48Z",
      "baseRepository": "mlswg/mls-protocol",
      "baseRefName": "main",
      "baseRefOid": "f78583b766d7ddb1af0ac93df5c55386feb676b5",
      "headRepository": "mlswg/mls-protocol",
      "headRefName": "auth48",
      "headRefOid": "6152eb5c42b9bd64c110b2378ac290633c1a93a6",
      "closedAt": "2023-07-18T14:48:43Z",
      "mergedAt": "2023-07-18T14:48:43Z",
      "mergedBy": "bifurcation",
      "mergeCommit": {
        "oid": "1a441b8af19f2dd6dc0b7301a9c788bb8985090f"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOBoyH6c5bgLal",
          "commit": {
            "abbreviatedOid": "6152eb5"
          },
          "author": "beurdouche",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-07-18T14:22:01Z",
          "updatedAt": "2023-07-18T14:22:01Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOBoyH6c5bgO6L",
          "commit": {
            "abbreviatedOid": "6152eb5"
          },
          "author": "raphaelrobert",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-07-18T14:28:19Z",
          "updatedAt": "2023-07-18T14:28:19Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOBoyH6c5bgXT-",
          "commit": {
            "abbreviatedOid": "6152eb5"
          },
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-07-18T14:43:05Z",
          "updatedAt": "2023-07-18T14:43:05Z",
          "comments": []
        }
      ]
    }
  ]
}